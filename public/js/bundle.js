(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":4}],4:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":5}],5:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":2}],6:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

"use strict";

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

},{}],7:[function(require,module,exports){
'use strict';
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function ownEnumerableKeys(obj) {
	var keys = Object.getOwnPropertyNames(obj);

	if (Object.getOwnPropertySymbols) {
		keys = keys.concat(Object.getOwnPropertySymbols(obj));
	}

	return keys.filter(function (key) {
		return propIsEnumerable.call(obj, key);
	});
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = ownEnumerableKeys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],8:[function(require,module,exports){
'use strict';

module.exports = require('react/lib/ReactDOM');

},{"react/lib/ReactDOM":49}],9:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react/addons"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react/addons"], factory);
	else if(typeof exports === 'object')
		exports["Highcharts"] = factory(require("react"), require("react/addons"));
	else
		root["Highcharts"] = factory(root["react"], root["react/addons"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {global.HighchartsAdapter = __webpack_require__(5);
	var Highcharts = __webpack_require__(6);
	var React = __webpack_require__(2);
	var update = __webpack_require__(3).addons.update;
	module.exports = React.createClass({
	  displayName: 'Highcharts',

	  renderChart: function () {
	    if (!this.props.config) {
	      throw new Error('Config has to be specified, for the Highchart component');
	    }

	    var config = this.props.config;
	    var node = this.refs.chart.getDOMNode();

	    if (!config.chart) {
	      config = update(config, {chart: {$set: {}}})
	    }

	    config = update(config, {chart: {renderTo: {$set: node}}});

	    this.chart = new Highcharts.Chart(config);
	  },

	  getChart: function() {
	    if (!this.chart) {
	        throw new Error('getChart() should not be called before the component is mounted');
	    }
	    return this.chart;
	  },

	  componentDidMount: function () {
	    this.renderChart();
	  },
	  componentDidUpdate: function () {
	    this.renderChart();
	  },
	  render: function () {
	    return React.createElement("div", {className: "chart", ref: "chart"})
	  }
	});

	module.exports.Highcharts = Highcharts;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license @product.name@ JS v@product.version@ (@product.date@)
	 *
	 * Standalone Highcharts Framework
	 *
	 * License: MIT License
	 */


	/*global Highcharts */
	var HighchartsAdapter = (function () {

	var UNDEFINED,
		doc = document,
		emptyArray = [],
		timers = [],
		timerId,
		animSetters = {},
		Fx;

	Math.easeInOutSine = function (t, b, c, d) {
		return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	};



	/**
	 * Extend given object with custom events
	 */
	function augment(obj) {
		function removeOneEvent(el, type, fn) {
			el.removeEventListener(type, fn, false);
		}

		function IERemoveOneEvent(el, type, fn) {
			fn = el.HCProxiedMethods[fn.toString()];
			el.detachEvent('on' + type, fn);
		}

		function removeAllEvents(el, type) {
			var events = el.HCEvents,
				remove,
				types,
				len,
				n;

			if (el.removeEventListener) {
				remove = removeOneEvent;
			} else if (el.attachEvent) {
				remove = IERemoveOneEvent;
			} else {
				return; // break on non-DOM events
			}


			if (type) {
				types = {};
				types[type] = true;
			} else {
				types = events;
			}

			for (n in types) {
				if (events[n]) {
					len = events[n].length;
					while (len--) {
						remove(el, n, events[n][len]);
					}
				}
			}
		}

		if (!obj.HCExtended) {
			Highcharts.extend(obj, {
				HCExtended: true,

				HCEvents: {},

				bind: function (name, fn) {
					var el = this,
						events = this.HCEvents,
						wrappedFn;

					// handle DOM events in modern browsers
					if (el.addEventListener) {
						el.addEventListener(name, fn, false);

					// handle old IE implementation
					} else if (el.attachEvent) {
						
						wrappedFn = function (e) {
							e.target = e.srcElement || window; // #2820
							fn.call(el, e);
						};

						if (!el.HCProxiedMethods) {
							el.HCProxiedMethods = {};
						}

						// link wrapped fn with original fn, so we can get this in removeEvent
						el.HCProxiedMethods[fn.toString()] = wrappedFn;

						el.attachEvent('on' + name, wrappedFn);
					}


					if (events[name] === UNDEFINED) {
						events[name] = [];
					}

					events[name].push(fn);
				},

				unbind: function (name, fn) {
					var events,
						index;

					if (name) {
						events = this.HCEvents[name] || [];
						if (fn) {
							index = HighchartsAdapter.inArray(fn, events);
							if (index > -1) {
								events.splice(index, 1);
								this.HCEvents[name] = events;
							}
							if (this.removeEventListener) {
								removeOneEvent(this, name, fn);
							} else if (this.attachEvent) {
								IERemoveOneEvent(this, name, fn);
							}
						} else {
							removeAllEvents(this, name);
							this.HCEvents[name] = [];
						}
					} else {
						removeAllEvents(this);
						this.HCEvents = {};
					}
				},

				trigger: function (name, args) {
					var events = this.HCEvents[name] || [],
						target = this,
						len = events.length,
						i,
						preventDefault,
						fn;

					// Attach a simple preventDefault function to skip default handler if called
					preventDefault = function () {
						args.defaultPrevented = true;
					};
					
					for (i = 0; i < len; i++) {
						fn = events[i];

						// args is never null here
						if (args.stopped) {
							return;
						}

						args.preventDefault = preventDefault;
						args.target = target;

						// If the type is not set, we're running a custom event (#2297). If it is set,
						// we're running a browser event, and setting it will cause en error in
						// IE8 (#2465).
						if (!args.type) {
							args.type = name;
						}
						

						
						// If the event handler return false, prevent the default handler from executing
						if (fn.call(this, args) === false) {
							args.preventDefault();
						}
					}
				}
			});
		}

		return obj;
	}


	return {

		/**
		 * Initialize the adapter. This is run once as Highcharts is first run.
		 */
		init: function (pathAnim) {

			/**
			 * Compatibility section to add support for legacy IE. This can be removed if old IE 
			 * support is not needed.
			 */
			if (!doc.defaultView) {
				this._getStyle = function (el, prop) {
					var val;
					if (el.style[prop]) {
						return el.style[prop];
					} else {
						if (prop === 'opacity') {
							prop = 'filter';
						}
						/*jslint unparam: true*/
						val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) { return b.toUpperCase(); })];
						if (prop === 'filter') {
							val = val.replace(
								/alpha\(opacity=([0-9]+)\)/, 
								function (a, b) { 
									return b / 100; 
								}
							);
						}
						/*jslint unparam: false*/
						return val === '' ? 1 : val;
					} 
				};
				this.adapterRun = function (elem, method) {
					var alias = { width: 'clientWidth', height: 'clientHeight' }[method];

					if (alias) {
						elem.style.zoom = 1;
						return elem[alias] - 2 * parseInt(HighchartsAdapter._getStyle(elem, 'padding'), 10);
					}
				};
			}

			if (!Array.prototype.forEach) {
				this.each = function (arr, fn) { // legacy
					var i = 0, 
						len = arr.length;
					for (; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			}

			if (!Array.prototype.indexOf) {
				this.inArray = function (item, arr) {
					var len, 
						i = 0;

					if (arr) {
						len = arr.length;
						
						for (; i < len; i++) {
							if (arr[i] === item) {
								return i;
							}
						}
					}

					return -1;
				};
			}

			if (!Array.prototype.filter) {
				this.grep = function (elements, callback) {
					var ret = [],
						i = 0,
						length = elements.length;

					for (; i < length; i++) {
						if (!!callback(elements[i], i)) {
							ret.push(elements[i]);
						}
					}

					return ret;
				};
			}

			//--- End compatibility section ---


			/**
			 * Start of animation specific code
			 */
			Fx = function (elem, options, prop) {
				this.options = options;
				this.elem = elem;
				this.prop = prop;
			};
			Fx.prototype = {
				
				update: function () {
					var styles,
						paths = this.paths,
						elem = this.elem,
						elemelem = elem.element; // if destroyed, it is null

					// Animation setter defined from outside
					if (animSetters[this.prop]) {
						animSetters[this.prop](this);

					// Animating a path definition on SVGElement
					} else if (paths && elemelem) {
						elem.attr('d', pathAnim.step(paths[0], paths[1], this.now, this.toD));

					// Other animations on SVGElement
					} else if (elem.attr) {
						if (elemelem) {
							elem.attr(this.prop, this.now);
						}

					// HTML styles
					} else {
						styles = {};
						styles[this.prop] = this.now + this.unit;
						Highcharts.css(elem, styles);
					}
					
					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}

				},
				custom: function (from, to, unit) {
					var self = this,
						t = function (gotoEnd) {
							return self.step(gotoEnd);
						},
						i;

					this.startTime = +new Date();
					this.start = from;
					this.end = to;
					this.unit = unit;
					this.now = this.start;
					this.pos = this.state = 0;

					t.elem = this.elem;

					if (t() && timers.push(t) === 1) {
						timerId = setInterval(function () {
							
							for (i = 0; i < timers.length; i++) {
								if (!timers[i]()) {
									timers.splice(i--, 1);
								}
							}

							if (!timers.length) {
								clearInterval(timerId);
							}
						}, 13);
					}
				},
				
				step: function (gotoEnd) {
					var t = +new Date(),
						ret,
						done,
						options = this.options,
						elem = this.elem,
						i;
					
					if (elem.stopAnimation || (elem.attr && !elem.element)) { // #2616, element including flag is destroyed
						ret = false;

					} else if (gotoEnd || t >= options.duration + this.startTime) {
						this.now = this.end;
						this.pos = this.state = 1;
						this.update();

						this.options.curAnim[this.prop] = true;

						done = true;
						for (i in options.curAnim) {
							if (options.curAnim[i] !== true) {
								done = false;
							}
						}

						if (done) {
							if (options.complete) {
								options.complete.call(elem);
							}
						}
						ret = false;

					} else {
						var n = t - this.startTime;
						this.state = n / options.duration;
						this.pos = options.easing(n, 0, 1, options.duration);
						this.now = this.start + ((this.end - this.start) * this.pos);
						this.update();
						ret = true;
					}
					return ret;
				}
			};

			/**
			 * The adapter animate method
			 */
			this.animate = function (el, prop, opt) {
				var start,
					unit = '',
					end,
					fx,
					args,
					name;

				el.stopAnimation = false; // ready for new

				if (typeof opt !== 'object' || opt === null) {
					args = arguments;
					opt = {
						duration: args[2],
						easing: args[3],
						complete: args[4]
					};
				}
				if (typeof opt.duration !== 'number') {
					opt.duration = 400;
				}
				opt.easing = Math[opt.easing] || Math.easeInOutSine;
				opt.curAnim = Highcharts.extend({}, prop);
				
				for (name in prop) {
					fx = new Fx(el, opt, name);
					end = null;
					
					if (name === 'd') {
						fx.paths = pathAnim.init(
							el,
							el.d,
							prop.d
						);
						fx.toD = prop.d;
						start = 0;
						end = 1;
					} else if (el.attr) {
						start = el.attr(name);
					} else {
						start = parseFloat(HighchartsAdapter._getStyle(el, name)) || 0;
						if (name !== 'opacity') {
							unit = 'px';
						}
					}
		
					if (!end) {
						end = prop[name];
					}
					fx.custom(start, end, unit);
				}	
			};
		},

		/**
		 * Internal method to return CSS value for given element and property
		 */
		_getStyle: function (el, prop) {
			return window.getComputedStyle(el, undefined).getPropertyValue(prop);
		},

		/**
		 * Add an animation setter for a specific property
		 */
		addAnimSetter: function (prop, fn) {
			animSetters[prop] = fn;
		},

		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: function (scriptLocation, callback) {
			// We cannot assume that Assets class from mootools-more is available so instead insert a script tag to download script.
			var head = doc.getElementsByTagName('head')[0],
				script = doc.createElement('script');

			script.type = 'text/javascript';
			script.src = scriptLocation;
			script.onload = callback;

			head.appendChild(script);
		},

		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: function (item, arr) {
			return arr.indexOf ? arr.indexOf(item) : emptyArray.indexOf.call(arr, item);
		},


		/**
		 * A direct link to adapter methods
		 */
		adapterRun: function (elem, method) {
			return parseInt(HighchartsAdapter._getStyle(elem, method), 10);
		},

		/**
		 * Filter an array
		 */
		grep: function (elements, callback) {
			return emptyArray.filter.call(elements, callback);
		},

		/**
		 * Map an array
		 */
		map: function (arr, fn) {
			var results = [], i = 0, len = arr.length;

			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}

			return results;
		},

		/**
		 * Get the element's offset position, corrected by overflow:auto. Loosely based on jQuery's offset method.
		 */
		offset: function (el) {
			var docElem = document.documentElement,
				box = el.getBoundingClientRect();

			return {
				top: box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
				left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
			};
		},

		/**
		 * Add an event listener
		 */
		addEvent: function (el, type, fn) {
			augment(el).bind(type, fn);
		},

		/**
		 * Remove event added with addEvent
		 */
		removeEvent: function (el, type, fn) {
			augment(el).unbind(type, fn);
		},

		/**
		 * Fire an event on a custom object
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var e;

			if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
				e = doc.createEvent('Events');
				e.initEvent(type, true, true);
				e.target = el;

				Highcharts.extend(e, eventArguments);

				if (el.dispatchEvent) {
					el.dispatchEvent(e);
				} else {
					el.fireEvent(type, e);
				}

			} else if (el.HCExtended === true) {
				eventArguments = eventArguments || {};
				el.trigger(type, eventArguments);
			}

			if (eventArguments && eventArguments.defaultPrevented) {
				defaultFunction = null;
			}

			if (defaultFunction) {
				defaultFunction(eventArguments);
			}
		},

		washMouseEvent: function (e) {
			return e;
		},


		/**
		 * Stop running animation
		 */
		stop: function (el) {
			el.stopAnimation = true;
		},

		/**
		 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		each: function (arr, fn) { // modern browsers
			return Array.prototype.forEach.call(arr, fn);
		}
	};
	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = HighchartsAdapter

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// ==ClosureCompiler==
	// @compilation_level SIMPLE_OPTIMIZATIONS

	/**
	 * @license Highcharts JS v4.1.7-modified ()
	 *
	 * (c) 2009-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	// JSLint options:
	/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
	/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
	(function () {
	// encapsulated variables
	var UNDEFINED,
		doc = document,
		win = window,
		math = Math,
		mathRound = math.round,
		mathFloor = math.floor,
		mathCeil = math.ceil,
		mathMax = math.max,
		mathMin = math.min,
		mathAbs = math.abs,
		mathCos = math.cos,
		mathSin = math.sin,
		mathPI = math.PI,
		deg2rad = mathPI * 2 / 360,


		// some variables
		userAgent = navigator.userAgent,
		isOpera = win.opera,
		isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
		docMode8 = doc.documentMode === 8,
		isWebKit = /AppleWebKit/.test(userAgent),
		isFirefox = /Firefox/.test(userAgent),
		isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
		SVG_NS = 'http://www.w3.org/2000/svg',
		hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
		hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
		useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
		Renderer,
		hasTouch,
		symbolSizes = {},
		idCounter = 0,
		garbageBin,
		defaultOptions,
		dateFormat, // function
		globalAnimation,
		pathAnim,
		timeUnits,
		noop = function () { return UNDEFINED; },
		charts = [],
		chartCount = 0,
		PRODUCT = 'Highcharts',
		VERSION = '4.1.7-modified',

		// some constants for frequently used strings
		DIV = 'div',
		ABSOLUTE = 'absolute',
		RELATIVE = 'relative',
		HIDDEN = 'hidden',
		PREFIX = 'highcharts-',
		VISIBLE = 'visible',
		PX = 'px',
		NONE = 'none',
		M = 'M',
		L = 'L',
		numRegex = /^[0-9]+$/,
		NORMAL_STATE = '',
		HOVER_STATE = 'hover',
		SELECT_STATE = 'select',
		marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
		
		// Object for extending Axis
		AxisPlotLineOrBandExtension,

		// constants for attributes
		STROKE_WIDTH = 'stroke-width',

		// time methods, changed based on whether or not UTC is used
		Date,  // Allow using a different Date class
		makeTime,
		timezoneOffset,
		getTimezoneOffset,
		getMinutes,
		getHours,
		getDay,
		getDate,
		getMonth,
		getFullYear,
		setMilliseconds,
		setSeconds,
		setMinutes,
		setHours,
		setDate,
		setMonth,
		setFullYear,


		// lookup over the types and the associated classes
		seriesTypes = {},
		Highcharts;

	// The Highcharts namespace
	Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

	Highcharts.seriesTypes = seriesTypes;

	/**
	 * Extend an object with the members of another
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to add to the first one
	 */
	var extend = Highcharts.extend = function (a, b) {
		var n;
		if (!a) {
			a = {};
		}
		for (n in b) {
			a[n] = b[n];
		}
		return a;
	};
		
	/**
	 * Deep merge two or more objects and return a third object. If the first argument is
	 * true, the contents of the second object is copied into the first object.
	 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
	 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
	 * it copied properties from extended prototypes. 
	 */
	function merge() {
		var i,
			args = arguments,
			len,
			ret = {},
			doCopy = function (copy, original) {
				var value, key;

				// An object is replacing a primitive
				if (typeof copy !== 'object') {
					copy = {};
				}

				for (key in original) {
					if (original.hasOwnProperty(key)) {
						value = original[key];

						// Copy the contents of objects, but not arrays or DOM nodes
						if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
								key !== 'renderTo' && typeof value.nodeType !== 'number') {
							copy[key] = doCopy(copy[key] || {}, value);
					
						// Primitives and arrays are copied over directly
						} else {
							copy[key] = original[key];
						}
					}
				}
				return copy;
			};

		// If first argument is true, copy into the existing object. Used in setOptions.
		if (args[0] === true) {
			ret = args[1];
			args = Array.prototype.slice.call(args, 2);
		}

		// For each argument, extend the return
		len = args.length;
		for (i = 0; i < len; i++) {
			ret = doCopy(ret, args[i]);
		}

		return ret;
	}

	/**
	 * Shortcut for parseInt
	 * @param {Object} s
	 * @param {Number} mag Magnitude
	 */
	function pInt(s, mag) {
		return parseInt(s, mag || 10);
	}

	/**
	 * Check for string
	 * @param {Object} s
	 */
	function isString(s) {
		return typeof s === 'string';
	}

	/**
	 * Check for object
	 * @param {Object} obj
	 */
	function isObject(obj) {
		return obj && typeof obj === 'object';
	}

	/**
	 * Check for array
	 * @param {Object} obj
	 */
	function isArray(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	}

	/**
	 * Check for number
	 * @param {Object} n
	 */
	function isNumber(n) {
		return typeof n === 'number';
	}

	function log2lin(num) {
		return math.log(num) / math.LN10;
	}
	function lin2log(num) {
		return math.pow(10, num);
	}

	/**
	 * Remove last occurence of an item from an array
	 * @param {Array} arr
	 * @param {Mixed} item
	 */
	function erase(arr, item) {
		var i = arr.length;
		while (i--) {
			if (arr[i] === item) {
				arr.splice(i, 1);
				break;
			}
		}
		//return arr;
	}

	/**
	 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
	 * @param {Object} obj
	 */
	function defined(obj) {
		return obj !== UNDEFINED && obj !== null;
	}

	/**
	 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
	 * it attempts to set expando properties on the SVG element, which is not allowed.
	 *
	 * @param {Object} elem The DOM element to receive the attribute(s)
	 * @param {String|Object} prop The property or an abject of key-value pairs
	 * @param {String} value The value if a single property is set
	 */
	function attr(elem, prop, value) {
		var key,
			ret;

		// if the prop is a string
		if (isString(prop)) {
			// set the value
			if (defined(value)) {
				elem.setAttribute(prop, value);

			// get the value
			} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
				ret = elem.getAttribute(prop);
			}

		// else if prop is defined, it is a hash of key/value pairs
		} else if (defined(prop) && isObject(prop)) {
			for (key in prop) {
				elem.setAttribute(key, prop[key]);
			}
		}
		return ret;
	}
	/**
	 * Check if an element is an array, and if not, make it into an array. Like
	 * MooTools' $.splat.
	 */
	function splat(obj) {
		return isArray(obj) ? obj : [obj];
	}


	/**
	 * Return the first value that is defined. Like MooTools' $.pick.
	 */
	var pick = Highcharts.pick = function () {
		var args = arguments,
			i,
			arg,
			length = args.length;
		for (i = 0; i < length; i++) {
			arg = args[i];
			if (arg !== UNDEFINED && arg !== null) {
				return arg;
			}
		}
	};

	/**
	 * Set CSS on a given element
	 * @param {Object} el
	 * @param {Object} styles Style object with camel case property names
	 */
	function css(el, styles) {
		if (isIE && !hasSVG) { // #2686
			if (styles && styles.opacity !== UNDEFINED) {
				styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
			}
		}
		extend(el.style, styles);
	}

	/**
	 * Utility function to create element with attributes and styles
	 * @param {Object} tag
	 * @param {Object} attribs
	 * @param {Object} styles
	 * @param {Object} parent
	 * @param {Object} nopad
	 */
	function createElement(tag, attribs, styles, parent, nopad) {
		var el = doc.createElement(tag);
		if (attribs) {
			extend(el, attribs);
		}
		if (nopad) {
			css(el, {padding: 0, border: NONE, margin: 0});
		}
		if (styles) {
			css(el, styles);
		}
		if (parent) {
			parent.appendChild(el);
		}
		return el;
	}

	/**
	 * Extend a prototyped class by new members
	 * @param {Object} parent
	 * @param {Object} members
	 */
	function extendClass(parent, members) {
		var object = function () { return UNDEFINED; };
		object.prototype = new parent();
		extend(object.prototype, members);
		return object;
	}

	/**
	 * Pad a string to a given length by adding 0 to the beginning
	 * @param {Number} number
	 * @param {Number} length
	 */
	function pad(number, length) {
		// Create an array of the remaining length +1 and join it with 0's
		return new Array((length || 2) + 1 - String(number).length).join(0) + number;
	}

	/**
	 * Return a length based on either the integer value, or a percentage of a base.
	 */
	function relativeLength (value, base) {
		return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
	}

	/**
	 * Wrap a method with extended functionality, preserving the original function
	 * @param {Object} obj The context object that the method belongs to 
	 * @param {String} method The name of the method to extend
	 * @param {Function} func A wrapper function callback. This function is called with the same arguments
	 * as the original function, except that the original function is unshifted and passed as the first 
	 * argument. 
	 */
	var wrap = Highcharts.wrap = function (obj, method, func) {
		var proceed = obj[method];
		obj[method] = function () {
			var args = Array.prototype.slice.call(arguments);
			args.unshift(proceed);
			return func.apply(this, args);
		};
	};


	function getTZOffset(timestamp) {
		return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
	}

	/**
	 * Based on http://www.php.net/manual/en/function.strftime.php
	 * @param {String} format
	 * @param {Number} timestamp
	 * @param {Boolean} capitalize
	 */
	dateFormat = function (format, timestamp, capitalize) {
		if (!defined(timestamp) || isNaN(timestamp)) {
			return 'Invalid date';
		}
		format = pick(format, '%Y-%m-%d %H:%M:%S');

		var date = new Date(timestamp - getTZOffset(timestamp)),
			key, // used in for constuct below
			// get the basic time values
			hours = date[getHours](),
			day = date[getDay](),
			dayOfMonth = date[getDate](),
			month = date[getMonth](),
			fullYear = date[getFullYear](),
			lang = defaultOptions.lang,
			langWeekdays = lang.weekdays,

			// List all format keys. Custom formats can be added from the outside. 
			replacements = extend({

				// Day
				'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
				'A': langWeekdays[day], // Long weekday, like 'Monday'
				'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
				'e': dayOfMonth, // Day of the month, 1 through 31
				'w': day,

				// Week (none implemented)
				//'W': weekNumber(),

				// Month
				'b': lang.shortMonths[month], // Short month, like 'Jan'
				'B': lang.months[month], // Long month, like 'January'
				'm': pad(month + 1), // Two digit month number, 01 through 12

				// Year
				'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
				'Y': fullYear, // Four digits year, like 2009

				// Time
				'H': pad(hours), // Two digits hours in 24h format, 00 through 23
				'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
				'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
				'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
				'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
				'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
				'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
				'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
			}, Highcharts.dateFormats);


		// do the replaces
		for (key in replacements) {
			while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
				format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
			}
		}

		// Optionally capitalize the string and return
		return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
	};

	/** 
	 * Format a single variable. Similar to sprintf, without the % prefix.
	 */
	function formatSingle(format, val) {
		var floatRegex = /f$/,
			decRegex = /\.([0-9])/,
			lang = defaultOptions.lang,
			decimals;

		if (floatRegex.test(format)) { // float
			decimals = format.match(decRegex);
			decimals = decimals ? decimals[1] : -1;
			if (val !== null) {
				val = Highcharts.numberFormat(
					val,
					decimals,
					lang.decimalPoint,
					format.indexOf(',') > -1 ? lang.thousandsSep : ''
				);
			}
		} else {
			val = dateFormat(format, val);
		}
		return val;
	}

	/**
	 * Format a string according to a subset of the rules of Python's String.format method.
	 */
	function format(str, ctx) {
		var splitter = '{',
			isInside = false,
			segment,
			valueAndFormat,
			path,
			i,
			len,
			ret = [],
			val,
			index;
		
		while ((index = str.indexOf(splitter)) !== -1) {
			
			segment = str.slice(0, index);
			if (isInside) { // we're on the closing bracket looking back
				
				valueAndFormat = segment.split(':');
				path = valueAndFormat.shift().split('.'); // get first and leave format
				len = path.length;
				val = ctx;

				// Assign deeper paths
				for (i = 0; i < len; i++) {
					val = val[path[i]];
				}

				// Format the replacement
				if (valueAndFormat.length) {
					val = formatSingle(valueAndFormat.join(':'), val);
				}

				// Push the result and advance the cursor
				ret.push(val);
				
			} else {
				ret.push(segment);
				
			}
			str = str.slice(index + 1); // the rest
			isInside = !isInside; // toggle
			splitter = isInside ? '}' : '{'; // now look for next matching bracket
		}
		ret.push(str);
		return ret.join('');
	}

	/**
	 * Get the magnitude of a number
	 */
	function getMagnitude(num) {
		return math.pow(10, mathFloor(math.log(num) / math.LN10));
	}

	/**
	 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
	 * @param {Number} interval
	 * @param {Array} multiples
	 * @param {Number} magnitude
	 * @param {Object} options
	 */
	function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
		var normalized, 
			i,
			retInterval = interval;

		// round to a tenfold of 1, 2, 2.5 or 5
		magnitude = pick(magnitude, 1);
		normalized = interval / magnitude;

		// multiples for a linear scale
		if (!multiples) {
			multiples = [1, 2, 2.5, 5, 10];

			// the allowDecimals option
			if (allowDecimals === false) {
				if (magnitude === 1) {
					multiples = [1, 2, 5, 10];
				} else if (magnitude <= 0.1) {
					multiples = [1 / magnitude];
				}
			}
		}

		// normalize the interval to the nearest multiple
		for (i = 0; i < multiples.length; i++) {
			retInterval = multiples[i];
			if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
				(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
				break;
			}
		}

		// multiply back to the correct magnitude
		retInterval *= magnitude;
		
		return retInterval;
	}


	/**
	 * Utility method that sorts an object array and keeping the order of equal items.
	 * ECMA script standard does not specify the behaviour when items are equal.
	 */
	function stableSort(arr, sortFunction) {
		var length = arr.length,
			sortValue,
			i;

		// Add index to each item
		for (i = 0; i < length; i++) {
			arr[i].ss_i = i; // stable sort index
		}

		arr.sort(function (a, b) {
			sortValue = sortFunction(a, b);
			return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
		});

		// Remove index from items
		for (i = 0; i < length; i++) {
			delete arr[i].ss_i; // stable sort index
		}
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMin(data) {
		var i = data.length,
			min = data[0];

		while (i--) {
			if (data[i] < min) {
				min = data[i];
			}
		}
		return min;
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMax(data) {
		var i = data.length,
			max = data[0];

		while (i--) {
			if (data[i] > max) {
				max = data[i];
			}
		}
		return max;
	}

	/**
	 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
	 * It loops all properties and invokes destroy if there is a destroy method. The property is
	 * then delete'ed.
	 * @param {Object} The object to destroy properties on
	 * @param {Object} Exception, do not destroy this property, only delete it.
	 */
	function destroyObjectProperties(obj, except) {
		var n;
		for (n in obj) {
			// If the object is non-null and destroy is defined
			if (obj[n] && obj[n] !== except && obj[n].destroy) {
				// Invoke the destroy
				obj[n].destroy();
			}

			// Delete the property from the object.
			delete obj[n];
		}
	}


	/**
	 * Discard an element by moving it to the bin and delete
	 * @param {Object} The HTML node to discard
	 */
	function discardElement(element) {
		// create a garbage bin element, not part of the DOM
		if (!garbageBin) {
			garbageBin = createElement(DIV);
		}

		// move the node and empty bin
		if (element) {
			garbageBin.appendChild(element);
		}
		garbageBin.innerHTML = '';
	}

	/**
	 * Provide error messages for debugging, with links to online explanation 
	 */
	function error (code, stop) {
		var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
		if (stop) {
			throw msg;
		}
		// else ...
		if (win.console) {
			console.log(msg);
		}
	}

	/**
	 * Fix JS round off float errors
	 * @param {Number} num
	 */
	function correctFloat(num, prec) {
		return parseFloat(
			num.toPrecision(prec || 14)
		);
	}

	/**
	 * Set the global animation to either a given value, or fall back to the
	 * given chart's animation option
	 * @param {Object} animation
	 * @param {Object} chart
	 */
	function setAnimation(animation, chart) {
		globalAnimation = pick(animation, chart.animation);
	}

	/**
	 * The time unit lookup
	 */
	timeUnits = {
		millisecond: 1,
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 24 * 3600000,
		week: 7 * 24 * 3600000,
		month: 28 * 24 * 3600000,
		year: 364 * 24 * 3600000
	};


	/**
	 * Format a number and return a string based on input settings
	 * @param {Number} number The input number to format
	 * @param {Number} decimals The amount of decimals
	 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
	 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
	 */
	Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
		var lang = defaultOptions.lang,
			// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
			n = +number || 0,
			c = decimals === -1 ?
				mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
				(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
			d = decPoint === undefined ? lang.decimalPoint : decPoint,
			t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
			s = n < 0 ? "-" : "",
			i = String(pInt(n = mathAbs(n).toFixed(c))),
			j = i.length > 3 ? i.length % 3 : 0;

		return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
				(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
	};
	/**
	 * Path interpolation algorithm used across adapters
	 */
	pathAnim = {
		/**
		 * Prepare start and end values so that the path can be animated one to one
		 */
		init: function (elem, fromD, toD) {
			fromD = fromD || '';
			var shift = elem.shift,
				bezier = fromD.indexOf('C') > -1,
				numParams = bezier ? 7 : 3,
				endLength,
				slice,
				i,
				start = fromD.split(' '),
				end = [].concat(toD), // copy
				startBaseLine,
				endBaseLine,
				sixify = function (arr) { // in splines make move points have six parameters like bezier curves
					i = arr.length;
					while (i--) {
						if (arr[i] === M) {
							arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
						}
					}
				};

			if (bezier) {
				sixify(start);
				sixify(end);
			}

			// pull out the base lines before padding
			if (elem.isArea) {
				startBaseLine = start.splice(start.length - 6, 6);
				endBaseLine = end.splice(end.length - 6, 6);
			}

			// if shifting points, prepend a dummy point to the end path
			if (shift <= end.length / numParams && start.length === end.length) {
				while (shift--) {
					end = [].concat(end).splice(0, numParams).concat(end);
				}
			}
			elem.shift = 0; // reset for following animations

			// copy and append last point until the length matches the end length
			if (start.length) {
				endLength = end.length;
				while (start.length < endLength) {

					//bezier && sixify(start);
					slice = [].concat(start).splice(start.length - numParams, numParams);
					if (bezier) { // disable first control point
						slice[numParams - 6] = slice[numParams - 2];
						slice[numParams - 5] = slice[numParams - 1];
					}
					start = start.concat(slice);
				}
			}

			if (startBaseLine) { // append the base lines for areas
				start = start.concat(startBaseLine);
				end = end.concat(endBaseLine);
			}
			return [start, end];
		},

		/**
		 * Interpolate each value of the path and return the array
		 */
		step: function (start, end, pos, complete) {
			var ret = [],
				i = start.length,
				startVal;

			if (pos === 1) { // land on the final path without adjustment points appended in the ends
				ret = complete;

			} else if (i === end.length && pos < 1) {
				while (i--) {
					startVal = parseFloat(start[i]);
					ret[i] =
						isNaN(startVal) ? // a letter instruction like M or L
							start[i] :
							pos * (parseFloat(end[i] - startVal)) + startVal;

				}
			} else { // if animation is finished or length not matching, land on right value
				ret = end;
			}
			return ret;
		}
	};

	(function ($) {
		/**
		 * The default HighchartsAdapter for jQuery
		 */
		win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
			
			/**
			 * Initialize the adapter by applying some extensions to jQuery
			 */
			init: function (pathAnim) {
				
				// extend the animate function to allow SVG animations
				var Fx = $.fx;
				
				/*jslint unparam: true*//* allow unused param x in this function */
				$.extend($.easing, {
					easeOutQuad: function (x, t, b, c, d) {
						return -c * (t /= d) * (t - 2) + b;
					}
				});
				/*jslint unparam: false*/
			
				// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
				$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
					var obj = Fx.step,
						base;
						
					// Handle different parent objects
					if (fn === 'cur') {
						obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
					
					} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
						obj = $.Tween.propHooks[fn];
						fn = 'set';
					}
			
					// Overwrite the method
					base = obj[fn];
					if (base) { // step.width and step.height don't exist in jQuery < 1.7
			
						// create the extended function replacement
						obj[fn] = function (fx) {

							var elem;
							
							// Fx.prototype.cur does not use fx argument
							fx = i ? fx : this;

							// Don't run animations on textual properties like align (#1821)
							if (fx.prop === 'align') {
								return;
							}
			
							// shortcut
							elem = fx.elem;
			
							// Fx.prototype.cur returns the current value. The other ones are setters
							// and returning a value has no effect.
							return elem.attr ? // is SVG element wrapper
								elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
								base.apply(this, arguments); // use jQuery's built-in method
						};
					}
				});

				// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
				wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
					return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
				});
				
				// Define the setter function for d (path definitions)
				this.addAnimSetter('d', function (fx) {
					var elem = fx.elem,
						ends;
			
					// Normally start and end should be set in state == 0, but sometimes,
					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
					// in these cases
					if (!fx.started) {
						ends = pathAnim.init(elem, elem.d, elem.toD);
						fx.start = ends[0];
						fx.end = ends[1];
						fx.started = true;
					}
			
					// Interpolate each value of the path
					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
				});
				
				/**
				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				this.each = Array.prototype.forEach ?
					function (arr, fn) { // modern browsers
						return Array.prototype.forEach.call(arr, fn);
						
					} : 
					function (arr, fn) { // legacy
						var i, 
							len = arr.length;
						for (i = 0; i < len; i++) {
							if (fn.call(arr[i], arr[i], i, arr) === false) {
								return i;
							}
						}
					};
				
				/**
				 * Register Highcharts as a plugin in the respective framework
				 */
				$.fn.highcharts = function () {
					var constr = 'Chart', // default constructor
						args = arguments,
						options,
						ret,
						chart;

					if (this[0]) {

						if (isString(args[0])) {
							constr = args[0];
							args = Array.prototype.slice.call(args, 1); 
						}
						options = args[0];

						// Create the chart
						if (options !== UNDEFINED) {
							/*jslint unused:false*/
							options.chart = options.chart || {};
							options.chart.renderTo = this[0];
							chart = new Highcharts[constr](options, args[1]);
							ret = this;
							/*jslint unused:true*/
						}

						// When called without parameters or with the return argument, get a predefined chart
						if (options === UNDEFINED) {
							ret = charts[attr(this[0], 'data-highcharts-chart')];
						}
					}
					
					return ret;
				};

			},

			/**
			 * Add an animation setter for a specific property
			 */
			addAnimSetter: function (prop, setter) {
				// jQuery 1.8 style
				if ($.Tween) {
					$.Tween.propHooks[prop] = {
						set: setter
					};
				// pre 1.8
				} else {
					$.fx.step[prop] = setter;
				}
			},
			
			/**
			 * Downloads a script and executes a callback when done.
			 * @param {String} scriptLocation
			 * @param {Function} callback
			 */
			getScript: $.getScript,
			
			/**
			 * Return the index of an item in an array, or -1 if not found
			 */
			inArray: $.inArray,
			
			/**
			 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
			 * @param {Object} elem The HTML element
			 * @param {String} method Which method to run on the wrapped element
			 */
			adapterRun: function (elem, method) {
				return $(elem)[method]();
			},
		
			/**
			 * Filter an array
			 */
			grep: $.grep,
		
			/**
			 * Map an array
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			map: function (arr, fn) {
				//return jQuery.map(arr, fn);
				var results = [],
					i = 0,
					len = arr.length;
				for (; i < len; i++) {
					results[i] = fn.call(arr[i], arr[i], i, arr);
				}
				return results;
		
			},
		
			/**
			 * Get the position of an element relative to the top left of the page
			 */
			offset: function (el) {
				return $(el).offset();
			},
		
			/**
			 * Add an event listener
			 * @param {Object} el A HTML element or custom object
			 * @param {String} event The event type
			 * @param {Function} fn The event handler
			 */
			addEvent: function (el, event, fn) {
				$(el).bind(event, fn);
			},
		
			/**
			 * Remove event added with addEvent
			 * @param {Object} el The object
			 * @param {String} eventType The event type. Leave blank to remove all events.
			 * @param {Function} handler The function to remove
			 */
			removeEvent: function (el, eventType, handler) {
				// workaround for jQuery issue with unbinding custom events:
				// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
				var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
				if (doc[func] && el && !el[func]) {
					el[func] = function () {};
				}
		
				$(el).unbind(eventType, handler);
			},
		
			/**
			 * Fire an event on a custom object
			 * @param {Object} el
			 * @param {String} type
			 * @param {Object} eventArguments
			 * @param {Function} defaultFunction
			 */
			fireEvent: function (el, type, eventArguments, defaultFunction) {
				var event = $.Event(type),
					detachedType = 'detached' + type,
					defaultPrevented;
		
				// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
				// never uses these properties, Chrome includes them in the default click event and
				// raises the warning when they are copied over in the extend statement below.
				//
				// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
				// testing if they are there (warning in chrome) the only option is to test if running IE.
				if (!isIE && eventArguments) {
					delete eventArguments.layerX;
					delete eventArguments.layerY;
					delete eventArguments.returnValue;
				}
		
				extend(event, eventArguments);
		
				// Prevent jQuery from triggering the object method that is named the
				// same as the event. For example, if the event is 'select', jQuery
				// attempts calling el.select and it goes into a loop.
				if (el[type]) {
					el[detachedType] = el[type];
					el[type] = null;
				}
		
				// Wrap preventDefault and stopPropagation in try/catch blocks in
				// order to prevent JS errors when cancelling events on non-DOM
				// objects. #615.
				/*jslint unparam: true*/
				$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
					var base = event[fn];
					event[fn] = function () {
						try {
							base.call(event);
						} catch (e) {
							if (fn === 'preventDefault') {
								defaultPrevented = true;
							}
						}
					};
				});
				/*jslint unparam: false*/
		
				// trigger it
				$(el).trigger(event);
		
				// attach the method
				if (el[detachedType]) {
					el[type] = el[detachedType];
					el[detachedType] = null;
				}
		
				if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
					defaultFunction(event);
				}
			},
			
			/**
			 * Extension method needed for MooTools
			 */
			washMouseEvent: function (e) {
				var ret = e.originalEvent || e;
				
				// computed by jQuery, needed by IE8
				if (ret.pageX === UNDEFINED) { // #1236
					ret.pageX = e.pageX;
					ret.pageY = e.pageY;
				}
				
				return ret;
			},
		
			/**
			 * Animate a HTML element or SVG element wrapper
			 * @param {Object} el
			 * @param {Object} params
			 * @param {Object} options jQuery-like animation options: duration, easing, callback
			 */
			animate: function (el, params, options) {
				var $el = $(el);
				if (!el.style) {
					el.style = {}; // #1881
				}
				if (params.d) {
					el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
					params.d = 1; // because in jQuery, animating to an array has a different meaning
				}
		
				$el.stop();
				if (params.opacity !== UNDEFINED && el.attr) {
					params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
				}
				el.hasAnim = 1; // #3342
				$el.animate(params, options);
		
			},
			/**
			 * Stop running animation
			 */
			stop: function (el) {
				if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
					$(el).stop();
				}
			}
		});
	}(win.jQuery));


	// check for a custom HighchartsAdapter defined prior to this file
	var globalAdapter = win.HighchartsAdapter,
		adapter = globalAdapter || {};
		
	// Initialize the adapter
	if (globalAdapter) {
		globalAdapter.init.call(globalAdapter, pathAnim);
	}


	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	var adapterRun = adapter.adapterRun,
		getScript = adapter.getScript,
		inArray = adapter.inArray,
		each = Highcharts.each = adapter.each,
		grep = adapter.grep,
		offset = adapter.offset,
		map = adapter.map,
		addEvent = adapter.addEvent,
		removeEvent = adapter.removeEvent,
		fireEvent = adapter.fireEvent,
		washMouseEvent = adapter.washMouseEvent,
		animate = adapter.animate,
		stop = adapter.stop;



	/* ****************************************************************************
	 * Handle the options                                                         *
	 *****************************************************************************/
	defaultOptions = {
		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
			    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
		symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
		lang: {
			loading: 'Loading...',
			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
					'August', 'September', 'October', 'November', 'December'],
			shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
			weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
			decimalPoint: '.',
			numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
			resetZoom: 'Reset zoom',
			resetZoomTitle: 'Reset zoom level 1:1',
			thousandsSep: ' '
		},
		global: {
			useUTC: true,
			//timezoneOffset: 0,
			canvasToolsURL: 'http://code.highcharts.com/4.1.7-modified/modules/canvas-tools.js',
			VMLRadialGradientURL: 'http://code.highcharts.com/4.1.7-modified/gfx/vml-radial-gradient.png'
		},
		chart: {
			//animation: true,
			//alignTicks: false,
			//reflow: true,
			//className: null,
			//events: { load, selection },
			//margin: [null],
			//marginTop: null,
			//marginRight: null,
			//marginBottom: null,
			//marginLeft: null,
			borderColor: '#4572A7',
			//borderWidth: 0,
			borderRadius: 0,
			defaultSeriesType: 'line',
			ignoreHiddenSeries: true,
			//inverted: false,
			//shadow: false,
			spacing: [10, 10, 15, 10],
			//spacingTop: 10,
			//spacingRight: 10,
			//spacingBottom: 15,
			//spacingLeft: 10,
			//style: {
			//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			//	fontSize: '12px'
			//},
			backgroundColor: '#FFFFFF',
			//plotBackgroundColor: null,
			plotBorderColor: '#C0C0C0',
			//plotBorderWidth: 0,
			//plotShadow: false,
			//zoomType: ''
			resetZoomButton: {
				theme: {
					zIndex: 20
				},
				position: {
					align: 'right',
					x: -10,
					//verticalAlign: 'top',
					y: 10
				}
				// relativeTo: 'plot'
			}
		},
		title: {
			text: 'Chart title',
			align: 'center',
			// floating: false,
			margin: 15,
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#333333',
				fontSize: '18px'
			}

		},
		subtitle: {
			text: '',
			align: 'center',
			// floating: false
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#555555'
			}
		},

		plotOptions: {
			line: { // base series options
				allowPointSelect: false,
				showCheckbox: false,
				animation: {
					duration: 1000
				},
				//connectNulls: false,
				//cursor: 'default',
				//clip: true,
				//dashStyle: null,
				//enableMouseTracking: true,
				events: {},
				//legendIndex: 0,
				//linecap: 'round',
				lineWidth: 2,
				//shadow: false,
				// stacking: null,
				marker: {
					//enabled: true,
					//symbol: null,
					lineWidth: 0,
					radius: 4,
					lineColor: '#FFFFFF',
					//fillColor: null,
					states: { // states for a single point
						hover: {
							enabled: true,
							lineWidthPlus: 1,
							radiusPlus: 2
						},
						select: {
							fillColor: '#FFFFFF',
							lineColor: '#000000',
							lineWidth: 2
						}
					}
				},
				point: {
					events: {}
				},
				dataLabels: {
					align: 'center',
					// defer: true,
					// enabled: false,
					formatter: function () {
						return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
					},
					style: {
						color: 'contrast',
						fontSize: '11px',
						fontWeight: 'bold',
						textShadow: '0 0 6px contrast, 0 0 3px contrast'
					},
					verticalAlign: 'bottom', // above singular point
					x: 0,
					y: 0,
					// backgroundColor: undefined,
					// borderColor: undefined,
					// borderRadius: undefined,
					// borderWidth: undefined,
					padding: 5
					// shadow: false
				},
				cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
				pointRange: 0,
				//pointStart: 0,
				//pointInterval: 1,
				//showInLegend: null, // auto: true for standalone series, false for linked series
				states: { // states for the entire series
					hover: {
						//enabled: false,
						lineWidthPlus: 1,
						marker: {
							// lineWidth: base + 1,
							// radius: base + 1
						},
						halo: {
							size: 10,
							opacity: 0.25
						}
					},
					select: {
						marker: {}
					}
				},
				stickyTracking: true,
				//tooltip: {
					//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
					//valueDecimals: null,
					//xDateFormat: '%A, %b %e, %Y',
					//valuePrefix: '',
					//ySuffix: ''				
				//}
				turboThreshold: 1000
				// zIndex: null
			}
		},
		labels: {
			//items: [],
			style: {
				//font: defaultFont,
				position: ABSOLUTE,
				color: '#3E576F'
			}
		},
		legend: {
			enabled: true,
			align: 'center',
			//floating: false,
			layout: 'horizontal',
			labelFormatter: function () {
				return this.name;
			},
			//borderWidth: 0,
			borderColor: '#909090',
			borderRadius: 0,
			navigation: {
				// animation: true,
				activeColor: '#274b6d',
				// arrowSize: 12
				inactiveColor: '#CCC'
				// style: {} // text styles
			},
			// margin: 20,
			// reversed: false,
			shadow: false,
			// backgroundColor: null,
			/*style: {
				padding: '5px'
			},*/
			itemStyle: {			
				color: '#333333',
				fontSize: '12px',
				fontWeight: 'bold'
			},
			itemHoverStyle: {
				//cursor: 'pointer', removed as of #601
				color: '#000'
			},
			itemHiddenStyle: {
				color: '#CCC'
			},
			itemCheckboxStyle: {
				position: ABSOLUTE,
				width: '13px', // for IE precision
				height: '13px'
			},
			// itemWidth: undefined,
			// symbolRadius: 0,
			// symbolWidth: 16,
			symbolPadding: 5,
			verticalAlign: 'bottom',
			// width: undefined,
			x: 0,
			y: 0,
			title: {
				//text: null,
				style: {
					fontWeight: 'bold'
				}
			}			
		},

		loading: {
			// hideDuration: 100,
			labelStyle: {
				fontWeight: 'bold',
				position: RELATIVE,
				top: '45%'
			},
			// showDuration: 0,
			style: {
				position: ABSOLUTE,
				backgroundColor: 'white',
				opacity: 0.5,
				textAlign: 'center'
			}
		},

		tooltip: {
			enabled: true,
			animation: hasSVG,
			//crosshairs: null,
			backgroundColor: 'rgba(249, 249, 249, .85)',
			borderWidth: 1,
			borderRadius: 3,
			dateTimeLabelFormats: { 
				millisecond: '%A, %b %e, %H:%M:%S.%L',
				second: '%A, %b %e, %H:%M:%S',
				minute: '%A, %b %e, %H:%M',
				hour: '%A, %b %e, %H:%M',
				day: '%A, %b %e, %Y',
				week: 'Week from %A, %b %e, %Y',
				month: '%B %Y',
				year: '%Y'
			},
			footerFormat: '',
			//formatter: defaultFormatter,
			headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
			pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
			shadow: true,
			//shape: 'callout',
			//shared: false,
			snap: isTouchDevice ? 25 : 10,
			style: {
				color: '#333333',
				cursor: 'default',
				fontSize: '12px',
				padding: '8px',
				whiteSpace: 'nowrap'
			}
			//xDateFormat: '%A, %b %e, %Y',
			//valueDecimals: null,
			//valuePrefix: '',
			//valueSuffix: ''
		},

		credits: {
			enabled: true,
			text: 'Highcharts.com',
			href: 'http://www.highcharts.com',
			position: {
				align: 'right',
				x: -10,
				verticalAlign: 'bottom',
				y: -5
			},
			style: {
				cursor: 'pointer',
				color: '#909090',
				fontSize: '9px'
			}
		}
	};




	// Series defaults
	var defaultPlotOptions = defaultOptions.plotOptions,
		defaultSeriesOptions = defaultPlotOptions.line;

	// set the default time methods
	setTimeMethods();



	/**
	 * Set the time methods globally based on the useUTC option. Time method can be either
	 * local time or UTC (default).
	 */
	function setTimeMethods() {
		var globalOptions = defaultOptions.global,
			useUTC = globalOptions.useUTC,
			GET = useUTC ? 'getUTC' : 'get',
			SET = useUTC ? 'setUTC' : 'set';


		Date = globalOptions.Date || window.Date;
		timezoneOffset = useUTC && globalOptions.timezoneOffset;
		getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
		makeTime = function (year, month, date, hours, minutes, seconds) {
			var d;
			if (useUTC) {
				d = Date.UTC.apply(0, arguments);
				d += getTZOffset(d);
			} else {
				d = new Date(
					year,
					month,
					pick(date, 1),
					pick(hours, 0),
					pick(minutes, 0),
					pick(seconds, 0)
				).getTime();
			}
			return d;
		};
		getMinutes =      GET + 'Minutes';
		getHours =        GET + 'Hours';
		getDay =          GET + 'Day';
		getDate =         GET + 'Date';
		getMonth =        GET + 'Month';
		getFullYear =     GET + 'FullYear';
		setMilliseconds = SET + 'Milliseconds';
		setSeconds =      SET + 'Seconds';
		setMinutes =      SET + 'Minutes';
		setHours =        SET + 'Hours';
		setDate =         SET + 'Date';
		setMonth =        SET + 'Month';
		setFullYear =     SET + 'FullYear';

	}

	/**
	 * Merge the default options with custom options and return the new options structure
	 * @param {Object} options The new custom options
	 */
	function setOptions(options) {
		
		// Copy in the default options
		defaultOptions = merge(true, defaultOptions, options);
		
		// Apply UTC
		setTimeMethods();

		return defaultOptions;
	}

	/**
	 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	 * wasn't enough because the setOptions method created a new object.
	 */
	function getOptions() {
		return defaultOptions;
	}


	/**
	 * Handle color operations. The object methods are chainable.
	 * @param {String} input The input color in either rbga or hex format
	 */
	var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
		hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
		rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

	var Color = function (input) {
		// declare variables
		var rgba = [], result, stops;

		/**
		 * Parse the input color to rgba array
		 * @param {String} input
		 */
		function init(input) {

			// Gradients
			if (input && input.stops) {
				stops = map(input.stops, function (stop) {
					return Color(stop[1]);
				});

			// Solid colors
			} else {
				// rgba
				result = rgbaRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
				} else { 
					// hex
					result = hexRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
					} else {
						// rgb
						result = rgbRegEx.exec(input);
						if (result) {
							rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
						}
					}
				}
			}		

		}
		/**
		 * Return the color a specified format
		 * @param {String} format
		 */
		function get(format) {
			var ret;

			if (stops) {
				ret = merge(input);
				ret.stops = [].concat(ret.stops);
				each(stops, function (stop, i) {
					ret.stops[i] = [ret.stops[i][0], stop.get(format)];
				});

			// it's NaN if gradient colors on a column chart
			} else if (rgba && !isNaN(rgba[0])) {
				if (format === 'rgb') {
					ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
				} else if (format === 'a') {
					ret = rgba[3];
				} else {
					ret = 'rgba(' + rgba.join(',') + ')';
				}
			} else {
				ret = input;
			}
			return ret;
		}

		/**
		 * Brighten the color
		 * @param {Number} alpha
		 */
		function brighten(alpha) {
			if (stops) {
				each(stops, function (stop) {
					stop.brighten(alpha);
				});
			
			} else if (isNumber(alpha) && alpha !== 0) {
				var i;
				for (i = 0; i < 3; i++) {
					rgba[i] += pInt(alpha * 255);

					if (rgba[i] < 0) {
						rgba[i] = 0;
					}
					if (rgba[i] > 255) {
						rgba[i] = 255;
					}
				}
			}
			return this;
		}
		/**
		 * Set the color's opacity to a given alpha value
		 * @param {Number} alpha
		 */
		function setOpacity(alpha) {
			rgba[3] = alpha;
			return this;
		}

		// initialize: parse the input
		init(input);

		// public methods
		return {
			get: get,
			brighten: brighten,
			rgba: rgba,
			setOpacity: setOpacity,
			raw: input
		};
	};


	/**
	 * A wrapper object for SVG elements
	 */
	function SVGElement() {}

	SVGElement.prototype = {
		
		// Default base for animation
		opacity: 1,
		// For labels, these CSS properties are applied to the <text> node directly
		textProps: ['fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 
			'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],
		
		/**
		 * Initialize the SVG renderer
		 * @param {Object} renderer
		 * @param {String} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this;
			wrapper.element = nodeName === 'span' ?
				createElement(nodeName) :
				doc.createElementNS(SVG_NS, nodeName);
			wrapper.renderer = renderer;
		},
		
		/**
		 * Animate a given attribute
		 * @param {Object} params
		 * @param {Number} options The same options as in jQuery animation
		 * @param {Function} complete Function to perform at the end of animation
		 */
		animate: function (params, options, complete) {
			var animOptions = pick(options, globalAnimation, true);
			stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
			if (animOptions) {
				animOptions = merge(animOptions, {}); //#2625
				if (complete) { // allows using a callback with the global animation without overwriting it
					animOptions.complete = complete;
				}
				animate(this, params, animOptions);
			} else {
				this.attr(params, null, complete);
			}
			return this;
		},

		/**
		 * Build an SVG gradient out of a common JavaScript configuration object
		 */
		colorGradient: function (color, prop, elem) {
			var renderer = this.renderer,
				colorObject,
				gradName,
				gradAttr,
				gradients,
				gradientObject,
				stops,
				stopColor,
				stopOpacity,
				radialReference,
				n,
				id,
				key = [];

			// Apply linear or radial gradients
			if (color.linearGradient) {
				gradName = 'linearGradient';
			} else if (color.radialGradient) {
				gradName = 'radialGradient';
			}

			if (gradName) {
				gradAttr = color[gradName];
				gradients = renderer.gradients;
				stops = color.stops;
				radialReference = elem.radialReference;

				// Keep < 2.2 kompatibility
				if (isArray(gradAttr)) {
					color[gradName] = gradAttr = {
						x1: gradAttr[0],
						y1: gradAttr[1],
						x2: gradAttr[2],
						y2: gradAttr[3],
						gradientUnits: 'userSpaceOnUse'
					};
				}

				// Correct the radial gradient for the radial reference system
				if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
					gradAttr = merge(gradAttr, {
						cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
						cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
						r: gradAttr.r * radialReference[2],
						gradientUnits: 'userSpaceOnUse'
					});
				}

				// Build the unique key to detect whether we need to create a new element (#1282)
				for (n in gradAttr) {
					if (n !== 'id') {
						key.push(n, gradAttr[n]);
					}
				}
				for (n in stops) {
					key.push(stops[n]);
				}
				key = key.join(',');

				// Check if a gradient object with the same config object is created within this renderer
				if (gradients[key]) {
					id = gradients[key].attr('id');

				} else {

					// Set the id and create the element
					gradAttr.id = id = PREFIX + idCounter++;
					gradients[key] = gradientObject = renderer.createElement(gradName)
						.attr(gradAttr)
						.add(renderer.defs);


					// The gradient needs to keep a list of stops to be able to destroy them
					gradientObject.stops = [];
					each(stops, function (stop) {
						var stopObject;
						if (stop[1].indexOf('rgba') === 0) {
							colorObject = Color(stop[1]);
							stopColor = colorObject.get('rgb');
							stopOpacity = colorObject.get('a');
						} else {
							stopColor = stop[1];
							stopOpacity = 1;
						}
						stopObject = renderer.createElement('stop').attr({
							offset: stop[0],
							'stop-color': stopColor,
							'stop-opacity': stopOpacity
						}).add(gradientObject);

						// Add the stop element to the gradient
						gradientObject.stops.push(stopObject);
					});
				}

				// Set the reference to the gradient object
				elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
			} 
		},

		/**
		 * Apply a polyfill to the text-stroke CSS property, by copying the text element
		 * and apply strokes to the copy.
		 *
		 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
		 * TODO: 
		 * - update defaults
		 */
		applyTextShadow: function (textShadow) {
			var elem = this.element,
				tspans,
				hasContrast = textShadow.indexOf('contrast') !== -1,
				styles = {},
				// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
				// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
				supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

			// When the text shadow is set to contrast, use dark stroke for light text and vice versa
			if (hasContrast) {
				styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
			}

			// Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
			// it removes the text shadows.
			if (isWebKit) {
				styles.textRendering = 'geometricPrecision';
			}

			/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
			if (elem.textContent.indexOf('2.') === 0) {
				elem.style['text-shadow'] = 'none';
				supports = false;
			}
			// */

			// No reason to polyfill, we've got native support
			if (supports) {
				css(elem, styles); // Apply altered textShadow or textRendering workaround
			} else {

				this.fakeTS = true; // Fake text shadow

				// In order to get the right y position of the clones, 
				// copy over the y setter
				this.ySetter = this.xSetter;

				tspans = [].slice.call(elem.getElementsByTagName('tspan'));
				each(textShadow.split(/\s?,\s?/g), function (textShadow) {
					var firstChild = elem.firstChild,
						color,
						strokeWidth;
					
					textShadow = textShadow.split(' ');
					color = textShadow[textShadow.length - 1];

					// Approximately tune the settings to the text-shadow behaviour
					strokeWidth = textShadow[textShadow.length - 2];

					if (strokeWidth) {
						each(tspans, function (tspan, y) {
							var clone;

							// Let the first line start at the correct X position
							if (y === 0) {
								tspan.setAttribute('x', elem.getAttribute('x'));
								y = elem.getAttribute('y');
								tspan.setAttribute('y', y || 0);
								if (y === null) {
									elem.setAttribute('y', 0);
								}
							}

							// Create the clone and apply shadow properties
							clone = tspan.cloneNode(1);
							attr(clone, {
								'class': PREFIX + 'text-shadow',
								'fill': color,
								'stroke': color,
								'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
								'stroke-width': strokeWidth,
								'stroke-linejoin': 'round'
							});
							elem.insertBefore(clone, firstChild);
						});
					}
				});
			}
		},

		/**
		 * Set or get a given attribute
		 * @param {Object|String} hash
		 * @param {Mixed|Undefined} val
		 */
		attr: function (hash, val, complete) {
			var key,
				value,
				element = this.element,
				hasSetSymbolSize,
				ret = this,
				skipAttr;

			// single key-value pair
			if (typeof hash === 'string' && val !== UNDEFINED) {
				key = hash;
				hash = {};
				hash[key] = val;
			}

			// used as a getter: first argument is a string, second is undefined
			if (typeof hash === 'string') {
				ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
			
			// setter
			} else {

				for (key in hash) {
					value = hash[key];
					skipAttr = false;



					if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
						if (!hasSetSymbolSize) {
							this.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					if (this.rotation && (key === 'x' || key === 'y')) {
						this.doTransform = true;
					}
					
					if (!skipAttr) {
						(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
					}

					// Let the shadow follow the main element
					if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
						this.updateShadows(key, value);
					}
				}

				// Update transform. Do this outside the loop to prevent redundant updating for batch setting
				// of attributes.
				if (this.doTransform) {
					this.updateTransform();
					this.doTransform = false;
				}

			}

			// In accordance with animate, run a complete callback
			if (complete) {
				complete();
			}

			return ret;
		},

		updateShadows: function (key, value) {
			var shadows = this.shadows,
				i = shadows.length;
			while (i--) {
				shadows[i].setAttribute(
					key,
					key === 'height' ?
						mathMax(value - (shadows[i].cutHeight || 0), 0) :
						key === 'd' ? this.d : value
				);
			}
		},

		/**
		 * Add a class name to an element
		 */
		addClass: function (className) {
			var element = this.element,
				currentClassName = attr(element, 'class') || '';

			if (currentClassName.indexOf(className) === -1) {
				attr(element, 'class', currentClassName + ' ' + className);
			}
			return this;
		},
		/* hasClass and removeClass are not (yet) needed
		hasClass: function (className) {
			return attr(this.element, 'class').indexOf(className) !== -1;
		},
		removeClass: function (className) {
			attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
			return this;
		},
		*/

		/**
		 * If one of the symbol size affecting parameters are changed,
		 * check all the others only once for each call to an element's
		 * .attr() method
		 * @param {Object} hash
		 */
		symbolAttr: function (hash) {
			var wrapper = this;

			each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
				wrapper[key] = pick(hash[key], wrapper[key]);
			});

			wrapper.attr({
				d: wrapper.renderer.symbols[wrapper.symbolName](
					wrapper.x,
					wrapper.y,
					wrapper.width,
					wrapper.height,
					wrapper
				)
			});
		},

		/**
		 * Apply a clipping path to this object
		 * @param {String} id
		 */
		clip: function (clipRect) {
			return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
		},

		/**
		 * Calculate the coordinates needed for drawing a rectangle crisply and return the
		 * calculated attributes
		 * @param {Number} strokeWidth
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		crisp: function (rect) {

			var wrapper = this,
				key,
				attribs = {},
				normalizer,
				strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

			normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

			// normalize for crisp edges
			rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
			rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
			rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
			rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
			rect.strokeWidth = strokeWidth;

			for (key in rect) {
				if (wrapper[key] !== rect[key]) { // only set attribute if changed
					wrapper[key] = attribs[key] = rect[key];
				}
			}

			return attribs;
		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: function (styles) {
			var elemWrapper = this,
				oldStyles = elemWrapper.styles,
				newStyles = {},
				elem = elemWrapper.element,
				textWidth,
				n,
				serializedCss = '',
				hyphenate,
				hasNew = !oldStyles;

			// convert legacy
			if (styles && styles.color) {
				styles.fill = styles.color;
			}

			// Filter out existing styles to increase performance (#2640)
			if (oldStyles) {
				for (n in styles) {
					if (styles[n] !== oldStyles[n]) {
						newStyles[n] = styles[n];
						hasNew = true;
					}
				}
			}
			if (hasNew) {
				textWidth = elemWrapper.textWidth = 
					(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
					elemWrapper.textWidth; // #3501

				// Merge the new styles with the old ones
				if (oldStyles) {
					styles = extend(
						oldStyles,
						newStyles
					);
				}		

				// store object
				elemWrapper.styles = styles;

				if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
					delete styles.width;
				}

				// serialize and set style attribute
				if (isIE && !hasSVG) {
					css(elemWrapper.element, styles);
				} else {
					/*jslint unparam: true*/
					hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
					/*jslint unparam: false*/
					for (n in styles) {
						serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
					}
					attr(elem, 'style', serializedCss); // #1881
				}


				// re-build text
				if (textWidth && elemWrapper.added) {
					elemWrapper.renderer.buildText(elemWrapper);
				}
			}

			return elemWrapper;
		},

		/**
		 * Add an event listener
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			var svgElement = this,
				element = svgElement.element;
			
			// touch
			if (hasTouch && eventType === 'click') {
				element.ontouchstart = function (e) {			
					svgElement.touchEventFired = Date.now();				
					e.preventDefault();
					handler.call(element, e);
				};
				element.onclick = function (e) {												
					if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
						handler.call(element, e);
					}
				};			
			} else {
				// simplest possible event model for internal use
				element['on' + eventType] = handler;
			}
			return this;
		},

		/**
		 * Set the coordinates needed to draw a consistent radial gradient across
		 * pie slices regardless of positioning inside the chart. The format is
		 * [centerX, centerY, diameter] in pixels.
		 */
		setRadialReference: function (coordinates) {
			this.element.radialReference = coordinates;
			return this;
		},

		/**
		 * Move an object and its children by x and y values
		 * @param {Number} x
		 * @param {Number} y
		 */
		translate: function (x, y) {
			return this.attr({
				translateX: x,
				translateY: y
			});
		},

		/**
		 * Invert a group, rotate and flip
		 */
		invert: function () {
			var wrapper = this;
			wrapper.inverted = true;
			wrapper.updateTransform();
			return wrapper;
		},

		/**
		 * Private method to update the transform attribute based on internal
		 * properties
		 */
		updateTransform: function () {
			var wrapper = this,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				scaleX = wrapper.scaleX,
				scaleY = wrapper.scaleY,
				inverted = wrapper.inverted,
				rotation = wrapper.rotation,
				element = wrapper.element,
				transform;

			// flipping affects translate as adjustment for flipping around the group's axis
			if (inverted) {
				translateX += wrapper.attr('width');
				translateY += wrapper.attr('height');
			}

			// Apply translate. Nearly all transformed elements have translation, so instead
			// of checking for translate = 0, do it always (#1767, #1846).
			transform = ['translate(' + translateX + ',' + translateY + ')'];

			// apply rotation
			if (inverted) {
				transform.push('rotate(90) scale(-1,1)');
			} else if (rotation) { // text rotation
				transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
				
				// Delete bBox memo when the rotation changes
				//delete wrapper.bBox;
			}

			// apply scale
			if (defined(scaleX) || defined(scaleY)) {
				transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
			}

			if (transform.length) {
				element.setAttribute('transform', transform.join(' '));
			}
		},
		/**
		 * Bring the element to the front
		 */
		toFront: function () {
			var element = this.element;
			element.parentNode.appendChild(element);
			return this;
		},


		/**
		 * Break down alignment options like align, verticalAlign, x and y
		 * to x and y relative to the chart.
		 *
		 * @param {Object} alignOptions
		 * @param {Boolean} alignByTranslate
		 * @param {String[Object} box The box to align to, needs a width and height. When the
		 *		box is a string, it refers to an object in the Renderer. For example, when
		 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
		 *		x and y properties.
		 *
		 */
		align: function (alignOptions, alignByTranslate, box) {
			var align,
				vAlign,
				x,
				y,
				attribs = {},
				alignTo,
				renderer = this.renderer,
				alignedObjects = renderer.alignedObjects;

			// First call on instanciate
			if (alignOptions) {
				this.alignOptions = alignOptions;
				this.alignByTranslate = alignByTranslate;
				if (!box || isString(box)) { // boxes other than renderer handle this internally
					this.alignTo = alignTo = box || 'renderer';
					erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
					alignedObjects.push(this);
					box = null; // reassign it below
				}

			// When called on resize, no arguments are supplied
			} else {
				alignOptions = this.alignOptions;
				alignByTranslate = this.alignByTranslate;
				alignTo = this.alignTo;
			}

			box = pick(box, renderer[alignTo], renderer);

			// Assign variables
			align = alignOptions.align;
			vAlign = alignOptions.verticalAlign;
			x = (box.x || 0) + (alignOptions.x || 0); // default: left align
			y = (box.y || 0) + (alignOptions.y || 0); // default: top align

			// Align
			if (align === 'right' || align === 'center') {
				x += (box.width - (alignOptions.width || 0)) /
						{ right: 1, center: 2 }[align];
			}
			attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


			// Vertical align
			if (vAlign === 'bottom' || vAlign === 'middle') {
				y += (box.height - (alignOptions.height || 0)) /
						({ bottom: 1, middle: 2 }[vAlign] || 1);

			}
			attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

			// Animate only if already placed
			this[this.placed ? 'animate' : 'attr'](attribs);
			this.placed = true;
			this.alignAttr = attribs;

			return this;
		},

		/**
		 * Get the bounding box (width, height, x and y) for the element
		 */
		getBBox: function (reload) {
			var wrapper = this,
				bBox,// = wrapper.bBox,
				renderer = wrapper.renderer,
				width,
				height,
				rotation = wrapper.rotation,
				element = wrapper.element,
				styles = wrapper.styles,
				rad = rotation * deg2rad,
				textStr = wrapper.textStr,
				textShadow,
				elemStyle = element.style,
				toggleTextShadowShim,
				cacheKey;

			if (textStr !== UNDEFINED) {

				// Properties that affect bounding box
				cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

				// Since numbers are monospaced, and numerical labels appear a lot in a chart,
				// we assume that a label of n characters has the same bounding box as others 
				// of the same length.
				if (textStr === '' || numRegex.test(textStr)) {
					cacheKey = 'num:' + textStr.toString().length + cacheKey;

				// Caching all strings reduces rendering time by 4-5%.
				} else {
					cacheKey = textStr + cacheKey;
				}
			}

			if (cacheKey && !reload) {
				bBox = renderer.cache[cacheKey];
			}

			// No cache found
			if (!bBox) {

				// SVG elements
				if (element.namespaceURI === SVG_NS || renderer.forExport) {
					try { // Fails in Firefox if the container has display: none.

						// When the text shadow shim is used, we need to hide the fake shadows
						// to get the correct bounding box (#3872)
						toggleTextShadowShim = this.fakeTS && function (display) {
							each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
								tspan.style.display = display;
							});
						};

						// Workaround for #3842, Firefox reporting wrong bounding box for shadows
						if (isFirefox && elemStyle.textShadow) {
							textShadow = elemStyle.textShadow;
							elemStyle.textShadow = '';
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim(NONE);
						}

						bBox = element.getBBox ?
							// SVG: use extend because IE9 is not allowed to change width and height in case
							// of rotation (below)
							extend({}, element.getBBox()) :
							// Canvas renderer and legacy IE in export mode
							{
								width: element.offsetWidth,
								height: element.offsetHeight
							};

						// #3842
						if (textShadow) {
							elemStyle.textShadow = textShadow;
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim('');
						}
					} catch (e) {}

					// If the bBox is not set, the try-catch block above failed. The other condition
					// is for Opera that returns a width of -Infinity on hidden elements.
					if (!bBox || bBox.width < 0) {
						bBox = { width: 0, height: 0 };
					}


				// VML Renderer or useHTML within SVG
				} else {

					bBox = wrapper.htmlGetBBox();

				}

				// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
				// need to compensated for rotation
				if (renderer.isSVG) {
					width = bBox.width;
					height = bBox.height;

					// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
					if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
						bBox.height = height = 14;
					}

					// Adjust for rotated text
					if (rotation) {
						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
					}
				}

				// Cache it
				if (cacheKey) {
					renderer.cache[cacheKey] = bBox;
				}
			}
			return bBox;
		},

		/**
		 * Show the element
		 */
		show: function (inherit) {
			return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
		},

		/**
		 * Hide the element
		 */
		hide: function () {
			return this.attr({ visibility: HIDDEN });
		},

		fadeOut: function (duration) {
			var elemWrapper = this;
			elemWrapper.animate({
				opacity: 0
			}, {
				duration: duration || 150,
				complete: function () {
					elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
				}
			});
		},

		/**
		 * Add the element
		 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
		 *	to append the element to the renderer.box.
		 */
		add: function (parent) {

			var renderer = this.renderer,
				element = this.element,
				inserted;

			if (parent) {
				this.parentGroup = parent;
			}

			// mark as inverted
			this.parentInverted = parent && parent.inverted;

			// build formatted text
			if (this.textStr !== undefined) {
				renderer.buildText(this);
			}

			// Mark as added
			this.added = true;

			// If we're adding to renderer root, or other elements in the group 
			// have a z index, we need to handle it
			if (!parent || parent.handleZ || this.zIndex) {
				inserted = this.zIndexSetter();
			}

			// If zIndex is not handled, append at the end
			if (!inserted) {
				(parent ? parent.element : renderer.box).appendChild(element);
			}

			// fire an event for internal hooks
			if (this.onAdd) {
				this.onAdd();
			}

			return this;
		},

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			var parentNode = element.parentNode;
			if (parentNode) {
				parentNode.removeChild(element);
			}
		},

		/**
		 * Destroy the element and element wrapper
		 */
		destroy: function () {
			var wrapper = this,
				element = wrapper.element || {},
				shadows = wrapper.shadows,
				parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
				grandParent,
				key,
				i;

			// remove events
			element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
			stop(wrapper); // stop running animations

			if (wrapper.clipPath) {
				wrapper.clipPath = wrapper.clipPath.destroy();
			}

			// Destroy stops in case this is a gradient object
			if (wrapper.stops) {
				for (i = 0; i < wrapper.stops.length; i++) {
					wrapper.stops[i] = wrapper.stops[i].destroy();
				}
				wrapper.stops = null;
			}

			// remove element
			wrapper.safeRemoveChild(element);

			// destroy shadows
			if (shadows) {
				each(shadows, function (shadow) {
					wrapper.safeRemoveChild(shadow);
				});
			}

			// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
			while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
				grandParent = parentToClean.parentGroup;
				wrapper.safeRemoveChild(parentToClean.div);
				delete parentToClean.div;
				parentToClean = grandParent;
			}

			// remove from alignObjects
			if (wrapper.alignTo) {
				erase(wrapper.renderer.alignedObjects, wrapper);
			}

			for (key in wrapper) {
				delete wrapper[key];
			}

			return null;
		},

		/**
		 * Add a shadow to the element. Must be done after the element is added to the DOM
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				shadow,
				element = this.element,
				strokeWidth,
				shadowWidth,
				shadowElementOpacity,

				// compensate for inverted plot area
				transform;


			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				transform = this.parentInverted ?
					'(-1,-1)' :
					'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
				for (i = 1; i <= shadowWidth; i++) {
					shadow = element.cloneNode(0);
					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
					attr(shadow, {
						'isShadow': 'true',
						'stroke': shadowOptions.color || 'black',
						'stroke-opacity': shadowElementOpacity * i,
						'stroke-width': strokeWidth,
						'transform': 'translate' + transform,
						'fill': NONE
					});
					if (cutOff) {
						attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
						shadow.cutHeight = strokeWidth;
					}

					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					shadows.push(shadow);
				}

				this.shadows = shadows;
			}
			return this;

		},

		xGetter: function (key) {
			if (this.element.nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			}
			return this._defaultGetter(key);
		},

		/** 
		 * Get the current value of an attribute or pseudo attribute, used mainly
		 * for animation.
		 */
		_defaultGetter: function (key) {
			var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

			if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
				ret = parseFloat(ret);
			}
			return ret;
		},


		dSetter: function (value, key, element) {
			if (value && value.join) { // join path
				value = value.join(' ');
			}
			if (/(NaN| {2}|^$)/.test(value)) {
				value = 'M 0 0';
			}
			element.setAttribute(key, value);

			this[key] = value;
		},
		dashstyleSetter: function (value) {
			var i;
			value = value && value.toLowerCase();
			if (value) {
				value = value
					.replace('shortdashdotdot', '3,1,1,1,1,1,')
					.replace('shortdashdot', '3,1,1,1')
					.replace('shortdot', '1,1,')
					.replace('shortdash', '3,1,')
					.replace('longdash', '8,3,')
					.replace(/dot/g, '1,3,')
					.replace('dash', '4,3,')
					.replace(/,$/, '')
					.split(','); // ending comma

				i = value.length;
				while (i--) {
					value[i] = pInt(value[i]) * this['stroke-width'];
				}
				value = value.join(',')
					.replace('NaN', 'none'); // #3226
				this.element.setAttribute('stroke-dasharray', value);
			}
		},
		alignSetter: function (value) {
			this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
		},
		opacitySetter: function (value, key, element) {
			this[key] = value;
			element.setAttribute(key, value);
		},
		titleSetter: function (value) {
			var titleNode = this.element.getElementsByTagName('title')[0];
			if (!titleNode) {
				titleNode = doc.createElementNS(SVG_NS, 'title');
				this.element.appendChild(titleNode);
			}
			titleNode.appendChild(
				doc.createTextNode(
					(String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
				)
			);
		},
		textSetter: function (value) {
			if (value !== this.textStr) {
				// Delete bBox memo when the text changes
				delete this.bBox;
			
				this.textStr = value;
				if (this.added) {
					this.renderer.buildText(this);
				}
			}
		},
		fillSetter: function (value, key, element) {
			if (typeof value === 'string') {
				element.setAttribute(key, value);
			} else if (value) {
				this.colorGradient(value, key, element);
			}
		},
		visibilitySetter: function (value, key, element) {
			// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
			if (value === 'inherit') {
				element.removeAttribute(key);
			}else {
				element.setAttribute(key, value);
			}
		},
		zIndexSetter: function (value, key) {
			var renderer = this.renderer,
				parentGroup = this.parentGroup,
				parentWrapper = parentGroup || renderer,
				parentNode = parentWrapper.element || renderer.box,
				childNodes,
				otherElement,
				otherZIndex,
				element = this.element,
				inserted,
				run = this.added,
				i;
			
			if (defined(value)) {
				element.setAttribute(key, value); // So we can read it for other elements in the group
				value = +value;
				if (this[key] === value) { // Only update when needed (#3865)
					run = false;
				}
				this[key] = value;
			}

			// Insert according to this and other elements' zIndex. Before .add() is called,
			// nothing is done. Then on add, or by later calls to zIndexSetter, the node
			// is placed on the right place in the DOM.
			if (run) {
				value = this.zIndex;

				if (value && parentGroup) {
					parentGroup.handleZ = true;
				}
			
				childNodes = parentNode.childNodes;
				for (i = 0; i < childNodes.length && !inserted; i++) {
					otherElement = childNodes[i];
					otherZIndex = attr(otherElement, 'zIndex');
					if (otherElement !== element && (
							// Insert before the first element with a higher zIndex
							pInt(otherZIndex) > value ||
							// If no zIndex given, insert before the first element with a zIndex
							(!defined(value) && defined(otherZIndex))

							)) {
						parentNode.insertBefore(element, otherElement);
						inserted = true;
					}
				}
				if (!inserted) {
					parentNode.appendChild(element);
				}
			}
			return inserted;
		},
		_defaultSetter: function (value, key, element) {
			element.setAttribute(key, value);
		}
	};

	// Some shared setters and getters
	SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
			SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
			SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
		this[key] = value;
		this.doTransform = true;
	};

	// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	// stroke attribute altogether. #1270, #1369, #3065, #3072.
	SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
		this[key] = value;
		// Only apply the stroke attribute if the stroke width is defined and larger than 0
		if (this.stroke && this['stroke-width']) {
			this.strokeWidth = this['stroke-width'];
			SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
			element.setAttribute('stroke-width', this['stroke-width']);
			this.hasStroke = true;
		} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
			element.removeAttribute('stroke');
			this.hasStroke = false;
		}
	};


	/**
	 * The default SVG renderer
	 */
	var SVGRenderer = function () {
		this.init.apply(this, arguments);
	};
	SVGRenderer.prototype = {
		Element: SVGElement,

		/**
		 * Initialize the SVGRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Boolean} forExport
		 */
		init: function (container, width, height, style, forExport) {
			var renderer = this,
				loc = location,
				boxWrapper,
				element,
				desc;

			boxWrapper = renderer.createElement('svg')
				.attr({
					version: '1.1'
				})
				.css(this.getStyle(style));
			element = boxWrapper.element;
			container.appendChild(element);

			// For browsers other than IE, add the namespace attribute (#1978)
			if (container.innerHTML.indexOf('xmlns') === -1) {
				attr(element, 'xmlns', SVG_NS);
			}

			// object properties
			renderer.isSVG = true;
			renderer.box = element;
			renderer.boxWrapper = boxWrapper;
			renderer.alignedObjects = [];

			// Page url used for internal references. #24, #672, #1070
			renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
				loc.href
					.replace(/#.*?$/, '') // remove the hash
					.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
					.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
				'';

			// Add description
			desc = this.createElement('desc').add();
			desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


			renderer.defs = this.createElement('defs').add();
			renderer.forExport = forExport;
			renderer.gradients = {}; // Object where gradient SvgElements are stored
			renderer.cache = {}; // Cache for numerical bounding boxes

			renderer.setSize(width, height, false);



			// Issue 110 workaround:
			// In Firefox, if a div is positioned by percentage, its pixel position may land
			// between pixels. The container itself doesn't display this, but an SVG element
			// inside this container will be drawn at subpixel precision. In order to draw
			// sharp lines, this must be compensated for. This doesn't seem to work inside
			// iframes though (like in jsFiddle).
			var subPixelFix, rect;
			if (isFirefox && container.getBoundingClientRect) {
				renderer.subPixelFix = subPixelFix = function () {
					css(container, { left: 0, top: 0 });
					rect = container.getBoundingClientRect();
					css(container, {
						left: (mathCeil(rect.left) - rect.left) + PX,
						top: (mathCeil(rect.top) - rect.top) + PX
					});
				};

				// run the fix now
				subPixelFix();

				// run it on resize
				addEvent(win, 'resize', subPixelFix);
			}
		},

		getStyle: function (style) {
			return (this.style = extend({
				fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
				fontSize: '12px'
			}, style));
		},

		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none. #608.
		 */
		isHidden: function () {
			return !this.boxWrapper.getBBox().width;
		},

		/**
		 * Destroys the renderer and its allocated members.
		 */
		destroy: function () {
			var renderer = this,
				rendererDefs = renderer.defs;
			renderer.box = null;
			renderer.boxWrapper = renderer.boxWrapper.destroy();

			// Call destroy on all gradient elements
			destroyObjectProperties(renderer.gradients || {});
			renderer.gradients = null;

			// Defs are null in VMLRenderer
			// Otherwise, destroy them here.
			if (rendererDefs) {
				renderer.defs = rendererDefs.destroy();
			}

			// Remove sub pixel fix handler
			// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
			// See issue #982
			if (renderer.subPixelFix) {
				removeEvent(win, 'resize', renderer.subPixelFix);
			}

			renderer.alignedObjects = null;

			return null;
		},

		/**
		 * Create a wrapper for an SVG element
		 * @param {Object} nodeName
		 */
		createElement: function (nodeName) {
			var wrapper = new this.Element();
			wrapper.init(this, nodeName);
			return wrapper;
		},

		/**
		 * Dummy function for use in canvas renderer
		 */
		draw: function () {},

		/**
		 * Parse a simple HTML string into SVG tspans
		 *
		 * @param {Object} textNode The parent text SVG node
		 */
		buildText: function (wrapper) {
			var textNode = wrapper.element,
				renderer = this,
				forExport = renderer.forExport,
				textStr = pick(wrapper.textStr, '').toString(),
				hasMarkup = textStr.indexOf('<') !== -1,
				lines,
				childNodes = textNode.childNodes,
				styleRegex,
				hrefRegex,
				parentX = attr(textNode, 'x'),
				textStyles = wrapper.styles,
				width = wrapper.textWidth,
				textLineHeight = textStyles && textStyles.lineHeight,
				textShadow = textStyles && textStyles.textShadow,
				ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
				i = childNodes.length,
				tempParent = width && !wrapper.added && this.box,
				getLineHeight = function (tspan) {
					return textLineHeight ? 
						pInt(textLineHeight) :
						renderer.fontMetrics(
							/(px|em)$/.test(tspan && tspan.style.fontSize) ?
								tspan.style.fontSize :
								((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
							tspan
						).h;
				},
				unescapeAngleBrackets = function (inputStr) {
					return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
				};

			/// remove old text
			while (i--) {
				textNode.removeChild(childNodes[i]);
			}

			// Skip tspans, add text directly to text node. The forceTSpan is a hook 
			// used in text outline hack.
			if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
				textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
				return;

			// Complex strings, add more logic
			} else {

				styleRegex = /<.*style="([^"]+)".*>/;
				hrefRegex = /<.*href="(http[^"]+)".*>/;

				if (tempParent) {
					tempParent.appendChild(textNode); // attach it to the DOM to read offset width
				}

				if (hasMarkup) {
					lines = textStr
						.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
						.replace(/<(i|em)>/g, '<span style="font-style:italic">')
						.replace(/<a/g, '<span')
						.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
						.split(/<br.*?>/g);

				} else {
					lines = [textStr];
				}


				// remove empty line at end
				if (lines[lines.length - 1] === '') {
					lines.pop();
				}

				
				// build the lines
				each(lines, function (line, lineNo) {
					var spans, spanNo = 0;

					line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
					spans = line.split('|||');

					each(spans, function (span) {
						if (span !== '' || spans.length === 1) {
							var attributes = {},
								tspan = doc.createElementNS(SVG_NS, 'tspan'),
								spanStyle; // #390
							if (styleRegex.test(span)) {
								spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
								attr(tspan, 'style', spanStyle);
							}
							if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
								attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
								css(tspan, { cursor: 'pointer' });
							}

							span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

							// Nested tags aren't supported, and cause crash in Safari (#1596)
							if (span !== ' ') {

								// add the text node
								tspan.appendChild(doc.createTextNode(span));

								if (!spanNo) { // first span in a line, align it to the left
									if (lineNo && parentX !== null) {
										attributes.x = parentX;
									}
								} else {
									attributes.dx = 0; // #16
								}

								// add attributes
								attr(tspan, attributes);

								// Append it
								textNode.appendChild(tspan);

								// first span on subsequent line, add the line height
								if (!spanNo && lineNo) {

									// allow getting the right offset height in exporting in IE
									if (!hasSVG && forExport) {
										css(tspan, { display: 'block' });
									}

									// Set the line height based on the font size of either
									// the text element or the tspan element
									attr(
										tspan,
										'dy',
										getLineHeight(tspan)
									);
								}

								/*if (width) {
									renderer.breakText(wrapper, width);
								}*/

								// Check width and apply soft breaks or ellipsis
								if (width) {
									var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
										hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
										tooLong,
										wasTooLong,
										actualWidth,
										rest = [],
										dy = getLineHeight(tspan),
										softLineNo = 1,
										rotation = wrapper.rotation,
										wordStr = span, // for ellipsis
										cursor = wordStr.length, // binary search cursor
										bBox;

									while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
										wrapper.rotation = 0; // discard rotation when computing box
										bBox = wrapper.getBBox(true);
										actualWidth = bBox.width;

										// Old IE cannot measure the actualWidth for SVG elements (#2314)
										if (!hasSVG && renderer.forExport) {
											actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
										}

										tooLong = actualWidth > width;

										// For ellipsis, do a binary search for the correct string length
										if (wasTooLong === undefined) {
											wasTooLong = tooLong; // First time
										}
										if (ellipsis && wasTooLong) {
											cursor /= 2;

											if (wordStr === '' || (!tooLong && cursor < 0.5)) {
												words = []; // All ok, break out
											} else {
												if (tooLong) {
													wasTooLong = true;
												}
												wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
												words = [wordStr + (width > 3 ? '\u2026' : '')];
												tspan.removeChild(tspan.firstChild);
											}

										// Looping down, this is the first word sequence that is not too long,
										// so we can move on to build the next line.
										} else if (!tooLong || words.length === 1) {
											words = rest;
											rest = [];
													
											if (words.length) {
												softLineNo++;
												
												tspan = doc.createElementNS(SVG_NS, 'tspan');
												attr(tspan, {
													dy: dy,
													x: parentX
												});
												if (spanStyle) { // #390
													attr(tspan, 'style', spanStyle);
												}
												textNode.appendChild(tspan);
											}
											if (actualWidth > width) { // a single word is pressing it out
												width = actualWidth;
											}
										} else { // append to existing line tspan
											tspan.removeChild(tspan.firstChild);
											rest.unshift(words.pop());
										}
										if (words.length) {
											tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
										}
									}
									if (wasTooLong) {
										wrapper.attr('title', wrapper.textStr);
									}
									wrapper.rotation = rotation;
								}

								spanNo++;
							}
						}
					});
				});
				if (tempParent) {
					tempParent.removeChild(textNode); // attach it to the DOM to read offset width
				}

				// Apply the text shadow
				if (textShadow && wrapper.applyTextShadow) {
					wrapper.applyTextShadow(textShadow);
				}
			}
		},

		

		/*
		breakText: function (wrapper, width) {
			var bBox = wrapper.getBBox(),
				node = wrapper.element,
				textLength = node.textContent.length,
				pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
				increment = 0,
				finalPos;

			if (bBox.width > width) {
				while (finalPos === undefined) {
					textLength = node.getSubStringLength(0, pos);

					if (textLength <= width) {
						if (increment === -1) {
							finalPos = pos;
						} else {
							increment = 1;
						}
					} else {
						if (increment === 1) {
							finalPos = pos - 1;
						} else {
							increment = -1;
						}
					}
					pos += increment;
				}
			}
			console.log(finalPos, node.getSubStringLength(0, finalPos))
		},
		*/

		/** 
		 * Returns white for dark colors and black for bright colors
		 */
		getContrast: function (color) {
			color = Color(color).rgba;
			return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
		},

		/**
		 * Create a button with preset states
		 * @param {String} text
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Function} callback
		 * @param {Object} normalState
		 * @param {Object} hoverState
		 * @param {Object} pressedState
		 */
		button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
			var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
				curState = 0,
				stateOptions,
				stateStyle,
				normalStyle,
				hoverStyle,
				pressedStyle,
				disabledStyle,
				verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

			// Normal state - prepare the attributes
			normalState = merge({
				'stroke-width': 1,
				stroke: '#CCCCCC',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FEFEFE'],
						[1, '#F6F6F6']
					]
				},
				r: 2,
				padding: 5,
				style: {
					color: 'black'
				}
			}, normalState);
			normalStyle = normalState.style;
			delete normalState.style;

			// Hover state
			hoverState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FFF'],
						[1, '#ACF']
					]
				}
			}, hoverState);
			hoverStyle = hoverState.style;
			delete hoverState.style;

			// Pressed state
			pressedState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#9BD'],
						[1, '#CDF']
					]
				}
			}, pressedState);
			pressedStyle = pressedState.style;
			delete pressedState.style;

			// Disabled state
			disabledState = merge(normalState, {
				style: {
					color: '#CCC'
				}
			}, disabledState);
			disabledStyle = disabledState.style;
			delete disabledState.style;

			// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
			addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
				if (curState !== 3) {
					label.attr(hoverState)
						.css(hoverStyle);
				}
			});
			addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
				if (curState !== 3) {
					stateOptions = [normalState, hoverState, pressedState][curState];
					stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
					label.attr(stateOptions)
						.css(stateStyle);
				}
			});

			label.setState = function (state) {
				label.state = curState = state;
				if (!state) {
					label.attr(normalState)
						.css(normalStyle);
				} else if (state === 2) {
					label.attr(pressedState)
						.css(pressedStyle);
				} else if (state === 3) {
					label.attr(disabledState)
						.css(disabledStyle);
				}
			};

			return label
				.on('click', function () {
					if (curState !== 3) {
						callback.call(label);
					}
				})
				.attr(normalState)
				.css(extend({ cursor: 'default' }, normalStyle));
		},

		/**
		 * Make a straight line crisper by not spilling out to neighbour pixels
		 * @param {Array} points
		 * @param {Number} width
		 */
		crispLine: function (points, width) {
			// points format: [M, 0, 0, L, 100, 0]
			// normalize to a crisp line
			if (points[1] === points[4]) {
				// Substract due to #1129. Now bottom and left axis gridlines behave the same.
				points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
			}
			if (points[2] === points[5]) {
				points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
			}
			return points;
		},


		/**
		 * Draw a path
		 * @param {Array} path An SVG path in array form
		 */
		path: function (path) {
			var attr = {
				fill: NONE
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			return this.createElement('path').attr(attr);
		},

		/**
		 * Draw and return an SVG circle
		 * @param {Number} x The x position
		 * @param {Number} y The y position
		 * @param {Number} r The radius
		 */
		circle: function (x, y, r) {
			var attr = isObject(x) ?
				x :
				{
					x: x,
					y: y,
					r: r
				},
				wrapper = this.createElement('circle');

			wrapper.xSetter = function (value) {
				this.element.setAttribute('cx', value);
			};
			wrapper.ySetter = function (value) {
				this.element.setAttribute('cy', value);
			};
			return wrapper.attr(attr);
		},

		/**
		 * Draw and return an arc
		 * @param {Number} x X position
		 * @param {Number} y Y position
		 * @param {Number} r Radius
		 * @param {Number} innerR Inner radius like used in donut charts
		 * @param {Number} start Starting angle
		 * @param {Number} end Ending angle
		 */
		arc: function (x, y, r, innerR, start, end) {
			var arc;

			if (isObject(x)) {
				y = x.y;
				r = x.r;
				innerR = x.innerR;
				start = x.start;
				end = x.end;
				x = x.x;
			}

			// Arcs are defined as symbols for the ability to set
			// attributes in attr and animate
			arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
				innerR: innerR || 0,
				start: start || 0,
				end: end || 0
			});
			arc.r = r; // #959
			return arc;
		},

		/**
		 * Draw and return a rectangle
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Number} r Border corner radius
		 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
		 */
		rect: function (x, y, width, height, r, strokeWidth) {

			r = isObject(x) ? x.r : r;

			var wrapper = this.createElement('rect'),
				attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
					x: x,
					y: y,
					width: mathMax(width, 0),
					height: mathMax(height, 0)
				};

			if (strokeWidth !== UNDEFINED) {
				attribs.strokeWidth = strokeWidth;
				attribs = wrapper.crisp(attribs);
			}

			if (r) {
				attribs.r = r;
			}

			wrapper.rSetter = function (value) {
				attr(this.element, {
					rx: value,
					ry: value
				});
			};
			
			return wrapper.attr(attribs);
		},

		/**
		 * Resize the box and re-align all aligned elements
		 * @param {Object} width
		 * @param {Object} height
		 * @param {Boolean} animate
		 *
		 */
		setSize: function (width, height, animate) {
			var renderer = this,
				alignedObjects = renderer.alignedObjects,
				i = alignedObjects.length;

			renderer.width = width;
			renderer.height = height;

			renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
				width: width,
				height: height
			});

			while (i--) {
				alignedObjects[i].align();
			}
		},

		/**
		 * Create a group
		 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
		 *	 This can be used for styling and scripting.
		 */
		g: function (name) {
			var elem = this.createElement('g');
			return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
		},

		/**
		 * Display an image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var attribs = {
					preserveAspectRatio: NONE
				},
				elemWrapper;

			// optional properties
			if (arguments.length > 1) {
				extend(attribs, {
					x: x,
					y: y,
					width: width,
					height: height
				});
			}

			elemWrapper = this.createElement('image').attr(attribs);

			// set the href in the xlink namespace
			if (elemWrapper.element.setAttributeNS) {
				elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
					'href', src);
			} else {
				// could be exporting in IE
				// using href throws "not supported" in ie7 and under, requries regex shim to fix later
				elemWrapper.element.setAttribute('hc-svg-href', src);
			}
			return elemWrapper;
		},

		/**
		 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
		 *
		 * @param {Object} symbol
		 * @param {Object} x
		 * @param {Object} y
		 * @param {Object} radius
		 * @param {Object} options
		 */
		symbol: function (symbol, x, y, width, height, options) {

			var obj,

				// get the symbol definition function
				symbolFn = this.symbols[symbol],

				// check if there's a path defined for this symbol
				path = symbolFn && symbolFn(
					mathRound(x),
					mathRound(y),
					width,
					height,
					options
				),

				imageElement,
				imageRegex = /^url\((.*?)\)$/,
				imageSrc,
				imageSize,
				centerImage;

			if (path) {

				obj = this.path(path);
				// expando properties for use in animate and attr
				extend(obj, {
					symbolName: symbol,
					x: x,
					y: y,
					width: width,
					height: height
				});
				if (options) {
					extend(obj, options);
				}


			// image symbols
			} else if (imageRegex.test(symbol)) {

				// On image load, set the size and position
				centerImage = function (img, size) {
					if (img.element) { // it may be destroyed in the meantime (#1390)
						img.attr({
							width: size[0],
							height: size[1]
						});

						if (!img.alignByTranslate) { // #185
							img.translate(
								mathRound((width - size[0]) / 2), // #1378
								mathRound((height - size[1]) / 2)
							);
						}
					}
				};

				imageSrc = symbol.match(imageRegex)[1];
				imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

				// Ireate the image synchronously, add attribs async
				obj = this.image(imageSrc)
					.attr({
						x: x,
						y: y
					});
				obj.isImg = true;

				if (imageSize) {
					centerImage(obj, imageSize);
				} else {
					// Initialize image to be 0 size so export will still function if there's no cached sizes.
					obj.attr({ width: 0, height: 0 });

					// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
					// the created element must be assigned to a variable in order to load (#292).
					imageElement = createElement('img', {
						onload: function () {
							centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
						},
						src: imageSrc
					});
				}
			}

			return obj;
		},

		/**
		 * An extendable collection of functions for defining symbol paths.
		 */
		symbols: {
			'circle': function (x, y, w, h) {
				var cpw = 0.166 * w;
				return [
					M, x + w / 2, y,
					'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
					'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
					'Z'
				];
			},

			'square': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle-down': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w / 2, y + h,
					'Z'
				];
			},
			'diamond': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h / 2,
					x + w / 2, y + h,
					x, y + h / 2,
					'Z'
				];
			},
			'arc': function (x, y, w, h, options) {
				var start = options.start,
					radius = options.r || w || h,
					end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
					innerRadius = options.innerR,
					open = options.open,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					longArc = options.end - start < mathPI ? 0 : 1;

				return [
					M,
					x + radius * cosStart,
					y + radius * sinStart,
					'A', // arcTo
					radius, // x radius
					radius, // y radius
					0, // slanting
					longArc, // long or short arc
					1, // clockwise
					x + radius * cosEnd,
					y + radius * sinEnd,
					open ? M : L,
					x + innerRadius * cosEnd,
					y + innerRadius * sinEnd,
					'A', // arcTo
					innerRadius, // x radius
					innerRadius, // y radius
					0, // slanting
					longArc, // long or short arc
					0, // clockwise
					x + innerRadius * cosStart,
					y + innerRadius * sinStart,

					open ? '' : 'Z' // close
				];
			},

			/**
			 * Callout shape used for default tooltips, also used for rounded rectangles in VML
			 */
			callout: function (x, y, w, h, options) {
				var arrowLength = 6,
					halfDistance = 6,
					r = mathMin((options && options.r) || 0, w, h),
					safeDistance = r + halfDistance,
					anchorX = options && options.anchorX,
					anchorY = options && options.anchorY,
					path;

				path = [
					'M', x + r, y, 
					'L', x + w - r, y, // top side
					'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
					'L', x + w, y + h - r, // right side
					'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
					'L', x + r, y + h, // bottom side
					'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
					'L', x, y + r, // left side
					'C', x, y, x, y, x + r, y // top-right corner
				];
				
				if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
					path.splice(13, 3,
						'L', x + w, anchorY - halfDistance, 
						x + w + arrowLength, anchorY,
						x + w, anchorY + halfDistance,
						x + w, y + h - r
					);
				} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
					path.splice(33, 3, 
						'L', x, anchorY + halfDistance, 
						x - arrowLength, anchorY,
						x, anchorY - halfDistance,
						x, y + r
					);
				} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
					path.splice(23, 3,
						'L', anchorX + halfDistance, y + h,
						anchorX, y + h + arrowLength,
						anchorX - halfDistance, y + h,
						x + r, y + h
					);
				} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
					path.splice(3, 3,
						'L', anchorX - halfDistance, y,
						anchorX, y - arrowLength,
						anchorX + halfDistance, y,
						w - r, y
					);
				}
				return path;
			}
		},

		/**
		 * Define a clipping rectangle
		 * @param {String} id
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {
			var wrapper,
				id = PREFIX + idCounter++,

				clipPath = this.createElement('clipPath').attr({
					id: id
				}).add(this.defs);

			wrapper = this.rect(x, y, width, height, 0).add(clipPath);
			wrapper.id = id;
			wrapper.clipPath = clipPath;
			wrapper.count = 0;

			return wrapper;
		},


		


		/**
		 * Add text to the SVG object
		 * @param {String} str
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Boolean} useHTML Use HTML to render the text
		 */
		text: function (str, x, y, useHTML) {

			// declare variables
			var renderer = this,
				fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
				wrapper,
				attr = {};

			if (useHTML && !renderer.forExport) {
				return renderer.html(str, x, y);
			}

			attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
			if (y) {
				attr.y = Math.round(y);
			}
			if (str || str === 0) {
				attr.text = str;
			}

			wrapper = renderer.createElement('text')
				.attr(attr);

			// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
			if (fakeSVG) {
				wrapper.css({
					position: ABSOLUTE
				});
			}

			if (!useHTML) {
				wrapper.xSetter = function (value, key, element) {
					var tspans = element.getElementsByTagName('tspan'),
						tspan,
						parentVal = element.getAttribute(key),
						i;
					for (i = 0; i < tspans.length; i++) {
						tspan = tspans[i];
						// If the x values are equal, the tspan represents a linebreak
						if (tspan.getAttribute(key) === parentVal) {
							tspan.setAttribute(key, value);
						}
					}
					element.setAttribute(key, value);
				};
			}
			
			return wrapper;
		},

		/**
		 * Utility to return the baseline offset and total line height from the font size
		 */
		fontMetrics: function (fontSize, elem) {
			var lineHeight,
				baseline,
				style;

			fontSize = fontSize || this.style.fontSize;
			if (elem && win.getComputedStyle) {
				elem = elem.element || elem; // SVGElement
				style = win.getComputedStyle(elem, "");
				fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
			}
			fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

			// Empirical values found by comparing font size and bounding box height.
			// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
			lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
			baseline = mathRound(lineHeight * 0.8);

			return {
				h: lineHeight,
				b: baseline,
				f: fontSize
			};
		},

		/**
		 * Correct X and Y positioning of a label for rotation (#1764)
		 */
		rotCorr: function (baseline, rotation, alterY) {
			var y = baseline;
			if (rotation && alterY) {
				y = mathMax(y * mathCos(rotation * deg2rad), 4);
			}
			return {
				x: (-baseline / 3) * mathSin(rotation * deg2rad),
				y: y
			};
		},

		/**
		 * Add a label, a text item that can hold a colored or gradient background
		 * as well as a border and shadow.
		 * @param {string} str
		 * @param {Number} x
		 * @param {Number} y
		 * @param {String} shape
		 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
		 *	coordinates it should be pinned to
		 * @param {Number} anchorY
		 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
		 *	like renderer.text, or to the upper border of the rectangle.
		 * @param {String} className Class name for the group
		 */
		label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

			var renderer = this,
				wrapper = renderer.g(className),
				text = renderer.text('', 0, 0, useHTML)
					.attr({
						zIndex: 1
					}),
					//.add(wrapper),
				box,
				bBox,
				alignFactor = 0,
				padding = 3,
				paddingLeft = 0,
				width,
				height,
				wrapperX,
				wrapperY,
				crispAdjust = 0,
				deferredAttr = {},
				baselineOffset,
				needsBox;

			/**
			 * This function runs after the label is added to the DOM (when the bounding box is
			 * available), and after the text of the label is updated to detect the new bounding
			 * box and reflect it in the border box.
			 */
			function updateBoxSize() {
				var boxX,
					boxY,
					style = text.element.style;

				bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
					text.getBBox(); //#3295 && 3514 box failure when string equals 0
				wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
				wrapper.height = (height || bBox.height || 0) + 2 * padding;

				// update the label-scoped y offset
				baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

				
				if (needsBox) {

					// create the border box if it is not already present
					if (!box) {
						boxX = mathRound(-alignFactor * padding) + crispAdjust;
						boxY = (baseline ? -baselineOffset : 0) + crispAdjust;

						wrapper.box = box = shape ?
							renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
							renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
						box.attr('fill', NONE).add(wrapper);
					}

					// apply the box attributes
					if (!box.isImg) { // #1630
						box.attr(extend({
							width: mathRound(wrapper.width),
							height: mathRound(wrapper.height)
						}, deferredAttr));
					}
					deferredAttr = null;
				}
			}

			/**
			 * This function runs after setting text or padding, but only if padding is changed
			 */
			function updateTextPadding() {
				var styles = wrapper.styles,
					textAlign = styles && styles.textAlign,
					x = paddingLeft + padding * (1 - alignFactor),
					y;

				// determin y based on the baseline
				y = baseline ? 0 : baselineOffset;

				// compensate for alignment
				if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
					x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
				}

				// update if anything changed
				if (x !== text.x || y !== text.y) {
					text.attr('x', x);
					if (y !== UNDEFINED) {
						text.attr('y', y);
					}
				}

				// record current values
				text.x = x;
				text.y = y;
			}

			/**
			 * Set a box attribute, or defer it if the box is not yet created
			 * @param {Object} key
			 * @param {Object} value
			 */
			function boxAttr(key, value) {
				if (box) {
					box.attr(key, value);
				} else {
					deferredAttr[key] = value;
				}
			}

			/**
			 * After the text element is added, get the desired size of the border box
			 * and add it before the text in the DOM.
			 */
			wrapper.onAdd = function () {
				text.add(wrapper);
				wrapper.attr({
					text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
					x: x,
					y: y
				});

				if (box && defined(anchorX)) {
					wrapper.attr({
						anchorX: anchorX,
						anchorY: anchorY
					});
				}
			};

			/*
			 * Add specific attribute setters.
			 */

			// only change local variables
			wrapper.widthSetter = function (value) {
				width = value;
			};
			wrapper.heightSetter = function (value) {
				height = value;
			};
			wrapper.paddingSetter =  function (value) {
				if (defined(value) && value !== padding) {
					padding = wrapper.padding = value;
					updateTextPadding();
				}
			};
			wrapper.paddingLeftSetter =  function (value) {
				if (defined(value) && value !== paddingLeft) {
					paddingLeft = value;
					updateTextPadding();
				}
			};


			// change local variable and prevent setting attribute on the group
			wrapper.alignSetter = function (value) {
				alignFactor = { left: 0, center: 0.5, right: 1 }[value];
			};

			// apply these to the box and the text alike
			wrapper.textSetter = function (value) {
				if (value !== UNDEFINED) {
					text.textSetter(value);
				}
				updateBoxSize();
				updateTextPadding();
			};

			// apply these to the box but not to the text
			wrapper['stroke-widthSetter'] = function (value, key) {
				if (value) {
					needsBox = true;
				}
				crispAdjust = value % 2 / 2;
				boxAttr(key, value);
			};
			wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
				if (key === 'fill' && value) {
					needsBox = true;
				}
				boxAttr(key, value);
			};
			wrapper.anchorXSetter = function (value, key) {
				anchorX = value;
				boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
			};
			wrapper.anchorYSetter = function (value, key) {
				anchorY = value;
				boxAttr(key, value - wrapperY);
			};

			// rename attributes
			wrapper.xSetter = function (value) {
				wrapper.x = value; // for animation getter
				if (alignFactor) {
					value -= alignFactor * ((width || bBox.width) + padding);
				}
				wrapperX = mathRound(value);
				wrapper.attr('translateX', wrapperX);
			};
			wrapper.ySetter = function (value) {
				wrapperY = wrapper.y = mathRound(value);
				wrapper.attr('translateY', wrapperY);
			};

			// Redirect certain methods to either the box or the text
			var baseCss = wrapper.css;
			return extend(wrapper, {
				/**
				 * Pick up some properties and apply them to the text instead of the wrapper
				 */
				css: function (styles) {
					if (styles) {
						var textStyles = {};
						styles = merge(styles); // create a copy to avoid altering the original object (#537)
						each(wrapper.textProps, function (prop) {
							if (styles[prop] !== UNDEFINED) {
								textStyles[prop] = styles[prop];
								delete styles[prop];
							}
						});
						text.css(textStyles);
					}
					return baseCss.call(wrapper, styles);
				},
				/**
				 * Return the bounding box of the box, not the group
				 */
				getBBox: function () {
					return {
						width: bBox.width + 2 * padding,
						height: bBox.height + 2 * padding,
						x: bBox.x - padding,
						y: bBox.y - padding
					};
				},
				/**
				 * Apply the shadow to the box
				 */
				shadow: function (b) {
					if (box) {
						box.shadow(b);
					}
					return wrapper;
				},
				/**
				 * Destroy and release memory.
				 */
				destroy: function () {

					// Added by button implementation
					removeEvent(wrapper.element, 'mouseenter');
					removeEvent(wrapper.element, 'mouseleave');

					if (text) {
						text = text.destroy();
					}
					if (box) {
						box = box.destroy();
					}
					// Call base implementation to destroy the rest
					SVGElement.prototype.destroy.call(wrapper);

					// Release local pointers (#1298)
					wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
				}
			});
		}
	}; // end SVGRenderer


	// general renderer
	Renderer = SVGRenderer;
	// extend SvgElement for useHTML option
	extend(SVGElement.prototype, {
		/**
		 * Apply CSS to HTML elements. This is used in text within SVG rendering and
		 * by the VML renderer
		 */
		htmlCss: function (styles) {
			var wrapper = this,
				element = wrapper.element,
				textWidth = styles && element.tagName === 'SPAN' && styles.width;

			if (textWidth) {
				delete styles.width;
				wrapper.textWidth = textWidth;
				wrapper.updateTransform();
			}
			if (styles && styles.textOverflow === 'ellipsis') {
				styles.whiteSpace = 'nowrap';
				styles.overflow = 'hidden';
			}
			wrapper.styles = extend(wrapper.styles, styles);
			css(wrapper.element, styles);

			return wrapper;
		},

		/**
		 * VML and useHTML method for calculating the bounding box based on offsets
		 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
		 * use the cached value
		 *
		 * @return {Object} A hash containing values for x, y, width and height
		 */

		htmlGetBBox: function () {
			var wrapper = this,
				element = wrapper.element;

			// faking getBBox in exported SVG in legacy IE
			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			return {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		},

		/**
		 * VML override private method to update elements based on internal
		 * properties based on SVG transform
		 */
		htmlUpdateTransform: function () {
			// aligning non added elements is expensive
			if (!this.added) {
				this.alignOnAdd = true;
				return;
			}

			var wrapper = this,
				renderer = wrapper.renderer,
				elem = wrapper.element,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				x = wrapper.x || 0,
				y = wrapper.y || 0,
				align = wrapper.textAlign || 'left',
				alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
				shadows = wrapper.shadows,
				styles = wrapper.styles;

			// apply translate
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}

			// apply inversion
			if (wrapper.inverted) { // wrapper is a group
				each(elem.childNodes, function (child) {
					renderer.invertChild(child, elem);
				});
			}

			if (elem.tagName === 'SPAN') {

				var width,
					rotation = wrapper.rotation,
					baseline,
					textWidth = pInt(wrapper.textWidth),
					currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

				if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


					baseline = renderer.fontMetrics(elem.style.fontSize).b;

					// Renderer specific handling of span rotation
					if (defined(rotation)) {
						wrapper.setSpanRotation(rotation, alignCorrection, baseline);
					}

					width = pick(wrapper.elemWidth, elem.offsetWidth);

					// Update textWidth
					if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
						css(elem, {
							width: textWidth + PX,
							display: 'block',
							whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
						});
						width = textWidth;
					}

					wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
				}

				// apply position with correction
				css(elem, {
					left: (x + (wrapper.xCorr || 0)) + PX,
					top: (y + (wrapper.yCorr || 0)) + PX
				});

				// force reflow in webkit to apply the left and top on useHTML element (#1249)
				if (isWebKit) {
					baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
				}

				// record current text transform
				wrapper.cTT = currentTextTransform;
			}
		},

		/**
		 * Set the rotation of an individual HTML span
		 */
		setSpanRotation: function (rotation, alignCorrection, baseline) {
			var rotationStyle = {},
				cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

			rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
			rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
			css(this.element, rotationStyle);
		},

		/**
		 * Get the correction in X and Y positioning as the element is rotated.
		 */
		getSpanCorrection: function (width, baseline, alignCorrection) {
			this.xCorr = -width * alignCorrection;
			this.yCorr = -baseline;
		}
	});

	// Extend SvgRenderer for useHTML option.
	extend(SVGRenderer.prototype, {
		/**
		 * Create HTML text node. This is used by the VML renderer as well as the SVG
		 * renderer through the useHTML option.
		 *
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		html: function (str, x, y) {
			var wrapper = this.createElement('span'),
				element = wrapper.element,
				renderer = wrapper.renderer;

			// Text setter
			wrapper.textSetter = function (value) {
				if (value !== element.innerHTML) {
					delete this.bBox;
				}
				element.innerHTML = this.textStr = value;
			};

			// Various setters which rely on update transform
			wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
				if (key === 'align') {
					key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
				}
				wrapper[key] = value;
				wrapper.htmlUpdateTransform();
			};

			// Set the default attributes
			wrapper.attr({
					text: str,
					x: mathRound(x),
					y: mathRound(y)
				})
				.css({
					position: ABSOLUTE,
					fontFamily: this.style.fontFamily,
					fontSize: this.style.fontSize
				});

			// Keep the whiteSpace style outside the wrapper.styles collection
			element.style.whiteSpace = 'nowrap';

			// Use the HTML specific .css method
			wrapper.css = wrapper.htmlCss;

			// This is specific for HTML within SVG
			if (renderer.isSVG) {
				wrapper.add = function (svgGroupWrapper) {

					var htmlGroup,
						container = renderer.box.parentNode,
						parentGroup,
						parents = [];

					this.parentGroup = svgGroupWrapper;

					// Create a mock group to hold the HTML elements
					if (svgGroupWrapper) {
						htmlGroup = svgGroupWrapper.div;
						if (!htmlGroup) {

							// Read the parent chain into an array and read from top down
							parentGroup = svgGroupWrapper;
							while (parentGroup) {

								parents.push(parentGroup);

								// Move up to the next parent group
								parentGroup = parentGroup.parentGroup;
							}

							// Ensure dynamically updating position when any parent is translated
							each(parents.reverse(), function (parentGroup) {
								var htmlGroupStyle,
									cls = attr(parentGroup.element, 'class');

								if (cls) {
									cls = { className: cls };
								} // else null

								// Create a HTML div and append it to the parent div to emulate
								// the SVG group structure
								htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
									position: ABSOLUTE,
									left: (parentGroup.translateX || 0) + PX,
									top: (parentGroup.translateY || 0) + PX
								}, htmlGroup || container); // the top group is appended to container

								// Shortcut
								htmlGroupStyle = htmlGroup.style;

								// Set listeners to update the HTML div's position whenever the SVG group
								// position is changed
								extend(parentGroup, {
									translateXSetter: function (value, key) {
										htmlGroupStyle.left = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									translateYSetter: function (value, key) {
										htmlGroupStyle.top = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									}
								});
								wrap(parentGroup, 'visibilitySetter', function (proceed, value, key, elem) {
									proceed.call(this, value, key, elem);
									htmlGroupStyle[key] = value;
								});
							});

						}
					} else {
						htmlGroup = container;
					}

					htmlGroup.appendChild(element);

					// Shared with VML:
					wrapper.added = true;
					if (wrapper.alignOnAdd) {
						wrapper.htmlUpdateTransform();
					}

					return wrapper;
				};
			}
			return wrapper;
		}
	});

	/* ****************************************************************************
	 *                                                                            *
	 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	 *                                                                            *
	 * For applications and websites that don't need IE support, like platform    *
	 * targeted mobile apps and web apps, this code can be removed.               *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * @constructor
	 */
	var VMLRenderer, VMLElement;
	if (!hasSVG && !useCanVG) {

	/**
	 * The VML element wrapper.
	 */
	VMLElement = {

		/**
		 * Initialize a new VML element wrapper. It builds the markup as a string
		 * to minimize DOM traffic.
		 * @param {Object} renderer
		 * @param {Object} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this,
				markup =  ['<', nodeName, ' filled="f" stroked="f"'],
				style = ['position: ', ABSOLUTE, ';'],
				isDiv = nodeName === DIV;

			// divs and shapes need size
			if (nodeName === 'shape' || isDiv) {
				style.push('left:0;top:0;width:1px;height:1px;');
			}
			style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

			markup.push(' style="', style.join(''), '"/>');

			// create element with default attributes and style
			if (nodeName) {
				markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
					markup.join('')
					: renderer.prepVML(markup);
				wrapper.element = createElement(markup);
			}

			wrapper.renderer = renderer;
		},

		/**
		 * Add the node to the given parent
		 * @param {Object} parent
		 */
		add: function (parent) {
			var wrapper = this,
				renderer = wrapper.renderer,
				element = wrapper.element,
				box = renderer.box,
				inverted = parent && parent.inverted,

				// get the parent node
				parentNode = parent ?
					parent.element || parent :
					box;


			// if the parent group is inverted, apply inversion on all children
			if (inverted) { // only on groups
				renderer.invertChild(element, parentNode);
			}

			// append it
			parentNode.appendChild(element);

			// align text after adding to be able to read offset
			wrapper.added = true;
			if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
				wrapper.updateTransform();
			}

			// fire an event for internal hooks
			if (wrapper.onAdd) {
				wrapper.onAdd();
			}

			return wrapper;
		},

		/**
		 * VML always uses htmlUpdateTransform
		 */
		updateTransform: SVGElement.prototype.htmlUpdateTransform,

		/**
		 * Set the rotation of a span with oldIE's filter
		 */
		setSpanRotation: function () {
			// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
			// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
			// has support for CSS3 transform. The getBBox method also needs to be updated
			// to compensate for the rotation, like it currently does for SVG.
			// Test case: http://jsfiddle.net/highcharts/Ybt44/

			var rotation = this.rotation,
				costheta = mathCos(rotation * deg2rad),
				sintheta = mathSin(rotation * deg2rad);
						
			css(this.element, {
				filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
					', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
					', sizingMethod=\'auto expand\')'].join('') : NONE
			});
		},

		/**
		 * Get the positioning correction for the span after rotating. 
		 */
		getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

			var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
				sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
				height = pick(this.elemHeight, this.element.offsetHeight),
				quad,
				nonLeft = align && align !== 'left';

			// correct x and y
			this.xCorr = costheta < 0 && -width;
			this.yCorr = sintheta < 0 && -height;

			// correct for baseline and corners spilling out after rotation
			quad = costheta * sintheta < 0;
			this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
			this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
			// correct for the length/height of the text
			if (nonLeft) {
				this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
				if (rotation) {
					this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
				}
				css(this.element, {
					textAlign: align
				});
			}
		},

		/**
		 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
		 * as the parameter and returns a string.
		 */
		pathToVML: function (value) {
			// convert paths
			var i = value.length,
				path = [];

			while (i--) {

				// Multiply by 10 to allow subpixel precision.
				// Substracting half a pixel seems to make the coordinates
				// align with SVG, but this hasn't been tested thoroughly
				if (isNumber(value[i])) {
					path[i] = mathRound(value[i] * 10) - 5;
				} else if (value[i] === 'Z') { // close the path
					path[i] = 'x';
				} else {
					path[i] = value[i];

					// When the start X and end X coordinates of an arc are too close,
					// they are rounded to the same value above. In this case, substract or 
					// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
					if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
						// Start and end X
						if (path[i + 5] === path[i + 7]) {
							path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
						}
						// Start and end Y
						if (path[i + 6] === path[i + 8]) {
							path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
						}
					}
				}
			}

			
			// Loop up again to handle path shortcuts (#2132)
			/*while (i++ < path.length) {
				if (path[i] === 'H') { // horizontal line to
					path[i] = 'L';
					path.splice(i + 2, 0, path[i - 1]);
				} else if (path[i] === 'V') { // vertical line to
					path[i] = 'L';
					path.splice(i + 1, 0, path[i - 2]);
				}
			}*/
			return path.join(' ') || 'x';
		},

		/**
		 * Set the element's clipping to a predefined rectangle
		 *
		 * @param {String} id The id of the clip rectangle
		 */
		clip: function (clipRect) {
			var wrapper = this,
				clipMembers,
				cssRet;

			if (clipRect) {
				clipMembers = clipRect.members;
				erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
				clipMembers.push(wrapper);
				wrapper.destroyClip = function () {
					erase(clipMembers, wrapper);
				};
				cssRet = clipRect.getCSS(wrapper);

			} else {
				if (wrapper.destroyClip) {
					wrapper.destroyClip();
				}
				cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
			}

			return wrapper.css(cssRet);

		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: SVGElement.prototype.htmlCss,

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			// discardElement will detach the node from its parent before attaching it
			// to the garbage bin. Therefore it is important that the node is attached and have parent.
			if (element.parentNode) {
				discardElement(element);
			}
		},

		/**
		 * Extend element.destroy by removing it from the clip members array
		 */
		destroy: function () {
			if (this.destroyClip) {
				this.destroyClip();
			}

			return SVGElement.prototype.destroy.apply(this);
		},

		/**
		 * Add an event listener. VML override for normalizing event parameters.
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			// simplest possible event model for internal use
			this.element['on' + eventType] = function () {
				var evt = win.event;
				evt.target = evt.srcElement;
				handler(evt);
			};
			return this;
		},

		/**
		 * In stacked columns, cut off the shadows so that they don't overlap
		 */
		cutOffPath: function (path, length) {

			var len;

			path = path.split(/[ ,]/);
			len = path.length;

			if (len === 9 || len === 11) {
				path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
			}
			return path.join(' ');
		},

		/**
		 * Apply a drop shadow by copying elements and giving them different strokes
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				element = this.element,
				renderer = this.renderer,
				shadow,
				elemStyle = element.style,
				markup,
				path = element.path,
				strokeWidth,
				modifiedPath,
				shadowWidth,
				shadowElementOpacity;

			// some times empty paths are not strings
			if (path && typeof path.value !== 'string') {
				path = 'x';
			}
			modifiedPath = path;

			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				for (i = 1; i <= 3; i++) {

					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

					// Cut off shadows for stacked column items
					if (cutOff) {
						modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
					}

					markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
						'" filled="false" path="', modifiedPath,
						'" coordsize="10 10" style="', element.style.cssText, '" />'];

					shadow = createElement(renderer.prepVML(markup),
						null, {
							left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
							top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
						}
					);
					if (cutOff) {
						shadow.cutOff = strokeWidth + 1;
					}

					// apply the opacity
					markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
					createElement(renderer.prepVML(markup), null, null, shadow);


					// insert it
					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					// record it
					shadows.push(shadow);

				}

				this.shadows = shadows;
			}
			return this;
		},
		updateShadows: noop, // Used in SVG only

		setAttr: function (key, value) {
			if (docMode8) { // IE8 setAttribute bug
				this.element[key] = value;
			} else {
				this.element.setAttribute(key, value);
			}
		},
		classSetter: function (value) {
			// IE8 Standards mode has problems retrieving the className unless set like this
			this.element.className = value;
		},
		dashstyleSetter: function (value, key, element) {
			var strokeElem = element.getElementsByTagName('stroke')[0] ||
				createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
			strokeElem[key] = value || 'solid';
			this[key] = value; /* because changing stroke-width will change the dash length
				and cause an epileptic effect */
		},
		dSetter: function (value, key, element) {
			var i,
				shadows = this.shadows;
			value = value || [];
			this.d = value.join && value.join(' '); // used in getter for animation

			element.path = value = this.pathToVML(value);

			// update shadows
			if (shadows) {
				i = shadows.length;
				while (i--) {
					shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
				}
			}
			this.setAttr(key, value);
		},
		fillSetter: function (value, key, element) {
			var nodeName = element.nodeName;
			if (nodeName === 'SPAN') { // text color
				element.style.color = value;
			} else if (nodeName !== 'IMG') { // #1336
				element.filled = value !== NONE;
				this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
			}
		},
		opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
		rotationSetter: function (value, key, element) {
			var style = element.style;
			this[key] = style[key] = value; // style is for #1873

			// Correction for the 1x1 size of the shape container. Used in gauge needles.
			style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
			style.top = mathRound(mathCos(value * deg2rad)) + PX;
		},
		strokeSetter: function (value, key, element) {
			this.setAttr('strokecolor', this.renderer.color(value, element, key));
		},
		'stroke-widthSetter': function (value, key, element) {
			element.stroked = !!value; // VML "stroked" attribute
			this[key] = value; // used in getter, issue #113
			if (isNumber(value)) {
				value += PX;
			}
			this.setAttr('strokeweight', value);
		},
		titleSetter: function (value, key) {
			this.setAttr(key, value);
		},
		visibilitySetter: function (value, key, element) {

			// Handle inherited visibility
			if (value === 'inherit') {
				value = VISIBLE;
			}
			
			// Let the shadow follow the main element
			if (this.shadows) {
				each(this.shadows, function (shadow) {
					shadow.style[key] = value;
				});
			}

			// Instead of toggling the visibility CSS property, move the div out of the viewport.
			// This works around #61 and #586
			if (element.nodeName === 'DIV') {
				value = value === HIDDEN ? '-999em' : 0;

				// In order to redraw, IE7 needs the div to be visible when tucked away
				// outside the viewport. So the visibility is actually opposite of
				// the expected value. This applies to the tooltip only.
				if (!docMode8) {
					element.style[key] = value ? VISIBLE : HIDDEN;
				}
				key = 'top';
			}
			element.style[key] = value;
		},
		xSetter: function (value, key, element) {
			this[key] = value; // used in getter

			if (key === 'x') {
				key = 'left';
			} else if (key === 'y') {
				key = 'top';
			}/* else {
				value = mathMax(0, value); // don't set width or height below zero (#311)
			}*/

			// clipping rectangle special
			if (this.updateClipping) {
				this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
				this.updateClipping();
			} else {
				// normal
				element.style[key] = value;
			}
		},
		zIndexSetter: function (value, key, element) {
			element.style[key] = value;
		}
	};
	Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	// Some shared setters
	VMLElement.prototype.ySetter =
		VMLElement.prototype.widthSetter = 
		VMLElement.prototype.heightSetter = 
		VMLElement.prototype.xSetter;


	/**
	 * The VML renderer
	 */
	var VMLRendererExtension = { // inherit SVGRenderer

		Element: VMLElement,
		isIE8: userAgent.indexOf('MSIE 8.0') > -1,


		/**
		 * Initialize the VMLRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 */
		init: function (container, width, height, style) {
			var renderer = this,
				boxWrapper,
				box,
				css;

			renderer.alignedObjects = [];

			boxWrapper = renderer.createElement(DIV)
				.css(extend(this.getStyle(style), { position: RELATIVE}));
			box = boxWrapper.element;
			container.appendChild(boxWrapper.element);


			// generate the containing box
			renderer.isVML = true;
			renderer.box = box;
			renderer.boxWrapper = boxWrapper;
			renderer.cache = {};


			renderer.setSize(width, height, false);

			// The only way to make IE6 and IE7 print is to use a global namespace. However,
			// with IE8 the only way to make the dynamic shapes visible in screen and print mode
			// seems to be to add the xmlns attribute and the behaviour style inline.
			if (!doc.namespaces.hcv) {

				doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

				// Setup default CSS (#2153, #2368, #2384)
				css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
					'{ behavior:url(#default#VML); display: inline-block; } ';
				try {
					doc.createStyleSheet().cssText = css;
				} catch (e) {
					doc.styleSheets[0].cssText += css;
				}

			}
		},


		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none
		 */
		isHidden: function () {
			return !this.box.offsetWidth;
		},

		/**
		 * Define a clipping rectangle. In VML it is accomplished by storing the values
		 * for setting the CSS style to all associated members.
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {

			// create a dummy element
			var clipRect = this.createElement(),
				isObj = isObject(x);

			// mimic a rectangle with its style object for automatic updating in attr
			return extend(clipRect, {
				members: [],
				count: 0,
				left: (isObj ? x.x : x) + 1,
				top: (isObj ? x.y : y) + 1,
				width: (isObj ? x.width : width) - 1,
				height: (isObj ? x.height : height) - 1,
				getCSS: function (wrapper) {
					var element = wrapper.element,
						nodeName = element.nodeName,
						isShape = nodeName === 'shape',
						inverted = wrapper.inverted,
						rect = this,
						top = rect.top - (isShape ? element.offsetTop : 0),
						left = rect.left,
						right = left + rect.width,
						bottom = top + rect.height,
						ret = {
							clip: 'rect(' +
								mathRound(inverted ? left : top) + 'px,' +
								mathRound(inverted ? bottom : right) + 'px,' +
								mathRound(inverted ? right : bottom) + 'px,' +
								mathRound(inverted ? top : left) + 'px)'
						};

					// issue 74 workaround
					if (!inverted && docMode8 && nodeName === 'DIV') {
						extend(ret, {
							width: right + PX,
							height: bottom + PX
						});
					}
					return ret;
				},

				// used in attr and animation to update the clipping of all members
				updateClipping: function () {
					each(clipRect.members, function (member) {
						if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
							member.css(clipRect.getCSS(member));
						}
					});
				}
			});

		},


		/**
		 * Take a color and return it if it's a string, make it a gradient if it's a
		 * gradient configuration object, and apply opacity.
		 *
		 * @param {Object} color The color or config object
		 */
		color: function (color, elem, prop, wrapper) {
			var renderer = this,
				colorObject,
				regexRgba = /^rgba/,
				markup,
				fillType,
				ret = NONE;

			// Check for linear or radial gradient
			if (color && color.linearGradient) {
				fillType = 'gradient';
			} else if (color && color.radialGradient) {
				fillType = 'pattern';
			}


			if (fillType) {

				var stopColor,
					stopOpacity,
					gradient = color.linearGradient || color.radialGradient,
					x1,
					y1,
					x2,
					y2,
					opacity1,
					opacity2,
					color1,
					color2,
					fillAttr = '',
					stops = color.stops,
					firstStop,
					lastStop,
					colors = [],
					addFillNode = function () {
						// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
						// are reversed.
						markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
							'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
						createElement(renderer.prepVML(markup), null, null, elem);
					};

				// Extend from 0 to 1
				firstStop = stops[0];
				lastStop = stops[stops.length - 1];
				if (firstStop[0] > 0) {
					stops.unshift([
						0,
						firstStop[1]
					]);
				}
				if (lastStop[0] < 1) {
					stops.push([
						1,
						lastStop[1]
					]);
				}

				// Compute the stops
				each(stops, function (stop, i) {
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}

					// Build the color attribute
					colors.push((stop[0] * 100) + '% ' + stopColor);

					// Only start and end opacities are allowed, so we use the first and the last
					if (!i) {
						opacity1 = stopOpacity;
						color2 = stopColor;
					} else {
						opacity2 = stopOpacity;
						color1 = stopColor;
					}
				});

				// Apply the gradient to fills only.
				if (prop === 'fill') {

					// Handle linear gradient angle
					if (fillType === 'gradient') {
						x1 = gradient.x1 || gradient[0] || 0;
						y1 = gradient.y1 || gradient[1] || 0;
						x2 = gradient.x2 || gradient[2] || 0;
						y2 = gradient.y2 || gradient[3] || 0;
						fillAttr = 'angle="' + (90  - math.atan(
							(y2 - y1) / // y vector
							(x2 - x1) // x vector
							) * 180 / mathPI) + '"';

						addFillNode();

					// Radial (circular) gradient
					} else {

						var r = gradient.r,
							sizex = r * 2,
							sizey = r * 2,
							cx = gradient.cx,
							cy = gradient.cy,
							radialReference = elem.radialReference,
							bBox,
							applyRadialGradient = function () {
								if (radialReference) {
									bBox = wrapper.getBBox();
									cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
									cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
									sizex *= radialReference[2] / bBox.width;
									sizey *= radialReference[2] / bBox.height;
								}
								fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
									'size="' + sizex + ',' + sizey + '" ' +
									'origin="0.5,0.5" ' +
									'position="' + cx + ',' + cy + '" ' +
									'color2="' + color2 + '" ';

								addFillNode();
							};

						// Apply radial gradient
						if (wrapper.added) {
							applyRadialGradient();
						} else {
							// We need to know the bounding box to get the size and position right
							wrapper.onAdd = applyRadialGradient;
						}

						// The fill element's color attribute is broken in IE8 standards mode, so we
						// need to set the parent shape's fillcolor attribute instead.
						ret = color1;
					}

				// Gradients are not supported for VML stroke, return the first color. #722.
				} else {
					ret = stopColor;
				}

			// if the color is an rgba color, split it and add a fill node
			// to hold the opacity component
			} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

				colorObject = Color(color);

				markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
				createElement(this.prepVML(markup), null, null, elem);

				ret = colorObject.get('rgb');


			} else {
				var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
				if (propNodes.length) {
					propNodes[0].opacity = 1;
					propNodes[0].type = 'solid';
				}
				ret = color;
			}

			return ret;
		},

		/**
		 * Take a VML string and prepare it for either IE8 or IE6/IE7.
		 * @param {Array} markup A string array of the VML markup to prepare
		 */
		prepVML: function (markup) {
			var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
				isIE8 = this.isIE8;

			markup = markup.join('');

			if (isIE8) { // add xmlns and style inline
				markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
				if (markup.indexOf('style="') === -1) {
					markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
				} else {
					markup = markup.replace('style="', 'style="' + vmlStyle);
				}

			} else { // add namespace
				markup = markup.replace('<', '<hcv:');
			}

			return markup;
		},

		/**
		 * Create rotated and aligned text
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		text: SVGRenderer.prototype.html,

		/**
		 * Create and return a path element
		 * @param {Array} path
		 */
		path: function (path) {
			var attr = {
				// subpixel precision down to 0.1 (width and height = 1px)
				coordsize: '10 10'
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			// create the shape
			return this.createElement('shape').attr(attr);
		},

		/**
		 * Create and return a circle element. In VML circles are implemented as
		 * shapes, which is faster than v:oval
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} r
		 */
		circle: function (x, y, r) {
			var circle = this.symbol('circle');
			if (isObject(x)) {
				r = x.r;
				y = x.y;
				x = x.x;
			}
			circle.isCircle = true; // Causes x and y to mean center (#1682)
			circle.r = r;
			return circle.attr({ x: x, y: y });
		},

		/**
		 * Create a group using an outer div and an inner v:group to allow rotating
		 * and flipping. A simple v:group would have problems with positioning
		 * child HTML elements and CSS clip.
		 *
		 * @param {String} name The name of the group
		 */
		g: function (name) {
			var wrapper,
				attribs;

			// set the class name
			if (name) {
				attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
			}

			// the div to hold HTML and clipping
			wrapper = this.createElement(DIV).attr(attribs);

			return wrapper;
		},

		/**
		 * VML override to create a regular HTML image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var obj = this.createElement('img')
				.attr({ src: src });

			if (arguments.length > 1) {
				obj.attr({
					x: x,
					y: y,
					width: width,
					height: height
				});
			}
			return obj;
		},

		/**
		 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
		 */
		createElement: function (nodeName) {
			return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
		},

		/**
		 * In the VML renderer, each child of an inverted div (group) is inverted
		 * @param {Object} element
		 * @param {Object} parentNode
		 */
		invertChild: function (element, parentNode) {
			var ren = this,
				parentStyle = parentNode.style,
				imgStyle = element.tagName === 'IMG' && element.style; // #1111

			css(element, {
				flip: 'x',
				left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
				top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
				rotation: -90
			});

			// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
			each(element.childNodes, function (child) {
				ren.invertChild(child, element);
			});
		},

		/**
		 * Symbol definitions that override the parent SVG renderer's symbols
		 *
		 */
		symbols: {
			// VML specific arc function
			arc: function (x, y, w, h, options) {
				var start = options.start,
					end = options.end,
					radius = options.r || w || h,
					innerRadius = options.innerR,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					ret;

				if (end - start === 0) { // no angle, don't show it.
					return ['x'];
				}

				ret = [
					'wa', // clockwise arc to
					x - radius, // left
					y - radius, // top
					x + radius, // right
					y + radius, // bottom
					x + radius * cosStart, // start x
					y + radius * sinStart, // start y
					x + radius * cosEnd, // end x
					y + radius * sinEnd  // end y
				];

				if (options.open && !innerRadius) {
					ret.push(
						'e',
						M,
						x,// - innerRadius,
						y// - innerRadius
					);
				}

				ret.push(
					'at', // anti clockwise arc to
					x - innerRadius, // left
					y - innerRadius, // top
					x + innerRadius, // right
					y + innerRadius, // bottom
					x + innerRadius * cosEnd, // start x
					y + innerRadius * sinEnd, // start y
					x + innerRadius * cosStart, // end x
					y + innerRadius * sinStart, // end y
					'x', // finish path
					'e' // close
				);

				ret.isArc = true;
				return ret;

			},
			// Add circle symbol path. This performs significantly faster than v:oval.
			circle: function (x, y, w, h, wrapper) {

				if (wrapper) {
					w = h = 2 * wrapper.r;
				}

				// Center correction, #1682
				if (wrapper && wrapper.isCircle) {
					x -= w / 2;
					y -= h / 2;
				}

				// Return the path
				return [
					'wa', // clockwisearcto
					x, // left
					y, // top
					x + w, // right
					y + h, // bottom
					x + w, // start x
					y + h / 2,     // start y
					x + w, // end x
					y + h / 2,     // end y
					//'x', // finish path
					'e' // close
				];
			},
			/**
			 * Add rectangle symbol path which eases rotation and omits arcsize problems
			 * compared to the built-in VML roundrect shape. When borders are not rounded,
			 * use the simpler square path, else use the callout path without the arrow.
			 */
			rect: function (x, y, w, h, options) {
				return SVGRenderer.prototype.symbols[
					!defined(options) || !options.r ? 'square' : 'callout'
				].call(0, x, y, w, h, options);
			}
		}
	};
	Highcharts.VMLRenderer = VMLRenderer = function () {
		this.init.apply(this, arguments);
	};
	VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

		// general renderer
		Renderer = VMLRenderer;
	}

	// This method is used with exporting in old IE, when emulating SVG (see #2314)
	SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
		var measuringSpan = doc.createElement('span'),
			offsetWidth,
		textNode = doc.createTextNode(text);

		measuringSpan.appendChild(textNode);
		css(measuringSpan, styles);
		this.box.appendChild(measuringSpan);
		offsetWidth = measuringSpan.offsetWidth;
		discardElement(measuringSpan); // #2463
		return offsetWidth;
	};


	/* ****************************************************************************
	 *                                                                            *
	 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	 *                                                                            *
	 *****************************************************************************/
	/* ****************************************************************************
	 *                                                                            *
	 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
	 * TARGETING THAT SYSTEM.                                                     *
	 *                                                                            *
	 *****************************************************************************/
	var CanVGRenderer,
		CanVGController;

	if (useCanVG) {
		/**
		 * The CanVGRenderer is empty from start to keep the source footprint small.
		 * When requested, the CanVGController downloads the rest of the source packaged
		 * together with the canvg library.
		 */
		Highcharts.CanVGRenderer = CanVGRenderer = function () {
			// Override the global SVG namespace to fake SVG/HTML that accepts CSS
			SVG_NS = 'http://www.w3.org/1999/xhtml';
		};

		/**
		 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
		 * the implementation from SvgRenderer will not be merged in until first render.
		 */
		CanVGRenderer.prototype.symbols = {};

		/**
		 * Handles on demand download of canvg rendering support.
		 */
		CanVGController = (function () {
			// List of renderering calls
			var deferredRenderCalls = [];

			/**
			 * When downloaded, we are ready to draw deferred charts.
			 */
			function drawDeferred() {
				var callLength = deferredRenderCalls.length,
					callIndex;

				// Draw all pending render calls
				for (callIndex = 0; callIndex < callLength; callIndex++) {
					deferredRenderCalls[callIndex]();
				}
				// Clear the list
				deferredRenderCalls = [];
			}

			return {
				push: function (func, scriptLocation) {
					// Only get the script once
					if (deferredRenderCalls.length === 0) {
						getScript(scriptLocation, drawDeferred);
					}
					// Register render call
					deferredRenderCalls.push(func);
				}
			};
		}());

		Renderer = CanVGRenderer;
	} // end CanVGRenderer

	/* ****************************************************************************
	 *                                                                            *
	 * END OF ANDROID < 3 SPECIFIC CODE                                           *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * The Tick class
	 */
	function Tick(axis, pos, type, noLabel) {
		this.axis = axis;
		this.pos = pos;
		this.type = type || '';
		this.isNew = true;

		if (!type && !noLabel) {
			this.addLabel();
		}
	}

	Tick.prototype = {
		/**
		 * Write the tick label
		 */
		addLabel: function () {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				categories = axis.categories,
				names = axis.names,
				pos = tick.pos,
				labelOptions = options.labels,
				str,
				tickPositions = axis.tickPositions,
				isFirst = pos === tickPositions[0],
				isLast = pos === tickPositions[tickPositions.length - 1],
				value = categories ?
					pick(categories[pos], names[pos], pos) :
					pos,
				label = tick.label,
				tickPositionInfo = tickPositions.info,
				dateTimeLabelFormat;

			// Set the datetime label format. If a higher rank is set for this position, use that. If not,
			// use the general format.
			if (axis.isDatetimeAxis && tickPositionInfo) {
				dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
			}
			// set properties for access in render method
			tick.isFirst = isFirst;
			tick.isLast = isLast;

			// get the string
			str = axis.labelFormatter.call({
				axis: axis,
				chart: chart,
				isFirst: isFirst,
				isLast: isLast,
				dateTimeLabelFormat: dateTimeLabelFormat,
				value: axis.isLog ? correctFloat(lin2log(value)) : value
			});

			// prepare CSS
			//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
			
			// first call
			if (!defined(label)) {

				tick.label = label =
					defined(str) && labelOptions.enabled ?
						chart.renderer.text(
								str,
								0,
								0,
								labelOptions.useHTML
							)
							//.attr(attr)
							// without position absolute, IE export sometimes is wrong
							.css(merge(labelOptions.style))
							.add(axis.labelGroup) :
						null;
				tick.labelLength = label && label.getBBox().width; // Un-rotated length
				tick.rotation = 0; // Base value to detect change for new calls to getBBox

			// update
			} else if (label) {
				label.attr({ text: str });
			}
		},

		/**
		 * Get the offset height or width of the label
		 */
		getLabelSize: function () {
			return this.label ?
				this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
				0;
		},

		/**
		 * Handle the label overflow by adjusting the labels to the left and right edge, or
		 * hide them if they collide into the neighbour label.
		 */
		handleOverflow: function (xy) {
			var axis = this.axis,
				pxPos = xy.x,
				chartWidth = axis.chart.chartWidth,
				spacing = axis.chart.spacing,
				leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
				rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
				label = this.label,
				rotation = this.rotation,
				factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
				labelWidth = label.getBBox().width,
				slotWidth = axis.slotWidth,
				xCorrection = factor,
				goRight = 1,
				leftPos,
				rightPos,
				textWidth,
				css = {};

			// Check if the label overshoots the chart spacing box. If it does, move it.
			// If it now overshoots the slotWidth, add ellipsis.
			if (!rotation) {
				leftPos = pxPos - factor * labelWidth;
				rightPos = pxPos + (1 - factor) * labelWidth;

				if (leftPos < leftBound) {
					slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;
				} else if (rightPos > rightBound) {
					slotWidth = rightBound - xy.x + slotWidth * factor;
					goRight = -1;
				}

				slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177
				if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {
					xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));				
				}
				// If the label width exceeds the available space, set a text width to be 
				// picked up below. Also, if a width has been set before, we need to set a new
				// one because the reported labelWidth will be limited by the box (#3938).
				if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {
					textWidth = slotWidth;
				}

			// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
			} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
				textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
			} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
				textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
			}

			if (textWidth) {
				css.width = textWidth;
				if (!axis.options.labels.style.textOverflow) {
					css.textOverflow = 'ellipsis';
				}
				label.css(css);
			}
		},

		/**
		 * Get the x and y position for ticks and labels
		 */
		getPosition: function (horiz, pos, tickmarkOffset, old) {
			var axis = this.axis,
				chart = axis.chart,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

			return {
				x: horiz ?
					axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
					axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

				y: horiz ?
					cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
					cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
			};

		},

		/**
		 * Get the x, y position of the tick label
		 */
		getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
			var axis = this.axis,
				transA = axis.transA,
				reversed = axis.reversed,
				staggerLines = axis.staggerLines,
				rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
				yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
				line;

			x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
				tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
			y = y + yOffset - (tickmarkOffset && !horiz ?
				tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

			// Correct for staggered labels
			if (staggerLines) {
				line = (index / (step || 1) % staggerLines);
				y += line * (axis.labelOffset / staggerLines);
			}

			return {
				x: x,
				y: mathRound(y)
			};
		},

		/**
		 * Extendible method to return the path of the marker
		 */
		getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
			return renderer.crispLine([
					M,
					x,
					y,
					L,
					x + (horiz ? 0 : -tickLength),
					y + (horiz ? tickLength : 0)
				], tickWidth);
		},

		/**
		 * Put everything in place
		 *
		 * @param index {Number}
		 * @param old {Boolean} Use old coordinates to prepare an animation into new position
		 */
		render: function (index, old, opacity) {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				renderer = chart.renderer,
				horiz = axis.horiz,
				type = tick.type,
				label = tick.label,
				pos = tick.pos,
				labelOptions = options.labels,
				gridLine = tick.gridLine,
				gridPrefix = type ? type + 'Grid' : 'grid',
				tickPrefix = type ? type + 'Tick' : 'tick',
				gridLineWidth = options[gridPrefix + 'LineWidth'],
				gridLineColor = options[gridPrefix + 'LineColor'],
				dashStyle = options[gridPrefix + 'LineDashStyle'],
				tickLength = options[tickPrefix + 'Length'],
				tickWidth = options[tickPrefix + 'Width'] || 0,
				tickColor = options[tickPrefix + 'Color'],
				tickPosition = options[tickPrefix + 'Position'],
				gridLinePath,
				mark = tick.mark,
				markPath,
				step = /*axis.labelStep || */labelOptions.step,
				attribs,
				show = true,
				tickmarkOffset = axis.tickmarkOffset,
				xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
				x = xy.x,
				y = xy.y,
				reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

			opacity = pick(opacity, 1);
			this.isActive = true;

			// create the grid line
			if (gridLineWidth) {
				gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

				if (gridLine === UNDEFINED) {
					attribs = {
						stroke: gridLineColor,
						'stroke-width': gridLineWidth
					};
					if (dashStyle) {
						attribs.dashstyle = dashStyle;
					}
					if (!type) {
						attribs.zIndex = 1;
					}
					if (old) {
						attribs.opacity = 0;
					}
					tick.gridLine = gridLine =
						gridLineWidth ?
							renderer.path(gridLinePath)
								.attr(attribs).add(axis.gridGroup) :
							null;
				}

				// If the parameter 'old' is set, the current call will be followed
				// by another call, therefore do not do any animations this time
				if (!old && gridLine && gridLinePath) {
					gridLine[tick.isNew ? 'attr' : 'animate']({
						d: gridLinePath,
						opacity: opacity
					});
				}
			}

			// create the tick mark
			if (tickWidth && tickLength) {

				// negate the length
				if (tickPosition === 'inside') {
					tickLength = -tickLength;
				}
				if (axis.opposite) {
					tickLength = -tickLength;
				}

				markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
				if (mark) { // updating
					mark.animate({
						d: markPath,
						opacity: opacity
					});
				} else { // first time
					tick.mark = renderer.path(
						markPath
					).attr({
						stroke: tickColor,
						'stroke-width': tickWidth,
						opacity: opacity
					}).add(axis.axisGroup);
				}
			}

			// the label is created on init - now move it into place
			if (label && !isNaN(x)) {
				label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

				// Apply show first and show last. If the tick is both first and last, it is
				// a single centered tick, in which case we show the label anyway (#2100).
				if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
						(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
					show = false;

				// Handle label overflow and show or hide accordingly
				} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
					tick.handleOverflow(xy);
				}

				// apply step
				if (step && index % step) {
					// show those indices dividable by step
					show = false;
				}

				// Set the new position, and show or hide
				if (show && !isNaN(xy.y)) {
					xy.opacity = opacity;
					label[tick.isNew ? 'attr' : 'animate'](xy);
					tick.isNew = false;
				} else {
					label.attr('y', -9999); // #1338
				}
			}
		},

		/**
		 * Destructor for the tick prototype
		 */
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		}
	};

	/**
	 * The object wrapper for plot lines and plot bands
	 * @param {Object} options
	 */
	Highcharts.PlotLineOrBand = function (axis, options) {
		this.axis = axis;

		if (options) {
			this.options = options;
			this.id = options.id;
		}
	};

	Highcharts.PlotLineOrBand.prototype = {
		
		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				axis = plotLine.axis,
				horiz = axis.horiz,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				isBand = defined(from) && defined(to),
				value = options.value,
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs = {},
				renderer = axis.chart.renderer;

			// logarithmic conversion
			if (axis.isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = axis.getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (isBand) { // plot band

				path = axis.getPlotBandPath(from, to, options);
				if (color) {
					attribs.fill = color;
				}
				if (options.borderWidth) {
					attribs.stroke = options.borderColor;
					attribs['stroke-width'] = options.borderWidth;
				}
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
					if (label) {
						plotLine.label = label = label.destroy();
					}
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && isBand && 'center',
					x: horiz ? !isBand && 4 : 10,
					verticalAlign : !horiz && isBand && 'middle',
					y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
					rotation: horiz && !isBand && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					attribs = {
						align: optionsLabel.textAlign || optionsLabel.align,
						rotation: optionsLabel.rotation
					};
					if (defined(zIndex)) {
						attribs.zIndex = zIndex;
					}
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0,
							optionsLabel.useHTML
						)
						.attr(attribs)
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				// #3000 changed to better handle choice between plotband or plotline
				xs = [path[1], path[4], (isBand ? path[6] : path[1])];
				ys = [path[2], path[5], (isBand ? path[7] : path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			// remove it from the lookup
			erase(this.axis.plotLinesAndBands, this);
			
			delete this.axis;
			destroyObjectProperties(this);
		}
	};

	/**
	 * Object with members for extending the Axis prototype
	 */

	AxisPlotLineOrBandExtension = {

		/**
		 * Create the path for a plot band
		 */ 
		getPlotBandPath: function (from, to) {
			var toPath = this.getPlotLinePath(to, null, null, true),
				path = this.getPlotLinePath(from, null, null, true);

			if (path && toPath && path.toString() !== toPath.toString()) { // #3836
				path.push(
					toPath[4],
					toPath[5],
					toPath[1],
					toPath[2]
				);
			} else { // outside the axis area
				path = null;
			}
			
			return path;
		},

		addPlotBand: function (options) {
			return this.addPlotBandOrLine(options, 'plotBands');
		},
		
		addPlotLine: function (options) {
			return this.addPlotBandOrLine(options, 'plotLines');
		},

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		addPlotBandOrLine: function (options, coll) {
			var obj = new Highcharts.PlotLineOrBand(this, options).render(),
				userOptions = this.userOptions;

			if (obj) { // #2189
				// Add it to the user options for exporting and Axis.update
				if (coll) {
					userOptions[coll] = userOptions[coll] || [];
					userOptions[coll].push(options); 
				}
				this.plotLinesAndBands.push(obj); 
			}
			
			return obj;
		},

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		removePlotBandOrLine: function (id) {
			var plotLinesAndBands = this.plotLinesAndBands,
				options = this.options,
				userOptions = this.userOptions,
				i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
			each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
				i = arr.length;
				while (i--) {
					if (arr[i].id === id) {
						erase(arr, arr[i]);
					}
				}
			});
		}
	};

	/**
	 * Create a new axis object
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Axis = Highcharts.Axis = function () {
		this.init.apply(this, arguments);
	};

	Axis.prototype = {

		/**
		 * Default options for the X axis - the Y axis has extended defaults
		 */
		defaultOptions: {
			// allowDecimals: null,
			// alternateGridColor: null,
			// categories: [],
			dateTimeLabelFormats: {
				millisecond: '%H:%M:%S.%L',
				second: '%H:%M:%S',
				minute: '%H:%M',
				hour: '%H:%M',
				day: '%e. %b',
				week: '%e. %b',
				month: '%b \'%y',
				year: '%Y'
			},
			endOnTick: false,
			gridLineColor: '#D8D8D8',
			// gridLineDashStyle: 'solid',
			// gridLineWidth: 0,
			// reversed: false,

			labels: {
				enabled: true,
				// rotation: 0,
				// align: 'center',
				// step: null,
				style: {
					color: '#606060',
					cursor: 'default',
					fontSize: '11px'
				},
				x: 0,
				y: 15
				/*formatter: function () {
					return this.value;
				},*/
			},
			lineColor: '#C0D0E0',
			lineWidth: 1,
			//linkedTo: null,
			//max: undefined,
			//min: undefined,
			minPadding: 0.01,
			maxPadding: 0.01,
			//minRange: null,
			minorGridLineColor: '#E0E0E0',
			// minorGridLineDashStyle: null,
			minorGridLineWidth: 1,
			minorTickColor: '#A0A0A0',
			//minorTickInterval: null,
			minorTickLength: 2,
			minorTickPosition: 'outside', // inside or outside
			//minorTickWidth: 0,
			//opposite: false,
			//offset: 0,
			//plotBands: [{
			//	events: {},
			//	zIndex: 1,
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//plotLines: [{
			//	events: {}
			//  dashStyle: {}
			//	zIndex:
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//reversed: false,
			// showFirstLabel: true,
			// showLastLabel: true,
			startOfWeek: 1,
			startOnTick: false,
			tickColor: '#C0D0E0',
			//tickInterval: null,
			tickLength: 10,
			tickmarkPlacement: 'between', // on or between
			tickPixelInterval: 100,
			tickPosition: 'outside',
			tickWidth: 1,
			title: {
				//text: null,
				align: 'middle', // low, middle or high
				//margin: 0 for horizontal, 10 for vertical axes,
				//rotation: 0,
				//side: 'outside',
				style: {
					color: '#707070'
				}
				//x: 0,
				//y: 0
			},
			type: 'linear' // linear, logarithmic or datetime
		},

		/**
		 * This options set extends the defaultOptions for Y axes
		 */
		defaultYAxisOptions: {
			endOnTick: true,
			gridLineWidth: 1,
			tickPixelInterval: 72,
			showLastLabel: true,
			labels: {
				x: -8,
				y: 3
			},
			lineWidth: 0,
			maxPadding: 0.05,
			minPadding: 0.05,
			startOnTick: true,
			tickWidth: 0,
			title: {
				rotation: 270,
				text: 'Values'
			},
			stackLabels: {
				enabled: false,
				//align: dynamic,
				//y: dynamic,
				//x: dynamic,
				//verticalAlign: dynamic,
				//textAlign: dynamic,
				//rotation: 0,
				formatter: function () {
					return Highcharts.numberFormat(this.total, -1);
				},
				style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
			}
		},

		/**
		 * These options extend the defaultOptions for left axes
		 */
		defaultLeftAxisOptions: {
			labels: {
				x: -15,
				y: null
			},
			title: {
				rotation: 270
			}
		},

		/**
		 * These options extend the defaultOptions for right axes
		 */
		defaultRightAxisOptions: {
			labels: {
				x: 15,
				y: null
			},
			title: {
				rotation: 90
			}
		},

		/**
		 * These options extend the defaultOptions for bottom axes
		 */
		defaultBottomAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: null // based on font size
				// overflow: undefined,
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},
		/**
		 * These options extend the defaultOptions for top axes
		 */
		defaultTopAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: -15
				// overflow: undefined
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},

		/**
		 * Initialize the axis
		 */
		init: function (chart, userOptions) {


			var isXAxis = userOptions.isX,
				axis = this;

			// Flag, is the axis horizontal
			axis.horiz = chart.inverted ? !isXAxis : isXAxis;

			// Flag, isXAxis
			axis.isXAxis = isXAxis;
			axis.coll = isXAxis ? 'xAxis' : 'yAxis';

			axis.opposite = userOptions.opposite; // needed in setOptions
			axis.side = userOptions.side || (axis.horiz ?
					(axis.opposite ? 0 : 2) : // top : bottom
					(axis.opposite ? 1 : 3));  // right : left

			axis.setOptions(userOptions);


			var options = this.options,
				type = options.type,
				isDatetimeAxis = type === 'datetime';

			axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


			// Flag, stagger lines or not
			axis.userOptions = userOptions;

			//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
			axis.minPixelPadding = 0;
			//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
			//axis.ignoreMaxPadding = UNDEFINED;

			axis.chart = chart;
			axis.reversed = options.reversed;
			axis.zoomEnabled = options.zoomEnabled !== false;

			// Initial categories
			axis.categories = options.categories || type === 'category';
			axis.names = axis.names || []; // Preserve on update (#3830)

			// Elements
			//axis.axisGroup = UNDEFINED;
			//axis.gridGroup = UNDEFINED;
			//axis.axisTitle = UNDEFINED;
			//axis.axisLine = UNDEFINED;

			// Shorthand types
			axis.isLog = type === 'logarithmic';
			axis.isDatetimeAxis = isDatetimeAxis;

			// Flag, if axis is linked to another axis
			axis.isLinked = defined(options.linkedTo);
			// Linked axis.
			//axis.linkedParent = UNDEFINED;

			// Tick positions
			//axis.tickPositions = UNDEFINED; // array containing predefined positions
			// Tick intervals
			//axis.tickInterval = UNDEFINED;
			//axis.minorTickInterval = UNDEFINED;

			
			// Major ticks
			axis.ticks = {};
			axis.labelEdge = [];
			// Minor ticks
			axis.minorTicks = {};

			// List of plotLines/Bands
			axis.plotLinesAndBands = [];

			// Alternate bands
			axis.alternateBands = {};

			// Axis metrics
			//axis.left = UNDEFINED;
			//axis.top = UNDEFINED;
			//axis.width = UNDEFINED;
			//axis.height = UNDEFINED;
			//axis.bottom = UNDEFINED;
			//axis.right = UNDEFINED;
			//axis.transA = UNDEFINED;
			//axis.transB = UNDEFINED;
			//axis.oldTransA = UNDEFINED;
			axis.len = 0;
			//axis.oldMin = UNDEFINED;
			//axis.oldMax = UNDEFINED;
			//axis.oldUserMin = UNDEFINED;
			//axis.oldUserMax = UNDEFINED;
			//axis.oldAxisLength = UNDEFINED;
			axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
			axis.range = options.range;
			axis.offset = options.offset || 0;


			// Dictionary for stacks
			axis.stacks = {};
			axis.oldStacks = {};
			axis.stacksTouched = 0;

			// Min and max in the data
			//axis.dataMin = UNDEFINED,
			//axis.dataMax = UNDEFINED,

			// The axis range
			axis.max = null;
			axis.min = null;

			// User set min and max
			//axis.userMin = UNDEFINED,
			//axis.userMax = UNDEFINED,

			// Crosshair options
			axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
			// Run Axis

			var eventType,
				events = axis.options.events;

			// Register
			if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
				if (isXAxis && !this.isColorAxis) { // #2713
					chart.axes.splice(chart.xAxis.length, 0, axis);
				} else {
					chart.axes.push(axis);
				}

				chart[axis.coll].push(axis);
			}

			axis.series = axis.series || []; // populated by Series

			// inverted charts have reversed xAxes as default
			if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
				axis.reversed = true;
			}

			axis.removePlotBand = axis.removePlotBandOrLine;
			axis.removePlotLine = axis.removePlotBandOrLine;


			// register event listeners
			for (eventType in events) {
				addEvent(axis, eventType, events[eventType]);
			}

			// extend logarithmic axis
			if (axis.isLog) {
				axis.val2lin = log2lin;
				axis.lin2val = lin2log;
			}
		},

		/**
		 * Merge and set options
		 */
		setOptions: function (userOptions) {
			this.options = merge(
				this.defaultOptions,
				this.isXAxis ? {} : this.defaultYAxisOptions,
				[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
					this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
				merge(
					defaultOptions[this.coll], // if set in setOptions (#1053)
					userOptions
				)
			);
		},

		/**
		 * The default label formatter. The context is a special config object for the label.
		 */
		defaultLabelFormatter: function () {
			var axis = this.axis,
				value = this.value,
				categories = axis.categories,
				dateTimeLabelFormat = this.dateTimeLabelFormat,
				numericSymbols = defaultOptions.lang.numericSymbols,
				i = numericSymbols && numericSymbols.length,
				multi,
				ret,
				formatOption = axis.options.labels.format,

				// make sure the same symbol is added for all labels on a linear axis
				numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

			if (formatOption) {
				ret = format(formatOption, this);

			} else if (categories) {
				ret = value;

			} else if (dateTimeLabelFormat) { // datetime axis
				ret = dateFormat(dateTimeLabelFormat, value);

			} else if (i && numericSymbolDetector >= 1000) {
				// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
				// If we are to enable this in tooltip or other places as well, we can move this
				// logic to the numberFormatter and enable it by a parameter.
				while (i-- && ret === UNDEFINED) {
					multi = Math.pow(1000, i + 1);
					if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {
						ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
					}
				}
			}

			if (ret === UNDEFINED) {
				if (mathAbs(value) >= 10000) { // add thousands separators
					ret = Highcharts.numberFormat(value, -1);

				} else { // small numbers
					ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
				}
			}

			return ret;
		},

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		getSeriesExtremes: function () {
			var axis = this,
				chart = axis.chart;

			axis.hasVisibleSeries = false;

			// Reset properties in case we're redrawing (#3353)
			axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;
			
			if (axis.buildStacks) {
				axis.buildStacks();
			}

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						xData,
						threshold = seriesOptions.threshold,
						seriesDataMin,
						seriesDataMax;

					axis.hasVisibleSeries = true;

					// Validate threshold in logarithmic axes
					if (axis.isLog && threshold <= 0) {
						threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (axis.isXAxis) {
						xData = series.xData;
						if (xData.length) {
							axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
							axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {

						// Get this particular series extremes
						series.getExtremes();
						seriesDataMax = series.dataMax;
						seriesDataMin = series.dataMin;

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
						// doesn't have active y data, we continue with nulls
						if (defined(seriesDataMin) && defined(seriesDataMax)) {
							axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
							axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (axis.dataMin >= threshold) {
								axis.dataMin = threshold;
								axis.ignoreMinPadding = true;
							} else if (axis.dataMax < threshold) {
								axis.dataMax = threshold;
								axis.ignoreMaxPadding = true;
							}
						}
					}
				}
			});
		},

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
			var axis = this.linkedParent || this, // #1417
				sign = 1,
				cvsOffset = 0,
				localA = old ? axis.oldTransA : axis.transA,
				localMin = old ? axis.oldMin : axis.min,
				returnValue,
				minPixelPadding = axis.minPixelPadding,
				doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

			if (!localA) {
				localA = axis.transA;
			}

			// In vertical axes, the canvas coordinates start from 0 at the top like in
			// SVG.
			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axis.len;
			}

			// Handle reversed axis
			if (axis.reversed) {
				sign *= -1;
				cvsOffset -= sign * (axis.sector || axis.len);
			}

			// From pixels to value
			if (backwards) { // reverse translation

				val = val * sign + cvsOffset;
				val -= minPixelPadding;
				returnValue = val / localA + localMin; // from chart pixel to value
				if (doPostTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			// From value to pixels
			} else {
				if (doPostTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}
				if (pointPlacement === 'between') {
					pointPlacement = 0.5;
				}
				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
					(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
			}

			return returnValue;
		},

		/**
		 * Utility method to translate an axis value to pixel position.
		 * @param {Number} value A value in terms of axis units
		 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
		 *        or just the axis/pane itself.
		 */
		toPixels: function (value, paneCoordinates) {
			return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
		},

		/*
		 * Utility method to translate a pixel position in to an axis value
		 * @param {Number} pixel The pixel value coordinate
		 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
		 *        axis/pane itself.
		 */
		toValue: function (pixel, paneCoordinates) {
			return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
		},

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
			var axis = this,
				chart = axis.chart,
				axisLeft = axis.left,
				axisTop = axis.top,
				x1,
				y1,
				x2,
				y2,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
				cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
				skip,
				transB = axis.transB,
				/**
				 * Check if x is between a and b. If not, either move to a/b or skip, 
				 * depending on the force parameter.
				 */
				between = function (x, a, b) {
					if (x < a || x > b) {
						if (force) {
							x = mathMin(mathMax(a, x), b);
						} else {
							skip = true;
						}
					}
					return x;
				};

			translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (axis.horiz) {
				y1 = axisTop;
				y2 = cHeight - axis.bottom;
				x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
			} else {
				x1 = axisLeft;
				x2 = cWidth - axis.right;
				y1 = y2 = between(y1, axisTop, axisTop + axis.height);
			}
			return skip && !force ?
				null :
				chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
		},

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		getLinearTickPositions: function (tickInterval, min, max) {
			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// For single points, add a tick regardless of the relative position (#2662)
			if (min === max && isNumber(min)) {
				return [min];
			}

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		},

		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		getMinorTickPositions: function () {
			var axis = this,
				options = axis.options,
				tickPositions = axis.tickPositions,
				minorTickInterval = axis.minorTickInterval,
				minorTickPositions = [],
				pos,
				i,
				min = axis.min,
				max = axis.max,
				range = max - min,
				len;

			// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
			if (range && range / minorTickInterval < axis.len / 3) { // #3875

				if (axis.isLog) {
					len = tickPositions.length;
					for (i = 1; i < len; i++) {
						minorTickPositions = minorTickPositions.concat(
							axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
						);
					}
				} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
					minorTickPositions = minorTickPositions.concat(
						axis.getTimeTicks(
							axis.normalizeTimeTickInterval(minorTickInterval),
							min,
							max,
							options.startOfWeek
						)
					);
				} else {
					for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
						minorTickPositions.push(pos);
					}
				}
			}

			axis.trimTicks(minorTickPositions); // #3652 #3743
			return minorTickPositions;
		},

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is
		 * not yet processed, so we don't have information on data cropping and grouping, or
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		adjustForMinRange: function () {
			var axis = this,
				options = axis.options,
				min = axis.min,
				max = axis.max,
				zoomOffset,
				spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;

			// Set the automatic minimum range based on the closest point distance
			if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

				if (defined(options.min) || defined(options.max)) {
					axis.minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
				}
			}

			// if minRange is exceeded, adjust
			if (max - min < axis.minRange) {
				var minRange = axis.minRange;
				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = axis.dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = axis.dataMax;
				}

				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}

			// Record modified extremes
			axis.min = min;
			axis.max = max;
		},

		/**
		 * Update translation information
		 */
		setAxisTranslation: function (saveOld) {
			var axis = this,
				range = axis.max - axis.min,
				pointRange = axis.axisPointRange || 0,
				closestPointRange,
				minPointOffset = 0,
				pointRangePadding = 0,
				linkedParent = axis.linkedParent,
				ordinalCorrection,
				hasCategories = !!axis.categories,
				transA = axis.transA,
				isXAxis = axis.isXAxis;

			// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
			if (isXAxis || hasCategories || pointRange) {
				if (linkedParent) {
					minPointOffset = linkedParent.minPointOffset;
					pointRangePadding = linkedParent.pointRangePadding;

				} else {
					each(axis.series, function (series) {
						var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
							pointPlacement = series.options.pointPlacement,
							seriesClosestPointRange = series.closestPointRange;

						if (seriesPointRange > range) { // #1446
							seriesPointRange = 0;
						}
						pointRange = mathMax(pointRange, seriesPointRange);

						if (!axis.single) {
							// minPointOffset is the value padding to the left of the axis in order to make
							// room for points with a pointRange, typically columns. When the pointPlacement option
							// is 'between' or 'on', this padding does not apply.
							minPointOffset = mathMax(
								minPointOffset,
								isString(pointPlacement) ? 0 : seriesPointRange / 2
							);

							// Determine the total padding needed to the length of the axis to make room for the
							// pointRange. If the series' pointPlacement is 'on', no padding is added.
							pointRangePadding = mathMax(
								pointRangePadding,
								pointPlacement === 'on' ? 0 : seriesPointRange
							);
						}

						// Set the closestPointRange
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}

				// Record minPointOffset and pointRangePadding
				ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
				axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
				axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = mathMin(pointRange, range);

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				if (isXAxis) {
					axis.closestPointRange = closestPointRange;
				}
			}

			// Secondary values
			if (saveOld) {
				axis.oldTransA = transA;
			}
			axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
			axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
			axis.minPixelPadding = transA * minPointOffset;
		},

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		setTickInterval: function (secondPass) {
			var axis = this,
				chart = axis.chart,
				options = axis.options,
				isLog = axis.isLog,
				isDatetimeAxis = axis.isDatetimeAxis,
				isXAxis = axis.isXAxis,
				isLinked = axis.isLinked,
				maxPadding = options.maxPadding,
				minPadding = options.minPadding,
				length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				minTickInterval,
				tickPixelIntervalOption = options.tickPixelInterval,
				categories = axis.categories;

			if (!isDatetimeAxis && !categories && !isLinked) {
				this.getTickAmount();
			}

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				axis.linkedParent = chart[axis.coll][options.linkedTo];
				linkedParentExtremes = axis.linkedParent.getExtremes();
				axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== axis.linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				axis.min = pick(axis.userMin, options.min, axis.dataMin);
				axis.max = pick(axis.userMax, options.max, axis.dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
					error(10, 1); // Can't plot negative values on log axis
				}
				// The correctFloat cures #934, float errors on full tens. But it
				// was too aggressive for #4360 because of conversion back to lin,
				// therefore use precision 15.
				axis.min = correctFloat(log2lin(axis.min), 15);
				axis.max = correctFloat(log2lin(axis.max), 15);
			}

			// handle zoomed range
			if (axis.range && defined(axis.max)) {
				axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
				axis.userMax = axis.max;

				axis.range = null;  // don't use it when running setExtremes
			}

			// Hook for adjusting this.min and this.max. Used by bubble series.
			if (axis.beforePadding) {
				axis.beforePadding();
			}

			// adjust min and max for the minimum range
			axis.adjustForMinRange();

			// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
			// into account, we do this after computing tick interval (#1337).
			if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
				length = axis.max - axis.min;
				if (length) {
					if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
						axis.min -= length * minPadding;
					}
					if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
						axis.max += length * maxPadding;
					}
				}
			}

			// Stay within floor and ceiling
			if (isNumber(options.floor)) {
				axis.min = mathMax(axis.min, options.floor);
			}
			if (isNumber(options.ceiling)) {
				axis.max = mathMin(axis.max, options.ceiling);
			}

			// get tickInterval
			if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
				axis.tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
				axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
			} else {
				axis.tickInterval = pick(
					tickIntervalOption,
					this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						// don't let it be more than the data range
						(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes.
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
				});
			}

			// set the translation factor used in translate function
			axis.setAxisTranslation(true);

			// hook for ordinal axes and radial axes
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}

			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
			}

			// In column-like charts, don't cramp in more ticks than there are points (#1943)
			if (axis.pointRange) {
				axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
			}

			// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
			minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
			if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
				axis.tickInterval = minTickInterval;
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
				axis.tickInterval = normalizeTickInterval(
					axis.tickInterval, 
					null, 
					getMagnitude(axis.tickInterval), 
					// If the tick interval is between 0.5 and 5 and the axis max is in the order of
					// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
					pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
					!!this.tickAmount
				);
			}
			
			// Prevent ticks from getting so close that we can't draw the labels
			if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
				axis.tickInterval = axis.unsquish();
			}

			this.setTickPositions();
		},

		/**
		 * Now we have computed the normalized tickInterval, get the tick positions
		 */
		setTickPositions: function () {

			var options = this.options,
				tickPositions,
				tickPositionsOption = options.tickPositions,
				tickPositioner = options.tickPositioner,
				startOnTick = options.startOnTick,
				endOnTick = options.endOnTick,
				single;

			// Set the tickmarkOffset
			this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
				this.tickInterval === 1) ? 0.5 : 0; // #3202


			// get minorTickInterval
			this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
				this.tickInterval / 5 : options.minorTickInterval;

			// Find the tick positions
			this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
			if (!tickPositions) {

				if (this.isDatetimeAxis) {
					tickPositions = this.getTimeTicks(
						this.normalizeTimeTickInterval(this.tickInterval, options.units),
						this.min,
						this.max,
						options.startOfWeek,
						this.ordinalPositions,
						this.closestPointRange,
						true
					);
				} else if (this.isLog) {
					tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
				} else {
					tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
				}

				this.tickPositions = tickPositions;

				// Run the tick positioner callback, that allows modifying auto tick positions.
				if (tickPositioner) {
					tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
					if (tickPositioner) {
						this.tickPositions = tickPositions = tickPositioner;
					}
				}

			}

			if (!this.isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				this.trimTicks(tickPositions, startOnTick, endOnTick);

				// When there is only one point, or all points have the same value on this axis, then min
				// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
				// in order to center the point, but leave it with one tick. #1337.
				if (this.min === this.max && defined(this.min) && !this.tickAmount) {
					// Substract half a unit (#2619, #2846, #2515, #3390)
					single = true;
					this.min -= 0.5;
					this.max += 0.5;
				}
				this.single = single;

				if (!tickPositionsOption && !tickPositioner) {
					this.adjustTickAmount();
				}
			}
		},

		/**
		 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
		 */
		trimTicks: function (tickPositions, startOnTick, endOnTick) {
			var roundedMin = tickPositions[0],
				roundedMax = tickPositions[tickPositions.length - 1],
				minPointOffset = this.minPointOffset || 0;
				
			if (startOnTick) {
				this.min = roundedMin;
			} else if (this.min - minPointOffset > roundedMin) {
				tickPositions.shift();
			}

			if (endOnTick) {
				this.max = roundedMax;
			} else if (this.max + minPointOffset < roundedMax) {
				tickPositions.pop();
			}

			// If no tick are left, set one tick in the middle (#3195) 
			if (tickPositions.length === 0 && defined(roundedMin)) {
				tickPositions.push((roundedMax + roundedMin) / 2);
			}		
		},

		/**
		 * Set the max ticks of either the x and y axis collection
		 */
		getTickAmount: function () {
			var others = {}, // Whether there is another axis to pair with this one
				hasOther,
				options = this.options,
				tickAmount = options.tickAmount,
				tickPixelInterval = options.tickPixelInterval;

			if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
					!this.isLog && options.startOnTick && options.endOnTick) {
				tickAmount = 2;
			}

			if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
				// Check if there are multiple axes in the same pane
				each(this.chart[this.coll], function (axis) {
					var options = axis.options,
						horiz = axis.horiz,
						key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
					
					if (others[key]) {
						if (axis.series.length) {
							hasOther = true; // #4201
						}
					} else {
						others[key] = 1;
					}
				});

				if (hasOther) {
					// Add 1 because 4 tick intervals require 5 ticks (including first and last)
					tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
				}
			}

			// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
			// prevents the axis from adding ticks that are too far away from the data extremes.
			if (tickAmount < 4) {
				this.finalTickAmt = tickAmount;
				tickAmount = 5;
			}
			
			this.tickAmount = tickAmount;
		},

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		adjustTickAmount: function () {
			var tickInterval = this.tickInterval,
				tickPositions = this.tickPositions,
				tickAmount = this.tickAmount,
				finalTickAmt = this.finalTickAmt,
				currentTickAmount = tickPositions && tickPositions.length,
				i,
				len;

			if (currentTickAmount < tickAmount) { // TODO: Check #3411
				while (tickPositions.length < tickAmount) {
					tickPositions.push(correctFloat(
						tickPositions[tickPositions.length - 1] + tickInterval
					));
				}
				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
				this.max = tickPositions[tickPositions.length - 1];

			// We have too many ticks, run second pass to try to reduce ticks
			} else if (currentTickAmount > tickAmount) {
				this.tickInterval *= 2;
				this.setTickPositions();
			}

			// The finalTickAmt property is set in getTickAmount
			if (defined(finalTickAmt)) {
				i = len = tickPositions.length;
				while (i--) {
					if (
						(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
						(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
					) {
						tickPositions.splice(i, 1);
					}	
				}
				this.finalTickAmt = UNDEFINED;
			}
		},

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		setScale: function () {
			var axis = this,
				isDirtyData,
				isDirtyAxisLength;

			axis.oldMin = axis.min;
			axis.oldMax = axis.max;
			axis.oldAxisLength = axis.len;

			// set the new axisLength
			axis.setAxisSize();
			//axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axis.len !== axis.oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
				axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

				if (axis.resetStacks) {
					axis.resetStacks();
				}

				axis.forceRedraw = false;

				// get data extremes if needed
				axis.getSeriesExtremes();

				// get fixed positions based on tickInterval
				axis.setTickInterval();

				// record old values to decide whether a rescale is necessary later on (#540)
				axis.oldUserMin = axis.userMin;
				axis.oldUserMax = axis.userMax;

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
				}
			} else if (axis.cleanStacks) {
				axis.cleanStacks();
			}
		},

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments
		 *
		 */
		setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
			var axis = this,
				chart = axis.chart;

			redraw = pick(redraw, true); // defaults to true

			each(axis.series, function (serie) {
				delete serie.kdTree;
			});

			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				axis.userMin = newMin;
				axis.userMax = newMax;
				axis.eventArgs = eventArguments;

				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;

				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		},

		/**
		 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
		 * in stock charts.
		 */
		zoom: function (newMin, newMax) {
			var dataMin = this.dataMin,
				dataMax = this.dataMax,
				options = this.options;

			// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
			if (!this.allowZoomOutside) {
				if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
					newMin = UNDEFINED;
				}
				if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
					newMax = UNDEFINED;
				}
			}

			// In full view, displaying the reset zoom button is not required
			this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

			// Do it
			this.setExtremes(
				newMin,
				newMax,
				false,
				UNDEFINED,
				{ trigger: 'zoom' }
			);
			return true;
		},

		/**
		 * Update the axis metrics
		 */
		setAxisSize: function () {
			var chart = this.chart,
				options = this.options,
				offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0,
				horiz = this.horiz,
				width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
				height = pick(options.height, chart.plotHeight),
				top = pick(options.top, chart.plotTop),
				left = pick(options.left, chart.plotLeft + offsetLeft),
				percentRegex = /%$/;

			// Check for percentage based input values
			if (percentRegex.test(height)) {
				height = parseFloat(height) / 100 * chart.plotHeight;
			}
			if (percentRegex.test(top)) {
				top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
			}

			// Expose basic values to use in Series object and navigator
			this.left = left;
			this.top = top;
			this.width = width;
			this.height = height;
			this.bottom = chart.chartHeight - height - top;
			this.right = chart.chartWidth - width - left;

			// Direction agnostic properties
			this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
			this.pos = horiz ? left : top; // distance from SVG origin
		},

		/**
		 * Get the actual axis extremes
		 */
		getExtremes: function () {
			var axis = this,
				isLog = axis.isLog;

			return {
				min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
				max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
				dataMin: axis.dataMin,
				dataMax: axis.dataMax,
				userMin: axis.userMin,
				userMax: axis.userMax
			};
		},

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		getThreshold: function (threshold) {
			var axis = this,
				isLog = axis.isLog,
				realMin = isLog ? lin2log(axis.min) : axis.min,
				realMax = isLog ? lin2log(axis.max) : axis.max;

			// With a threshold of null, make the columns/areas rise from the top or bottom 
			// depending on the value, assuming an actual threshold of 0 (#4233).
			if (threshold === null) {
				threshold = realMax < 0 ? realMax : realMin;
			} else if (realMin > threshold) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return axis.translate(threshold, 0, 1, 0, 1);
		},

		/**
		 * Compute auto alignment for the axis label based on which side the axis is on
		 * and the given rotation for the label
		 */
		autoLabelAlign: function (rotation) {
			var ret,
				angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

			if (angle > 15 && angle < 165) {
				ret = 'right';
			} else if (angle > 195 && angle < 345) {
				ret = 'left';
			} else {
				ret = 'center';
			}
			return ret;
		},

		/**
		 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
		 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
		 * On a vertical axis remove ticks and add ellipsis.
		 */
		unsquish: function () {
			var chart = this.chart,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				tickInterval = this.tickInterval,
				newTickInterval = tickInterval,
				slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
				rotation,
				rotationOption = labelOptions.rotation,
				labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				step,
				bestScore = Number.MAX_VALUE,
				autoRotation,
				// Return the multiple of tickInterval that is needed to avoid collision
				getStep = function (spaceNeeded) {
					var step = spaceNeeded / (slotSize || 1);
					step = step > 1 ? mathCeil(step) : 1;
					return step * tickInterval;
				};
			
			if (horiz) {
				autoRotation = defined(rotationOption) ? 
					[rotationOption] :
					slotSize < pick(labelOptions.autoRotationLimit, 80) && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

				if (autoRotation) {

					// Loop over the given autoRotation options, and determine which gives the best score. The 
					// best score is that with the lowest number of steps and a rotation closest to horizontal.
					each(autoRotation, function (rot) {
						var score;

						if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
						
							step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

							score = step + mathAbs(rot / 360);

							if (score < bestScore) {
								bestScore = score;
								rotation = rot;
								newTickInterval = step;
							}
						}
					});
				}

			} else {
				newTickInterval = getStep(labelMetrics.h);
			}

			this.autoRotation = autoRotation;
			this.labelRotation = rotation;

			return newTickInterval;
		},

		renderUnsquish: function () {
			var chart = this.chart,
				renderer = chart.renderer,
				tickPositions = this.tickPositions,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				margin = chart.margin,
				slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,
				slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
					((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
					(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
				innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
				attr = {},
				labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				textOverflowOption = labelOptions.style.textOverflow,
				css,
				labelLength = 0,
				label,
				i,
				pos;

			// Set rotation option unless it is "auto", like in gauges
			if (!isString(labelOptions.rotation)) {
				attr.rotation = labelOptions.rotation;
			}
			
			// Handle auto rotation on horizontal axis
			if (this.autoRotation) {

				// Get the longest label length
				each(tickPositions, function (tick) {
					tick = ticks[tick];
					if (tick && tick.labelLength > labelLength) {
						labelLength = tick.labelLength;
					}
				});
				
				// Apply rotation only if the label is too wide for the slot, and
				// the label is wider than its height.
				if (labelLength > innerWidth && labelLength > labelMetrics.h) {
					attr.rotation = this.labelRotation;
				} else {
					this.labelRotation = 0;
				}

			// Handle word-wrap or ellipsis on vertical axis
			} else if (slotWidth) {
				// For word-wrap or ellipsis
				css = { width: innerWidth + PX };

				if (!textOverflowOption) {
					css.textOverflow = 'clip';

					// On vertical axis, only allow word wrap if there is room for more lines.
					i = tickPositions.length;
					while (!horiz && i--) {
						pos = tickPositions[i];
						label = ticks[pos].label;
						if (label) {
							// Reset ellipsis in order to get the correct bounding box (#4070)
							if (label.styles.textOverflow === 'ellipsis') {
								label.css({ textOverflow: 'clip' });
							}
							if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
								label.specCss = { textOverflow: 'ellipsis' };
							}
						}
					}
				}
			}


			// Add ellipsis if the label length is significantly longer than ideal
			if (attr.rotation) {
				css = { 
					width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
				};
				if (!textOverflowOption) {
					css.textOverflow = 'ellipsis';
				}
			}

			// Set the explicit or automatic label alignment
			this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

			// Apply general and specific CSS
			each(tickPositions, function (pos) {
				var tick = ticks[pos],
					label = tick && tick.label;
				if (label) {
					if (css) {
						label.css(merge(css, label.specCss));
					}
					delete label.specCss;
					label.attr(attr);
					tick.rotation = attr.rotation;
				}
			});

			// TODO: Why not part of getLabelPosition?
			this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
		},

		/**
		 * Return true if the axis has associated data
		 */
		hasData: function () {
			return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
		},

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		getOffset: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				tickPositions = axis.tickPositions,
				ticks = axis.ticks,
				horiz = axis.horiz,
				side = axis.side,
				invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
				hasData,
				showAxis,
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				labelOffset = 0, // reset
				labelOffsetPadded,
				axisOffset = chart.axisOffset,
				clipOffset = chart.clipOffset,
				clip,
				directionFactor = [-1, 1, 1, -1][side],
				n,
				lineHeightCorrection;

			// For reuse in Axis.render
			hasData = axis.hasData();
			axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

			// Set/reset staggerLines
			axis.staggerLines = axis.horiz && labelOptions.staggerLines;

			// Create the axisGroup and gridGroup elements on first iteration
			if (!axis.axisGroup) {
				axis.gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
				axis.axisGroup = renderer.g('axis')
					.attr({ zIndex: options.zIndex || 2 })
					.add();
				axis.labelGroup = renderer.g('axis-labels')
					.attr({ zIndex: labelOptions.zIndex || 7 })
					.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
					.add();
			}

			if (hasData || axis.isLinked) {
				
				// Generate ticks
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(axis, pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}
				});

				axis.renderUnsquish();

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}
				});

				if (axis.staggerLines) {
					labelOffset *= axis.staggerLines;
					axis.labelOffset = labelOffset;
				}


			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
				if (!axis.axisTitle) {
					axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.addClass(PREFIX + this.coll.toLowerCase() + '-title')
					.css(axisTitleOptions.style)
					.add(axis.axisGroup);
					axis.axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleOffsetOption = axisTitleOptions.offset;
					titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
				}

				// hide or show the title depending on whether showEmpty is set
				axis.axisTitle[showAxis ? 'show' : 'hide']();
			}

			// handle automatic or user set offset
			axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

			axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
			lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
			labelOffsetPadded = labelOffset + titleMargin +
				(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
			axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
				labelOffsetPadded // #3027
			);

			// Decide the clipping needed to keep the graph inside the plot area and axis lines
			clip = mathFloor(options.lineWidth / 2) * 2;
			if (options.offset) {
				clip = mathMax(0, clip - options.offset);		
			}
			clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
		},

		/**
		 * Get the path for the axis line
		 */
		getLinePath: function (lineWidth) {
			var chart = this.chart,
				opposite = this.opposite,
				offset = this.offset,
				horiz = this.horiz,
				lineLeft = this.left + (opposite ? this.width : 0) + offset,
				lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

			if (opposite) {
				lineWidth *= -1; // crispify the other way - #1480, #1687
			}

			return chart.renderer.crispLine([
					M,
					horiz ?
						this.left :
						lineLeft,
					horiz ?
						lineTop :
						this.top,
					L,
					horiz ?
						chart.chartWidth - this.right :
						lineLeft,
					horiz ?
						lineTop :
						chart.chartHeight - this.bottom
				], lineWidth);
		},

		/**
		 * Position the title
		 */
		getTitlePosition: function () {
			// compute anchor points for each of the title align options
			var horiz = this.horiz,
				axisLeft = this.left,
				axisTop = this.top,
				axisLength = this.len,
				axisTitleOptions = this.options.title,
				margin = horiz ? axisLeft : axisTop,
				opposite = this.opposite,
				offset = this.offset,
				xOption = axisTitleOptions.x || 0,
				yOption = axisTitleOptions.y || 0,
				fontSize = pInt(axisTitleOptions.style.fontSize || 12),

				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + this.height : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					this.axisTitleMargin +
					(this.side === 2 ? fontSize : 0);

			return {
				x: horiz ?
					alongAxis + xOption :
					offAxis + (opposite ? this.width : 0) + offset + xOption,
				y: horiz ?
					offAxis + yOption - (opposite ? this.height : 0) + offset :
					alongAxis + yOption
			};
		},

		/**
		 * Render the axis
		 */
		render: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				isLog = axis.isLog,
				isLinked = axis.isLinked,
				tickPositions = axis.tickPositions,
				axisTitle = axis.axisTitle,			
				ticks = axis.ticks,
				minorTicks = axis.minorTicks,
				alternateBands = axis.alternateBands,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				tickmarkOffset = axis.tickmarkOffset,
				lineWidth = options.lineWidth,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
				showAxis = axis.showAxis,
				from,
				to;

			// Reset
			axis.labelEdge.length = 0;
			//axis.justifyToPlot = overflow === 'justify';
			axis.overlap = false;

			// Mark all elements inActive before we go over and mark the active ones
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					coll[pos].isActive = false;
				}
			});

			// If the series has data draw the ticks. Else only the line and title
			if (axis.hasData() || isLinked) {

				// minor ticks
				if (axis.minorTickInterval && !axis.categories) {
					each(axis.getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(axis, pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}

						minorTicks[pos].render(null, false, 1);
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				if (tickPositions.length) { // #1300
					each(tickPositions, function (pos, i) {

						// linked axes need an extra check to find out if
						if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

							if (!ticks[pos]) {
								ticks[pos] = new Tick(axis, pos);
							}

							// render new ticks in old position
							if (slideInTicks && ticks[pos].isNew) {
								ticks[pos].render(i, true, 0.1);
							}

							ticks[pos].render(i);
						}

					});
					// In a categorized axis, the tick marks are displayed between labels. So
					// we need to add a tick mark and grid line at the left edge of the X axis.
					if (tickmarkOffset && (axis.min === 0 || axis.single)) {
						if (!ticks[-1]) {
							ticks[-1] = new Tick(axis, -1, null, true);
						}
						ticks[-1].render(-1);
					}

				}

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < axis.max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
							}
							from = pos + tickmarkOffset; // #949
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						axis.addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}

			} // end if hasData

			// Remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos,
					i,
					forDestruction = [],
					delay = globalAnimation ? globalAnimation.duration || 500 : 0,
					destroyInactiveItems = function () {
						i = forDestruction.length;
						while (i--) {
							// When resizing rapidly, the same items may be destroyed in different timeouts,
							// or the may be reactivated
							if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
								coll[forDestruction[i]].destroy();
								delete coll[forDestruction[i]];
							}
						}

					};

				for (pos in coll) {

					if (!coll[pos].isActive) {
						// Render to zero opacity
						coll[pos].render(pos, false, 0);
						coll[pos].isActive = false;
						forDestruction.push(pos);
					}
				}

				// When the objects are finished fading out, destroy them
				if (coll === alternateBands || !chart.hasRendered || !delay) {
					destroyInactiveItems();
				} else if (delay) {
					setTimeout(destroyInactiveItems, delay);
				}
			});

			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				linePath = axis.getLinePath(lineWidth);
				if (!axis.axisLine) {
					axis.axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add(axis.axisGroup);
				} else {
					axis.axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axis.axisLine[showAxis ? 'show' : 'hide']();
			}

			if (axisTitle && showAxis) {

				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
					axis.getTitlePosition()
				);
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				axis.renderStackTotals();
			}
			// End stacked totals

			axis.isDirty = false;
		},

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		redraw: function () {
			
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(this.series, function (series) {
				series.isDirty = true;
			});

		},

		/**
		 * Destroys an Axis instance.
		 */
		destroy: function (keepEvents) {
			var axis = this,
				stacks = axis.stacks,
				stackKey,
				plotLinesAndBands = axis.plotLinesAndBands,
				i;

			// Remove the events
			if (!keepEvents) {
				removeEvent(axis);
			}

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy collections
			each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
				destroyObjectProperties(coll);
			});
			i = plotLinesAndBands.length;
			while (i--) { // #1975
				plotLinesAndBands[i].destroy();
			}

			// Destroy local variables
			each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
				if (axis[prop]) {
					axis[prop] = axis[prop].destroy();
				}
			});

			// Destroy crosshair
			if (this.cross) {
				this.cross.destroy();
			}
		},

		/**
		 * Draw the crosshair
		 */
		drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

			var path,
				options = this.crosshair,
				animation = options.animation,
				pos,
				attribs,
				categorized;
			
			if (
				// Disabled in options
				!this.crosshair || 
				// Snap
				((defined(point) || !pick(this.crosshair.snap, true)) === false) || 
				// Not on this axis (#4095, #2888)
				(point && point.series && point.series[this.coll] !== this)
			) {
				this.hideCrosshair();
			
			} else {			

				// Get the path
				if (!pick(options.snap, true)) {
					pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
				} else if (defined(point)) {
					/*jslint eqeq: true*/
					pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
					/*jslint eqeq: false*/
				}

				if (this.isRadial) {
					path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
				} else {
					path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
				}

				if (path === null) {
					this.hideCrosshair();
					return;
				}

				// Draw the cross
				if (this.cross) {
					this.cross
						.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
				} else {
					categorized = this.categories && !this.isRadial;
					attribs = {
						'stroke-width': options.width || (categorized ? this.transA : 1),
						stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
						zIndex: options.zIndex || 2
					};
					if (options.dashStyle) {
						attribs.dashstyle = options.dashStyle;
					}
					this.cross = this.chart.renderer.path(path).attr(attribs).add();
				}

			}

		},

		/**
		 *	Hide the crosshair.
		 */
		hideCrosshair: function () {
			if (this.cross) {
				this.cross.hide();
			}
		}
	}; // end Axis

	extend(Axis.prototype, AxisPlotLineOrBandExtension);

	/**
	 * Set the tick positions to a time unit that makes sense, for example
	 * on the first of each month or on every Monday. Return an array
	 * with the time positions. Used in datetime axes as well as for grouping
	 * data on a datetime axis.
	 *
	 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	 * @param {Number} min The minimum in axis values
	 * @param {Number} max The maximum in axis values
	 * @param {Number} startOfWeek
	 */
	Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
		var tickPositions = [],
			i,
			higherRanks = {},
			useUTC = defaultOptions.global.useUTC,
			minYear, // used in months and years as a basis for Date.UTC()
			minDate = new Date(min - getTZOffset(min)),
			interval = normalizedInterval.unitRange,
			count = normalizedInterval.count;

		if (defined(min)) { // #1300
			minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
				count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

			if (interval >= timeUnits.second) { // second
				minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
					count * mathFloor(minDate.getSeconds() / count));
			}
		
			if (interval >= timeUnits.minute) { // minute
				minDate[setMinutes](interval >= timeUnits.hour ? 0 :
					count * mathFloor(minDate[getMinutes]() / count));
			}
		
			if (interval >= timeUnits.hour) { // hour
				minDate[setHours](interval >= timeUnits.day ? 0 :
					count * mathFloor(minDate[getHours]() / count));
			}
		
			if (interval >= timeUnits.day) { // day
				minDate[setDate](interval >= timeUnits.month ? 1 :
					count * mathFloor(minDate[getDate]() / count));
			}
		
			if (interval >= timeUnits.month) { // month
				minDate[setMonth](interval >= timeUnits.year ? 0 :
					count * mathFloor(minDate[getMonth]() / count));
				minYear = minDate[getFullYear]();
			}
		
			if (interval >= timeUnits.year) { // year
				minYear -= minYear % count;
				minDate[setFullYear](minYear);
			}
		
			// week is a special case that runs outside the hierarchy
			if (interval === timeUnits.week) {
				// get start of current week, independent of count
				minDate[setDate](minDate[getDate]() - minDate[getDay]() +
					pick(startOfWeek, 1));
			}
		
		
			// get tick positions
			i = 1;
			if (timezoneOffset || getTimezoneOffset) {
				minDate = minDate.getTime();
				minDate = new Date(minDate + getTZOffset(minDate));
			}
			minYear = minDate[getFullYear]();
			var time = minDate.getTime(),
				minMonth = minDate[getMonth](),
				minDateDate = minDate[getDate](),
				localTimezoneOffset = (timeUnits.day + 
						(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
					) % timeUnits.day; // #950, #3359
		
			// iterate and add tick positions at appropriate values
			while (time < max) {
				tickPositions.push(time);
		
				// if the interval is years, use Date.UTC to increase years
				if (interval === timeUnits.year) {
					time = makeTime(minYear + i * count, 0);
		
				// if the interval is months, use Date.UTC to increase months
				} else if (interval === timeUnits.month) {
					time = makeTime(minYear, minMonth + i * count);
		
				// if we're using global time, the interval is not fixed as it jumps
				// one hour at the DST crossover
				} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
					time = makeTime(minYear, minMonth, minDateDate +
						i * count * (interval === timeUnits.day ? 1 : 7));
		
				// else, the interval is fixed and we use simple addition
				} else {
					time += interval * count;
				}
		
				i++;
			}
		
			// push the last time
			tickPositions.push(time);


			// mark new days if the time is dividible by day (#1649, #1760)
			each(grep(tickPositions, function (time) {
				return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
			}), function (time) {
				higherRanks[time] = 'day';
			});
		}


		// record information on the chosen unit - for dynamic label formatter
		tickPositions.info = extend(normalizedInterval, {
			higherRanks: higherRanks,
			totalRange: interval * count
		});

		return tickPositions;
	};

	/**
	 * Get a normalized tick interval for dates. Returns a configuration object with
	 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
	 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	 * of segments in stock charts, the normalizing logic was extracted in order to 
	 * prevent it for running over again for each segment having the same interval. 
	 * #662, #697.
	 */
	Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
		var units = unitsOption || [[
					'millisecond', // unit name
					[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
				], [
					'second',
					[1, 2, 5, 10, 15, 30]
				], [
					'minute',
					[1, 2, 5, 10, 15, 30]
				], [
					'hour',
					[1, 2, 3, 4, 6, 8, 12]
				], [
					'day',
					[1, 2]
				], [
					'week',
					[1, 2]
				], [
					'month',
					[1, 2, 3, 4, 6]
				], [
					'year',
					null
				]],
			unit = units[units.length - 1], // default unit is years
			interval = timeUnits[unit[0]],
			multiples = unit[1],
			count,
			i;
			
		// loop through the units to find the one that best fits the tickInterval
		for (i = 0; i < units.length; i++) {
			unit = units[i];
			interval = timeUnits[unit[0]];
			multiples = unit[1];


			if (units[i + 1]) {
				// lessThan is in the middle between the highest multiple and the next unit.
				var lessThan = (interval * multiples[multiples.length - 1] +
							timeUnits[units[i + 1][0]]) / 2;

				// break and keep the current unit
				if (tickInterval <= lessThan) {
					break;
				}
			}
		}

		// prevent 2.5 years intervals, though 25, 250 etc. are allowed
		if (interval === timeUnits.year && tickInterval < 5 * interval) {
			multiples = [1, 2, 5];
		}

		// get the count
		count = normalizeTickInterval(
			tickInterval / interval, 
			multiples,
			unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
		);
		
		return {
			unitRange: interval,
			count: count,
			unitName: unit[0]
		};
	};/**
	 * Methods defined on the Axis prototype
	 */

	/**
	 * Set the tick positions of a logarithmic axis
	 */
	Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
		var axis = this,
			options = axis.options,
			axisLength = axis.len,
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			positions = []; 
		
		// Reset
		if (!minor) {
			axis._minorAutoInterval = null;
		}
		
		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		if (interval >= 0.5) {
			interval = mathRound(interval);
			positions = axis.getLinearTickPositions(interval, min, max);
			
		// Second case: We need intermediary ticks. For example 
		// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
		} else if (interval >= 0.08) {
			var roundedMin = mathFloor(min),
				intermediate,
				i,
				j,
				len,
				pos,
				lastPos,
				break2;
				
			if (interval > 0.3) {
				intermediate = [1, 2, 4];
			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 4, 6, 8];
			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			}
			
			for (i = roundedMin; i < max + 1 && !break2; i++) {
				len = intermediate.length;
				for (j = 0; j < len && !break2; j++) {
					pos = log2lin(lin2log(i) * intermediate[j]);
					if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
						positions.push(lastPos);
					}
					
					if (lastPos > max) {
						break2 = true;
					}
					lastPos = pos;
				}
			}
			
		// Third case: We are so deep in between whole logarithmic values that
		// we might as well handle the tick positions like a linear axis. For
		// example 1.01, 1.02, 1.03, 1.04.
		} else {
			var realMin = lin2log(min),
				realMax = lin2log(max),
				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
			
			interval = pick(
				filteredTickIntervalOption,
				axis._minorAutoInterval,
				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
			);
			
			interval = normalizeTickInterval(
				interval, 
				null, 
				getMagnitude(interval)
			);
			
			positions = map(axis.getLinearTickPositions(
				interval, 
				realMin,
				realMax	
			), log2lin);
			
			if (!minor) {
				axis._minorAutoInterval = interval / 5;
			}
		}
		
		// Set the axis-level tickInterval variable 
		if (!minor) {
			axis.tickInterval = interval;
		}
		return positions;
	};/**
	 * The tooltip object
	 * @param {Object} chart The chart instance
	 * @param {Object} options Tooltip options
	 */
	var Tooltip = Highcharts.Tooltip = function () {
		this.init.apply(this, arguments);
	};

	Tooltip.prototype = {

		init: function (chart, options) {

			var borderWidth = options.borderWidth,
				style = options.style,
				padding = pInt(style.padding);

			// Save the chart and options
			this.chart = chart;
			this.options = options;

			// Keep track of the current series
			//this.currentSeries = UNDEFINED;

			// List of crosshairs
			this.crosshairs = [];

			// Current values of x and y when animating
			this.now = { x: 0, y: 0 };

			// The tooltip is initially hidden
			this.isHidden = true;


			// create the label		
			this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
				.attr({
					padding: padding,
					fill: options.backgroundColor,
					'stroke-width': borderWidth,
					r: options.borderRadius,
					zIndex: 8
				})
				.css(style)
				.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
				.add()
				.attr({ y: -9999 }); // #2301, #2657

			// When using canVG the shadow shows up as a gray circle
			// even if the tooltip is hidden.
			if (!useCanVG) {
				this.label.shadow(options.shadow);
			}

			// Public property for getting the shared state.
			this.shared = options.shared;
		},

		/**
		 * Destroy the tooltip and its elements.
		 */
		destroy: function () {
			// Destroy and clear local variables
			if (this.label) {
				this.label = this.label.destroy();
			}
			clearTimeout(this.hideTimer);
			clearTimeout(this.tooltipTimeout);
		},

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @private
		 */
		move: function (x, y, anchorX, anchorY) {
			var tooltip = this,
				now = tooltip.now,
				animate = tooltip.options.animation !== false && !tooltip.isHidden && 
					// When we get close to the target position, abort animation and land on the right place (#3056)
					(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
				skipAnchor = tooltip.followPointer || tooltip.len > 1;

			// Get intermediate values for animation
			extend(now, {
				x: animate ? (2 * now.x + x) / 3 : x,
				y: animate ? (now.y + y) / 2 : y,
				anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
				anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
			});

			// Move to the intermediate value
			tooltip.label.attr(now);

			
			// Run on next tick of the mouse tracker
			if (animate) {
			
				// Never allow two timeouts
				clearTimeout(this.tooltipTimeout);
				
				// Set the fixed interval ticking for the smooth tooltip
				this.tooltipTimeout = setTimeout(function () {
					// The interval function may still be running during destroy, so check that the chart is really there before calling.
					if (tooltip) {
						tooltip.move(x, y, anchorX, anchorY);
					}
				}, 32);
				
			}
		},

		/**
		 * Hide the tooltip
		 */
		hide: function (delay) {
			var tooltip = this,
				hoverPoints;
			
			clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
			if (!this.isHidden) {
				hoverPoints = this.chart.hoverPoints;

				this.hideTimer = setTimeout(function () {
					tooltip.label.fadeOut();
					tooltip.isHidden = true;
				}, pick(delay, this.options.hideDelay, 500));
			}
		},
		
		/** 
		 * Extendable method to get the anchor position of the tooltip
		 * from a point or set of points
		 */
		getAnchor: function (points, mouseEvent) {
			var ret,
				chart = this.chart,
				inverted = chart.inverted,
				plotTop = chart.plotTop,
				plotLeft = chart.plotLeft,
				plotX = 0,
				plotY = 0,
				yAxis,
				xAxis;
			
			points = splat(points);
			
			// Pie uses a special tooltipPos
			ret = points[0].tooltipPos;
			
			// When tooltip follows mouse, relate the position to the mouse
			if (this.followPointer && mouseEvent) {
				if (mouseEvent.chartX === UNDEFINED) {
					mouseEvent = chart.pointer.normalize(mouseEvent);
				}
				ret = [
					mouseEvent.chartX - chart.plotLeft,
					mouseEvent.chartY - plotTop
				];
			}
			// When shared, use the average position
			if (!ret) {
				each(points, function (point) {
					yAxis = point.series.yAxis;
					xAxis = point.series.xAxis;
					plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
					plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
						(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
				});
				
				plotX /= points.length;
				plotY /= points.length;
				
				ret = [
					inverted ? chart.plotWidth - plotY : plotX,
					this.shared && !inverted && points.length > 1 && mouseEvent ? 
						mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
						inverted ? chart.plotHeight - plotX : plotY
				];
			}

			return map(ret, mathRound);
		},
		
		/**
		 * Place the tooltip in a chart without spilling over
		 * and not covering the point it self.
		 */
		getPosition: function (boxWidth, boxHeight, point) {
			
			var chart = this.chart,
				distance = this.distance,
				ret = {},
				h = point.h || 0, // #4117
				swapped,
				first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
				second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
				// The far side is right or bottom
				preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
				/**
				 * Handle the preferred dimension. When the preferred dimension is tooltip
				 * on top or bottom of the point, it will look for space there.
				 */
				firstDimension = function (dim, outerSize, innerSize, point) {
					var roomLeft = innerSize < point - distance,
						roomRight = point + distance + innerSize < outerSize,
						alignedLeft = point - distance - innerSize,
						alignedRight = point + distance;

					if (preferFarSide && roomRight) {
						ret[dim] = alignedRight;
					} else if (!preferFarSide && roomLeft) {
						ret[dim] = alignedLeft;
					} else if (roomLeft) {
						ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;
					} else if (roomRight) {
						ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;
					} else {
						return false;
					}
				},
				/**
				 * Handle the secondary dimension. If the preferred dimension is tooltip
				 * on top or bottom of the point, the second dimension is to align the tooltip
				 * above the point, trying to align center but allowing left or right
				 * align within the chart box.
				 */
				secondDimension = function (dim, outerSize, innerSize, point) {
					// Too close to the edge, return false and swap dimensions
					if (point < distance || point > outerSize - distance) {
						return false;
					
					// Align left/top
					} else if (point < innerSize / 2) {
						ret[dim] = 1;
					// Align right/bottom
					} else if (point > outerSize - innerSize / 2) {
						ret[dim] = outerSize - innerSize - 2;
					// Align center
					} else {
						ret[dim] = point - innerSize / 2;
					}
				},
				/**
				 * Swap the dimensions 
				 */
				swap = function (count) {
					var temp = first;
					first = second;
					second = temp;
					swapped = count;
				},
				run = function () {
					if (firstDimension.apply(0, first) !== false) {
						if (secondDimension.apply(0, second) === false && !swapped) {
							swap(true);
							run();
						}
					} else if (!swapped) {
						swap(true);
						run();
					} else {
						ret.x = ret.y = 0;
					}
				};

			// Under these conditions, prefer the tooltip on the side of the point
			if (chart.inverted || this.len > 1) {
				swap();
			}
			run();

			return ret;
		
		},

		/**
		 * In case no user defined formatter is given, this will be used. Note that the context
		 * here is an object holding point, series, x, y etc.
		 */
		defaultFormatter: function (tooltip) {
			var items = this.points || splat(this),
				s;

			// build the header
			s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

			// build the values
			s = s.concat(tooltip.bodyFormatter(items));

			// footer
			s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

			return s.join('');
		},

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 */
		refresh: function (point, mouseEvent) {
			var tooltip = this,
				chart = tooltip.chart,
				label = tooltip.label,
				options = tooltip.options,
				x,
				y,
				anchor,
				textConfig = {},
				text,
				pointConfig = [],
				formatter = options.formatter || tooltip.defaultFormatter,
				hoverPoints = chart.hoverPoints,
				borderColor,
				shared = tooltip.shared,
				currentSeries;
				
			clearTimeout(this.hideTimer);
			
			// get the reference point coordinates (pie charts use tooltipPos)
			tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
			anchor = tooltip.getAnchor(point, mouseEvent);
			x = anchor[0];
			y = anchor[1];

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				
				// hide previous hoverPoints and set new
				
				chart.hoverPoints = point;
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				each(point, function (item) {
					item.setState(HOVER_STATE);

					pointConfig.push(item.getLabelConfig());
				});

				textConfig = {
					x: point[0].category,
					y: point[0].y
				};
				textConfig.points = pointConfig;
				this.len = pointConfig.length;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig, tooltip);

			// register the current series
			currentSeries = point.series;
			this.distance = pick(currentSeries.tooltipOptions.distance, 16);

			// update the inner HTML
			if (text === false) {
				this.hide();
			} else {

				// show it
				if (tooltip.isHidden) {
					stop(label);
					label.attr('opacity', 1).show();
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});
				tooltip.updatePosition({ 
					plotX: x, 
					plotY: y, 
					negative: point.negative, 
					ttBelow: point.ttBelow, 
					h: anchor[2] || 0
				});
			
				this.isHidden = false;
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + chart.plotLeft,
					y: y + chart.plotTop,
					borderColor: borderColor
				});
		},
		
		/**
		 * Find the new position and perform the move
		 */
		updatePosition: function (point) {
			var chart = this.chart,
				label = this.label, 
				pos = (this.options.positioner || this.getPosition).call(
					this,
					label.width,
					label.height,
					point
				);

			// do the move
			this.move(
				mathRound(pos.x), 
				mathRound(pos.y || 0), // can be undefined (#3977) 
				point.plotX + chart.plotLeft, 
				point.plotY + chart.plotTop
			);
		},

		/** 
		 * Get the best X date format based on the closest point range on the axis.
		 */
		getXDateFormat: function (point, options, xAxis) {
			var xDateFormat,
				dateTimeLabelFormats = options.dateTimeLabelFormats,
				closestPointRange = xAxis && xAxis.closestPointRange,
				n,
				blank = '01-01 00:00:00.000',
				strpos = {
					millisecond: 15,
					second: 12,
					minute: 9,
					hour: 6,
					day: 3
				},
				date,
				lastN = 'millisecond'; // for sub-millisecond data, #4223

			if (closestPointRange) {
				date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
				for (n in timeUnits) {

					// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
					if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
							date.substr(6) === blank.substr(6)) {
						n = 'week';
						break;

					// The first format that is too great for the range
					} else if (timeUnits[n] > closestPointRange) {
						n = lastN;
						break;
					
					// If the point is placed every day at 23:59, we need to show
					// the minutes as well. #2637.
					} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
						break;
					}

					// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
					if (n !== 'week') {
						lastN = n;
					}
				}
				
				if (n) {
					xDateFormat = dateTimeLabelFormats[n];
				}
			} else {
				xDateFormat = dateTimeLabelFormats.day;
			}

			return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
		},

		/**
		 * Format the footer/header of the tooltip
		 * #3397: abstraction to enable formatting of footer and header
		 */
		tooltipFooterHeaderFormatter: function (point, isFooter) {
			var footOrHead = isFooter ? 'footer' : 'header',
				series = point.series,
				tooltipOptions = series.tooltipOptions,
				xDateFormat = tooltipOptions.xDateFormat,
				xAxis = series.xAxis,
				isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
				formatString = tooltipOptions[footOrHead+'Format'];

			// Guess the best date format based on the closest point distance (#568, #3418)
			if (isDateTime && !xDateFormat) {
				xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
			}

			// Insert the footer date format if any
			if (isDateTime && xDateFormat) {
				formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
			}

			return format(formatString, {
				point: point,
				series: series
			});
		},

		/**
	     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	     * abstracting this functionality allows to easily overwrite and extend it. 
		 */
		bodyFormatter: function (items) {
	        return map(items, function (item) {
	            var tooltipOptions = item.series.tooltipOptions;
	            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
	        });
	    }
	    
	};

	var hoverChartIndex;

	// Global flag for touch support
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

	/**
	 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
	 * Subsequent methods should be named differently from what they are doing.
	 * @param {Object} chart The Chart instance
	 * @param {Object} options The root options object
	 */
	var Pointer = Highcharts.Pointer = function (chart, options) {
		this.init(chart, options);
	};

	Pointer.prototype = {
		/**
		 * Initialize Pointer
		 */
		init: function (chart, options) {
			
			var chartOptions = options.chart,
				chartEvents = chartOptions.events,
				zoomType = useCanVG ? '' : chartOptions.zoomType,
				inverted = chart.inverted,
				zoomX,
				zoomY;

			// Store references
			this.options = options;
			this.chart = chart;
			
			// Zoom status
			this.zoomX = zoomX = /x/.test(zoomType);
			this.zoomY = zoomY = /y/.test(zoomType);
			this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
			this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
			this.hasZoom = zoomX || zoomY;

			// Do we need to handle click on a touch device?
			this.runChartClick = chartEvents && !!chartEvents.click;

			this.pinchDown = [];
			this.lastValidTouch = {};

			if (Highcharts.Tooltip && options.tooltip.enabled) {
				chart.tooltip = new Tooltip(chart, options.tooltip);
				this.followTouchMove = pick(options.tooltip.followTouchMove, true);
			}

			this.setDOMEvents();
		}, 

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		normalize: function (e, chartPosition) {
			var chartX,
				chartY,
				ePos;

			// common IE normalizing
			e = e || window.event;

			// Framework specific normalizing (#1165)
			e = washMouseEvent(e);

			// More IE normalizing, needs to go after washMouseEvent
			if (!e.target) {
				e.target = e.srcElement;
			}
			
			// iOS (#2757)
			ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

			// Get mouse position
			if (!chartPosition) {
				this.chartPosition = chartPosition = offset(this.chart.container);
			}

			// chartX and chartY
			if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
				chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
					// for IE10 quirks mode within framesets
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosition.left;
				chartY = ePos.pageY - chartPosition.top;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		},

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A pointer event
		 */
		getCoordinates: function (e) {
			var coordinates = {
					xAxis: [],
					yAxis: []
				};

			each(this.chart.axes, function (axis) {
				coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
				});
			});
			return coordinates;
		},
		
		/**
		 * With line type charts with a single tracker, get the point closest to the mouse.
		 * Run Point.onMouseOver and display tooltip for the point or points.
		 */
		runPointActions: function (e) {

			var pointer = this,
				chart = pointer.chart,
				series = chart.series,
				tooltip = chart.tooltip,
				shared = tooltip ? tooltip.shared : false,
				followPointer,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				distance = chart.chartWidth,
				anchor,
				noSharedTooltip,
				directTouch,
				kdpoints = [],
				kdpoint,
				kdpointT;

			// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
			// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
			if (!shared && !hoverSeries) {
				for (i = 0; i < series.length; i++) {
					if (series[i].directTouch || !series[i].options.stickyTracking) {
						series = [];
					}
				}
			}

			// If it has a hoverPoint and that series requires direct touch (like columns), 
			// use the hoverPoint (#3899). Otherwise, search the k-d tree.
			if (!shared && hoverSeries && hoverSeries.directTouch && hoverPoint) {
				kdpoint = hoverPoint;

			// Handle shared tooltip or cases where a series is not yet hovered
			} else {
				// Find nearest points on all series
				each(series, function (s) {
					// Skip hidden series
					noSharedTooltip = s.noSharedTooltip && shared;
					directTouch = !shared && s.directTouch;
					if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
						kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
						if (kdpointT) {
							kdpoints.push(kdpointT);
						}
					}
				});
				// Find absolute nearest point
				each(kdpoints, function (p) {
					if (p && typeof p.dist === 'number' && p.dist < distance) {
						distance = p.dist;
						kdpoint = p;
					}
				});
			}

			// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
			if (kdpoint && (kdpoint !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
				// Draw tooltip if necessary
				if (shared && !kdpoint.series.noSharedTooltip) {
					i = kdpoints.length;
					while (i--) {
						if (kdpoints[i].clientX !== kdpoint.clientX || kdpoints[i].series.noSharedTooltip) {
							kdpoints.splice(i, 1);
						}
					}
					if (kdpoints.length && tooltip) {
						tooltip.refresh(kdpoints, e);
					}

					// do mouseover on all points except the closest
					each(kdpoints, function (point) {
						if (point !== kdpoint) { 
							point.onMouseOver(e);
						}
					});	
					// #3919, #3985 do mouseover on the closest point last to ensure it is the hoverpoint
					((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint).onMouseOver(e); 
				} else {
					if (tooltip) { 
						tooltip.refresh(kdpoint, e);
					}
					kdpoint.onMouseOver(e); 
				}
				this.prevKDPoint = kdpoint;
			
			// Update positions (regardless of kdpoint or hoverPoint)
			} else {
				followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
				if (tooltip && followPointer && !tooltip.isHidden) {
					anchor = tooltip.getAnchor([{}], e);
					tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
				}
			}

			// Start the event listener to pick up the tooltip 
			if (tooltip && !pointer._onDocumentMouseMove) {
				pointer._onDocumentMouseMove = function (e) {
					if (charts[hoverChartIndex]) {
						charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
					}
				};
				addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
			}
			
			// Crosshair
			each(chart.axes, function (axis) {
				axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
			});	
			

		},



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 * 
		 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
		 */
		reset: function (allowMove, delay) {
			var pointer = this,
				chart = pointer.chart,
				hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint,
				hoverPoints = chart.hoverPoints,
				tooltip = chart.tooltip,
				tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
				
			// Narrow in allowMove
			allowMove = allowMove && tooltip && tooltipPoints;
				
			// Check if the points have moved outside the plot area, #1003		
			if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
				allowMove = false;
			}	
			// Just move the tooltip, #349
			if (allowMove) {
				tooltip.refresh(tooltipPoints);
				if (hoverPoint) { // #2500
					hoverPoint.setState(hoverPoint.state, true);
					each(chart.axes, function (axis) {
						if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
							axis.drawCrosshair(null, hoverPoint);
						}  else {
							axis.hideCrosshair();
						}
					});
					
				}

			// Full reset
			} else {

				if (hoverPoint) {
					hoverPoint.onMouseOut();
				}

				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				if (hoverSeries) {
					hoverSeries.onMouseOut();
				}

				if (tooltip) {
					tooltip.hide(delay);
				}

				if (pointer._onDocumentMouseMove) {
					removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
					pointer._onDocumentMouseMove = null;
				}

				// Remove crosshairs
				each(chart.axes, function (axis) {
					axis.hideCrosshair();
				});
				
				pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;

			}
		},

		/**
		 * Scale series groups to a certain scale and translation
		 */
		scaleGroups: function (attribs, clip) {

			var chart = this.chart,
				seriesAttribs;

			// Scale each series
			each(chart.series, function (series) {
				seriesAttribs = attribs || series.getPlotBox(); // #1701
				if (series.xAxis && series.xAxis.zoomEnabled) {
					series.group.attr(seriesAttribs);
					if (series.markerGroup) {
						series.markerGroup.attr(seriesAttribs);
						series.markerGroup.clip(clip ? chart.clipRect : null);
					}
					if (series.dataLabelsGroup) {
						series.dataLabelsGroup.attr(seriesAttribs);
					}
				}
			});
			
			// Clip
			chart.clipRect.attr(clip || chart.clipBox);
		},

		/**
		 * Start a drag operation
		 */
		dragStart: function (e) {
			var chart = this.chart;

			// Record the start position
			chart.mouseIsDown = e.type;
			chart.cancelClick = false;
			chart.mouseDownX = this.mouseDownX = e.chartX;
			chart.mouseDownY = this.mouseDownY = e.chartY;
		},

		/**
		 * Perform a drag operation in response to a mousemove event while the mouse is down
		 */
		drag: function (e) {

			var chart = this.chart,
				chartOptions = chart.options.chart,
				chartX = e.chartX,
				chartY = e.chartY,
				zoomHor = this.zoomHor,
				zoomVert = this.zoomVert,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				clickedInside,
				size,
				mouseDownX = this.mouseDownX,
				mouseDownY = this.mouseDownY,
				panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

			// If the mouse is outside the plot area, adjust to cooordinates
			// inside to prevent the selection marker from going outside
			if (chartX < plotLeft) {
				chartX = plotLeft;
			} else if (chartX > plotLeft + plotWidth) {
				chartX = plotLeft + plotWidth;
			}

			if (chartY < plotTop) {
				chartY = plotTop;
			} else if (chartY > plotTop + plotHeight) {
				chartY = plotTop + plotHeight;
			}
			
			// determine if the mouse has moved more than 10px
			this.hasDragged = Math.sqrt(
				Math.pow(mouseDownX - chartX, 2) +
				Math.pow(mouseDownY - chartY, 2)
			);
			
			if (this.hasDragged > 10) {
				clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

				// make a selection
				if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
					if (!this.selectionMarker) {
						this.selectionMarker = chart.renderer.rect(
							plotLeft,
							plotTop,
							zoomHor ? 1 : plotWidth,
							zoomVert ? 1 : plotHeight,
							0
						)
						.attr({
							fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
							zIndex: 7
						})
						.add();
					}
				}

				// adjust the width of the selection marker
				if (this.selectionMarker && zoomHor) {
					size = chartX - mouseDownX;
					this.selectionMarker.attr({
						width: mathAbs(size),
						x: (size > 0 ? 0 : size) + mouseDownX
					});
				}
				// adjust the height of the selection marker
				if (this.selectionMarker && zoomVert) {
					size = chartY - mouseDownY;
					this.selectionMarker.attr({
						height: mathAbs(size),
						y: (size > 0 ? 0 : size) + mouseDownY
					});
				}

				// panning
				if (clickedInside && !this.selectionMarker && chartOptions.panning) {
					chart.pan(e, chartOptions.panning);
				}
			}
		},

		/**
		 * On mouse up or touch end across the entire document, drop the selection.
		 */
		drop: function (e) {
			var pointer = this,
				chart = this.chart,
				hasPinched = this.hasPinched;

			if (this.selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: [],
						originalEvent: e.originalEvent || e
					},
					selectionBox = this.selectionMarker,
					selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
					selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
					selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
					selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
					runZoom;

				// a selection has been made
				if (this.hasDragged || hasPinched) {

					// record each axis' min and max
					each(chart.axes, function (axis) {
						if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
							var horiz = axis.horiz,
								minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
								selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
								selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

							selectionData[axis.coll].push({
								axis: axis,
								min: mathMin(selectionMin, selectionMax), // for reversed axes
								max: mathMax(selectionMin, selectionMax)
							});
							runZoom = true;
						}
					});
					if (runZoom) {
						fireEvent(chart, 'selection', selectionData, function (args) { 
							chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
						});
					}

				}
				this.selectionMarker = this.selectionMarker.destroy();

				// Reset scaling preview
				if (hasPinched) {
					this.scaleGroups();
				}
			}

			// Reset all
			if (chart) { // it may be destroyed on mouse up - #877
				css(chart.container, { cursor: chart._cursor });
				chart.cancelClick = this.hasDragged > 10; // #370
				chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
				this.pinchDown = [];
			}
		},

		onContainerMouseDown: function (e) {

			e = this.normalize(e);

			// issue #295, dragging not always working in Firefox
			if (e.preventDefault) {
				e.preventDefault();
			}
			
			this.dragStart(e);
		},

		

		onDocumentMouseUp: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		},

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 * Issue #149 workaround. The mouseleave event does not always fire. 
		 */
		onDocumentMouseMove: function (e) {
			var chart = this.chart,
				chartPosition = this.chartPosition;

			e = this.normalize(e, chartPosition);

			// If we're outside, hide the tooltip
			if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
					!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
				this.reset();
			}
		},

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		onContainerMouseLeave: function () {
			var chart = charts[hoverChartIndex];
			if (chart) {
				chart.pointer.reset();
				chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
			}
		},

		// The mousemove, touchmove and touchstart event handler
		onContainerMouseMove: function (e) {

			var chart = this.chart;

			hoverChartIndex = chart.index;

			e = this.normalize(e);		
			e.returnValue = false; // #2251, #3224
			
			if (chart.mouseIsDown === 'mousedown') {
				this.drag(e);
			} 
			
			// Show the tooltip and run mouse over events (#977)
			if ((this.inClass(e.target, 'highcharts-tracker') || 
					chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
				this.runPointActions(e);
			}
		},

		/**
		 * Utility to detect whether an element has, or has a parent with, a specific
		 * class name. Used on detection of tracker objects and on deciding whether
		 * hovering the tooltip should cause the active series to mouse out.
		 */
		inClass: function (element, className) {
			var elemClassName;
			while (element) {
				elemClassName = attr(element, 'class');
				if (elemClassName) {
					if (elemClassName.indexOf(className) !== -1) {
						return true;
					} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
						return false;
					}
				}
				element = element.parentNode;
			}		
		},

		onTrackerMouseOut: function (e) {
			var series = this.chart.hoverSeries,
				relatedTarget = e.relatedTarget || e.toElement,
				relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499
			
			if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
					relatedSeries !== series) {
				series.onMouseOut();
			}
		},

		onContainerClick: function (e) {
			var chart = this.chart,
				hoverPoint = chart.hoverPoint, 
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop;
			
			e = this.normalize(e);
			e.originalEvent = e; // #3913

			if (!chart.cancelClick) {
				
				// On tracker click, fire the series and point events. #783, #1583
				if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

					// the series click event
					fireEvent(hoverPoint.series, 'click', extend(e, {
						point: hoverPoint
					}));

					// the point click event
					if (chart.hoverPoint) { // it may be destroyed (#1844)
						hoverPoint.firePointEvent('click', e);
					}

				// When clicking outside a tracker, fire a chart event
				} else {
					extend(e, this.getCoordinates(e));

					// fire a click event in the chart
					if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
						fireEvent(chart, 'click', e);
					}
				}


			}
		},

		/**
		 * Set the JS DOM events on the container and document. This method should contain
		 * a one-to-one assignment between methods and their handlers. Any advanced logic should
		 * be moved to the handler reflecting the event's name.
		 */
		setDOMEvents: function () {

			var pointer = this,
				container = pointer.chart.container;

			container.onmousedown = function (e) {
				pointer.onContainerMouseDown(e);
			};
			container.onmousemove = function (e) {
				pointer.onContainerMouseMove(e);
			};
			container.onclick = function (e) {
				pointer.onContainerClick(e);
			};
			addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
			if (chartCount === 1) {
				addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
			}
			if (hasTouch) {
				container.ontouchstart = function (e) {
					pointer.onContainerTouchStart(e);
				};
				container.ontouchmove = function (e) {
					pointer.onContainerTouchMove(e);
				};
				if (chartCount === 1) {
					addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
				}
			}
			
		},

		/**
		 * Destroys the Pointer object and disconnects DOM events.
		 */
		destroy: function () {
			var prop;

			removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
			if (!chartCount) {
				removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
				removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
			}

			// memory and CPU leak
			clearInterval(this.tooltipTimeout);

			for (prop in this) {
				this[prop] = null;
			}
		}
	};


	/* Support for touch devices */
	extend(Highcharts.Pointer.prototype, {

		/**
		 * Run translation operations
		 */
		pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
			if (this.zoomHor || this.pinchHor) {
				this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
			if (this.zoomVert || this.pinchVert) {
				this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
		},

		/**
		 * Run translation operations for each direction (horizontal and vertical) independently
		 */
		pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
			var chart = this.chart,
				xy = horiz ? 'x' : 'y',
				XY = horiz ? 'X' : 'Y',
				sChartXY = 'chart' + XY,
				wh = horiz ? 'width' : 'height',
				plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
				selectionWH,
				selectionXY,
				clipXY,
				scale = forcedScale || 1,
				inverted = chart.inverted,
				bounds = chart.bounds[horiz ? 'h' : 'v'],
				singleTouch = pinchDown.length === 1,
				touch0Start = pinchDown[0][sChartXY],
				touch0Now = touches[0][sChartXY],
				touch1Start = !singleTouch && pinchDown[1][sChartXY],
				touch1Now = !singleTouch && touches[1][sChartXY],
				outOfBounds,
				transformScale,
				scaleKey,
				setScale = function () {
					if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
						scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
					}
					
					clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
					selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
				};

			// Set the scale, first pass
			setScale();

			selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

			// Out of bounds
			if (selectionXY < bounds.min) {
				selectionXY = bounds.min;
				outOfBounds = true;
			} else if (selectionXY + selectionWH > bounds.max) {
				selectionXY = bounds.max - selectionWH;
				outOfBounds = true;
			}
			
			// Is the chart dragged off its bounds, determined by dataMin and dataMax?
			if (outOfBounds) {

				// Modify the touchNow position in order to create an elastic drag movement. This indicates
				// to the user that the chart is responsive but can't be dragged further.
				touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
				if (!singleTouch) {
					touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
				}

				// Set the scale, second pass to adapt to the modified touchNow positions
				setScale();

			} else {
				lastValidTouch[xy] = [touch0Now, touch1Now];
			}

			// Set geometry for clipping, selection and transformation
			if (!inverted) { // TODO: implement clipping for inverted charts
				clip[xy] = clipXY - plotLeftTop;
				clip[wh] = selectionWH;
			}
			scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
			transformScale = inverted ? 1 / scale : scale;

			selectionMarker[wh] = selectionWH;
			selectionMarker[xy] = selectionXY;
			transform[scaleKey] = scale;
			transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
		},
		
		/**
		 * Handle touch events with two touches
		 */
		pinch: function (e) {

			var self = this,
				chart = self.chart,
				pinchDown = self.pinchDown,
				touches = e.touches,
				touchesLength = touches.length,
				lastValidTouch = self.lastValidTouch,
				hasZoom = self.hasZoom,
				selectionMarker = self.selectionMarker,
				transform = {},
				fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
					chart.runTrackerClick) || self.runChartClick),
				clip = {};

			// Don't initiate panning until the user has pinched. This prevents us from 
			// blocking page scrolling as users scroll down a long page (#4210).
			if (touchesLength > 1) {
				self.initiated = true;
			}

			// On touch devices, only proceed to trigger click if a handler is defined
			if (hasZoom && self.initiated && !fireClickEvent) {
				e.preventDefault();
			}
			
			// Normalize each touch
			map(touches, function (e) {
				return self.normalize(e);
			});
			
			// Register the touch start position
			if (e.type === 'touchstart') {
				each(touches, function (e, i) {
					pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
				});
				lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
				lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

				// Identify the data bounds in pixels
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled) {
						var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
							minPixelPadding = axis.minPixelPadding,
							min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
							max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
							absMin = mathMin(min, max),
							absMax = mathMax(min, max);

						// Store the bounds for use in the touchmove handler
						bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
						bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
					}
				});
				self.res = true; // reset on next move
			
			// Event type is touchmove, handle panning and pinching
			} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
				

				// Set the marker
				if (!selectionMarker) {
					self.selectionMarker = selectionMarker = extend({
						destroy: noop
					}, chart.plotBox);
				}
				
				self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

				self.hasPinched = hasZoom;

				// Scale and translate the groups to provide visual feedback during pinching
				self.scaleGroups(transform, clip);
				
				// Optionally move the tooltip on touchmove
				if (!hasZoom && self.followTouchMove && touchesLength === 1) {
					this.runPointActions(self.normalize(e));
				} else if (self.res) {
					self.res = false;
					this.reset(false, 0);
				}
			}
		},

		/**
		 * General touch handler shared by touchstart and touchmove.
		 */
		touch: function (e, start) {
			var chart = this.chart;

			hoverChartIndex = chart.index;

			if (e.touches.length === 1) {

				e = this.normalize(e);

				if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

					// Run mouse events and display tooltip etc
					if (start) {
						this.runPointActions(e);
					}

					this.pinch(e);

				} else if (start) {
					// Hide the tooltip on touching outside the plot area (#1203)
					this.reset();
				}

			} else if (e.touches.length === 2) {
				this.pinch(e);
			}
		},

		onContainerTouchStart: function (e) {
			this.touch(e, true);
		},

		onContainerTouchMove: function (e) {
			this.touch(e);
		},

		onDocumentTouchEnd: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		}

	});
	if (win.PointerEvent || win.MSPointerEvent) {
		
		// The touches object keeps track of the points being touched at all times
		var touches = {},
			hasPointerEvent = !!win.PointerEvent,
			getWebkitTouches = function () {
				var key, fake = [];
				fake.item = function (i) { return this[i]; };
				for (key in touches) {
					if (touches.hasOwnProperty(key)) {
						fake.push({
							pageX: touches[key].pageX,
							pageY: touches[key].pageY,
							target: touches[key].target
						});
					}
				}
				return fake;
			},
			translateMSPointer = function (e, method, wktype, callback) {
				var p;
				e = e.originalEvent || e;
				if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
					callback(e);
					p = charts[hoverChartIndex].pointer;
					p[method]({
						type: wktype,
						target: e.currentTarget,
						preventDefault: noop,
						touches: getWebkitTouches()
					});				
				}
			};

		/**
		 * Extend the Pointer prototype with methods for each event handler and more
		 */
		extend(Pointer.prototype, {
			onContainerPointerDown: function (e) {
				translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
				});
			},
			onContainerPointerMove: function (e) {
				translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
					if (!touches[e.pointerId].target) {
						touches[e.pointerId].target = e.currentTarget;
					}
				});
			},
			onDocumentPointerUp: function (e) {
				translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
					delete touches[e.pointerId];
				});
			},

			/**
			 * Add or remove the MS Pointer specific events
			 */
			batchMSEvents: function (fn) {
				fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
				fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
				fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
			}
		});

		// Disable default IE actions for pinch and such on chart element
		wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
			proceed.call(this, chart, options);
			if (this.hasZoom) { // #4014
				css(chart.container, {
					'-ms-touch-action': NONE,
					'touch-action': NONE
				});
			}
		});

		// Add IE specific touch events to chart
		wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
			proceed.apply(this);
			if (this.hasZoom || this.followTouchMove) {
				this.batchMSEvents(addEvent);
			}
		});
		// Destroy MS events also
		wrap(Pointer.prototype, 'destroy', function (proceed) {
			this.batchMSEvents(removeEvent);
			proceed.call(this);
		});
	}
	/**
	 * The overview of the chart's series
	 */
	var Legend = Highcharts.Legend = function (chart, options) {
		this.init(chart, options);
	};

	Legend.prototype = {
		
		/**
		 * Initialize the legend
		 */
		init: function (chart, options) {
			
			var legend = this,
				itemStyle = options.itemStyle,
				padding,
				itemMarginTop = options.itemMarginTop || 0;
		
			this.options = options;

			if (!options.enabled) {
				return;
			}
		
			legend.itemStyle = itemStyle;
			legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
			legend.itemMarginTop = itemMarginTop;
			legend.padding = padding = pick(options.padding, 8);
			legend.initialItemX = padding;
			legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
			legend.maxItemWidth = 0;
			legend.chart = chart;
			legend.itemHeight = 0;
			legend.symbolWidth = pick(options.symbolWidth, 16);
			legend.pages = [];


			// Render it
			legend.render();

			// move checkboxes
			addEvent(legend.chart, 'endResize', function () { 
				legend.positionCheckboxes();
			});

		},

		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		colorizeItem: function (item, visible) {
			var legend = this,
				options = legend.options,
				legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = legend.itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
				markerOptions = item.options && item.options.marker,
				symbolAttr = { fill: symbolColor },
				key,
				val;
			
			if (legendItem) {
				legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			
			if (legendSymbol) {
				
				// Apply marker options
				if (markerOptions && legendSymbol.isMarker) { // #585
					symbolAttr.stroke = symbolColor;
					markerOptions = item.convertAttribs(markerOptions);
					for (key in markerOptions) {
						val = markerOptions[key];
						if (val !== UNDEFINED) {
							symbolAttr[key] = val;
						}
					}
				}

				legendSymbol.attr(symbolAttr);
			}
		},

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 */
		positionItem: function (item) {
			var legend = this,
				options = legend.options,
				symbolPadding = options.symbolPadding,
				ltr = !options.rtl,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				checkbox = item.checkbox,
				legendGroup = item.legendGroup;

			if (legendGroup && legendGroup.element) {
				legendGroup.translate(
					ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
					itemY
				);
			}

			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		},

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		destroyItem: function (item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
				if (item[key]) {
					item[key] = item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}
		},

		/**
		 * Destroys the legend.
		 */
		destroy: function () {
			var legend = this,
				legendGroup = legend.group,
				box = legend.box;

			if (box) {
				legend.box = box.destroy();
			}

			if (legendGroup) {
				legend.group = legendGroup.destroy();
			}
		},

		/**
		 * Position the checkboxes after the width is determined
		 */
		positionCheckboxes: function (scrollOffset) {
			var alignAttr = this.group.alignAttr,
				translateY,
				clipHeight = this.clipHeight || this.legendHeight;

			if (alignAttr) {
				translateY = alignAttr.translateY;
				each(this.allItems, function (item) {
					var checkbox = item.checkbox,
						top;
					
					if (checkbox) {
						top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
						css(checkbox, {
							left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
							top: top + PX,
							display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
						});
					}
				});
			}
		},
		
		/**
		 * Render the legend title on top of the legend
		 */
		renderTitle: function () {
			var options = this.options,
				padding = this.padding,
				titleOptions = options.title,
				titleHeight = 0,
				bBox;
			
			if (titleOptions.text) {
				if (!this.title) {
					this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
						.attr({ zIndex: 1 })
						.css(titleOptions.style)
						.add(this.group);
				}
				bBox = this.title.getBBox();
				titleHeight = bBox.height;
				this.offsetWidth = bBox.width; // #1717
				this.contentGroup.attr({ translateY: titleHeight });
			}
			this.titleHeight = titleHeight;
		},

		/**
		 * Set the legend item text
		 */
		setText: function (item) {
			var options = this.options;
			item.legendItem.attr({
				text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
			});
		},

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		renderItem: function (item) {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				options = legend.options,
				horizontal = options.layout === 'horizontal',
				symbolWidth = legend.symbolWidth,
				symbolPadding = options.symbolPadding,
				itemStyle = legend.itemStyle,
				itemHiddenStyle = legend.itemHiddenStyle,
				padding = legend.padding,
				itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
				ltr = !options.rtl,
				itemHeight,
				widthOption = options.width,
				itemMarginBottom = options.itemMarginBottom || 0,
				itemMarginTop = legend.itemMarginTop,
				initialItemX = legend.initialItemX,
				bBox,
				itemWidth,
				li = item.legendItem,
				series = item.series && item.series.drawLegendSymbol ? item.series : item,
				seriesOptions = series.options,
				showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
				useHTML = options.useHTML;

			if (!li) { // generate it once, later move it

				// Generate the group box
				// A group to hold the symbol and text. Text is to be appended in Legend class.
				item.legendGroup = renderer.g('legend-item')
					.attr({ zIndex: 1 })
					.add(legend.scrollGroup);

				// Generate the list item text and add it to the group
				item.legendItem = li = renderer.text(
						'',
						ltr ? symbolWidth + symbolPadding : -symbolPadding,
						legend.baseline || 0,
						useHTML
					)
					.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(item.legendGroup);

				// Get the baseline for the first item - the font size is equal for all
				if (!legend.baseline) {
					legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
					legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
					li.attr('y', legend.baseline);
				}

				// Draw the legend symbol inside the group box
				series.drawLegendSymbol(legend, item);

				if (legend.setItemEvents) {
					legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
				}			

				// Colorize the items
				legend.colorizeItem(item, item.visible);

				// add the HTML checkbox on top
				if (showCheckbox) {
					legend.createCheckboxForItem(item);				
				}
			}

			// Always update the text
			legend.setText(item);

			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.checkboxOffset = 
				options.itemWidth || 
				item.legendItemWidth || 
				symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
			legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

			// if the item exceeds the width, start a new line
			if (horizontal && legend.itemX - initialItemX + itemWidth >
					(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
				legend.itemX = initialItemX;
				legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
				legend.lastLineHeight = 0; // reset for next line (#915, #3976)
			}

			// If the item exceeds the height, start a new column
			/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
				legend.itemY = legend.initialItemY;
				legend.itemX += legend.maxItemWidth;
				legend.maxItemWidth = 0;
			}*/

			// Set the edge positions
			legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
			legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
			legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

			// cache the position of the newly generated or reordered items
			item._legendItemPos = [legend.itemX, legend.itemY];

			// advance
			if (horizontal) {
				legend.itemX += itemWidth;

			} else {
				legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
				legend.lastLineHeight = itemHeight;
			}

			// the width of the widest item
			legend.offsetWidth = widthOption || mathMax(
				(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
				legend.offsetWidth
			);
		},

		/**
		 * Get all items, which is one item per series for normal series and one item per point
		 * for pie series.
		 */
		getAllItems: function () {
			var allItems = [];
			each(this.chart.series, function (series) {
				var seriesOptions = series.options;

				// Handle showInLegend. If the series is linked to another series, defaults to false.
				if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						series.legendItems ||
						(seriesOptions.legendType === 'point' ?
								series.data :
								series)
				);
			});
			return allItems;
		},

		/**
		 * Adjust the chart margins by reserving space for the legend on only one side
		 * of the chart. If the position is set to a corner, top or bottom is reserved
		 * for horizontal legends and left or right for vertical ones.
		 */
		adjustMargins: function (margin, spacing) {
			var chart = this.chart, 
				options = this.options,
				// Use the first letter of each alignment option in order to detect the side 
				alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];
				
			if (this.display && !options.floating) {

				each([
					/(lth|ct|rth)/,
					/(rtv|rm|rbv)/,
					/(rbh|cb|lbh)/,
					/(lbv|lm|ltv)/
				], function (alignments, side) {
					if (alignments.test(alignment) && !defined(margin[side])) {
						// Now we have detected on which side of the chart we should reserve space for the legend
						chart[marginNames[side]] = mathMax(
							chart[marginNames[side]],
							chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
								[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
								pick(options.margin, 12) +
								spacing[side]
						);
					}
				});
			}
		},

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		render: function () {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				legendGroup = legend.group,
				allItems,
				display,
				legendWidth,
				legendHeight,
				box = legend.box,
				options = legend.options,
				padding = legend.padding,
				legendBorderWidth = options.borderWidth,
				legendBackgroundColor = options.backgroundColor;

			legend.itemX = legend.initialItemX;
			legend.itemY = legend.initialItemY;
			legend.offsetWidth = 0;
			legend.lastItemY = 0;

			if (!legendGroup) {
				legend.group = legendGroup = renderer.g('legend')
					.attr({ zIndex: 7 }) 
					.add();
				legend.contentGroup = renderer.g()
					.attr({ zIndex: 1 }) // above background
					.add(legendGroup);
				legend.scrollGroup = renderer.g()
					.add(legend.contentGroup);
			}
			
			legend.renderTitle();

			// add each series or point
			allItems = legend.getAllItems();

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
			});

			// reversed legend
			if (options.reversed) {
				allItems.reverse();
			}

			legend.allItems = allItems;
			legend.display = display = !!allItems.length;

			// render the items
			legend.lastLineHeight = 0;
			each(allItems, function (item) {
				legend.renderItem(item); 
			});

			// Get the box
			legendWidth = (options.width || legend.offsetWidth) + padding;
			legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
			legendHeight = legend.handleOverflow(legendHeight);
			legendHeight += padding;

			// Draw the border and/or background
			if (legendBorderWidth || legendBackgroundColor) {

				if (!box) {
					legend.box = box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp({ width: legendWidth, height: legendHeight })
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[display ? 'show' : 'hide']();
			}
			
			legend.legendWidth = legendWidth;
			legend.legendHeight = legendHeight;

			// Now that the legend width and height are established, put the items in the 
			// final position
			each(allItems, function (item) {
				legend.positionItem(item);
			});

			// 1.x compatibility: positioning based on style
			/*var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (options.style[prop] && options.style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
				}
			}*/

			if (display) {
				legendGroup.align(extend({
					width: legendWidth,
					height: legendHeight
				}, options), true, 'spacingBox');
			}

			if (!chart.isResizing) {
				this.positionCheckboxes();
			}
		},
		
		/**
		 * Set up the overflow handling by adding navigation with up and down arrows below the
		 * legend.
		 */
		handleOverflow: function (legendHeight) {
			var legend = this,
				chart = this.chart,
				renderer = chart.renderer,
				options = this.options,
				optionsY = options.y,
				alignTop = options.verticalAlign === 'top',
				spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
				maxHeight = options.maxHeight,
				clipHeight,
				clipRect = this.clipRect,
				navOptions = options.navigation,
				animation = pick(navOptions.animation, true),
				arrowSize = navOptions.arrowSize || 12,
				nav = this.nav,
				pages = this.pages,
				padding = this.padding,
				lastY,
				allItems = this.allItems,
				clipToHeight = function (height) {
					clipRect.attr({
						height: height
					});

					// useHTML
					if (legend.contentGroup.div) {
						legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
					}
				};

				
			// Adjust the height
			if (options.layout === 'horizontal') {
				spaceHeight /= 2;
			}
			if (maxHeight) {
				spaceHeight = mathMin(spaceHeight, maxHeight);
			}
			
			// Reset the legend height and adjust the clipping rectangle
			pages.length = 0;
			if (legendHeight > spaceHeight) {

				this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
				this.currentPage = pick(this.currentPage, 1);
				this.fullHeight = legendHeight;
				
				// Fill pages with Y positions so that the top of each a legend item defines
				// the scroll top for each page (#2098)
				each(allItems, function (item, i) {
					var y = item._legendItemPos[1],
						h = mathRound(item.legendItem.getBBox().height),
						len = pages.length;
					
					if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
						pages.push(lastY || y);
						len++;
					}
					
					if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
						pages.push(y);
					}
					if (y !== lastY) {
						lastY = y;
					}
				});

				// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
				if (!clipRect) {
					clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
					legend.contentGroup.clip(clipRect);
				}
					
				clipToHeight(clipHeight);

				// Add navigation elements
				if (!nav) {
					this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
					this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(-1, animation);
						})
						.add(nav);
					this.pager = renderer.text('', 15, 10)
						.css(navOptions.style)
						.add(nav);
					this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(1, animation);
						})
						.add(nav);
				}
				
				// Set initial position
				legend.scroll(0);
				
				legendHeight = spaceHeight;
				
			} else if (nav) {
				clipToHeight(chart.chartHeight);
				nav.hide();
				this.scrollGroup.attr({
					translateY: 1
				});
				this.clipHeight = 0; // #1379
			}
			
			return legendHeight;
		},
		
		/**
		 * Scroll the legend by a number of pages
		 * @param {Object} scrollBy
		 * @param {Object} animation
		 */
		scroll: function (scrollBy, animation) {
			var pages = this.pages,
				pageCount = pages.length,
				currentPage = this.currentPage + scrollBy,
				clipHeight = this.clipHeight,
				navOptions = this.options.navigation,
				activeColor = navOptions.activeColor,
				inactiveColor = navOptions.inactiveColor,
				pager = this.pager,
				padding = this.padding,
				scrollOffset;
			
			// When resizing while looking at the last page
			if (currentPage > pageCount) {
				currentPage = pageCount;
			}
			
			if (currentPage > 0) {
				
				if (animation !== UNDEFINED) {
					setAnimation(animation, this.chart);
				}
				
				this.nav.attr({
					translateX: padding,
					translateY: clipHeight + this.padding + 7 + this.titleHeight,
					visibility: VISIBLE
				});
				this.up.attr({
						fill: currentPage === 1 ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === 1 ? 'default' : 'pointer'
					});
				pager.attr({
					text: currentPage + '/' + pageCount
				});
				this.down.attr({
						x: 18 + this.pager.getBBox().width, // adjust to text width
						fill: currentPage === pageCount ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === pageCount ? 'default' : 'pointer'
					});
				
				scrollOffset = -pages[currentPage - 1] + this.initialItemY;

				this.scrollGroup.animate({
					translateY: scrollOffset
				});			
				
				this.currentPage = currentPage;
				this.positionCheckboxes(scrollOffset);
			}
				
		}
		
	};

	/*
	 * LegendSymbolMixin
	 */ 

	var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

		/**
		 * Get the series' symbol in the legend
		 * 
		 * @param {Object} legend The legend object
		 * @param {Object} item The series (this) or point
		 */
		drawRectangle: function (legend, item) {
			var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

			item.legendSymbol = this.chart.renderer.rect(
				0,
				legend.baseline - symbolHeight + 1, // #3988
				legend.symbolWidth,
				symbolHeight,
				legend.options.symbolRadius || 0
			).attr({
				zIndex: 3
			}).add(item.legendGroup);		
			
		},

		/**
		 * Get the series' symbol in the legend. This method should be overridable to create custom 
		 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
		 * 
		 * @param {Object} legend The legend object
		 */
		drawLineMarker: function (legend) {

			var options = this.options,
				markerOptions = options.marker,
				radius,
				legendSymbol,
				symbolWidth = legend.symbolWidth,
				renderer = this.chart.renderer,
				legendItemGroup = this.legendGroup,
				verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
				attr;

			// Draw the line
			if (options.lineWidth) {
				attr = {
					'stroke-width': options.lineWidth
				};
				if (options.dashStyle) {
					attr.dashstyle = options.dashStyle;
				}
				this.legendLine = renderer.path([
					M,
					0,
					verticalCenter,
					L,
					symbolWidth,
					verticalCenter
				])
				.attr(attr)
				.add(legendItemGroup);
			}
			
			// Draw the marker
			if (markerOptions && markerOptions.enabled !== false) {
				radius = markerOptions.radius;
				this.legendSymbol = legendSymbol = renderer.symbol(
					this.symbol,
					(symbolWidth / 2) - radius,
					verticalCenter - radius,
					2 * radius,
					2 * radius
				)
				.add(legendItemGroup);
				legendSymbol.isMarker = true;
			}
		}
	};

	// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	// and for #2580, a similar drawing flaw in Firefox 26.
	// TODO: Explore if there's a general cause for this. The problem may be related 
	// to nested group elements, as the legend item texts are within 4 group elements.
	if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
		wrap(Legend.prototype, 'positionItem', function (proceed, item) {
			var legend = this,
				runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
					if (item._legendItemPos) {
						proceed.call(legend, item);
					}
				};

			// Do it now, for export and to get checkbox placement
			runPositionItem();
			
			// Do it after to work around the core issue
			setTimeout(runPositionItem);
		});
	}
	/**
	 * The chart class
	 * @param {Object} options
	 * @param {Function} callback Function to run when the chart has loaded
	 */
	var Chart = Highcharts.Chart = function () {
		this.init.apply(this, arguments);
	};

	Chart.prototype = {

		/**
		 * Hook for modules
		 */
		callbacks: [],

		/**
		 * Initialize the chart
		 */
		init: function (userOptions, callback) {

			// Handle regular options
			var options,
				seriesOptions = userOptions.series; // skip merging data points to increase performance

			userOptions.series = null;
			options = merge(defaultOptions, userOptions); // do the merge
			options.series = userOptions.series = seriesOptions; // set back the series data
			this.userOptions = userOptions;

			var optionsChart = options.chart;
			
			// Create margin & spacing array
			this.margin = this.splashArray('margin', optionsChart);
			this.spacing = this.splashArray('spacing', optionsChart);

			var chartEvents = optionsChart.events;

			//this.runChartClick = chartEvents && !!chartEvents.click;
			this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

			this.callback = callback;
			this.isResizing = 0;
			this.options = options;
			//chartTitleOptions = UNDEFINED;
			//chartSubtitleOptions = UNDEFINED;

			this.axes = [];
			this.series = [];
			this.hasCartesianSeries = optionsChart.showAxes;
			//this.axisOffset = UNDEFINED;
			//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
			//this.inverted = UNDEFINED;
			//this.loadingShown = UNDEFINED;
			//this.container = UNDEFINED;
			//this.chartWidth = UNDEFINED;
			//this.chartHeight = UNDEFINED;
			//this.marginRight = UNDEFINED;
			//this.marginBottom = UNDEFINED;
			//this.containerWidth = UNDEFINED;
			//this.containerHeight = UNDEFINED;
			//this.oldChartWidth = UNDEFINED;
			//this.oldChartHeight = UNDEFINED;

			//this.renderTo = UNDEFINED;
			//this.renderToClone = UNDEFINED;

			//this.spacingBox = UNDEFINED

			//this.legend = UNDEFINED;

			// Elements
			//this.chartBackground = UNDEFINED;
			//this.plotBackground = UNDEFINED;
			//this.plotBGImage = UNDEFINED;
			//this.plotBorder = UNDEFINED;
			//this.loadingDiv = UNDEFINED;
			//this.loadingSpan = UNDEFINED;

			var chart = this,
				eventType;

			// Add the chart to the global lookup
			chart.index = charts.length;
			charts.push(chart);
			chartCount++;

			// Set up auto resize
			if (optionsChart.reflow !== false) {
				addEvent(chart, 'load', function () {
					chart.initReflow();
				});
			}

			// Chart event handlers
			if (chartEvents) {
				for (eventType in chartEvents) {
					addEvent(chart, eventType, chartEvents[eventType]);
				}
			}

			chart.xAxis = [];
			chart.yAxis = [];

			// Expose methods and variables
			chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
			chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

			chart.firstRender();
		},

		/**
		 * Initialize an individual series, called internally before render time
		 */
		initSeries: function (options) {
			var chart = this,
				optionsChart = chart.options.chart,
				type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
				series,
				constr = seriesTypes[type];

			// No such series type
			if (!constr) {
				error(17, true);
			}

			series = new constr();
			series.init(this, options);
			return series;
		},

		/**
		 * Check whether a given point is within the plot area
		 *
		 * @param {Number} plotX Pixel x relative to the plot area
		 * @param {Number} plotY Pixel y relative to the plot area
		 * @param {Boolean} inverted Whether the chart is inverted
		 */
		isInsidePlot: function (plotX, plotY, inverted) {
			var x = inverted ? plotY : plotX,
				y = inverted ? plotX : plotY;
				
			return x >= 0 &&
				x <= this.plotWidth &&
				y >= 0 &&
				y <= this.plotHeight;
		},

		/**
		 * Redraw legend, axes or series based on updated data
		 *
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		redraw: function (animation) {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				pointer = chart.pointer,
				legend = chart.legend,
				redrawLegend = chart.isDirtyLegend,
				hasStackedSeries,
				hasDirtyStacks,
				hasCartesianSeries = chart.hasCartesianSeries,
				isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
				seriesLength = series.length,
				i = seriesLength,
				serie,
				renderer = chart.renderer,
				isHiddenChart = renderer.isHidden(),
				afterRedraw = [];
				
			setAnimation(animation, chart);
			
			if (isHiddenChart) {
				chart.cloneRenderTo();
			}

			// Adjust title layout (reflow multiline text)
			chart.layOutTitles();

			// link stacked series
			while (i--) {
				serie = series[i];

				if (serie.options.stacking) {
					hasStackedSeries = true;
					
					if (serie.isDirty) {
						hasDirtyStacks = true;
						break;
					}
				}
			}
			if (hasDirtyStacks) { // mark others as dirty
				i = seriesLength;
				while (i--) {
					serie = series[i];
					if (serie.options.stacking) {
						serie.isDirty = true;
					}
				}
			}

			// Handle updated data in the series
			each(series, function (serie) {
				if (serie.isDirty) {
					if (serie.options.legendType === 'point') {
						if (serie.updateTotals) {
							serie.updateTotals();
						}
						redrawLegend = true;
					}
				}
			});

			// handle added or removed series
			if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
				// draw legend graphics
				legend.render();

				chart.isDirtyLegend = false;
			}

			// reset stacks
			if (hasStackedSeries) {
				chart.getStacks();
			}


			if (hasCartesianSeries) {
				if (!chart.isResizing) {

					// reset maxTicks
					chart.maxTicks = null;

					// set axes scales
					each(axes, function (axis) {
						axis.setScale();
					});
				}
			}

			chart.getMargins(); // #3098

			if (hasCartesianSeries) {
				// If one axis is dirty, all axes must be redrawn (#792, #2169)
				each(axes, function (axis) {
					if (axis.isDirty) {
						isDirtyBox = true;
					}
				});

				// redraw axes
				each(axes, function (axis) {
					
					// Fire 'afterSetExtremes' only if extremes are set
					if (axis.isDirtyExtremes) { // #821
						axis.isDirtyExtremes = false;
						afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
							fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
							delete axis.eventArgs;
						});
					}
					
					if (isDirtyBox || hasStackedSeries) {
						axis.redraw();
					}
				});
			}
			
			// the plot areas size has changed
			if (isDirtyBox) {
				chart.drawChartBox();
			}


			// redraw affected series
			each(series, function (serie) {
				if (serie.isDirty && serie.visible &&
						(!serie.isCartesian || serie.xAxis)) { // issue #153
					serie.redraw();
				}
			});

			// move tooltip or reset
			if (pointer) {
				pointer.reset(true);
			}

			// redraw if canvas
			renderer.draw();

			// fire the event
			fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
			
			if (isHiddenChart) {
				chart.cloneRenderTo(true);
			}
			
			// Fire callbacks that are put on hold until after the redraw
			each(afterRedraw, function (callback) {
				callback.call();
			});
		},

		/**
		 * Get an axis, series or point object by id.
		 * @param id {String} The id as given in the configuration options
		 */
		get: function (id) {
			var chart = this,
				axes = chart.axes,
				series = chart.series;

			var i,
				j,
				points;

			// search axes
			for (i = 0; i < axes.length; i++) {
				if (axes[i].options.id === id) {
					return axes[i];
				}
			}

			// search series
			for (i = 0; i < series.length; i++) {
				if (series[i].options.id === id) {
					return series[i];
				}
			}

			// search points
			for (i = 0; i < series.length; i++) {
				points = series[i].points || [];
				for (j = 0; j < points.length; j++) {
					if (points[j].id === id) {
						return points[j];
					}
				}
			}
			return null;
		},

		/**
		 * Create the Axis instances based on the config options
		 */
		getAxes: function () {
			var chart = this,
				options = this.options,
				xAxisOptions = options.xAxis = splat(options.xAxis || {}),
				yAxisOptions = options.yAxis = splat(options.yAxis || {}),
				optionsArray,
				axis;

			// make sure the options are arrays and add some members
			each(xAxisOptions, function (axis, i) {
				axis.index = i;
				axis.isX = true;
			});

			each(yAxisOptions, function (axis, i) {
				axis.index = i;
			});

			// concatenate all axis options into one array
			optionsArray = xAxisOptions.concat(yAxisOptions);

			each(optionsArray, function (axisOptions) {
				axis = new Axis(chart, axisOptions);
			});
		},


		/**
		 * Get the currently selected points from all series
		 */
		getSelectedPoints: function () {
			var points = [];
			each(this.series, function (serie) {
				points = points.concat(grep(serie.points || [], function (point) {
					return point.selected;
				}));
			});
			return points;
		},

		/**
		 * Get the currently selected series
		 */
		getSelectedSeries: function () {
			return grep(this.series, function (serie) {
				return serie.selected;
			});
		},

		/**
		 * Show the title and subtitle of the chart
		 *
		 * @param titleOptions {Object} New title options
		 * @param subtitleOptions {Object} New subtitle options
		 *
		 */
		setTitle: function (titleOptions, subtitleOptions, redraw) {
			var chart = this,
				options = chart.options,
				chartTitleOptions,
				chartSubtitleOptions;

			chartTitleOptions = options.title = merge(options.title, titleOptions);
			chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

			// add title and subtitle
			each([
				['title', titleOptions, chartTitleOptions],
				['subtitle', subtitleOptions, chartSubtitleOptions]
			], function (arr) {
				var name = arr[0],
					title = chart[name],
					titleOptions = arr[1],
					chartTitleOptions = arr[2];

				if (title && titleOptions) {
					chart[name] = title = title.destroy(); // remove old
				}
				
				if (chartTitleOptions && chartTitleOptions.text && !title) {
					chart[name] = chart.renderer.text(
						chartTitleOptions.text,
						0,
						0,
						chartTitleOptions.useHTML
					)
					.attr({
						align: chartTitleOptions.align,
						'class': PREFIX + name,
						zIndex: chartTitleOptions.zIndex || 4
					})
					.css(chartTitleOptions.style)
					.add();
				}	
			});
			chart.layOutTitles(redraw);
		},

		/**
		 * Lay out the chart titles and cache the full offset height for use in getMargins
		 */
		layOutTitles: function (redraw) {
			var titleOffset = 0,
				title = this.title,
				subtitle = this.subtitle,
				options = this.options,
				titleOptions = options.title,
				subtitleOptions = options.subtitle,
				requiresDirtyBox,
				renderer = this.renderer,
				autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

			if (title) {
				title
					.css({ width: (titleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
					}, titleOptions), false, 'spacingBox');
				
				if (!titleOptions.floating && !titleOptions.verticalAlign) {
					titleOffset = title.getBBox().height;
				}
			}
			if (subtitle) {
				subtitle
					.css({ width: (subtitleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
					}, subtitleOptions), false, 'spacingBox');
				
				if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
					titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
				}
			}

			requiresDirtyBox = this.titleOffset !== titleOffset;				
			this.titleOffset = titleOffset; // used in getMargins

			if (!this.isDirtyBox && requiresDirtyBox) {
				this.isDirtyBox = requiresDirtyBox;
				// Redraw if necessary (#2719, #2744)		
				if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
					this.redraw();
				}
			}
		},

		/**
		 * Get chart width and height according to options and container size
		 */
		getChartSize: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				widthOption = optionsChart.width,
				heightOption = optionsChart.height,
				renderTo = chart.renderToClone || chart.renderTo;

			// get inner width and height from jQuery (#824)
			if (!defined(widthOption)) {
				chart.containerWidth = adapterRun(renderTo, 'width');
			}
			if (!defined(heightOption)) {
				chart.containerHeight = adapterRun(renderTo, 'height');
			}
			
			chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
			chart.chartHeight = mathMax(0, pick(heightOption,
				// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
				chart.containerHeight > 19 ? chart.containerHeight : 400));
		},

		/**
		 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
		 * size computation on chart.render and chart.redraw
		 */
		cloneRenderTo: function (revert) {
			var clone = this.renderToClone,
				container = this.container;
			
			// Destroy the clone and bring the container back to the real renderTo div
			if (revert) {
				if (clone) {
					this.renderTo.appendChild(container);
					discardElement(clone);
					delete this.renderToClone;
				}
			
			// Set up the clone
			} else {
				if (container && container.parentNode === this.renderTo) {
					this.renderTo.removeChild(container); // do not clone this
				}
				this.renderToClone = clone = this.renderTo.cloneNode(0);
				css(clone, {
					position: ABSOLUTE,
					top: '-9999px',
					display: 'block' // #833
				});
				if (clone.style.setProperty) { // #2631
					clone.style.setProperty('display', 'block', 'important');
				}
				doc.body.appendChild(clone);
				if (container) {
					clone.appendChild(container);
				}
			}
		},

		/**
		 * Get the containing element, determine the size and create the inner container
		 * div to hold the chart
		 */
		getContainer: function () {
			var chart = this,
				container,
				optionsChart = chart.options.chart,
				chartWidth,
				chartHeight,
				renderTo,
				indexAttrName = 'data-highcharts-chart',
				oldChartIndex,
				containerId;

			chart.renderTo = renderTo = optionsChart.renderTo;
			containerId = PREFIX + idCounter++;

			if (isString(renderTo)) {
				chart.renderTo = renderTo = doc.getElementById(renderTo);
			}
			
			// Display an error if the renderTo is wrong
			if (!renderTo) {
				error(13, true);
			}
			
			// If the container already holds a chart, destroy it. The check for hasRendered is there
			// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
			// attribute and the SVG contents, but not an interactive chart. So in this case,
			// charts[oldChartIndex] will point to the wrong chart if any (#2609).
			oldChartIndex = pInt(attr(renderTo, indexAttrName));
			if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
				charts[oldChartIndex].destroy();
			}		
			
			// Make a reference to the chart from the div
			attr(renderTo, indexAttrName, chart.index);

			// remove previous chart
			renderTo.innerHTML = '';

			// If the container doesn't have an offsetWidth, it has or is a child of a node
			// that has display:none. We need to temporarily move it out to a visible
			// state to determine the size, else the legend and tooltips won't render
			// properly. The allowClone option is used in sparklines as a micro optimization,
			// saving about 1-2 ms each chart.
			if (!optionsChart.skipClone && !renderTo.offsetWidth) {
				chart.cloneRenderTo();
			}

			// get the width and height
			chart.getChartSize();
			chartWidth = chart.chartWidth;
			chartHeight = chart.chartHeight;

			// create the inner container
			chart.container = container = createElement(DIV, {
					className: PREFIX + 'container' +
						(optionsChart.className ? ' ' + optionsChart.className : ''),
					id: containerId
				}, extend({
					position: RELATIVE,
					overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
						// content overflow in IE
					width: chartWidth + PX,
					height: chartHeight + PX,
					textAlign: 'left',
					lineHeight: 'normal', // #427
					zIndex: 0, // #1072
					'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
				}, optionsChart.style),
				chart.renderToClone || renderTo
			);

			// cache the cursor (#1650)
			chart._cursor = container.style.cursor;

			// Initialize the renderer
			chart.renderer =
				optionsChart.forExport ? // force SVG, used for SVG export
					new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
					new Renderer(container, chartWidth, chartHeight, optionsChart.style);

			if (useCanVG) {
				// If we need canvg library, extend and configure the renderer
				// to get the tracker for translating mouse events
				chart.renderer.create(chart, container, chartWidth, chartHeight);
			}
			// Add a reference to the charts index
			chart.renderer.chartIndex = chart.index;
		},

		/**
		 * Calculate margins by rendering axis labels in a preliminary position. Title,
		 * subtitle and legend have already been rendered at this stage, but will be
		 * moved into their final positions
		 */
		getMargins: function (skipAxes) {
			var chart = this,
				spacing = chart.spacing,
				margin = chart.margin,
				titleOffset = chart.titleOffset;

			chart.resetMargins();

			// Adjust for title and subtitle
			if (titleOffset && !defined(margin[0])) {
				chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
			}
			
			// Adjust for legend
			chart.legend.adjustMargins(margin, spacing);

			// adjust for scroller
			if (chart.extraBottomMargin) {
				chart.marginBottom += chart.extraBottomMargin;
			}
			if (chart.extraTopMargin) {
				chart.plotTop += chart.extraTopMargin;
			}
			if (!skipAxes) {
				this.getAxisMargins();
			}
		},

		getAxisMargins: function () {

			var chart = this,
				axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
				margin = chart.margin;
			
			// pre-render axes to get labels offset width
			if (chart.hasCartesianSeries) {
				each(chart.axes, function (axis) {
					axis.getOffset();
				});
			}

			// Add the axis offsets
			each(marginNames, function (m, side) {
				if (!defined(margin[side])) {
					chart[m] += axisOffset[side];
				}		
			});

			chart.setChartSize();

		},

		/**
		 * Resize the chart to its container if size is not explicitly set
		 */
		reflow: function (e) {
			var chart = this,
				optionsChart = chart.options.chart,
				renderTo = chart.renderTo,
				width = optionsChart.width || adapterRun(renderTo, 'width'),
				height = optionsChart.height || adapterRun(renderTo, 'height'),
				target = e ? e.target : win, // #805 - MooTools doesn't supply e
				doReflow = function () {
					if (chart.container) { // It may have been destroyed in the meantime (#1257)
						chart.setSize(width, height, false);
						chart.hasUserSize = null;
					}
				};
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
				if (width !== chart.containerWidth || height !== chart.containerHeight) {
					clearTimeout(chart.reflowTimeout);
					if (e) { // Called from window.resize
						chart.reflowTimeout = setTimeout(doReflow, 100);
					} else { // Called directly (#2224)
						doReflow();
					}
				}
				chart.containerWidth = width;
				chart.containerHeight = height;
			}
		},

		/**
		 * Add the event handlers necessary for auto resizing
		 */
		initReflow: function () {
			var chart = this,
				reflow = function (e) {
					chart.reflow(e);
				};
				
			
			addEvent(win, 'resize', reflow);
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', reflow);
			});
		},

		/**
		 * Resize the chart to a given width and height
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Object|Boolean} animation
		 */
		setSize: function (width, height, animation) {
			var chart = this,
				chartWidth,
				chartHeight,
				fireEndResize;

			// Handle the isResizing counter
			chart.isResizing += 1;
			fireEndResize = function () {
				if (chart) {
					fireEvent(chart, 'endResize', null, function () {
						chart.isResizing -= 1;
					});
				}
			};

			// set the animation for the current process
			setAnimation(animation, chart);

			chart.oldChartHeight = chart.chartHeight;
			chart.oldChartWidth = chart.chartWidth;
			if (defined(width)) {
				chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
				chart.hasUserSize = !!chartWidth;
			}
			if (defined(height)) {
				chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
			}

			// Resize the container with the global animation applied if enabled (#2503)
			(globalAnimation ? animate : css)(chart.container, {
				width: chartWidth + PX,
				height: chartHeight + PX
			}, globalAnimation);

			chart.setChartSize(true);
			chart.renderer.setSize(chartWidth, chartHeight, animation);

			// handle axes
			chart.maxTicks = null;
			each(chart.axes, function (axis) {
				axis.isDirty = true;
				axis.setScale();
			});

			// make sure non-cartesian series are also handled
			each(chart.series, function (serie) {
				serie.isDirty = true;
			});

			chart.isDirtyLegend = true; // force legend redraw
			chart.isDirtyBox = true; // force redraw of plot and chart border

			chart.layOutTitles(); // #2857
			chart.getMargins();

			chart.redraw(animation);


			chart.oldChartHeight = null;
			fireEvent(chart, 'resize');

			// fire endResize and set isResizing back
			// If animation is disabled, fire without delay
			if (globalAnimation === false) {
				fireEndResize();
			} else { // else set a timeout with the animation duration
				setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
			}
		},

		/**
		 * Set the public chart properties. This is done before and after the pre-render
		 * to determine margin sizes
		 */
		setChartSize: function (skipAxes) {
			var chart = this,
				inverted = chart.inverted,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				optionsChart = chart.options.chart,
				spacing = chart.spacing,
				clipOffset = chart.clipOffset,
				clipX,
				clipY,
				plotLeft,
				plotTop,
				plotWidth,
				plotHeight,
				plotBorderWidth;

			chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
			chart.plotTop = plotTop = mathRound(chart.plotTop);
			chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
			chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

			chart.plotSizeX = inverted ? plotHeight : plotWidth;
			chart.plotSizeY = inverted ? plotWidth : plotHeight;
			
			chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

			// Set boxes used for alignment
			chart.spacingBox = renderer.spacingBox = {
				x: spacing[3],
				y: spacing[0],
				width: chartWidth - spacing[3] - spacing[1],
				height: chartHeight - spacing[0] - spacing[2]
			};
			chart.plotBox = renderer.plotBox = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

			plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
			clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
			clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
			chart.clipBox = {
				x: clipX, 
				y: clipY, 
				width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
				height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
			};

			if (!skipAxes) {
				each(chart.axes, function (axis) {
					axis.setAxisSize();
					axis.setAxisTranslation();
				});
			}
		},

		/**
		 * Initial margins before auto size margins are applied
		 */
		resetMargins: function () {
			var chart = this;

			each(marginNames, function (m, side) {
				chart[m] = pick(chart.margin[side], chart.spacing[side]);
			});
			chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
			chart.clipOffset = [0, 0, 0, 0];
		},

		/**
		 * Draw the borders and backgrounds for chart and plot area
		 */
		drawChartBox: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				chartBackground = chart.chartBackground,
				plotBackground = chart.plotBackground,
				plotBorder = chart.plotBorder,
				plotBGImage = chart.plotBGImage,
				chartBorderWidth = optionsChart.borderWidth || 0,
				chartBackgroundColor = optionsChart.backgroundColor,
				plotBackgroundColor = optionsChart.plotBackgroundColor,
				plotBackgroundImage = optionsChart.plotBackgroundImage,
				plotBorderWidth = optionsChart.plotBorderWidth || 0,
				mgn,
				bgAttr,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				plotBox = chart.plotBox,
				clipRect = chart.clipRect,
				clipBox = chart.clipBox;

			// Chart area
			mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

			if (chartBorderWidth || chartBackgroundColor) {
				if (!chartBackground) {
					
					bgAttr = {
						fill: chartBackgroundColor || NONE
					};
					if (chartBorderWidth) { // #980
						bgAttr.stroke = optionsChart.borderColor;
						bgAttr['stroke-width'] = chartBorderWidth;
					}
					chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
							optionsChart.borderRadius, chartBorderWidth)
						.attr(bgAttr)
						.addClass(PREFIX + 'background')
						.add()
						.shadow(optionsChart.shadow);

				} else { // resize
					chartBackground.animate(
						chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
					);
				}
			}


			// Plot background
			if (plotBackgroundColor) {
				if (!plotBackground) {
					chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
						.attr({
							fill: plotBackgroundColor
						})
						.add()
						.shadow(optionsChart.plotShadow);
				} else {
					plotBackground.animate(plotBox);
				}
			}
			if (plotBackgroundImage) {
				if (!plotBGImage) {
					chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
						.add();
				} else {
					plotBGImage.animate(plotBox);
				}
			}
			
			// Plot clip
			if (!clipRect) {
				chart.clipRect = renderer.clipRect(clipBox);
			} else {
				clipRect.animate({
					width: clipBox.width,
					height: clipBox.height
				});
			}

			// Plot area border
			if (plotBorderWidth) {
				if (!plotBorder) {
					chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
						.attr({
							stroke: optionsChart.plotBorderColor,
							'stroke-width': plotBorderWidth,
							fill: NONE,
							zIndex: 1
						})
						.add();
				} else {
					plotBorder.animate(
						plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
					);
				}
			}

			// reset
			chart.isDirtyBox = false;
		},

		/**
		 * Detect whether a certain chart property is needed based on inspecting its options
		 * and series. This mainly applies to the chart.invert property, and in extensions to 
		 * the chart.angular and chart.polar properties.
		 */
		propFromSeries: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				klass,
				seriesOptions = chart.options.series,
				i,
				value;
				
				
			each(['inverted', 'angular', 'polar'], function (key) {
				
				// The default series type's class
				klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
				
				// Get the value from available chart-wide properties
				value = (
					chart[key] || // 1. it is set before
					optionsChart[key] || // 2. it is set in the options
					(klass && klass.prototype[key]) // 3. it's default series class requires it
				);
		
				// 4. Check if any the chart's series require it
				i = seriesOptions && seriesOptions.length;
				while (!value && i--) {
					klass = seriesTypes[seriesOptions[i].type];
					if (klass && klass.prototype[key]) {
						value = true;
					}
				}
		
				// Set the chart property
				chart[key] = value;	
			});
			
		},

		/**
		 * Link two or more series together. This is done initially from Chart.render,
		 * and after Chart.addSeries and Series.remove.
		 */
		linkSeries: function () {
			var chart = this,
				chartSeries = chart.series;

			// Reset links
			each(chartSeries, function (series) {
				series.linkedSeries.length = 0;
			});

			// Apply new links
			each(chartSeries, function (series) {
				var linkedTo = series.options.linkedTo;
				if (isString(linkedTo)) {
					if (linkedTo === ':previous') {
						linkedTo = chart.series[series.index - 1];
					} else {
						linkedTo = chart.get(linkedTo);
					}
					if (linkedTo) {
						linkedTo.linkedSeries.push(series);
						series.linkedParent = linkedTo;
					}
				}
			});
		},

		/**
		 * Render series for the chart
		 */
		renderSeries: function () {
			each(this.series, function (serie) {
				serie.translate();
				serie.render();
			});
		},
			
		/**
		 * Render labels for the chart
		 */
		renderLabels: function () {
			var chart = this,
				labels = chart.options.labels;
			if (labels.items) {
				each(labels.items, function (label) {
					var style = extend(labels.style, label.style),
						x = pInt(style.left) + chart.plotLeft,
						y = pInt(style.top) + chart.plotTop + 12;

					// delete to prevent rewriting in IE
					delete style.left;
					delete style.top;

					chart.renderer.text(
						label.html,
						x,
						y
					)
					.attr({ zIndex: 2 })
					.css(style)
					.add();

				});
			}
		},

		/**
		 * Render all graphics for the chart
		 */
		render: function () {
			var chart = this,
				axes = chart.axes,
				renderer = chart.renderer,
				options = chart.options,
				tempWidth,
				tempHeight,
				redoHorizontal,
				redoVertical;

			// Title
			chart.setTitle();


			// Legend
			chart.legend = new Legend(chart, options.legend);

			// Get stacks
			if (chart.getStacks) {
				chart.getStacks();
			}

			// Get chart margins
			chart.getMargins(true);
			chart.setChartSize();

			// Record preliminary dimensions for later comparison
			tempWidth = chart.plotWidth;
			tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

			// Get margins by pre-rendering axes
			each(axes, function (axis) {
				axis.setScale();
			});
			chart.getAxisMargins();

			// If the plot area size has changed significantly, calculate tick positions again
			redoHorizontal = tempWidth / chart.plotWidth > 1.1;
			redoVertical = tempHeight / chart.plotHeight > 1.1;

			if (redoHorizontal || redoVertical) {

				chart.maxTicks = null; // reset for second pass
				each(axes, function (axis) {
					if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
						axis.setTickInterval(true); // update to reflect the new margins
					}
				});
				chart.getMargins(); // second pass to check for new labels
			}

			// Draw the borders and backgrounds
			chart.drawChartBox();		


			// Axes
			if (chart.hasCartesianSeries) {
				each(axes, function (axis) {
					axis.render();
				});
			}

			// The series
			if (!chart.seriesGroup) {
				chart.seriesGroup = renderer.g('series-group')
					.attr({ zIndex: 3 })
					.add();
			}
			chart.renderSeries();

			// Labels
			chart.renderLabels();

			// Credits
			chart.showCredits(options.credits);

			// Set flag
			chart.hasRendered = true;

		},

		/**
		 * Show chart credits based on config options
		 */
		showCredits: function (credits) {
			if (credits.enabled && !this.credits) {
				this.credits = this.renderer.text(
					credits.text,
					0,
					0
				)
				.on('click', function () {
					if (credits.href) {
						location.href = credits.href;
					}
				})
				.attr({
					align: credits.position.align,
					zIndex: 8
				})
				.css(credits.style)
				.add()
				.align(credits.position);
			}
		},

		/**
		 * Clean up memory usage
		 */
		destroy: function () {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				container = chart.container,
				i,
				parentNode = container && container.parentNode;
				
			// fire the chart.destoy event
			fireEvent(chart, 'destroy');
			
			// Delete the chart from charts lookup array
			charts[chart.index] = UNDEFINED;
			chartCount--;
			chart.renderTo.removeAttribute('data-highcharts-chart');

			// remove events
			removeEvent(chart);

			// ==== Destroy collections:
			// Destroy axes
			i = axes.length;
			while (i--) {
				axes[i] = axes[i].destroy();
			}

			// Destroy each series
			i = series.length;
			while (i--) {
				series[i] = series[i].destroy();
			}

			// ==== Destroy chart properties:
			each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
					'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
					'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
				var prop = chart[name];

				if (prop && prop.destroy) {
					chart[name] = prop.destroy();
				}
			});

			// remove container and all SVG
			if (container) { // can break in IE when destroyed before finished loading
				container.innerHTML = '';
				removeEvent(container);
				if (parentNode) {
					discardElement(container);
				}

			}

			// clean it all up
			for (i in chart) {
				delete chart[i];
			}

		},


		/**
		 * VML namespaces can't be added until after complete. Listening
		 * for Perini's doScroll hack is not enough.
		 */
		isReadyToRender: function () {
			var chart = this;

			// Note: in spite of JSLint's complaints, win == win.top is required
			/*jslint eqeq: true*/
			if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
			/*jslint eqeq: false*/
				if (useCanVG) {
					// Delay rendering until canvg library is downloaded and ready
					CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
				} else {
					doc.attachEvent('onreadystatechange', function () {
						doc.detachEvent('onreadystatechange', chart.firstRender);
						if (doc.readyState === 'complete') {
							chart.firstRender();
						}
					});
				}
				return false;
			}
			return true;
		},

		/**
		 * Prepare for first rendering after all data are loaded
		 */
		firstRender: function () {
			var chart = this,
				options = chart.options,
				callback = chart.callback;

			// Check whether the chart is ready to render
			if (!chart.isReadyToRender()) {
				return;
			}

			// Create the container
			chart.getContainer();

			// Run an early event after the container and renderer are established
			fireEvent(chart, 'init');

			
			chart.resetMargins();
			chart.setChartSize();

			// Set the common chart properties (mainly invert) from the given series
			chart.propFromSeries();

			// get axes
			chart.getAxes();

			// Initialize the series
			each(options.series || [], function (serieOptions) {
				chart.initSeries(serieOptions);
			});

			chart.linkSeries();

			// Run an event after axes and series are initialized, but before render. At this stage,
			// the series data is indexed and cached in the xData and yData arrays, so we can access
			// those before rendering. Used in Highstock. 
			fireEvent(chart, 'beforeRender'); 

			// depends on inverted and on margins being set
			if (Highcharts.Pointer) {
				chart.pointer = new Pointer(chart, options);
			}

			chart.render();

			// add canvas
			chart.renderer.draw();
			// run callbacks
			if (callback) {
				callback.apply(chart, [chart]);
			}
			each(chart.callbacks, function (fn) {
				if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
					fn.apply(chart, [chart]);
				}
			});
			
			// Fire the load event
			fireEvent(chart, 'load');		
			
			// If the chart was rendered outside the top container, put it back in (#3679)
			chart.cloneRenderTo(true);

		},

		/**
		* Creates arrays for spacing and margin from given options.
		*/
		splashArray: function (target, options) {
			var oVar = options[target],
				tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

			return [pick(options[target + 'Top'], tArray[0]),
					pick(options[target + 'Right'], tArray[1]),
					pick(options[target + 'Bottom'], tArray[2]),
					pick(options[target + 'Left'], tArray[3])];
		}
	}; // end Chart

	var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
		/**
		 * Get the center of the pie based on the size and center options relative to the  
		 * plot area. Borrowed by the polar and gauge series types.
		 */
		getCenter: function () {
			
			var options = this.options,
				chart = this.chart,
				slicingRoom = 2 * (options.slicedOffset || 0),
				handleSlicingRoom,
				plotWidth = chart.plotWidth - 2 * slicingRoom,
				plotHeight = chart.plotHeight - 2 * slicingRoom,
				centerOption = options.center,
				positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
				smallestSize = mathMin(plotWidth, plotHeight),
				i,
				value;

			for (i = 0; i < 4; ++i) {
				value = positions[i];
				handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));
				
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 3: innerSize, relative to size
				positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
					(handleSlicingRoom ? slicingRoom : 0);

			}
			return positions;
		}
	};

	/**
	 * The Point object and prototype. Inheritable and used as base for PiePoint
	 */
	var Point = function () {};
	Point.prototype = {

		/**
		 * Initialize the point
		 * @param {Object} series The series object containing this point
		 * @param {Object} options The data in either number, array or object format
		 */
		init: function (series, options, x) {

			var point = this,
				colors;
			point.series = series;
			point.color = series.color; // #3445
			point.applyOptions(options, x);
			point.pointAttr = {};

			if (series.options.colorByPoint) {
				colors = series.options.colors || series.chart.options.colors;
				point.color = point.color || colors[series.colorCounter++];
				// loop back to zero
				if (series.colorCounter === colors.length) {
					series.colorCounter = 0;
				}
			}

			series.chart.pointCount++;
			return point;
		},
		/**
		 * Apply the options containing the x and y data and possible some extra properties.
		 * This is called on point init or from point.update.
		 *
		 * @param {Object} options
		 */
		applyOptions: function (options, x) {
			var point = this,
				series = point.series,
				pointValKey = series.options.pointValKey || series.pointValKey;

			options = Point.prototype.optionsToObject.call(this, options);

			// copy options directly to point
			extend(point, options);
			point.options = point.options ? extend(point.options, options) : options;

			// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
			if (pointValKey) {
				point.y = point[pointValKey];
			}

			// If no x is set by now, get auto incremented value. All points must have an
			// x value, however the y value can be null to create a gap in the series
			if (point.x === UNDEFINED && series) {
				point.x = x === UNDEFINED ? series.autoIncrement() : x;
			}

			return point;
		},

		/**
		 * Transform number or array configs into objects
		 */
		optionsToObject: function (options) {
			var ret = {},
				series = this.series,
				keys = series.options.keys,
				pointArrayMap = keys || series.pointArrayMap || ['y'],
				valueCount = pointArrayMap.length,
				firstItemType,
				i = 0,
				j = 0;

			if (typeof options === 'number' || options === null) {
				ret[pointArrayMap[0]] = options;

			} else if (isArray(options)) {
				// with leading x value
				if (!keys && options.length > valueCount) {
					firstItemType = typeof options[0];
					if (firstItemType === 'string') {
						ret.name = options[0];
					} else if (firstItemType === 'number') {
						ret.x = options[0];
					}
					i++;
				}
				while (j < valueCount) {
					ret[pointArrayMap[j++]] = options[i++];
				}
			} else if (typeof options === 'object') {
				ret = options;

				// This is the fastest way to detect if there are individual point dataLabels that need
				// to be considered in drawDataLabels. These can only occur in object configs.
				if (options.dataLabels) {
					series._hasPointLabels = true;
				}

				// Same approach as above for markers
				if (options.marker) {
					series._hasPointMarkers = true;
				}
			}
			return ret;
		},

		/**
		 * Destroy a point to clear memory. Its reference still stays in series.data.
		 */
		destroy: function () {
			var point = this,
				series = point.series,
				chart = series.chart,
				hoverPoints = chart.hoverPoints,
				prop;

			chart.pointCount--;

			if (hoverPoints) {
				point.setState();
				erase(hoverPoints, point);
				if (!hoverPoints.length) {
					chart.hoverPoints = null;
				}

			}
			if (point === chart.hoverPoint) {
				point.onMouseOut();
			}

			// remove all events
			if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
				removeEvent(point);
				point.destroyElements();
			}

			if (point.legendItem) { // pies have legend items
				chart.legend.destroyItem(point);
			}

			for (prop in point) {
				point[prop] = null;
			}


		},

		/**
		 * Destroy SVG elements associated with the point
		 */
		destroyElements: function () {
			var point = this,
				props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
				prop,
				i = 6;
			while (i--) {
				prop = props[i];
				if (point[prop]) {
					point[prop] = point[prop].destroy();
				}
			}
		},

		/**
		 * Return the configuration hash needed for the data label and tooltip formatters
		 */
		getLabelConfig: function () {
			var point = this;
			return {
				x: point.category,
				y: point.y,
				key: point.name || point.category,
				series: point.series,
				point: point,
				percentage: point.percentage,
				total: point.total || point.stackTotal
			};
		},	

		/**
		 * Extendable method for formatting each point's tooltip line
		 *
		 * @return {String} A string to be concatenated in to the common tooltip text
		 */
		tooltipFormatter: function (pointFormat) {

			// Insert options for valueDecimals, valuePrefix, and valueSuffix
			var series = this.series,
				seriesTooltipOptions = series.tooltipOptions,
				valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
				valuePrefix = seriesTooltipOptions.valuePrefix || '',
				valueSuffix = seriesTooltipOptions.valueSuffix || '';

			// Loop over the point array map and replace unformatted values with sprintf formatting markup
			each(series.pointArrayMap || ['y'], function (key) {
				key = '{point.' + key; // without the closing bracket
				if (valuePrefix || valueSuffix) {
					pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
				}
				pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
			});

			return format(pointFormat, {
				point: this,
				series: this.series
			});
		},

		/**
		 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
		 * causes a name clash in MooTools
		 * @param {String} eventType
		 * @param {Object} eventArgs Additional event arguments
		 * @param {Function} defaultFunction Default event handler
		 */
		firePointEvent: function (eventType, eventArgs, defaultFunction) {
			var point = this,
				series = this.series,
				seriesOptions = series.options;

			// load event handlers on demand to save time on mouseover/out
			if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
				this.importEvents();
			}

			// add default handler if in selection mode
			if (eventType === 'click' && seriesOptions.allowPointSelect) {
				defaultFunction = function (event) {
					// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
					if (point.select) { // Could be destroyed by prior event handlers (#2911)
						point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
					}
				};
			}

			fireEvent(this, eventType, eventArgs, defaultFunction);
		}
	};/**
	 * @classDescription The base function which all other series types inherit from. The data in the series is stored
	 * in various arrays.
	 *
	 * - First, series.options.data contains all the original config options for
	 * each point whether added by options or methods like series.addPoint.
	 * - Next, series.data contains those values converted to points, but in case the series data length
	 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
	 * only contains the points that have been created on demand.
	 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
	 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
	 * compared to series.data and series.options.data. If however the series data is grouped, these can't
	 * be correlated one to one.
	 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
	 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
	 *
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Series = Highcharts.Series = function () {};

	Series.prototype = {

		isCartesian: true,
		type: 'line',
		pointClass: Point,
		sorted: true, // requires the data to be sorted
		requireSorting: true,
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'lineColor',
			'stroke-width': 'lineWidth',
			fill: 'fillColor',
			r: 'radius'
		},
		axisTypes: ['xAxis', 'yAxis'],
		colorCounter: 0,
		parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
		init: function (chart, options) {
			var series = this,
				eventType,
				events,
				chartSeries = chart.series,
				sortByIndex = function (a, b) {
					return pick(a.options.index, a._i) - pick(b.options.index, b._i);
				};

			series.chart = chart;
			series.options = options = series.setOptions(options); // merge with plotOptions
			series.linkedSeries = [];

			// bind the axes
			series.bindAxes();

			// set some variables
			extend(series, {
				name: options.name,
				state: NORMAL_STATE,
				pointAttr: {},
				visible: options.visible !== false, // true by default
				selected: options.selected === true // false by default
			});

			// special
			if (useCanVG) {
				options.animation = false;
			}

			// register event listeners
			events = options.events;
			for (eventType in events) {
				addEvent(series, eventType, events[eventType]);
			}
			if (
				(events && events.click) ||
				(options.point && options.point.events && options.point.events.click) ||
				options.allowPointSelect
			) {
				chart.runTrackerClick = true;
			}

			series.getColor();
			series.getSymbol();

			// Set the data
			each(series.parallelArrays, function (key) {
				series[key + 'Data'] = [];
			});
			series.setData(options.data, false);

			// Mark cartesian
			if (series.isCartesian) {
				chart.hasCartesianSeries = true;
			}

			// Register it in the chart
			chartSeries.push(series);
			series._i = chartSeries.length - 1;

			// Sort series according to index option (#248, #1123, #2456)
			stableSort(chartSeries, sortByIndex);
			if (this.yAxis) {
				stableSort(this.yAxis.series, sortByIndex);
			}

			each(chartSeries, function (series, i) {
				series.index = i;
				series.name = series.name || 'Series ' + (i + 1);
			});

		},

		/**
		 * Set the xAxis and yAxis properties of cartesian series, and register the series
		 * in the axis.series array
		 */
		bindAxes: function () {
			var series = this,
				seriesOptions = series.options,
				chart = series.chart,
				axisOptions;

			each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					axisOptions = axis.options;

					// apply if the series xAxis or yAxis option mathches the number of the
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

						// register this series in the axis.series lookup
						axis.series.push(series);

						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;

						// mark dirty for redraw
						axis.isDirty = true;
					}
				});

				// The series needs an X and an Y axis
				if (!series[AXIS] && series.optionalAxis !== AXIS) {
					error(18, true);
				}

			});
		},

		/**
		 * For simple series types like line and column, the data values are held in arrays like
		 * xData and yData for quick lookup to find extremes and more. For multidimensional series
		 * like bubble and map, this can be extended with arrays like zData and valueData by
		 * adding to the series.parallelArrays array.
		 */
		updateParallelArrays: function (point, i) {
			var series = point.series,
				args = arguments,
				fn = typeof i === 'number' ?
					 // Insert the value in the given position
					function (key) {
						var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
						series[key + 'Data'][i] = val;
					} :
					// Apply the method specified in i with the following arguments as arguments
					function (key) {
						Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
					};

			each(series.parallelArrays, fn);
		},

		/**
		 * Return an auto incremented x value based on the pointStart and pointInterval options.
		 * This is only used if an x value is not given for the point that calls autoIncrement.
		 */
		autoIncrement: function () {

			var options = this.options,
				xIncrement = this.xIncrement,
				date,
				pointInterval,
				pointIntervalUnit = options.pointIntervalUnit;
			
			xIncrement = pick(xIncrement, options.pointStart, 0);
			
			this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
			
			// Added code for pointInterval strings
			if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
				date = new Date(xIncrement);
				date = (pointIntervalUnit === 'month') ?
					+date[setMonth](date[getMonth]() + pointInterval) :
					+date[setFullYear](date[getFullYear]() + pointInterval);
				pointInterval = date - xIncrement;
			}
			
			this.xIncrement = xIncrement + pointInterval;
			return xIncrement;
		},

		/**
		 * Divide the series data into segments divided by null values.
		 */
		getSegments: function () {
			var series = this,
				lastNull = -1,
				segments = [],
				i,
				points = series.points,
				pointsLength = points.length;

			if (pointsLength) { // no action required for []

				// if connect nulls, just remove null points
				if (series.options.connectNulls) {
					i = pointsLength;
					while (i--) {
						if (points[i].y === null) {
							points.splice(i, 1);
						}
					}
					if (points.length) {
						segments = [points];
					}

				// else, split on null points
				} else {
					each(points, function (point, i) {
						if (point.y === null) {
							if (i > lastNull + 1) {
								segments.push(points.slice(lastNull + 1, i));
							}
							lastNull = i;
						} else if (i === pointsLength - 1) { // last value
							segments.push(points.slice(lastNull + 1, i + 1));
						}
					});
				}
			}

			// register it
			series.segments = segments;
		},

		/**
		 * Set the series options by merging from the options tree
		 * @param {Object} itemOptions
		 */
		setOptions: function (itemOptions) {
			var chart = this.chart,
				chartOptions = chart.options,
				plotOptions = chartOptions.plotOptions,
				userOptions = chart.userOptions || {},
				userPlotOptions = userOptions.plotOptions || {},
				typeOptions = plotOptions[this.type],
				options,
				zones;

			this.userOptions = itemOptions;

			// General series options take precedence over type options because otherwise, default
			// type options like column.animation would be overwritten by the general option.
			// But issues have been raised here (#3881), and the solution may be to distinguish 
			// between default option and userOptions like in the tooltip below.
			options = merge(
				typeOptions,
				plotOptions.series,
				itemOptions
			);

			// The tooltip options are merged between global and series specific options
			this.tooltipOptions = merge(
				defaultOptions.tooltip,
				defaultOptions.plotOptions[this.type].tooltip,
				userOptions.tooltip,
				userPlotOptions.series && userPlotOptions.series.tooltip,
				userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
				itemOptions.tooltip
			);

			// Delete marker object if not allowed (#1125)
			if (typeOptions.marker === null) {
				delete options.marker;
			}

			// Handle color zones
			this.zoneAxis = options.zoneAxis;
			zones = this.zones = (options.zones || []).slice();
			if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
				zones.push({
					value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
					color: options.negativeColor,
					fillColor: options.negativeFillColor
				});
			}
			if (zones.length) { // Push one extra zone for the rest
				if (defined(zones[zones.length - 1].value)) {
					zones.push({
						color: this.color,
						fillColor: this.fillColor
					});
				}
			}
			return options;
		},

		getCyclic: function (prop, value, defaults) {
			var i,
				userOptions = this.userOptions,
				indexName = '_' + prop + 'Index',
				counterName = prop + 'Counter';

			if (!value) {
				if (defined(userOptions[indexName])) { // after Series.update()
					i = userOptions[indexName];
				} else {
					userOptions[indexName] = i = this.chart[counterName] % defaults.length;
					this.chart[counterName] += 1;
				}
				value = defaults[i];
			}
			this[prop] = value;
		},

		/**
		 * Get the series' color
		 */
		getColor: function () {
			if (!this.options.colorByPoint) {
				this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
			}
		},
		/**
		 * Get the series' symbol
		 */
		getSymbol: function () {
			var seriesMarkerOption = this.options.marker;

			this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

			// don't substract radius in image symbols (#604)
			if (/^url/.test(this.symbol)) {
				seriesMarkerOption.radius = 0;
			}
		},

		drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

		/**
		 * Replace the series data with a new set of data
		 * @param {Object} data
		 * @param {Object} redraw
		 */
		setData: function (data, redraw, animation, updatePoints) {
			var series = this,
				oldData = series.points,
				oldDataLength = (oldData && oldData.length) || 0,
				dataLength,
				options = series.options,
				chart = series.chart,
				firstPoint = null,
				xAxis = series.xAxis,
				hasCategories = xAxis && !!xAxis.categories,
				i,
				turboThreshold = options.turboThreshold,
				pt,
				xData = this.xData,
				yData = this.yData,
				pointArrayMap = series.pointArrayMap,
				valueCount = pointArrayMap && pointArrayMap.length;

			data = data || [];
			dataLength = data.length;
			redraw = pick(redraw, true);

			// If the point count is the same as is was, just run Point.update which is
			// cheaper, allows animation, and keeps references to points.
			if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
				each(data, function (point, i) {
					if (oldData[i].update) { // Linked, previously hidden series (#3709)
						oldData[i].update(point, false, null, false);
					}
				});

			} else {

				// Reset properties
				series.xIncrement = null;
				series.pointRange = hasCategories ? 1 : options.pointRange;

				series.colorCounter = 0; // for series with colorByPoint (#1547)
				
				// Update parallel arrays
				each(this.parallelArrays, function (key) {
					series[key + 'Data'].length = 0;
				});

				// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
				// first value is tested, and we assume that all the rest are defined the same
				// way. Although the 'for' loops are similar, they are repeated inside each
				// if-else conditional for max performance.
				if (turboThreshold && dataLength > turboThreshold) {

					// find the first non-null point
					i = 0;
					while (firstPoint === null && i < dataLength) {
						firstPoint = data[i];
						i++;
					}


					if (isNumber(firstPoint)) { // assume all points are numbers
						var x = pick(options.pointStart, 0),
							pointInterval = pick(options.pointInterval, 1);

						for (i = 0; i < dataLength; i++) {
							xData[i] = x;
							yData[i] = data[i];
							x += pointInterval;
						}
						series.xIncrement = x;
					} else if (isArray(firstPoint)) { // assume all points are arrays
						if (valueCount) { // [x, low, high] or [x, o, h, l, c]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt.slice(1, valueCount + 1);
							}
						} else { // [x, y]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt[1];
							}
						}
					} else {
						error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
					}
				} else {
					for (i = 0; i < dataLength; i++) {
						if (data[i] !== UNDEFINED) { // stray commas in oldIE
							pt = { series: series };
							series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
							series.updateParallelArrays(pt, i);
							if (hasCategories && pt.name) {
								xAxis.names[pt.x] = pt.name; // #2046
							}
						}
					}
				}

				// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
				if (isString(yData[0])) {
					error(14, true);
				}

				series.data = [];
				series.options.data = data;
				//series.zData = zData;

				// destroy old points
				i = oldDataLength;
				while (i--) {
					if (oldData[i] && oldData[i].destroy) {
						oldData[i].destroy();
					}
				}

				// reset minRange (#878)
				if (xAxis) {
					xAxis.minRange = xAxis.userMinRange;
				}

				// redraw
				series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
				animation = false;
			}

			if (redraw) {
				chart.redraw(animation);
			}
		},

		/**
		 * Process the data by cropping away unused data points if the series is longer
		 * than the crop threshold. This saves computing time for lage series.
		 */
		processData: function (force) {
			var series = this,
				processedXData = series.xData, // copied during slice operation below
				processedYData = series.yData,
				dataLength = processedXData.length,
				croppedData,
				cropStart = 0,
				cropped,
				distance,
				closestPointRange,
				xAxis = series.xAxis,
				i, // loop variable
				options = series.options,
				cropThreshold = options.cropThreshold,
				isCartesian = series.isCartesian,
				xExtremes,
				min,
				max;

			// If the series data or axes haven't changed, don't go through this. Return false to pass
			// the message on to override methods like in data grouping.
			if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
				return false;
			}

			if (xAxis) {
				xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
				min = xExtremes.min;
				max = xExtremes.max;
			}

			// optionally filter out points outside the plot area
			if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
				
				// it's outside current extremes
				if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
					processedXData = [];
					processedYData = [];

				// only crop if it's actually spilling out
				} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
					croppedData = this.cropData(series.xData, series.yData, min, max);
					processedXData = croppedData.xData;
					processedYData = croppedData.yData;
					cropStart = croppedData.start;
					cropped = true;
				}
			}


			// Find the closest distance between processed points
			for (i = processedXData.length - 1; i >= 0; i--) {
				distance = processedXData[i] - processedXData[i - 1];
				
				if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
					closestPointRange = distance;

				// Unsorted data is not supported by the line tooltip, as well as data grouping and
				// navigation in Stock charts (#725) and width calculation of columns (#1900)
				} else if (distance < 0 && series.requireSorting) {
					error(15);
				}
			}

			// Record the properties
			series.cropped = cropped; // undefined or true
			series.cropStart = cropStart;
			series.processedXData = processedXData;
			series.processedYData = processedYData;

			if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
				series.pointRange = closestPointRange || 1;
			}
			series.closestPointRange = closestPointRange;

		},

		/**
		 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
		 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
		 */
		cropData: function (xData, yData, min, max) {
			var dataLength = xData.length,
				cropStart = 0,
				cropEnd = dataLength,
				cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
				i;

			// iterate up to find slice start
			for (i = 0; i < dataLength; i++) {
				if (xData[i] >= min) {
					cropStart = mathMax(0, i - cropShoulder);
					break;
				}
			}

			// proceed to find slice end
			for (; i < dataLength; i++) {
				if (xData[i] > max) {
					cropEnd = i + cropShoulder;
					break;
				}
			}

			return {
				xData: xData.slice(cropStart, cropEnd),
				yData: yData.slice(cropStart, cropEnd),
				start: cropStart,
				end: cropEnd
			};
		},


		/**
		 * Generate the data point after the data has been processed by cropping away
		 * unused points and optionally grouped in Highcharts Stock.
		 */
		generatePoints: function () {
			var series = this,
				options = series.options,
				dataOptions = options.data,
				data = series.data,
				dataLength,
				processedXData = series.processedXData,
				processedYData = series.processedYData,
				pointClass = series.pointClass,
				processedDataLength = processedXData.length,
				cropStart = series.cropStart || 0,
				cursor,
				hasGroupedData = series.hasGroupedData,
				point,
				points = [],
				i;

			if (!data && !hasGroupedData) {
				var arr = [];
				arr.length = dataOptions.length;
				data = series.data = arr;
			}

			for (i = 0; i < processedDataLength; i++) {
				cursor = cropStart + i;
				if (!hasGroupedData) {
					if (data[cursor]) {
						point = data[cursor];
					} else if (dataOptions[cursor] !== UNDEFINED) { // #970
						data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
					}
					points[i] = point;
				} else {
					// splat the y data in case of ohlc data array
					points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
				}
				points[i].index = cursor; // For faster access in Point.update
			}

			// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
			// swithching view from non-grouped data to grouped data (#637)
			if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
				for (i = 0; i < dataLength; i++) {
					if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
						i += processedDataLength;
					}
					if (data[i]) {
						data[i].destroyElements();
						data[i].plotX = UNDEFINED; // #1003
					}
				}
			}

			series.data = data;
			series.points = points;
		},

		/**
		 * Calculate Y extremes for visible data
		 */
		getExtremes: function (yData) {
			var xAxis = this.xAxis,
				yAxis = this.yAxis,
				xData = this.processedXData,
				yDataLength,
				activeYData = [],
				activeCounter = 0,
				xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
				xMin = xExtremes.min,
				xMax = xExtremes.max,
				validValue,
				withinRange,
				x,
				y,
				i,
				j;

			yData = yData || this.stackedYData || this.processedYData;
			yDataLength = yData.length;

			for (i = 0; i < yDataLength; i++) {

				x = xData[i];
				y = yData[i];

				// For points within the visible range, including the first point outside the
				// visible range, consider y extremes
				validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
				withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
					((xData[i + 1] || x) >= xMin &&	(xData[i - 1] || x) <= xMax);

				if (validValue && withinRange) {

					j = y.length;
					if (j) { // array, like ohlc or range data
						while (j--) {
							if (y[j] !== null) {
								activeYData[activeCounter++] = y[j];
							}
						}
					} else {
						activeYData[activeCounter++] = y;
					}
				}
			}
			this.dataMin = arrayMin(activeYData);
			this.dataMax = arrayMax(activeYData);
		},

		/**
		 * Translate data points from raw data values to chart specific positioning data
		 * needed later in drawPoints, drawGraph and drawTracker.
		 */
		translate: function () {
			if (!this.processedXData) { // hidden series
				this.processData();
			}
			this.generatePoints();
			var series = this,
				options = series.options,
				stacking = options.stacking,
				xAxis = series.xAxis,
				categories = xAxis.categories,
				yAxis = series.yAxis,
				points = series.points,
				dataLength = points.length,
				hasModifyValue = !!series.modifyValue,
				i,
				pointPlacement = options.pointPlacement,
				dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
				threshold = options.threshold,
				stackThreshold = options.startFromThreshold ? threshold : 0,
				plotX,
				plotY,
				lastPlotX,
				closestPointRangePx = Number.MAX_VALUE;

			// Translate each point
			for (i = 0; i < dataLength; i++) {
				var point = points[i],
					xValue = point.x,
					yValue = point.y,
					yBottom = point.low,
					stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
					pointStack,
					stackValues;

				// Discard disallowed y values for log axes (#3434)
				if (yAxis.isLog && yValue !== null && yValue <= 0) {
					point.y = yValue = null;
					error(10);
				}

				// Get the plotX translation
				point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923


				// Calculate the bottom y value for stacked series
				if (stacking && series.visible && stack && stack[xValue]) {

					pointStack = stack[xValue];
					stackValues = pointStack.points[series.index + ',' + i];
					yBottom = stackValues[0];
					yValue = stackValues[1];

					if (yBottom === stackThreshold) {
						yBottom = pick(threshold, yAxis.min);
					}
					if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
						yBottom = null;
					}

					point.total = point.stackTotal = pointStack.total;
					point.percentage = pointStack.total && (point.y / pointStack.total * 100);
					point.stackY = yValue;

					// Place the stack label
					pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

				}

				// Set translated yBottom or remove it
				point.yBottom = defined(yBottom) ?
					yAxis.translate(yBottom, 0, 1, 0, 1) :
					null;

				// general hook, used for Highstock compare mode
				if (hasModifyValue) {
					yValue = series.modifyValue(yValue, point);
				}

				// Set the the plotY value, reset it for redraws
				point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
					mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
					UNDEFINED;
				point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
					plotX >= 0 && plotX <= xAxis.len;


				// Set client related positions for mouse tracking
				point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

				point.negative = point.y < (threshold || 0);

				// some API data
				point.category = categories && categories[point.x] !== UNDEFINED ?
					categories[point.x] : point.x;

				// Determine auto enabling of markers (#3635)
				if (i) {
					closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
				}
				lastPlotX = plotX;

			}

			series.closestPointRangePx = closestPointRangePx;

			// now that we have the cropped data, build the segments
			series.getSegments();
		},

		/**
		 * Set the clipping for the series. For animated series it is called twice, first to initiate
		 * animating the clip then the second time without the animation to set the final clip.
		 */
		setClip: function (animation) {
			var chart = this.chart,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesClipBox = this.clipBox,
				clipBox = seriesClipBox || chart.clipBox,
				sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
				clipRect = chart[sharedClipKey],
				markerClipRect = chart[sharedClipKey + 'm'];

			// If a clipping rectangle with the same properties is currently present in the chart, use that.
			if (!clipRect) {

				// When animation is set, prepare the initial positions
				if (animation) { 
					clipBox.width = 0;

					chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
						-99, // include the width of the first marker
						inverted ? -chart.plotLeft : -chart.plotTop,
						99,
						inverted ? chart.chartWidth : chart.chartHeight
					);
				}
				chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
				
			}
			if (animation) {
				clipRect.count += 1;
			}

			if (this.options.clip !== false) {
				this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
				this.markerGroup.clip(markerClipRect);
				this.sharedClipKey = sharedClipKey;
			}

			// Remove the shared clipping rectangle when all series are shown
			if (!animation) {
				clipRect.count -= 1;
				if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
					if (!seriesClipBox) {
						chart[sharedClipKey] = chart[sharedClipKey].destroy();
					}
					if (chart[sharedClipKey + 'm']) {
						chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
					}
				}
			}
		},

		/**
		 * Animate in the series
		 */
		animate: function (init) {
			var series = this,
				chart = series.chart,
				clipRect,
				animation = series.options.animation,
				sharedClipKey;

			// Animation option is set to true
			if (animation && !isObject(animation)) {
				animation = defaultPlotOptions[series.type].animation;
			}

			// Initialize the animation. Set up the clipping rectangle.
			if (init) {

				series.setClip(animation);

			// Run the animation
			} else {
				sharedClipKey = this.sharedClipKey;
				clipRect = chart[sharedClipKey];
				if (clipRect) {
					clipRect.animate({
						width: chart.plotSizeX
					}, animation);
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'].animate({
						width: chart.plotSizeX + 99
					}, animation);
				}

				// Delete this function to allow it only once
				series.animate = null;
	 
			}
		},

		/**
		 * This runs after animation to land on the final plot clipping
		 */
		afterAnimate: function () {
			this.setClip();
			fireEvent(this, 'afterAnimate');
		},

		/**
		 * Draw the markers
		 */
		drawPoints: function () {
			var series = this,
				pointAttr,
				points = series.points,
				chart = series.chart,
				plotX,
				plotY,
				i,
				point,
				radius,
				symbol,
				isImage,
				graphic,
				options = series.options,
				seriesMarkerOptions = options.marker,
				seriesPointAttr = series.pointAttr[''],
				pointMarkerOptions,
				hasPointMarker,
				enabled,
				isInside,
				markerGroup = series.markerGroup,
				xAxis = series.xAxis,
				globallyEnabled = pick(
					seriesMarkerOptions.enabled, 
					xAxis.isRadial,
					series.closestPointRangePx > 2 * seriesMarkerOptions.radius
				);

			if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

				i = points.length;
				while (i--) {
					point = points[i];
					plotX = mathFloor(point.plotX); // #1843
					plotY = point.plotY;
					graphic = point.graphic;
					pointMarkerOptions = point.marker || {};
					hasPointMarker = !!point.marker;
					enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
					isInside = point.isInside;

					// only draw the point if y is defined
					if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

						// shortcuts
						pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
						radius = pointAttr.r;
						symbol = pick(pointMarkerOptions.symbol, series.symbol);
						isImage = symbol.indexOf('url') === 0;

						if (graphic) { // update
							graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
								.animate(extend({
									x: plotX - radius,
									y: plotY - radius
								}, graphic.symbolName ? { // don't apply to image symbols #507
									width: 2 * radius,
									height: 2 * radius
								} : {}));
						} else if (isInside && (radius > 0 || isImage)) {
							point.graphic = graphic = chart.renderer.symbol(
								symbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius,
								hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
							)
							.attr(pointAttr)
							.add(markerGroup);
						}

					} else if (graphic) {
						point.graphic = graphic.destroy(); // #1269
					}
				}
			}

		},

		/**
		 * Convert state properties from API naming conventions to SVG attributes
		 *
		 * @param {Object} options API options object
		 * @param {Object} base1 SVG attribute object to inherit from
		 * @param {Object} base2 Second level SVG attribute object to inherit from
		 */
		convertAttribs: function (options, base1, base2, base3) {
			var conversion = this.pointAttrToOptions,
				attr,
				option,
				obj = {};

			options = options || {};
			base1 = base1 || {};
			base2 = base2 || {};
			base3 = base3 || {};

			for (attr in conversion) {
				option = conversion[attr];
				obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
			}
			return obj;
		},

		/**
		 * Get the state attributes. Each series type has its own set of attributes
		 * that are allowed to change on a point's state change. Series wide attributes are stored for
		 * all series, and additionally point specific attributes are stored for all
		 * points with individual marker options. If such options are not defined for the point,
		 * a reference to the series wide attributes is stored in point.pointAttr.
		 */
		getAttribs: function () {
			var series = this,
				seriesOptions = series.options,
				normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
				stateOptions = normalOptions.states,
				stateOptionsHover = stateOptions[HOVER_STATE],
				pointStateOptionsHover,
				seriesColor = series.color,
				seriesNegativeColor = series.options.negativeColor,
				normalDefaults = {
					stroke: seriesColor,
					fill: seriesColor
				},
				points = series.points || [], // #927
				i,
				point,
				seriesPointAttr = [],
				pointAttr,
				pointAttrToOptions = series.pointAttrToOptions,
				hasPointSpecificOptions = series.hasPointSpecificOptions,
				defaultLineColor = normalOptions.lineColor,
				defaultFillColor = normalOptions.fillColor,
				turboThreshold = seriesOptions.turboThreshold,
				zones = series.zones,
				zoneAxis = series.zoneAxis || 'y',
				attr,
				key;

			// series type specific modifications
			if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

				// if no hover radius is given, default to normal radius + 2
				stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
				stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

			} else { // column, bar, pie

				// if no hover color is given, brighten the normal color
				stateOptionsHover.color = stateOptionsHover.color ||
					Color(stateOptionsHover.color || seriesColor)
						.brighten(stateOptionsHover.brightness).get();

				// if no hover negativeColor is given, brighten the normal negativeColor
				stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
					Color(stateOptionsHover.negativeColor || seriesNegativeColor)
						.brighten(stateOptionsHover.brightness).get();
			}

			// general point attributes for the series normal state
			seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

			// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
			each([HOVER_STATE, SELECT_STATE], function (state) {
				seriesPointAttr[state] =
						series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
			});

			// set it
			series.pointAttr = seriesPointAttr;


			// Generate the point-specific attribute collections if specific point
			// options are given. If not, create a referance to the series wide point
			// attributes
			i = points.length;
			if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
				while (i--) {
					point = points[i];
					normalOptions = (point.options && point.options.marker) || point.options;
					if (normalOptions && normalOptions.enabled === false) {
						normalOptions.radius = 0;
					}

					if (zones.length) {
						var j = 0,
							threshold = zones[j];
						while (point[zoneAxis] >= threshold.value) {				
							threshold = zones[++j];
						}
						
						point.color = point.fillColor = threshold.color;
					}

					hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

					// check if the point has specific visual options
					if (point.options) {
						for (key in pointAttrToOptions) {
							if (defined(normalOptions[pointAttrToOptions[key]])) {
								hasPointSpecificOptions = true;
							}
						}
					}

					// a specific marker config object is defined for the individual point:
					// create it's own attribute collection
					if (hasPointSpecificOptions) {
						normalOptions = normalOptions || {};
						pointAttr = [];
						stateOptions = normalOptions.states || {}; // reassign for individual point
						pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

						// Handle colors for column and pies
						if (!seriesOptions.marker) { // column, bar, point
							// If no hover color is given, brighten the normal color. #1619, #2579
							pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
								Color(point.color)
									.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
									.get();
						}

						// normal point state inherits series wide normal state
						attr = { color: point.color }; // #868
						if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
							attr.fillColor = point.color;
						}
						if (!defaultLineColor) {
							attr.lineColor = point.color; // Bubbles take point color, line markers use white
						}
						// Color is explicitly set to null or undefined (#1288, #4068)
						if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
							delete normalOptions.color;
						}
						pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

						// inherit from point normal and series hover
						pointAttr[HOVER_STATE] = series.convertAttribs(
							stateOptions[HOVER_STATE],
							seriesPointAttr[HOVER_STATE],
							pointAttr[NORMAL_STATE]
						);

						// inherit from point normal and series hover
						pointAttr[SELECT_STATE] = series.convertAttribs(
							stateOptions[SELECT_STATE],
							seriesPointAttr[SELECT_STATE],
							pointAttr[NORMAL_STATE]
						);


					// no marker config object is created: copy a reference to the series-wide
					// attribute collection
					} else {
						pointAttr = seriesPointAttr;
					}

					point.pointAttr = pointAttr;
				}
			}
		},

		/**
		 * Clear DOM objects and free up memory
		 */
		destroy: function () {
			var series = this,
				chart = series.chart,
				issue134 = /AppleWebKit\/533/.test(userAgent),
				destroy,
				i,
				data = series.data || [],
				point,
				prop,
				axis;

			// add event hook
			fireEvent(series, 'destroy');

			// remove all events
			removeEvent(series);

			// erase from axes
			each(series.axisTypes || [], function (AXIS) {
				axis = series[AXIS];
				if (axis) {
					erase(axis.series, series);
					axis.isDirty = axis.forceRedraw = true;
				}
			});

			// remove legend items
			if (series.legendItem) {
				series.chart.legend.destroyItem(series);
			}

			// destroy all points with their elements
			i = data.length;
			while (i--) {
				point = data[i];
				if (point && point.destroy) {
					point.destroy();
				}
			}
			series.points = null;

			// Clear the animation timeout if we are destroying the series during initial animation
			clearTimeout(series.animationTimeout);

			// Destroy all SVGElements associated to the series
			for (prop in series) {
				if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

					// issue 134 workaround
					destroy = issue134 && prop === 'group' ?
						'hide' :
						'destroy';

					series[prop][destroy]();
				}
			}

			// remove from hoverSeries
			if (chart.hoverSeries === series) {
				chart.hoverSeries = null;
			}
			erase(chart.series, series);

			// clear all members
			for (prop in series) {
				delete series[prop];
			}
		},

		/**
		 * Return the graph path of a segment
		 */
		getSegmentPath: function (segment) {
			var series = this,
				segmentPath = [],
				step = series.options.step;

			// build the segment line
			each(segment, function (point, i) {

				var plotX = point.plotX,
					plotY = point.plotY,
					lastPoint;

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (step && i) {
						lastPoint = segment[i - 1];
						if (step === 'right') {
							segmentPath.push(
								lastPoint.plotX,
								plotY
							);

						} else if (step === 'center') {
							segmentPath.push(
								(lastPoint.plotX + plotX) / 2,
								lastPoint.plotY,
								(lastPoint.plotX + plotX) / 2,
								plotY
							);

						} else {
							segmentPath.push(
								plotX,
								lastPoint.plotY
							);
						}
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			return segmentPath;
		},

		/**
		 * Get the graph path
		 */
		getGraphPath: function () {
			var series = this,
				graphPath = [],
				segmentPath,
				singlePoints = []; // used in drawTracker

			// Divide into segments and build graph and area paths
			each(series.segments, function (segment) {

				segmentPath = series.getSegmentPath(segment);

				// add the segment to the graph, or a single point for tracking
				if (segment.length > 1) {
					graphPath = graphPath.concat(segmentPath);
				} else {
					singlePoints.push(segment[0]);
				}
			});

			// Record it for use in drawGraph and drawTracker, and return graphPath
			series.singlePoints = singlePoints;
			series.graphPath = graphPath;

			return graphPath;

		},

		/**
		 * Draw the actual graph
		 */
		drawGraph: function () {
			var series = this,
				options = this.options,
				props = [['graph', options.lineColor || this.color, options.dashStyle]],
				lineWidth = options.lineWidth,
				roundCap = options.linecap !== 'square',
				graphPath = this.getGraphPath(),
				fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
				zones = this.zones;

			each(zones, function (threshold, i) {
				props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
			});
			
			// Draw the graph
			each(props, function (prop, i) {
				var graphKey = prop[0],
					graph = series[graphKey],
					attribs;

				if (graph) {
					stop(graph); // cancel running animations, #459
					graph.animate({ d: graphPath });

				} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
					attribs = {
						stroke: prop[1],
						'stroke-width': lineWidth,
						fill: fillColor,
						zIndex: 1 // #1069
					};
					if (prop[2]) {
						attribs.dashstyle = prop[2];
					} else if (roundCap) {
						attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
					}

					series[graphKey] = series.chart.renderer.path(graphPath)
						.attr(attribs)
						.add(series.group)
						.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
				}
			});
		},

		/**
		 * Clip the graphs into the positive and negative coloured graphs
		 */
		applyZones: function () {
			var series = this,
				chart = this.chart,
				renderer = chart.renderer,
				zones = this.zones,
				translatedFrom,
				translatedTo,
				clips = this.clips || [],
				clipAttr,
				graph = this.graph,
				area = this.area,
				chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
				zoneAxis = this.zoneAxis || 'y',
				axis = this[zoneAxis + 'Axis'],
				extremes,
				reversed = axis.reversed,
				inverted = chart.inverted,
				horiz = axis.horiz,
				pxRange,
				pxPosMin,
				pxPosMax,
				ignoreZones = false;

			if (zones.length && (graph || area)) {
				// The use of the Color Threshold assumes there are no gaps
				// so it is safe to hide the original graph and area
				if (graph) {
					graph.hide();
				}
				if (area) { 
					area.hide(); 
				}

				// Create the clips
				extremes = axis.getExtremes();
				each(zones, function (threshold, i) {

					translatedFrom = reversed ? 
						(horiz ? chart.plotWidth : 0) : 
						(horiz ? 0 : axis.toPixels(extremes.min));
					translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
					translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);
					
					if (ignoreZones) {
						translatedFrom = translatedTo = axis.toPixels(extremes.max);
					}

					pxRange = Math.abs(translatedFrom - translatedTo);
					pxPosMin = mathMin(translatedFrom, translatedTo);
					pxPosMax = mathMax(translatedFrom, translatedTo);
					if (axis.isXAxis) {
						clipAttr = {
							x: inverted ? pxPosMax : pxPosMin,
							y: 0,
							width: pxRange, 
							height: chartSizeMax
						};
						if (!horiz) {
							clipAttr.x = chart.plotHeight - clipAttr.x;
						}
					} else {
						clipAttr = {
							x: 0,
							y: inverted ? pxPosMax : pxPosMin,
							width: chartSizeMax, 
							height: pxRange
						};					
						if (horiz) {
							clipAttr.y = chart.plotWidth - clipAttr.y;
						}
					}

					/// VML SUPPPORT
					if (chart.inverted && renderer.isVML) {
						if (axis.isXAxis) {			
							clipAttr = {
								x: 0,
								y: reversed ? pxPosMin : pxPosMax,
								height: clipAttr.width,
								width: chart.chartWidth
							};		
						} else {				
							clipAttr = {
								x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
								y: 0,
								width: clipAttr.height,
								height: chart.chartHeight
							};	
						}				
					}
					/// END OF VML SUPPORT

					if (clips[i]) {
						clips[i].animate(clipAttr);
					} else {
						clips[i] = renderer.clipRect(clipAttr);

						if (graph) {
							series['zoneGraph' + i].clip(clips[i]);
						}

						if (area) {
							series['zoneArea' + i].clip(clips[i]);
						}
					}
					// if this zone extends out of the axis, ignore the others
					ignoreZones = threshold.value > extremes.max;
				});
				this.clips = clips;
			}
		},

		/**
		 * Initialize and perform group inversion on series.group and series.markerGroup
		 */
		invertGroups: function () {
			var series = this,
				chart = series.chart;

			// Pie, go away (#1736)
			if (!series.xAxis) {
				return;
			}

			// A fixed size is needed for inversion to work
			function setInvert() {
				var size = {
					width: series.yAxis.len,
					height: series.xAxis.len
				};

				each(['group', 'markerGroup'], function (groupName) {
					if (series[groupName]) {
						series[groupName].attr(size).invert();
					}
				});
			}

			addEvent(chart, 'resize', setInvert); // do it on resize
			addEvent(series, 'destroy', function () {
				removeEvent(chart, 'resize', setInvert);
			});

			// Do it now
			setInvert(); // do it now

			// On subsequent render and redraw, just do setInvert without setting up events again
			series.invertGroups = setInvert;
		},

		/**
		 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
		 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
		 */
		plotGroup: function (prop, name, visibility, zIndex, parent) {
			var group = this[prop],
				isNew = !group;

			// Generate it on first call
			if (isNew) {
				this[prop] = group = this.chart.renderer.g(name)
					.attr({
						visibility: visibility,
						zIndex: zIndex || 0.1 // IE8 needs this
					})
					.add(parent);
			}
			// Place it on first and subsequent (redraw) calls
			group[isNew ? 'attr' : 'animate'](this.getPlotBox());
			return group;
		},

		/**
		 * Get the translation and scale for the plot area of this series
		 */
		getPlotBox: function () {
			var chart = this.chart,
				xAxis = this.xAxis,
				yAxis = this.yAxis;

			// Swap axes for inverted (#2339)
			if (chart.inverted) {
				xAxis = yAxis;
				yAxis = this.xAxis;
			}
			return {
				translateX: xAxis ? xAxis.left : chart.plotLeft,
				translateY: yAxis ? yAxis.top : chart.plotTop,
				scaleX: 1, // #1623
				scaleY: 1
			};
		},

		/**
		 * Render the graph and markers
		 */
		render: function () {
			var series = this,
				chart = series.chart,
				group,
				options = series.options,
				animation = options.animation,
				// Animation doesn't work in IE8 quirks when the group div is hidden,
				// and looks bad in other oldIE
				animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
				visibility = series.visible ? VISIBLE : HIDDEN,
				zIndex = options.zIndex,
				hasRendered = series.hasRendered,
				chartSeriesGroup = chart.seriesGroup;

			// the group
			group = series.plotGroup(
				'group',
				'series',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			series.markerGroup = series.plotGroup(
				'markerGroup',
				'markers',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			// initiate the animation
			if (animDuration) {
				series.animate(true);
			}

			// cache attributes for shapes
			series.getAttribs();

			// SVGRenderer needs to know this before drawing elements (#1089, #1795)
			group.inverted = series.isCartesian ? chart.inverted : false;

			// draw the graph if any
			if (series.drawGraph) {
				series.drawGraph();
				series.applyZones();
			}

			each(series.points, function (point) {
				if (point.redraw) {
					point.redraw();
				}
			});

			// draw the data labels (inn pies they go before the points)
			if (series.drawDataLabels) {
				series.drawDataLabels();
			}

			// draw the points
			if (series.visible) {
				series.drawPoints();
			}


			// draw the mouse tracking area
			if (series.drawTracker && series.options.enableMouseTracking !== false) {
				series.drawTracker();
			}

			// Handle inverted series and tracker groups
			if (chart.inverted) {
				series.invertGroups();
			}

			// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
			if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
				group.clip(chart.clipRect);
			}

			// Run the animation
			if (animDuration) {
				series.animate();
			} 

			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
			// which should be available to the user).
			if (!hasRendered) {
				if (animDuration) {
					series.animationTimeout = setTimeout(function () {
						series.afterAnimate();
					}, animDuration);
				} else {
					series.afterAnimate();
				}
			}

			series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			series.hasRendered = true;
		},

		/**
		 * Redraw the series after an update in the axes.
		 */
		redraw: function () {
			var series = this,
				chart = series.chart,
				wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
				wasDirty = series.isDirty,
				group = series.group,
				xAxis = series.xAxis,
				yAxis = series.yAxis;

			// reposition on resize
			if (group) {
				if (chart.inverted) {
					group.attr({
						width: chart.plotWidth,
						height: chart.plotHeight
					});
				}

				group.animate({
					translateX: pick(xAxis && xAxis.left, chart.plotLeft),
					translateY: pick(yAxis && yAxis.top, chart.plotTop)
				});
			}

			series.translate();
			series.render();
			if (wasDirtyData) {
				fireEvent(series, 'updatedData');
			}
			if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
				delete this.kdTree; // #3868 recalculate the kdtree with dirty data
			}
		},

		/**
		 * KD Tree && PointSearching Implementation
		 */

		kdDimensions: 1,
		kdAxisArray: ['clientX', 'plotY'],

		searchPoint: function (e, compareX) {
			var series = this,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				inverted = series.chart.inverted;
			
			return this.searchKDTree({
				clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
				plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
			}, compareX);
		},

		buildKDTree: function () {
			var series = this,
				dimensions = series.kdDimensions;

			// Internal function
			function _kdtree(points, depth, dimensions) {
				var axis, median, length = points && points.length;

				if (length) {

					// alternate between the axis
					axis = series.kdAxisArray[depth % dimensions];

					// sort point array
					points.sort(function(a, b) {
						return a[axis] - b[axis];
					});
				
					median = Math.floor(length / 2);
					
					// build and return nod
					return {
						point: points[median],
						left: _kdtree(points.slice(0, median), depth + 1, dimensions),
						right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
					};
				
				}
			}

			// Start the recursive build process with a clone of the points array and null points filtered out (#3873)
			function startRecursive() {
				var points = grep(series.points, function (point) {
					return point.y !== null;
				});

				series.kdTree = _kdtree(points, dimensions, dimensions);
			}
			delete series.kdTree;
			
			if (series.options.kdSync) {  // For testing tooltips, don't build async
				startRecursive();
			} else {
				setTimeout(startRecursive);
			}
		},

		searchKDTree: function (point, compareX) {
			var series = this,
				kdX = this.kdAxisArray[0],
				kdY = this.kdAxisArray[1],
				kdComparer = compareX ? 'distX' : 'dist';

			// Set the one and two dimensional distance on the point object
			function setDistance(p1, p2) {
				var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
					y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
					r = (x || 0) + (y || 0);

				p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
				p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
			}
			function _search(search, tree, depth, dimensions) {
				var point = tree.point,
					axis = series.kdAxisArray[depth % dimensions],
					tdist,
					sideA,
					sideB,
					ret = point,
					nPoint1,
					nPoint2;
				
				setDistance(search, point);

				// Pick side based on distance to splitting point
				tdist = search[axis] - point[axis];
				sideA = tdist < 0 ? 'left' : 'right';
				sideB = tdist < 0 ? 'right' : 'left';

				// End of tree
				if (tree[sideA]) {
					nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

					ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
				} 
				if (tree[sideB]) {
					// compare distance to current best to splitting point to decide wether to check side B or not
					if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
						nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
						ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
					}
				}
				
				return ret;
			}

			if (!this.kdTree) {
				this.buildKDTree();
			}

			if (this.kdTree) {
				return _search(point, 
					this.kdTree, this.kdDimensions, this.kdDimensions);
			}
		}

	}; // end Series prototype

	/**
	 * The class for stack items
	 */
	function StackItem(axis, options, isNegative, x, stackOption) {
		
		var inverted = axis.chart.inverted;

		this.axis = axis;

		// Tells if the stack is negative
		this.isNegative = isNegative;

		// Save the options to be able to style the label
		this.options = options;

		// Save the x value to be able to position the label later
		this.x = x;

		// Initialize total value
		this.total = null;

		// This will keep each points' extremes stored by series.index and point index
		this.points = {};

		// Save the stack option on the series configuration object, and whether to treat it as percent
		this.stack = stackOption;

		// The align options and text align varies on whether the stack is negative and
		// if the chart is inverted or not.
		// First test the user supplied value, then use the dynamic.
		this.alignOptions = {
			align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
			verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
			y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
			x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
		};

		this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
	}

	StackItem.prototype = {
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		},

		/**
		 * Renders the stack total label and adds it to the stack label group.
		 */
		render: function (group) {
			var options = this.options,
				formatOption = options.format,
				str = formatOption ?
					format(formatOption, this) : 
					options.formatter.call(this);  // format the text in the label

			// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
			if (this.label) {
				this.label.attr({text: str, visibility: HIDDEN});
			// Create new label
			} else {
				this.label =
					this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
						.css(options.style)				// apply style
						.attr({
							align: this.textAlign,				// fix the text-anchor
							rotation: options.rotation,	// rotation
							visibility: HIDDEN					// hidden until setOffset is called
						})				
						.add(group);							// add to the labels-group
			}
		},

		/**
		 * Sets the offset that the stack has from the x value and repositions the label.
		 */
		setOffset: function (xOffset, xWidth) {
			var stackItem = this,
				axis = stackItem.axis,
				chart = axis.chart,
				inverted = chart.inverted,
				reversed = axis.reversed,
				neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
				y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
				yZero = axis.translate(0),						// stack origin
				h = mathAbs(y - yZero),							// stack height
				x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
				plotHeight = chart.plotHeight,
				stackBox = {	// this is the box for the complete stack
					x: inverted ? (neg ? y : y - h) : x,
					y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
					width: inverted ? h : xWidth,
					height: inverted ? xWidth : h
				},
				label = this.label,
				alignAttr;
			
			if (label) {
				label.align(this.alignOptions, null, stackBox);	// align the label to the box
					
				// Set visibility (#678)
				alignAttr = label.alignAttr;
				label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
			}
		}
	};

	/**
	 * Generate stacks for each series and calculate stacks total values
	 */
	Chart.prototype.getStacks = function () {
		var chart = this;

		// reset stacks for each yAxis
		each(chart.yAxis, function (axis) {
			if (axis.stacks && axis.hasVisibleSeries) {
				axis.oldStacks = axis.stacks;
			}
		});

		each(chart.series, function (series) {
			if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
				series.stackKey = series.type + pick(series.options.stack, '');
			}
		});
	};


	// Stacking methods defined on the Axis prototype

	/**
	 * Build the stacks from top down
	 */
	Axis.prototype.buildStacks = function () {
		var series = this.series,
			reversedStacks = pick(this.options.reversedStacks, true),
			i = series.length;
		if (!this.isXAxis) {
			this.usePercentage = false;
			while (i--) {
				series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
			}
			// Loop up again to compute percent stack
			if (this.usePercentage) {
				for (i = 0; i < series.length; i++) {
					series[i].setPercentStacks();
				}
			}
		}
	};

	Axis.prototype.renderStackTotals = function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			stacks = axis.stacks,
			stackKey, 
			oneStack, 
			stackCategory,
			stackTotalGroup = axis.stackTotalGroup;

		// Create a separate group for the stack total labels
		if (!stackTotalGroup) {
			axis.stackTotalGroup = stackTotalGroup =
				renderer.g('stack-labels')
					.attr({
						visibility: VISIBLE,
						zIndex: 6
					})
					.add();
		}

		// plotLeft/Top will change when y axis gets wider so we need to translate the
		// stackTotalGroup at every render call. See bug #506 and #516
		stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

		// Render each stack total
		for (stackKey in stacks) {
			oneStack = stacks[stackKey];
			for (stackCategory in oneStack) {
				oneStack[stackCategory].render(stackTotalGroup);
			}
		}
	};

	/**
	 * Set all the stacks to initial states and destroy unused ones.
	 */
	Axis.prototype.resetStacks = function () {
		var stacks = this.stacks,
			type,
			i;
		if (!this.isXAxis) {
			for (type in stacks) {
				for (i in stacks[type]) {

					// Clean up memory after point deletion (#1044, #4320)
					if (stacks[type][i].touched < this.stacksTouched) {
						stacks[type][i].destroy();
						delete stacks[type][i];

					// Reset stacks
					} else {
						stacks[type][i].total = null;
						stacks[type][i].cum = 0;
					}
				}
			}
		}
	};

	Axis.prototype.cleanStacks = function () {
		var stacks, type, i;

		if (!this.isXAxis) {
			if (this.oldStacks) {
				stacks = this.stacks = this.oldStacks;
			}

			// reset stacks
			for (type in stacks) {
				for (i in stacks[type]) {
					stacks[type][i].cum = stacks[type][i].total;
				}
			}
		}
	};


	// Stacking methods defnied for Series prototype

	/**
	 * Adds series' points value to corresponding stack
	 */
	Series.prototype.setStackedPoints = function () {
		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
			return;
		}

		var series = this,
			xData = series.processedXData,
			yData = series.processedYData,
			stackedYData = [],
			yDataLength = yData.length,
			seriesOptions = series.options,
			threshold = seriesOptions.threshold,
			stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
			stackOption = seriesOptions.stack,
			stacking = seriesOptions.stacking,
			stackKey = series.stackKey,
			negKey = '-' + stackKey,
			negStacks = series.negStacks,
			yAxis = series.yAxis,
			stacks = yAxis.stacks,
			oldStacks = yAxis.oldStacks,
			isNegative,
			stack,
			other,
			key,
			pointKey,
			i,
			x,
			y;


		yAxis.stacksTouched += 1;

		// loop over the non-null y values and read them into a local array
		for (i = 0; i < yDataLength; i++) {
			x = xData[i];
			y = yData[i];
			pointKey = series.index + ',' + i;

			// Read stacked values into a stack based on the x value,
			// the sign of y and the stack key. Stacking is also handled for null values (#739)
			isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
			key = isNegative ? negKey : stackKey;

			// Create empty object for this stack if it doesn't exist yet
			if (!stacks[key]) {
				stacks[key] = {};
			}

			// Initialize StackItem for this x
			if (!stacks[key][x]) {
				if (oldStacks[key] && oldStacks[key][x]) {
					stacks[key][x] = oldStacks[key][x];
					stacks[key][x].total = null;
				} else {
					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
				}
			}

			// If the StackItem doesn't exist, create it first
			stack = stacks[key][x];
			//stack.points[pointKey] = [stack.cum || stackThreshold];
			stack.points[pointKey] = [pick(stack.cum, stackThreshold)];
			stack.touched = yAxis.stacksTouched;
			

			// Add value to the stack total
			if (stacking === 'percent') {

				// Percent stacked column, totals are the same for the positive and negative stacks
				other = isNegative ? stackKey : negKey;
				if (negStacks && stacks[other] && stacks[other][x]) {
					other = stacks[other][x];
					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

				// Percent stacked areas
				} else {
					stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
				}
			} else {
				stack.total = correctFloat(stack.total + (y || 0));
			}

			stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

			stack.points[pointKey].push(stack.cum);
			stackedYData[i] = stack.cum;

		}

		if (stacking === 'percent') {
			yAxis.usePercentage = true;
		}

		this.stackedYData = stackedYData; // To be used in getExtremes

		// Reset old stacks
		yAxis.oldStacks = {};
	};

	/**
	 * Iterate over all stacks and compute the absolute values to percent
	 */
	Series.prototype.setPercentStacks = function () {
		var series = this,
			stackKey = series.stackKey,
			stacks = series.yAxis.stacks,
			processedXData = series.processedXData;

		each([stackKey, '-' + stackKey], function (key) {
			var i = processedXData.length,
				x,
				stack,
				pointExtremes,
				totalFactor;

			while (i--) {
				x = processedXData[i];
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[series.index + ',' + i];
				if (pointExtremes) {
					totalFactor = stack.total ? 100 / stack.total : 0;
					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
					series.stackedYData[i] = pointExtremes[1];
				}
			}
		});
	};

	// Extend the Chart prototype for dynamic methods
	extend(Chart.prototype, {

		/**
		 * Add a series dynamically after  time
		 *
		 * @param {Object} options The config options
		 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 * @return {Object} series The newly created series object
		 */
		addSeries: function (options, redraw, animation) {
			var series,
				chart = this;

			if (options) {
				redraw = pick(redraw, true); // defaults to true

				fireEvent(chart, 'addSeries', { options: options }, function () {
					series = chart.initSeries(options);

					chart.isDirtyLegend = true; // the series array is out of sync with the display
					chart.linkSeries();
					if (redraw) {
						chart.redraw(animation);
					}
				});
			}

			return series;
		},

		/**
	     * Add an axis to the chart
	     * @param {Object} options The axis option
	     * @param {Boolean} isX Whether it is an X axis or a value axis
	     */
		addAxis: function (options, isX, redraw, animation) {
			var key = isX ? 'xAxis' : 'yAxis',
				chartOptions = this.options,
				axis;

			/*jslint unused: false*/
			axis = new Axis(this, merge(options, {
				index: this[key].length,
				isX: isX
			}));
			/*jslint unused: true*/

			// Push the new axis options to the chart options
			chartOptions[key] = splat(chartOptions[key] || {});
			chartOptions[key].push(options);

			if (pick(redraw, true)) {
				this.redraw(animation);
			}
		},

		/**
		 * Dim the chart and show a loading text or symbol
		 * @param {String} str An optional text to show in the loading label instead of the default one
		 */
		showLoading: function (str) {
			var chart = this,
				options = chart.options,
				loadingDiv = chart.loadingDiv,
				loadingOptions = options.loading,
				setLoadingSize = function () {
					if (loadingDiv) {
						css(loadingDiv, {
							left: chart.plotLeft + PX,
							top: chart.plotTop + PX,
							width: chart.plotWidth + PX,
							height: chart.plotHeight + PX
						});
					}
				};

			// create the layer at the first call
			if (!loadingDiv) {
				chart.loadingDiv = loadingDiv = createElement(DIV, {
					className: PREFIX + 'loading'
				}, extend(loadingOptions.style, {
					zIndex: 10,
					display: NONE
				}), chart.container);

				chart.loadingSpan = createElement(
					'span',
					null,
					loadingOptions.labelStyle,
					loadingDiv
				);
				addEvent(chart, 'redraw', setLoadingSize); // #1080
			}

			// update text
			chart.loadingSpan.innerHTML = str || options.lang.loading;

			// show it
			if (!chart.loadingShown) {
				css(loadingDiv, {
					opacity: 0,
					display: ''				
				});
				animate(loadingDiv, {
					opacity: loadingOptions.style.opacity
				}, {
					duration: loadingOptions.showDuration || 0
				});
				chart.loadingShown = true;
			}
			setLoadingSize();
		},

		/**
		 * Hide the loading layer
		 */
		hideLoading: function () {
			var options = this.options,
				loadingDiv = this.loadingDiv;

			if (loadingDiv) {
				animate(loadingDiv, {
					opacity: 0
				}, {
					duration: options.loading.hideDuration || 100,
					complete: function () {
						css(loadingDiv, { display: NONE });
					}
				});
			}
			this.loadingShown = false;
		}
	});

	// extend the Point prototype for dynamic methods
	extend(Point.prototype, {
		/**
		 * Update the point with new options (typically x/y data) and optionally redraw the series.
		 *
		 * @param {Object} options Point options as defined in the series.data array
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 */
		update: function (options, redraw, animation, runEvent) {
			var point = this,
				series = point.series,
				graphic = point.graphic,
				i,
				chart = series.chart,
				seriesOptions = series.options,
				names = series.xAxis && series.xAxis.names;

			redraw = pick(redraw, true);

			function update() {

				point.applyOptions(options);

				// Update visuals
				if (point.y === null && graphic) { // #4146
					point.graphic = graphic.destroy();
				}
				if (isObject(options) && !isArray(options)) {
					// Defer the actual redraw until getAttribs has been called (#3260)
					point.redraw = function () {
						if (graphic && graphic.element) {
							if (options && options.marker && options.marker.symbol) {
								point.graphic = graphic.destroy();
							} else {
								graphic.attr(point.pointAttr[point.state || ''])[point.visible === false ? 'hide' : 'show'](true); // #2430
							}
						}
						if (options && options.dataLabels && point.dataLabel) { // #2468
							point.dataLabel = point.dataLabel.destroy();
						}
						point.redraw = null;
					};
				}

				// record changes in the parallel arrays
				i = point.index;
				series.updateParallelArrays(point, i);
				if (names && point.name) {
					names[point.x] = point.name;
				}

				seriesOptions.data[i] = point.options;

				// redraw
				series.isDirty = series.isDirtyData = true;
				if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
					chart.isDirtyBox = true;
				}

				if (seriesOptions.legendType === 'point') { // #1831, #1885
					chart.isDirtyLegend = true;
				}
				if (redraw) {
					chart.redraw(animation);
				}
			}

			// Fire the event with a default handler of doing the update
			if (runEvent === false) { // When called from setData
				update();
			} else {
				point.firePointEvent('update', { options: options }, update);
			}
		},

		/**
		 * Remove a point and optionally redraw the series and if necessary the axes
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		remove: function (redraw, animation) {
			this.series.removePoint(inArray(this, this.series.data), redraw, animation);
		}
	});

	// Extend the series prototype for dynamic methods
	extend(Series.prototype, {
		/**
		 * Add a point dynamically after chart load time
		 * @param {Object} options Point options as given in series.data
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean} shift If shift is true, a point is shifted off the start
		 *    of the series as one is appended to the end.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		addPoint: function (options, redraw, shift, animation) {
			var series = this,
				seriesOptions = series.options,
				data = series.data,
				graph = series.graph,
				area = series.area,
				chart = series.chart,
				names = series.xAxis && series.xAxis.names,
				currentShift = (graph && graph.shift) || 0,
				shiftShapes = ['graph', 'area'],
				dataOptions = seriesOptions.data,
				point,
				isInTheMiddle,
				xData = series.xData,
				i,
				x;

			setAnimation(animation, chart);

			// Make graph animate sideways
			if (shift) {
				i = series.zones.length;
				while (i--) {
					shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);
				}
				each(shiftShapes, function (shape) {
					if (series[shape]) {
						series[shape].shift = currentShift + 1;
					}
				});
			}
			if (area) {
				area.isArea = true; // needed in animation, both with and without shift
			}

			// Optional redraw, defaults to true
			redraw = pick(redraw, true);

			// Get options and push the point to xData, yData and series.options. In series.generatePoints
			// the Point instance will be created on demand and pushed to the series.data array.
			point = { series: series };
			series.pointClass.prototype.applyOptions.apply(point, [options]);
			x = point.x;

			// Get the insertion point
			i = xData.length;
			if (series.requireSorting && x < xData[i - 1]) {
				isInTheMiddle = true;
				while (i && xData[i - 1] > x) {
					i--;
				}
			}

			series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
			series.updateParallelArrays(point, i); // update it

			if (names && point.name) {
				names[x] = point.name;
			}
			dataOptions.splice(i, 0, options);

			if (isInTheMiddle) {
				series.data.splice(i, 0, null);
				series.processData();
			}

			// Generate points to be added to the legend (#1329)
			if (seriesOptions.legendType === 'point') {
				series.generatePoints();
			}

			// Shift the first point off the parallel arrays
			// todo: consider series.removePoint(i) method
			if (shift) {
				if (data[0] && data[0].remove) {
					data[0].remove(false);
				} else {
					data.shift();
					series.updateParallelArrays(point, 'shift');

					dataOptions.shift();
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				series.getAttribs(); // #1937
				chart.redraw();
			}
		},

		/**
		 * Remove a point (rendered or not), by index
		 */
		removePoint: function (i, redraw, animation) {

			var series = this,
				data = series.data,
				point = data[i],
				points = series.points,
				chart = series.chart,
				remove = function () {

					if (data.length === points.length) {
						points.splice(i, 1);
					}
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

					if (point) {
						point.destroy();
					}

					// redraw
					series.isDirty = true;
					series.isDirtyData = true;
					if (redraw) {
						chart.redraw();
					}
				};

			setAnimation(animation, chart);
			redraw = pick(redraw, true);

			// Fire the event with a default handler of removing the point
			if (point) {
				point.firePointEvent('remove', null, remove);
			} else {
				remove();
			}
		},

		/**
		 * Remove a series and optionally redraw the chart
		 *
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */

		remove: function (redraw, animation) {
			var series = this,
				chart = series.chart;
			redraw = pick(redraw, true);

			if (!series.isRemoving) {  /* prevent triggering native event in jQuery
					(calling the remove function from the remove event) */
				series.isRemoving = true;

				// fire the event with a default handler of removing the point
				fireEvent(series, 'remove', null, function () {


					// destroy elements
					series.destroy();


					// redraw
					chart.isDirtyLegend = chart.isDirtyBox = true;
					chart.linkSeries();

					if (redraw) {
						chart.redraw(animation);
					}
				});

			}
			series.isRemoving = false;
		},

		/**
		 * Update the series with a new set of options
		 */
		update: function (newOptions, redraw) {
			var series = this,
				chart = this.chart,
				// must use user options when changing type because this.options is merged
				// in with type specific plotOptions
				oldOptions = this.userOptions,
				oldType = this.type,
				proto = seriesTypes[oldType].prototype,
				preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
				n;

			// If we're changing type or zIndex, create new groups (#3380, #3404)
			if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
				preserve.length = 0;
			}

			// Make sure groups are not destroyed (#3094)
			each(preserve, function (prop) {
				preserve[prop] = series[prop];
				delete series[prop];
			});

			// Do the merge, with some forced options
			newOptions = merge(oldOptions, {
				animation: false,
				index: this.index,
				pointStart: this.xData[0] // when updating after addPoint
			}, { data: this.options.data }, newOptions);

			// Destroy the series and delete all properties. Reinsert all methods 
			// and properties from the new type prototype (#2270, #3719)
			this.remove(false);
			for (n in proto) {
				this[n] = UNDEFINED;
			}
			extend(this, seriesTypes[newOptions.type || oldType].prototype);

			// Re-register groups (#3094)
			each(preserve, function (prop) {
				series[prop] = preserve[prop];
			});

			this.init(chart, newOptions);
			chart.linkSeries(); // Links are lost in this.remove (#3028)
			if (pick(redraw, true)) {
				chart.redraw(false);
			}
		}
	});

	// Extend the Axis.prototype for dynamic methods
	extend(Axis.prototype, {

		/**
		 * Update the axis with a new options structure
		 */
		update: function (newOptions, redraw) {
			var chart = this.chart;

			newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

			this.destroy(true);
			this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314

			this.init(chart, extend(newOptions, { events: UNDEFINED }));

			chart.isDirtyBox = true;
			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
	     * Remove the axis from the chart
	     */
		remove: function (redraw) {
			var chart = this.chart,
				key = this.coll, // xAxis or yAxis
				axisSeries = this.series,
				i = axisSeries.length;

			// Remove associated series (#2687)
			while (i--) {
				if (axisSeries[i]) {
					axisSeries[i].remove(false);
				}
			}

			// Remove the axis
			erase(chart.axes, this);
			erase(chart[key], this);
			chart.options[key].splice(this.options.index, 1);
			each(chart[key], function (axis, i) { // Re-index, #1706
				axis.options.index = i;
			});
			this.destroy();
			chart.isDirtyBox = true;

			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
		 * Update the axis title by options
		 */
		setTitle: function (newTitleOptions, redraw) {
			this.update({ title: newTitleOptions }, redraw);
		},

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} categories
		 * @param {Boolean} redraw
		 */
		setCategories: function (categories, redraw) {
			this.update({ categories: categories }, redraw);
		}

	});


	/**
	 * LineSeries object
	 */
	var LineSeries = extendClass(Series);
	seriesTypes.line = LineSeries;

	/**
	 * Set the default options for area
	 */
	defaultPlotOptions.area = merge(defaultSeriesOptions, {
		threshold: 0
		// trackByArea: false,
		// lineColor: null, // overrides color, but lets fillColor be unaltered
		// fillOpacity: 0.75,
		// fillColor: null
	});

	/**
	 * AreaSeries object
	 */
	var AreaSeries = extendClass(Series, {
		type: 'area',
		/**
		 * For stacks, don't split segments on null values. Instead, draw null values with 
		 * no marker. Also insert dummy points for any X position that exists in other series
		 * in the stack.
		 */ 
		getSegments: function () {
			var series = this,
				segments = [],
				segment = [],
				keys = [],
				xAxis = this.xAxis,
				yAxis = this.yAxis,
				stack = yAxis.stacks[this.stackKey],
				pointMap = {},
				plotX,
				plotY,
				points = this.points,
				connectNulls = this.options.connectNulls,
				i,
				x;

			if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
				// Create a map where we can quickly look up the points by their X value.
				for (i = 0; i < points.length; i++) {
					pointMap[points[i].x] = points[i];
				}

				// Sort the keys (#1651)
				for (x in stack) {
					if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
						keys.push(+x);
					}
				}
				keys.sort(function (a, b) {
					return a - b;
				});

				each(keys, function (x) {
					var y = 0,
						stackPoint;

					if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
						return;

					// The point exists, push it to the segment
					} else if (pointMap[x]) {
						segment.push(pointMap[x]);

					// There is no point for this X value in this series, so we 
					// insert a dummy point in order for the areas to be drawn
					// correctly.
					} else {

						// Loop down the stack to find the series below this one that has
						// a value (#1991)
						for (i = series.index; i <= yAxis.series.length; i++) {
							stackPoint = stack[x].points[i + ',' + x];
							if (stackPoint) {
								y = stackPoint[1];
								break;
							}
						}

						plotX = xAxis.translate(x);
						plotY = yAxis.toPixels(y, true);
						segment.push({ 
							y: null, 
							plotX: plotX,
							clientX: plotX, 
							plotY: plotY, 
							yBottom: plotY,
							onMouseOver: noop
						});
					}
				});

				if (segment.length) {
					segments.push(segment);
				}

			} else {
				Series.prototype.getSegments.call(this);
				segments = this.segments;
			}

			this.segments = segments;
		},
		
		/**
		 * Extend the base Series getSegmentPath method by adding the path for the area.
		 * This path is pushed to the series.areaPath property.
		 */
		getSegmentPath: function (segment) {
			
			var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
				areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
				i,
				options = this.options,
				segLength = segmentPath.length,
				translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
				yBottom;
			
			if (segLength === 3) { // for animation from 1 to two points
				areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
			}
			if (options.stacking && !this.closedStacks) {
				
				// Follow stack back. Todo: implement areaspline. A general solution could be to 
				// reverse the entire graphPath of the previous series, though may be hard with
				// splines and with series with different extremes
				for (i = segment.length - 1; i >= 0; i--) {

					yBottom = pick(segment[i].yBottom, translatedThreshold);
				
					// step line?
					if (i < segment.length - 1 && options.step) {
						areaSegmentPath.push(segment[i + 1].plotX, yBottom);
					}
					
					areaSegmentPath.push(segment[i].plotX, yBottom);
				}

			} else { // follow zero line back
				this.closeSegment(areaSegmentPath, segment, translatedThreshold);
			}
			this.areaPath = this.areaPath.concat(areaSegmentPath);
			return segmentPath;
		},
		
		/**
		 * Extendable method to close the segment path of an area. This is overridden in polar 
		 * charts.
		 */
		closeSegment: function (path, segment, translatedThreshold) {
			path.push(
				L,
				segment[segment.length - 1].plotX,
				translatedThreshold,
				L,
				segment[0].plotX,
				translatedThreshold
			);
		},
		
		/**
		 * Draw the graph and the underlying area. This method calls the Series base
		 * function and adds the area. The areaPath is calculated in the getSegmentPath
		 * method called from Series.prototype.drawGraph.
		 */
		drawGraph: function () {
			
			// Define or reset areaPath
			this.areaPath = [];
			
			// Call the base method
			Series.prototype.drawGraph.apply(this);
			
			// Define local variables
			var series = this,
				areaPath = this.areaPath,
				options = this.options,
				zones = this.zones,
				props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
			
			each(zones, function (threshold, i) {
				props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
			});
			each(props, function (prop) {
				var areaKey = prop[0],
					area = series[areaKey];
					
				// Create or update the area
				if (area) { // update
					area.animate({ d: areaPath });
		
				} else { // create
					series[areaKey] = series.chart.renderer.path(areaPath)
						.attr({
							fill: pick(
								prop[2],
								Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
							),
							zIndex: 0 // #1069
						}).add(series.group);
				}
			});
		},

		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

	seriesTypes.area = AreaSeries;
	/**
	 * Set the default options for spline
	 */
	defaultPlotOptions.spline = merge(defaultSeriesOptions);

	/**
	 * SplineSeries object
	 */
	var SplineSeries = extendClass(Series, {
		type: 'spline',

		/**
		 * Get the spline segment from a given point's previous neighbour to the given point
		 */
		getPointSpline: function (segment, point, i) {
			var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
				denom = smoothing + 1,
				plotX = point.plotX,
				plotY = point.plotY,
				lastPoint = segment[i - 1],
				nextPoint = segment[i + 1],
				leftContX,
				leftContY,
				rightContX,
				rightContY,
				ret;

			// find control points
			if (lastPoint && nextPoint) {
			
				var lastX = lastPoint.plotX,
					lastY = lastPoint.plotY,
					nextX = nextPoint.plotX,
					nextY = nextPoint.plotY,
					correction;

				leftContX = (smoothing * plotX + lastX) / denom;
				leftContY = (smoothing * plotY + lastY) / denom;
				rightContX = (smoothing * plotX + nextX) / denom;
				rightContY = (smoothing * plotY + nextY) / denom;

				// have the two control points make a straight line through main point
				correction = ((rightContY - leftContY) * (rightContX - plotX)) /
					(rightContX - leftContX) + plotY - rightContY;

				leftContY += correction;
				rightContY += correction;

				// to prevent false extremes, check that control points are between
				// neighbouring points' y values
				if (leftContY > lastY && leftContY > plotY) {
					leftContY = mathMax(lastY, plotY);
					rightContY = 2 * plotY - leftContY; // mirror of left control point
				} else if (leftContY < lastY && leftContY < plotY) {
					leftContY = mathMin(lastY, plotY);
					rightContY = 2 * plotY - leftContY;
				}
				if (rightContY > nextY && rightContY > plotY) {
					rightContY = mathMax(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				} else if (rightContY < nextY && rightContY < plotY) {
					rightContY = mathMin(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				}

				// record for drawing in next point
				point.rightContX = rightContX;
				point.rightContY = rightContY;

			}
			
			// Visualize control points for debugging
			/*
			if (leftContX) {
				this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'red',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'red',
						'stroke-width': 1
					})
					.add();
				this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'green',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'green',
						'stroke-width': 1
					})
					.add();
			}
			*/

			// moveTo or lineTo
			if (!i) {
				ret = [M, plotX, plotY];
			} else { // curve from last point to this
				ret = [
					'C',
					lastPoint.rightContX || lastPoint.plotX,
					lastPoint.rightContY || lastPoint.plotY,
					leftContX || plotX,
					leftContY || plotY,
					plotX,
					plotY
				];
				lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
			}
			return ret;
		}
	});
	seriesTypes.spline = SplineSeries;

	/**
	 * Set the default options for areaspline
	 */
	defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

	/**
	 * AreaSplineSeries object
	 */
	var areaProto = AreaSeries.prototype,
		AreaSplineSeries = extendClass(SplineSeries, {
			type: 'areaspline',
			closedStacks: true, // instead of following the previous graph back, follow the threshold back
			
			// Mix in methods from the area series
			getSegmentPath: areaProto.getSegmentPath,
			closeSegment: areaProto.closeSegment,
			drawGraph: areaProto.drawGraph,
			drawLegendSymbol: LegendSymbolMixin.drawRectangle
		});

	seriesTypes.areaspline = AreaSplineSeries;

	/**
	 * Set the default options for column
	 */
	defaultPlotOptions.column = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		//borderWidth: 1,
		borderRadius: 0,
		//colorByPoint: undefined,
		groupPadding: 0.2,
		//grouping: true,
		marker: null, // point options are specified in the base options
		pointPadding: 0.1,
		//pointWidth: null,
		minPointLength: 0,
		cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
		pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
		states: {
			hover: {
				brightness: 0.1,
				shadow: false,
				halo: false
			},
			select: {
				color: '#C0C0C0',
				borderColor: '#000000',
				shadow: false
			}
		},
		dataLabels: {
			align: null, // auto
			verticalAlign: null, // auto
			y: null
		},
		startFromThreshold: true, // docs: http://jsfiddle.net/highcharts/hz8fopan/14/
		stickyTracking: false,
		tooltip: {
			distance: 6
		},
		threshold: 0
	});

	/**
	 * ColumnSeries object
	 */
	var ColumnSeries = extendClass(Series, {
		type: 'column',
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			fill: 'color',
			r: 'borderRadius'
		},
		cropShoulder: 0,
		directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
		trackerGroups: ['group', 'dataLabelsGroup'],
		negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
			// point is substracted from previous (#1910)
		
		/**
		 * Initialize the series
		 */
		init: function () {
			Series.prototype.init.apply(this, arguments);

			var series = this,
				chart = series.chart;

			// if the series is added dynamically, force redraw of other
			// series affected by a new column
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}
		},

		/**
		 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
		 * pointWidth etc. 
		 */
		getColumnMetrics: function () {

			var series = this,
				options = series.options,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				reversedXAxis = xAxis.reversed,
				stackKey,
				stackGroups = {},
				columnIndex,
				columnCount = 0;

			// Get the total number of column type series.
			// This is called on every series. Consider moving this logic to a
			// chart.orderStacks() function and call it on init, addSeries and removeSeries
			if (options.grouping === false) {
				columnCount = 1;
			} else {
				each(series.chart.series, function (otherSeries) {
					var otherOptions = otherSeries.options,
						otherYAxis = otherSeries.yAxis;
					if (otherSeries.type === series.type && otherSeries.visible &&
							yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
						if (otherOptions.stacking) {
							stackKey = otherSeries.stackKey;
							if (stackGroups[stackKey] === UNDEFINED) {
								stackGroups[stackKey] = columnCount++;
							}
							columnIndex = stackGroups[stackKey];
						} else if (otherOptions.grouping !== false) { // #1162
							columnIndex = columnCount++;
						}
						otherSeries.columnIndex = columnIndex;
					}
				});
			}

			var categoryWidth = mathMin(
					mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
					xAxis.len // #1535
				),
				groupPadding = categoryWidth * options.groupPadding,
				groupWidth = categoryWidth - 2 * groupPadding,
				pointOffsetWidth = groupWidth / columnCount,
				pointWidth = mathMin(
					options.maxPointWidth || xAxis.len, // docs: Sample created. Add "See also" to pointWidth. Close UserVoice.
					pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
				),
				pointPadding = (pointOffsetWidth - pointWidth) / 2,
				colIndex = (reversedXAxis ? 
					columnCount - (series.columnIndex || 0) : // #1251
					series.columnIndex) || 0,
				pointXOffset = pointPadding + (groupPadding + colIndex *
					pointOffsetWidth - (categoryWidth / 2)) *
					(reversedXAxis ? -1 : 1);

			// Save it for reading in linked series (Error bars particularly)
			return (series.columnMetrics = { 
				width: pointWidth, 
				offset: pointXOffset 
			});
				
		},

		/**
		 * Translate each point to the plot area coordinate system and find shape positions
		 */
		translate: function () {
			var series = this,
				chart = series.chart,
				options = series.options,
				borderWidth = series.borderWidth = pick(
					options.borderWidth, 
					series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
				),
				yAxis = series.yAxis,
				threshold = options.threshold,
				translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
				minPointLength = pick(options.minPointLength, 5),
				metrics = series.getColumnMetrics(),
				pointWidth = metrics.width,
				seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
				pointXOffset = series.pointXOffset = metrics.offset,
				xCrisp = -(borderWidth % 2 ? 0.5 : 0),
				yCrisp = borderWidth % 2 ? 0.5 : 1;

			if (chart.inverted) {
				translatedThreshold -= 0.5; // #3355
				if (chart.renderer.isVML) {
					yCrisp += 1;
				}
			}

			// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
			// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
			// columns (#2694).
			if (options.pointPadding) {
				seriesBarW = mathCeil(seriesBarW);
			}

			Series.prototype.translate.apply(series);

			// Record the new values
			each(series.points, function (point) {
				var yBottom = pick(point.yBottom, translatedThreshold),
					safeDistance = 999 + mathAbs(yBottom),
					plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
					barX = point.plotX + pointXOffset,
					barW = seriesBarW,
					barY = mathMin(plotY, yBottom),
					right,
					bottom,
					fromTop,
					up,
					barH = mathMax(plotY, yBottom) - barY;

				// Handle options.minPointLength
				if (mathAbs(barH) < minPointLength) {
					if (minPointLength) {
						barH = minPointLength;
						up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
						barY =
							mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
								yBottom - minPointLength : // keep position
								translatedThreshold - (up ? minPointLength : 0)); // #1485, #4051
					}
				}

				// Cache for access in polar
				point.barX = barX;
				point.pointWidth = pointWidth;

				// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
				right = mathRound(barX + barW) + xCrisp;
				barX = mathRound(barX) + xCrisp;
				barW = right - barX;

				fromTop = mathAbs(barY) < 0.5;
				bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
				barY = mathRound(barY) + yCrisp;
				barH = bottom - barY;

				// Top edges are exceptions
				if (fromTop) {
					barY -= 1;
					barH += 1;
				}

				// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
				point.tooltipPos = chart.inverted ? 
					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : 
					[barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

				// Register shape type and arguments to be used in drawPoints
				point.shapeType = 'rect';
				point.shapeArgs = {
					x: barX,
					y: barY,
					width: barW,
					height: barH
				};
			});

		},

		getSymbol: noop,
		
		/**
		 * Use a solid rectangle like the area series types
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,
		
		
		/**
		 * Columns have no graph
		 */
		drawGraph: noop,

		/**
		 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
		 * apply for columns and bars. This method is inherited by scatter series.
		 *
		 */
		drawPoints: function () {
			var series = this,
				chart = this.chart,
				options = series.options,
				renderer = chart.renderer,
				animationLimit = options.animationLimit || 250,
				shapeArgs,
				pointAttr;

			// draw the columns
			each(series.points, function (point) {
				var plotY = point.plotY,
					graphic = point.graphic,
					borderAttr;

				if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
					shapeArgs = point.shapeArgs;

					borderAttr = defined(series.borderWidth) ? {
						'stroke-width': series.borderWidth
					} : {};

					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
					
					if (graphic) { // update
						stop(graphic);
						graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

					} else {
						point.graphic = graphic = renderer[point.shapeType](shapeArgs)
							.attr(borderAttr)
							.attr(pointAttr)
							.add(series.group)
							.shadow(options.shadow, null, options.stacking && !options.borderRadius);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			});
		},

		/**
		 * Animate the column heights one by one from zero
		 * @param {Boolean} init Whether to initialize the animation or run it
		 */
		animate: function (init) {
			var series = this,
				yAxis = this.yAxis,
				options = series.options,
				inverted = this.chart.inverted,
				attr = {},
				translatedThreshold;

			if (hasSVG) { // VML is too slow anyway
				if (init) {
					attr.scaleY = 0.001;
					translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
					if (inverted) {
						attr.translateX = translatedThreshold - yAxis.len;
					} else {
						attr.translateY = translatedThreshold;
					}
					series.group.attr(attr);

				} else { // run the animation
					
					attr.scaleY = 1;
					attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
					series.group.animate(attr, series.options.animation);

					// delete this function to allow it only once
					series.animate = null;
				}
			}
		},
		
		/**
		 * Remove this series from the chart
		 */
		remove: function () {
			var series = this,
				chart = series.chart;

			// column and bar series affects other series of the same type
			// as they are either stacked or grouped
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}

			Series.prototype.remove.apply(series, arguments);
		}
	});
	seriesTypes.column = ColumnSeries;
	/**
	 * Set the default options for bar
	 */
	defaultPlotOptions.bar = merge(defaultPlotOptions.column);
	/**
	 * The Bar series class
	 */
	var BarSeries = extendClass(ColumnSeries, {
		type: 'bar',
		inverted: true
	});
	seriesTypes.bar = BarSeries;

	/**
	 * Set the default options for scatter
	 */
	defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
		lineWidth: 0,
		marker: {
			enabled: true // Overrides auto-enabling in line series (#3647)
		},
		tooltip: {
			headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
			pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
		}
	});

	/**
	 * The scatter series class
	 */
	var ScatterSeries = extendClass(Series, {
		type: 'scatter',
		sorted: false,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
		takeOrdinalPosition: false, // #2342
		kdDimensions: 2,
		drawGraph: function () {
			if (this.options.lineWidth) {
				Series.prototype.drawGraph.call(this);
			}
		}
	});

	seriesTypes.scatter = ScatterSeries;

	/**
	 * Set the default options for pie
	 */
	defaultPlotOptions.pie = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		borderWidth: 1,
		center: [null, null],
		clip: false,
		colorByPoint: true, // always true for pies
		dataLabels: {
			// align: null,
			// connectorWidth: 1,
			// connectorColor: point.color,
			// connectorPadding: 5,
			distance: 30,
			enabled: true,
			formatter: function () { // #2945
				return this.y === null ? undefined : this.point.name;
			},
			// softConnector: true,
			x: 0
			// y: 0
		},
		ignoreHiddenPoint: true,
		//innerSize: 0,
		legendType: 'point',
		marker: null, // point options are specified in the base options
		size: null,
		showInLegend: false,
		slicedOffset: 10,
		states: {
			hover: {
				brightness: 0.1,
				shadow: false
			}
		},
		stickyTracking: false,
		tooltip: {
			followPointer: true
		}
	});

	/**
	 * Extended point object for pies
	 */
	var PiePoint = extendClass(Point, {
		/**
		 * Initiate the pie slice
		 */
		init: function () {

			Point.prototype.init.apply(this, arguments);

			var point = this,
				toggleSlice;

			extend(point, {
				visible: point.visible !== false,
				name: pick(point.name, 'Slice')
			});

			// add event listener for select
			toggleSlice = function (e) {
				point.slice(e.type === 'select');
			};
			addEvent(point, 'select', toggleSlice);
			addEvent(point, 'unselect', toggleSlice);

			return point;
		},

		/**
		 * Toggle the visibility of the pie slice
		 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
		 *    visibility is toggled
		 */
		setVisible: function (vis, redraw) {
			var point = this,
				series = point.series,
				chart = series.chart,
				ignoreHiddenPoint = series.options.ignoreHiddenPoint;
			
			redraw = pick(redraw, ignoreHiddenPoint);

			if (vis !== point.visible) {

				// If called without an argument, toggle visibility
				point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
				series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

				// Show and hide associated elements. This is performed regardless of redraw or not,
				// because chart.redraw only handles full series.
				each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
					if (point[key]) {
						point[key][vis ? 'show' : 'hide'](true);
					}
				});

				if (point.legendItem) {
					chart.legend.colorizeItem(point, vis);
				}

				// #4170, hide halo after hiding point
				if (!vis && point.state === 'hover') {
					point.setState('');
				}
				
				// Handle ignore hidden slices
				if (ignoreHiddenPoint) {
					series.isDirty = true;
				}

				if (redraw) {
					chart.redraw();
				}
			}
		},

		/**
		 * Set or toggle whether the slice is cut out from the pie
		 * @param {Boolean} sliced When undefined, the slice state is toggled
		 * @param {Boolean} redraw Whether to redraw the chart. True by default.
		 */
		slice: function (sliced, redraw, animation) {
			var point = this,
				series = point.series,
				chart = series.chart,
				translation;

			setAnimation(animation, chart);

			// redraw is true by default
			redraw = pick(redraw, true);

			// if called without an argument, toggle
			point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			translation = sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			point.graphic.animate(translation);
			
			if (point.shadowGroup) {
				point.shadowGroup.animate(translation);
			}

		},

		haloPath: function (size) {
			var shapeArgs = this.shapeArgs,
				chart = this.series.chart;

			return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
				innerR: this.shapeArgs.r,
				start: shapeArgs.start,
				end: shapeArgs.end
			});
		}
	});

	/**
	 * The Pie series class
	 */
	var PieSeries = {
		type: 'pie',
		isCartesian: false,
		pointClass: PiePoint,
		requireSorting: false,
		directTouch: true,
		noSharedTooltip: true,
		trackerGroups: ['group', 'dataLabelsGroup'],
		axisTypes: [],
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			'stroke-width': 'borderWidth',
			fill: 'color'
		},

		/**
		 * Pies have one color each point
		 */
		getColor: noop,

		/**
		 * Animate the pies in
		 */
		animate: function (init) {
			var series = this,
				points = series.points,
				startAngleRad = series.startAngleRad;

			if (!init) {
				each(points, function (point) {
					var graphic = point.graphic,
						args = point.shapeArgs;

					if (graphic) {
						// start values
						graphic.attr({
							r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
							start: startAngleRad,
							end: startAngleRad
						});

						// animate
						graphic.animate({
							r: args.r,
							start: args.start,
							end: args.end
						}, series.options.animation);
					}
				});

				// delete this function to allow it only once
				series.animate = null;
			}
		},

		/**
		 * Extend the basic setData method by running processData and generatePoints immediately,
		 * in order to access the points from the legend.
		 */
		setData: function (data, redraw, animation, updatePoints) {
			Series.prototype.setData.call(this, data, false, animation, updatePoints);
			this.processData();
			this.generatePoints();
			if (pick(redraw, true)) {
				this.chart.redraw(animation);
			} 
		},

		/**
		 * Recompute total chart sum and update percentages of points.
		 */
		updateTotals: function () {
			var i,
				total = 0,
				points = this.points,
				len = points.length,
				point,
				ignoreHiddenPoint = this.options.ignoreHiddenPoint;

			// Get the total sum
			for (i = 0; i < len; i++) {
				point = points[i];
				total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
			}
			this.total = total;

			// Set each point's properties
			for (i = 0; i < len; i++) {
				point = points[i];
				point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
				point.total = total;
			}
		},

		/**
		 * Extend the generatePoints method by adding total and percentage properties to each point
		 */
		generatePoints: function () {
			Series.prototype.generatePoints.call(this);
			this.updateTotals();
		},
		
		/**
		 * Do translation for pie slices
		 */
		translate: function (positions) {
			this.generatePoints();
			
			var series = this,
				cumulative = 0,
				precision = 1000, // issue #172
				options = series.options,
				slicedOffset = options.slicedOffset,
				connectorOffset = slicedOffset + options.borderWidth,
				start,
				end,
				angle,
				startAngle = options.startAngle || 0,
				startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
				endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
				circ = endAngleRad - startAngleRad, //2 * mathPI,
				points = series.points,
				radiusX, // the x component of the radius vector for a given point
				radiusY,
				labelDistance = options.dataLabels.distance,
				ignoreHiddenPoint = options.ignoreHiddenPoint,
				i,
				len = points.length,
				point;

			// Get positions - either an integer or a percentage string must be given.
			// If positions are passed as a parameter, we're in a recursive loop for adjusting
			// space for data labels.
			if (!positions) {
				series.center = positions = series.getCenter();
			}

			// utility for getting the x value from a given y, used for anticollision logic in data labels
			series.getX = function (y, left) {

				angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

				return positions[0] +
					(left ? -1 : 1) *
					(mathCos(angle) * (positions[2] / 2 + labelDistance));
			};

			// Calculate the geometry for each point
			for (i = 0; i < len; i++) {
				
				point = points[i];
				
				// set start and end angle
				start = startAngleRad + (cumulative * circ);
				if (!ignoreHiddenPoint || point.visible) {
					cumulative += point.percentage / 100;
				}
				end = startAngleRad + (cumulative * circ);

				// set the shape
				point.shapeType = 'arc';
				point.shapeArgs = {
					x: positions[0],
					y: positions[1],
					r: positions[2] / 2,
					innerR: positions[3] / 2,
					start: mathRound(start * precision) / precision,
					end: mathRound(end * precision) / precision
				};

				// The angle must stay within -90 and 270 (#2645)
				angle = (end + start) / 2;
				if (angle > 1.5 * mathPI) {
					angle -= 2 * mathPI;
				} else if (angle < -mathPI / 2) {
					angle += 2 * mathPI;
				}

				// Center for the sliced out slice
				point.slicedTranslation = {
					translateX: mathRound(mathCos(angle) * slicedOffset),
					translateY: mathRound(mathSin(angle) * slicedOffset)
				};

				// set the anchor point for tooltips
				radiusX = mathCos(angle) * positions[2] / 2;
				radiusY = mathSin(angle) * positions[2] / 2;
				point.tooltipPos = [
					positions[0] + radiusX * 0.7,
					positions[1] + radiusY * 0.7
				];
				
				point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
				point.angle = angle;

				// set the anchor point for data labels
				connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
				point.labelPos = [
					positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
					positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
					positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
					positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
					positions[0] + radiusX, // landing point for connector
					positions[1] + radiusY, // a/a
					labelDistance < 0 ? // alignment
						'center' :
						point.half ? 'right' : 'left', // alignment
					angle // center angle
				];

			}
		},
		
		drawGraph: null,

		/**
		 * Draw the data points
		 */
		drawPoints: function () {
			var series = this,
				chart = series.chart,
				renderer = chart.renderer,
				groupTranslation,
				//center,
				graphic,
				//group,
				shadow = series.options.shadow,
				shadowGroup,
				shapeArgs,
				attr;

			if (shadow && !series.shadowGroup) {
				series.shadowGroup = renderer.g('shadow')
					.add(series.group);
			}

			// draw the slices
			each(series.points, function (point) {
				if (point.y !== null) {
					graphic = point.graphic;
					shapeArgs = point.shapeArgs;
					shadowGroup = point.shadowGroup;

					// put the shadow behind all points
					if (shadow && !shadowGroup) {
						shadowGroup = point.shadowGroup = renderer.g('shadow')
							.add(series.shadowGroup);
					}

					// if the point is sliced, use special translation, else use plot area traslation
					groupTranslation = point.sliced ? point.slicedTranslation : {
						translateX: 0,
						translateY: 0
					};

					//group.translate(groupTranslation[0], groupTranslation[1]);
					if (shadowGroup) {
						shadowGroup.attr(groupTranslation);
					}

					// draw the slice
					if (graphic) {
						graphic.animate(extend(shapeArgs, groupTranslation));				
					} else {
						attr = { 'stroke-linejoin': 'round' };
						if (!point.visible) {
							attr.visibility = 'hidden';
						}

						point.graphic = graphic = renderer[point.shapeType](shapeArgs)
							.setRadialReference(series.center)
							.attr(
								point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
							)
							.attr(attr)
							.attr(groupTranslation)
							.add(series.group)
							.shadow(shadow, shadowGroup);	
					}
				}
			});

		},


		searchPoint: noop,

		/**
		 * Utility for sorting data labels
		 */
		sortByAngle: function (points, sign) {
			points.sort(function (a, b) {
				return a.angle !== undefined && (b.angle - a.angle) * sign;
			});
		},		

		/**
		 * Use a simple symbol from LegendSymbolMixin
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,

		/**
		 * Use the getCenter method from drawLegendSymbol
		 */
		getCenter: CenteredSeriesMixin.getCenter,

		/**
		 * Pies don't have point marker symbols
		 */
		getSymbol: noop

	};
	PieSeries = extendClass(Series, PieSeries);
	seriesTypes.pie = PieSeries;

	/**
	 * Draw the data labels
	 */
	Series.prototype.drawDataLabels = function () {

		var series = this,
			seriesOptions = series.options,
			cursor = seriesOptions.cursor,
			options = seriesOptions.dataLabels,
			points = series.points,
			pointOptions,
			generalOptions,
			hasRendered = series.hasRendered || 0,
			str,
			dataLabelsGroup,
			renderer = series.chart.renderer;

		if (options.enabled || series._hasPointLabels) {

			// Process default alignment of data labels for columns
			if (series.dlProcessOptions) {
				series.dlProcessOptions(options);
			}

			// Create a separate group for the data labels to avoid rotation
			dataLabelsGroup = series.plotGroup(
				'dataLabelsGroup',
				'data-labels',
				options.defer ? HIDDEN : VISIBLE,
				options.zIndex || 6
			);

			if (pick(options.defer, true)) {
				dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
				if (!hasRendered) {
					addEvent(series, 'afterAnimate', function () {
						if (series.visible) { // #3023, #3024
							dataLabelsGroup.show();
						}
						dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
					});
				}
			}

			// Make the labels for each point
			generalOptions = options;
			each(points, function (point) {

				var enabled,
					dataLabel = point.dataLabel,
					labelConfig,
					attr,
					name,
					rotation,
					connector = point.connector,
					isNew = true,
					style,
					moreStyle = {};

				// Determine if each data label is enabled
				pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && !enabled) {
					point.dataLabel = dataLabel.destroy();

				// Individual labels are disabled if the are explicitly disabled
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {

					// Create individual options structure that can be extended without
					// affecting others
					options = merge(generalOptions, pointOptions);
					style = options.style;

					rotation = options.rotation;

					// Get the string
					labelConfig = point.getLabelConfig();
					str = options.format ?
						format(options.format, labelConfig) :
						options.formatter.call(labelConfig, options);

					// Determine the color
					style.color = pick(options.color, style.color, series.color, 'black');


					// update existing label
					if (dataLabel) {

						if (defined(str)) {
							dataLabel
								.attr({
									text: str
								});
							isNew = false;

						} else { // #1437 - the label is shown conditionally
							point.dataLabel = dataLabel = dataLabel.destroy();
							if (connector) {
								point.connector = connector.destroy();
							}
						}

					// create new label
					} else if (defined(str)) {
						attr = {
							//align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius || 0,
							rotation: rotation,
							padding: options.padding,
							zIndex: 1
						};
						
						// Get automated contrast color
						if (style.color === 'contrast') {
							moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
								renderer.getContrast(point.color || series.color) : 
								'#000000';
						}
						if (cursor) {
							moreStyle.cursor = cursor;
						}
						

						// Remove unused attributes (#947)
						for (name in attr) {
							if (attr[name] === UNDEFINED) {
								delete attr[name];
							}
						}

						dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							0,
							-999,
							options.shape,
							null,
							null,
							options.useHTML
						)
						.attr(attr)
						.css(extend(style, moreStyle))
						.add(dataLabelsGroup)
						.shadow(options.shadow);

					}

					if (dataLabel) {
						// Now the data label is created and placed at 0,0, so we need to align it
						series.alignDataLabel(point, dataLabel, options, null, isNew);
					}
				}
			});
		}
	};

	/**
	 * Align each individual data label
	 */
	Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			plotX = pick(point.plotX, -999),
			plotY = pick(point.plotY, -999),
			bBox = dataLabel.getBBox(),
			baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
			rotCorr, // rotation correction
			// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
			visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
				(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
			alignAttr; // the final position;

		if (visible) {

			// The alignment box is a singular point
			alignTo = extend({
				x: inverted ? chart.plotWidth - plotY : plotX,
				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
				width: 0,
				height: 0
			}, alignTo);

			// Add the text size for alignment calculation
			extend(options, {
				width: bBox.width,
				height: bBox.height
			});

			// Allow a hook for changing alignment in the last moment, then do the alignment
			if (options.rotation) { // Fancy box alignment isn't supported for rotated text
				rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
				dataLabel[isNew ? 'attr' : 'animate']({
						x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
						y: alignTo.y + options.y + alignTo.height / 2
					})
					.attr({ // #3003
						align: options.align
					});
			} else {
				dataLabel.align(options, null, alignTo);
				alignAttr = dataLabel.alignAttr;

				// Handle justify or crop
				if (pick(options.overflow, 'justify') === 'justify') {
					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

				} else if (pick(options.crop, true)) {
					// Now check that the data label is within the plot area
					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

				}

				// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
				if (options.shape) {
					dataLabel.attr({
						anchorX: point.plotX,
						anchorY: point.plotY
					});
				}

			}
		}

		// Show or hide based on the final aligned position
		if (!visible) {
			dataLabel.attr({ y: -999 });
			dataLabel.placed = false; // don't animate back in
		}

	};

	/**
	 * If data labels fall partly outside the plot area, align them back in, in a way that
	 * doesn't hide the point.
	 */
	Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
		var chart = this.chart,
			align = options.align,
			verticalAlign = options.verticalAlign,
			off,
			justified,
			padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

		// Off left
		off = alignAttr.x + padding;
		if (off < 0) {
			if (align === 'right') {
				options.align = 'left';
			} else {
				options.x = -off;
			}
			justified = true;
		}

		// Off right
		off = alignAttr.x + bBox.width - padding;
		if (off > chart.plotWidth) {
			if (align === 'left') {
				options.align = 'right';
			} else {
				options.x = chart.plotWidth - off;
			}
			justified = true;
		}

		// Off top
		off = alignAttr.y + padding;
		if (off < 0) {
			if (verticalAlign === 'bottom') {
				options.verticalAlign = 'top';
			} else {
				options.y = -off;
			}
			justified = true;
		}

		// Off bottom
		off = alignAttr.y + bBox.height - padding;
		if (off > chart.plotHeight) {
			if (verticalAlign === 'top') {
				options.verticalAlign = 'bottom';
			} else {
				options.y = chart.plotHeight - off;
			}
			justified = true;
		}

		if (justified) {
			dataLabel.placed = !isNew;
			dataLabel.align(options, null, alignTo);
		}
	};

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawDataLabels = function () {
			var series = this,
				data = series.data,
				point,
				chart = series.chart,
				options = series.options.dataLabels,
				connectorPadding = pick(options.connectorPadding, 10),
				connectorWidth = pick(options.connectorWidth, 1),
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				connector,
				connectorPath,
				softConnector = pick(options.softConnector, true),
				distanceOption = options.distance,
				seriesCenter = series.center,
				radius = seriesCenter[2] / 2,
				centerY = seriesCenter[1],
				outside = distanceOption > 0,
				dataLabel,
				dataLabelWidth,
				labelPos,
				labelHeight,
				halves = [// divide the points into right and left halves for anti collision
					[], // right
					[]  // left
				],
				x,
				y,
				visibility,
				rankArr,
				i,
				j,
				overflow = [0, 0, 0, 0], // top, right, bottom, left
				sort = function (a, b) {
					return b.y - a.y;
				};

			// get out if not enabled
			if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
				return;
			}

			// run parent method
			Series.prototype.drawDataLabels.apply(series);

			// arrange points for detection collision
			each(data, function (point) {
				if (point.dataLabel && point.visible) { // #407, #2510
					halves[point.half].push(point);
				}
			});

			/* Loop over the points in each half, starting from the top and bottom
			 * of the pie to detect overlapping labels.
			 */
			i = 2;
			while (i--) {

				var slots = [],
					slotsLength,
					usedSlots = [],
					points = halves[i],
					pos,
					bottom,
					length = points.length,
					slotIndex;

				if (!length) {
					continue;
				}

				// Sort by angle
				series.sortByAngle(points, i - 0.5);

				// Assume equal label heights on either hemisphere (#2630)
				j = labelHeight = 0;
				while (!labelHeight && points[j]) { // #1569
					labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
					j++;
				}

				// Only do anti-collision when we are outside the pie and have connectors (#856)
				if (distanceOption > 0) {

					// Build the slots
					bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
					for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
						slots.push(pos);
					}
					slotsLength = slots.length;


					/* Visualize the slots
					if (!series.slotElements) {
						series.slotElements = [];
					}
					if (i === 1) {
						series.slotElements.forEach(function (elem) {
							elem.destroy();
						});
						series.slotElements.length = 0;
					}
						
					slots.forEach(function (pos, no) {
						var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
							slotY = pos + chart.plotTop;
						
						if (!isNaN(slotX)) {
							series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
								.attr({
									'stroke-width': 1,
									stroke: 'silver',
									fill: 'rgba(0,0,255,0.1)'
								})
								.add());
							series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
								.attr({
									fill: 'silver'
								}).add());
						}
					});
					// */

					// if there are more values than available slots, remove lowest values
					if (length > slotsLength) {
						// create an array for sorting and ranking the points within each quarter
						rankArr = [].concat(points);
						rankArr.sort(sort);
						j = length;
						while (j--) {
							rankArr[j].rank = j;
						}
						j = length;
						while (j--) {
							if (points[j].rank >= slotsLength) {
								points.splice(j, 1);
							}
						}
						length = points.length;
					}

					// The label goes to the nearest open slot, but not closer to the edge than
					// the label's index.
					for (j = 0; j < length; j++) {

						point = points[j];
						labelPos = point.labelPos;

						var closest = 9999,
							distance,
							slotI;

						// find the closest slot index
						for (slotI = 0; slotI < slotsLength; slotI++) {
							distance = mathAbs(slots[slotI] - labelPos[1]);
							if (distance < closest) {
								closest = distance;
								slotIndex = slotI;
							}
						}

						// if that slot index is closer to the edges of the slots, move it
						// to the closest appropriate slot
						if (slotIndex < j && slots[j] !== null) { // cluster at the top
							slotIndex = j;
						} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
							slotIndex = slotsLength - length + j;
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						} else {
							// Slot is taken, find next free slot below. In the next run, the next slice will find the
							// slot above these, because it is the closest one
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						}

						usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
						slots[slotIndex] = null; // mark as taken
					}
					// sort them in order to fill in from the top
					usedSlots.sort(sort);
				}

				// now the used slots are sorted, fill them up sequentially
				for (j = 0; j < length; j++) {

					var slot, naturalY;

					point = points[j];
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;
					visibility = point.visible === false ? HIDDEN : 'inherit';
					naturalY = labelPos[1];

					if (distanceOption > 0) {
						slot = usedSlots.pop();
						slotIndex = slot.i;

						// if the slot next to currrent slot is free, the y value is allowed
						// to fall back to the natural position
						y = slot.y;
						if ((naturalY > y && slots[slotIndex + 1] !== null) ||
								(naturalY < y &&  slots[slotIndex - 1] !== null)) {
							y = mathMin(mathMax(0, naturalY), chart.plotHeight);
						}

					} else {
						y = naturalY;
					}

					// get the x - use the natural x position for first and last slot, to prevent the top
					// and botton slice connectors from touching each other on either side
					x = options.justify ?
						seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
						series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


					// Record the placement and visibility
					dataLabel._attr = {
						visibility: visibility,
						align: labelPos[6]
					};
					dataLabel._pos = {
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y - 10 // 10 is for the baseline (label vs text)
					};
					dataLabel.connX = x;
					dataLabel.connY = y;


					// Detect overflowing data labels
					if (this.options.size === null) {
						dataLabelWidth = dataLabel.width;
						// Overflow left
						if (x - dataLabelWidth < connectorPadding) {
							overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

						// Overflow right
						} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
							overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
						}

						// Overflow top
						if (y - labelHeight / 2 < 0) {
							overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

						// Overflow left
						} else if (y + labelHeight / 2 > plotHeight) {
							overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
						}
					}
				} // for each point
			} // for each half

			// Do not apply the final placement and draw the connectors until we have verified
			// that labels are not spilling over.
			if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

				// Place the labels in the final position
				this.placeDataLabels();

				// Draw the connectors
				if (outside && connectorWidth) {
					each(this.points, function (point) {
						connector = point.connector;
						labelPos = point.labelPos;
						dataLabel = point.dataLabel;

						if (dataLabel && dataLabel._pos && point.visible) {
							visibility = dataLabel._attr.visibility;
							x = dataLabel.connX;
							y = dataLabel.connY;
							connectorPath = softConnector ? [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								'C',
								x, y, // first break, next to the label
								2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							] : [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								L,
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							];

							if (connector) {
								connector.animate({ d: connectorPath });
								connector.attr('visibility', visibility);

							} else {
								point.connector = connector = series.chart.renderer.path(connectorPath).attr({
									'stroke-width': connectorWidth,
									stroke: options.connectorColor || point.color || '#606060',
									visibility: visibility
									//zIndex: 0 // #2722 (reversed)
								})
								.add(series.dataLabelsGroup);
							}
						} else if (connector) {
							point.connector = connector.destroy();
						}
					});
				}
			}
		};
		/**
		 * Perform the final placement of the data labels after we have verified that they
		 * fall within the plot area.
		 */
		seriesTypes.pie.prototype.placeDataLabels = function () {
			each(this.points, function (point) {
				var dataLabel = point.dataLabel,
					_pos;

				if (dataLabel && point.visible) {
					_pos = dataLabel._pos;
					if (_pos) {
						dataLabel.attr(dataLabel._attr);
						dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
						dataLabel.moved = true;
					} else if (dataLabel) {
						dataLabel.attr({ y: -999 });
					}
				}
			});
		};

		seriesTypes.pie.prototype.alignDataLabel =  noop;

		/**
		 * Verify whether the data labels are allowed to draw, or we should run more translation and data
		 * label positioning to keep them inside the plot area. Returns true when data labels are ready
		 * to draw.
		 */
		seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

			var center = this.center,
				options = this.options,
				centerOption = options.center,
				minSize = options.minSize || 80,
				newSize = minSize,
				ret;

			// Handle horizontal size and center
			if (centerOption[0] !== null) { // Fixed center
				newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

			} else { // Auto center
				newSize = mathMax(
					center[2] - overflow[1] - overflow[3], // horizontal overflow
					minSize
				);
				center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
			}

			// Handle vertical size and center
			if (centerOption[1] !== null) { // Fixed center
				newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

			} else { // Auto center
				newSize = mathMax(
					mathMin(
						newSize,
						center[2] - overflow[0] - overflow[2] // vertical overflow
					),
					minSize
				);
				center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
			}

			// If the size must be decreased, we need to run translate and drawDataLabels again
			if (newSize < center[2]) {
				center[2] = newSize;
				center[3] = relativeLength(options.innerSize || 0, newSize);
				this.translate(center);
				each(this.points, function (point) {
					if (point.dataLabel) {
						point.dataLabel._pos = null; // reset
					}
				});

				if (this.drawDataLabels) {
					this.drawDataLabels();
				}
			// Else, return true to indicate that the pie and its labels is within the plot area
			} else {
				ret = true;
			}
			return ret;
		};
	}

	if (seriesTypes.column) {

		/**
		 * Override the basic data label alignment by adjusting for the position of the column
		 */
		seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
			var inverted = this.chart.inverted,
				series = point.series,
				dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
				below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
				inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

			// Align to the column itself, or the top of it
			if (dlBox) { // Area range uses this method but not alignTo
				alignTo = merge(dlBox);

				if (inverted) {
					alignTo = {
						x: series.yAxis.len - alignTo.y - alignTo.height,
						y: series.xAxis.len - alignTo.x - alignTo.width,
						width: alignTo.height,
						height: alignTo.width
					};
				}

				// Compute the alignment box
				if (!inside) {
					if (inverted) {
						alignTo.x += below ? 0 : alignTo.width;
						alignTo.width = 0;
					} else {
						alignTo.y += below ? alignTo.height : 0;
						alignTo.height = 0;
					}
				}
			}


			// When alignment is undefined (typically columns and bars), display the individual
			// point below or above the point depending on the threshold
			options.align = pick(
				options.align,
				!inverted || inside ? 'center' : below ? 'right' : 'left'
			);
			options.verticalAlign = pick(
				options.verticalAlign,
				inverted || inside ? 'middle' : below ? 'top' : 'bottom'
			);

			// Call the parent method
			Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
		};
	}



	/**
	 * Highcharts JS v4.1.7-modified ()
	 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
	 *
	 * (c) 2010-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	/*global Highcharts, HighchartsAdapter */
	(function (H) {
		var Chart = H.Chart,
			each = H.each,
			pick = H.pick,
			addEvent = HighchartsAdapter.addEvent;

		// Collect potensial overlapping data labels. Stack labels probably don't need to be 
		// considered because they are usually accompanied by data labels that lie inside the columns.
		Chart.prototype.callbacks.push(function (chart) {
			function collectAndHide() {
				var labels = [];

				each(chart.series, function (series) {
					var dlOptions = series.options.dataLabels;
					if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
						each(series.points, function (point) { 
							if (point.dataLabel) {
								point.dataLabel.labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
								labels.push(point.dataLabel);
							}
						});
					}
				});
				chart.hideOverlappingLabels(labels);
			}

			// Do it now ...
			collectAndHide();

			// ... and after each chart redraw
			addEvent(chart, 'redraw', collectAndHide);

		});

		/**
		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
		 * visual imression.
		 */		
		Chart.prototype.hideOverlappingLabels = function (labels) {

			var len = labels.length,
				label,
				i,
				j,
				label1,
				label2,
				isIntersecting,
				pos1,
				pos2,
				padding,
				intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
					return !(
						x2 > x1 + w1 ||
						x2 + w2 < x1 ||
						y2 > y1 + h1 ||
						y2 + h2 < y1
					);
				};
		
			// Mark with initial opacity
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					label.oldOpacity = label.opacity;
					label.newOpacity = 1;
				}
			}

			// Prevent a situation in a gradually rising slope, that each label
			// will hide the previous one because the previous one always has
			// lower rank.
			labels.sort(function (a, b) {
				return (b.labelrank || 0) - (a.labelrank || 0);
			});

			// Detect overlapping labels
			for (i = 0; i < len; i++) {
				label1 = labels[i];

				for (j = i + 1; j < len; ++j) {
					label2 = labels[j];
					if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
						pos1 = label1.alignAttr;
						pos2 = label2.alignAttr;
						padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)
						isIntersecting = intersectRect(
							pos1.x,
							pos1.y,
							label1.width - padding,
							label1.height - padding,
							pos2.x,
							pos2.y,
							label2.width - padding,
							label2.height - padding
						);

						if (isIntersecting) {
							(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
						}
					}
				}
			}

			// Hide or show
			each(labels, function (label) {
				var complete,
					newOpacity;

				if (label) {
					newOpacity = label.newOpacity;

					if (label.oldOpacity !== newOpacity && label.placed) {

						// Make sure the label is completely hidden to avoid catching clicks (#4362)
						if (newOpacity) {
							label.show(true);
						} else {
							complete = function () {
								label.hide();
							};
						}

						// Animate or set the opacity					
						label.alignAttr.opacity = newOpacity;
						label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
						
					}
					label.isOld = true;
				}
			});
		};

	}(Highcharts));/**
	 * TrackerMixin for points and graphs
	 */

	var TrackerMixin = Highcharts.TrackerMixin = {

		drawTrackerPoint: function () {
			var series = this,
				chart = series.chart,
				pointer = chart.pointer,
				cursor = series.options.cursor,
				css = cursor && { cursor: cursor },
				onMouseOver = function (e) {
					var target = e.target,
					point;

					while (target && !point) {
						point = target.point;
						target = target.parentNode;
					}

					if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
						point.onMouseOver(e);
					}
				};

			// Add reference to the point
			each(series.points, function (point) {
				if (point.graphic) {
					point.graphic.element.point = point;
				}
				if (point.dataLabel) {
					point.dataLabel.element.point = point;
				}
			});

			// Add the event listeners, we need to do this only once
			if (!series._hasTracking) {
				each(series.trackerGroups, function (key) {
					if (series[key]) { // we don't always have dataLabelsGroup
						series[key]
							.addClass(PREFIX + 'tracker')
							.on('mouseover', onMouseOver)
							.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
							.css(css);
						if (hasTouch) {
							series[key].on('touchstart', onMouseOver);
						}
					}
				});
				series._hasTracking = true;
			}
		},

		/**
		 * Draw the tracker object that sits above all data labels and markers to
		 * track mouse events on the graph or points. For the line type charts
		 * the tracker uses the same graphPath, but with a greater stroke width
		 * for better control.
		 */
		drawTrackerGraph: function () {
			var series = this,
				options = series.options,
				trackByArea = options.trackByArea,
				trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
				trackerPathLength = trackerPath.length,
				chart = series.chart,
				pointer = chart.pointer,
				renderer = chart.renderer,
				snap = chart.options.tooltip.snap,
				tracker = series.tracker,
				cursor = options.cursor,
				css = cursor && { cursor: cursor },
				singlePoints = series.singlePoints,
				singlePoint,
				i,
				onMouseOver = function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				},
				/*
				 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
				 * IE6: 0.002
				 * IE7: 0.002
				 * IE8: 0.002
				 * IE9: 0.00000000001 (unlimited)
				 * IE10: 0.0001 (exporting only)
				 * FF: 0.00000000001 (unlimited)
				 * Chrome: 0.000001
				 * Safari: 0.000001
				 * Opera: 0.00000000001 (unlimited)
				 */
				TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

			// Extend end points. A better way would be to use round linecaps,
			// but those are not clickable in VML.
			if (trackerPathLength && !trackByArea) {
				i = trackerPathLength + 1;
				while (i--) {
					if (trackerPath[i] === M) { // extend left side
						trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
					}
					if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
						trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
					}
				}
			}

			// handle single points
			for (i = 0; i < singlePoints.length; i++) {
				singlePoint = singlePoints[i];
				trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
			}

			// draw the tracker
			if (tracker) {
				tracker.attr({ d: trackerPath });
			} else { // create

				series.tracker = renderer.path(trackerPath)
				.attr({
					'stroke-linejoin': 'round', // #1225
					visibility: series.visible ? VISIBLE : HIDDEN,
					stroke: TRACKER_FILL,
					fill: trackByArea ? TRACKER_FILL : NONE,
					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
					zIndex: 2
				})
				.add(series.group);

				// The tracker is added to the series group, which is clipped, but is covered
				// by the marker group. So the marker group also needs to capture events.
				each([series.tracker, series.markerGroup], function (tracker) {
					tracker.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);

					if (hasTouch) {
						tracker.on('touchstart', onMouseOver);
					}
				});
			}
		}
	};
	/* End TrackerMixin */


	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */ 

	if (seriesTypes.column) {
		ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
	}

	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	if (seriesTypes.scatter) {
		ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	/* 
	 * Extend Legend for item events 
	 */ 
	extend(Legend.prototype, {

		setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
		var legend = this;
		// Set the events on the item group, or in case of useHTML, the item itself (#1249)
		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
				item.setState(HOVER_STATE);
				legendItem.css(legend.options.itemHoverStyle);
			})
			.on('mouseout', function () {
				legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
				item.setState();
			})
			.on('click', function (event) {
				var strLegendItemClick = 'legendItemClick',
					fnLegendItemClick = function () {
						item.setVisible();
					};
					
				// Pass over the click/touch event. #4.
				event = {
					browserEvent: event
				};

				// click the name or symbol
				if (item.firePointEvent) { // point
					item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
				} else {
					fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
				}
			});
		},

		createCheckboxForItem: function (item) {
			var legend = this;

			item.checkbox = createElement('input', {
				type: 'checkbox',
				checked: item.selected,
				defaultChecked: item.selected // required by IE7
			}, legend.options.itemCheckboxStyle, legend.chart.container);

			addEvent(item.checkbox, 'click', function (event) {
				var target = event.target;
				fireEvent(item.series || item, 'checkboxClick', { // #3712
						checked: target.checked,
						item: item
					},
					function () {
						item.select();
					}
				);
			});
		}	
	});

	/* 
	 * Add pointer cursor to legend itemstyle in defaultOptions
	 */
	defaultOptions.legend.itemStyle.cursor = 'pointer';


	/* 
	 * Extend the Chart object with interaction
	 */

	extend(Chart.prototype, {
		/**
		 * Display the zoom button
		 */
		showResetZoom: function () {
			var chart = this,
				lang = defaultOptions.lang,
				btnOptions = chart.options.chart.resetZoomButton,
				theme = btnOptions.theme,
				states = theme.states,
				alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
				
			this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
				.attr({
					align: btnOptions.position.align,
					title: lang.resetZoomTitle
				})
				.add()
				.align(btnOptions.position, false, alignTo);
				
		},

		/**
		 * Zoom out to 1:1
		 */
		zoomOut: function () {
			var chart = this;
			fireEvent(chart, 'selection', { resetSelection: true }, function () { 
				chart.zoom();
			});
		},

		/**
		 * Zoom into a given portion of the chart given by axis coordinates
		 * @param {Object} event
		 */
		zoom: function (event) {
			var chart = this,
				hasZoomed,
				pointer = chart.pointer,
				displayButton = false,
				resetZoomButton;

			// If zoom is called with no arguments, reset the axes
			if (!event || event.resetSelection) {
				each(chart.axes, function (axis) {
					hasZoomed = axis.zoom();
				});
			} else { // else, zoom in on all axes
				each(event.xAxis.concat(event.yAxis), function (axisData) {
					var axis = axisData.axis,
						isXAxis = axis.isXAxis;

					// don't zoom more than minRange
					if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
						hasZoomed = axis.zoom(axisData.min, axisData.max);
						if (axis.displayBtn) {
							displayButton = true;
						}
					}
				});
			}
			
			// Show or hide the Reset zoom button
			resetZoomButton = chart.resetZoomButton;
			if (displayButton && !resetZoomButton) {
				chart.showResetZoom();
			} else if (!displayButton && isObject(resetZoomButton)) {
				chart.resetZoomButton = resetZoomButton.destroy();
			}
			

			// Redraw
			if (hasZoomed) {
				chart.redraw(
					pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
				);
			}
		},

		/**
		 * Pan the chart by dragging the mouse across the pane. This function is called
		 * on mouse move, and the distance to pan is computed from chartX compared to
		 * the first chartX position in the dragging operation.
		 */
		pan: function (e, panning) {

			var chart = this,
				hoverPoints = chart.hoverPoints,
				doRedraw;

			// remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
				var mousePos = e[isX ? 'chartX' : 'chartY'],
					axis = chart[isX ? 'xAxis' : 'yAxis'][0],
					startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
					halfPointRange = (axis.pointRange || 0) / 2,
					extremes = axis.getExtremes(),
					newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
					newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
					goingLeft = startPos > mousePos; // #3613

				if (axis.series.length && 
						(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
						(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
					axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
					doRedraw = true;
				}

				chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
			});

			if (doRedraw) {
				chart.redraw(false);
			}
			css(chart.container, { cursor: 'move' });
		}
	});

	/*
	 * Extend the Point object with interaction
	 */
	extend(Point.prototype, {
		/**
		 * Toggle the selection status of a point
		 * @param {Boolean} selected Whether to select or unselect the point.
		 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
		 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
		 */
		select: function (selected, accumulate) {
			var point = this,
				series = point.series,
				chart = series.chart;

			selected = pick(selected, !point.selected);

			// fire the event with the defalut handler
			point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
				point.selected = point.options.selected = selected;
				series.options.data[inArray(point, series.data)] = point.options;

				point.setState(selected && SELECT_STATE);

				// unselect all other points unless Ctrl or Cmd + click
				if (!accumulate) {
					each(chart.getSelectedPoints(), function (loopPoint) {
						if (loopPoint.selected && loopPoint !== point) {
							loopPoint.selected = loopPoint.options.selected = false;
							series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
							loopPoint.setState(NORMAL_STATE);
								loopPoint.firePointEvent('unselect');
						}
					});
				}
			});
		},

		/**
		 * Runs on mouse over the point
		 */
		onMouseOver: function (e) {
			var point = this,
				series = point.series,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			if (chart.hoverSeries !== series) {
				series.onMouseOver();
			}		

			// set normal state to previous series
			if (hoverPoint && hoverPoint !== point) {
				hoverPoint.onMouseOut();
			}

			if (point.series) { // It may have been destroyed, #4130

				// trigger the event
				point.firePointEvent('mouseOver');

				// update the tooltip
				if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
					tooltip.refresh(point, e);
				}

				// hover this
				point.setState(HOVER_STATE);
				chart.hoverPoint = point;
			}
		},

		/**
		 * Runs on mouse out from the point
		 */
		onMouseOut: function () {
			var chart = this.series.chart,
				hoverPoints = chart.hoverPoints;

			this.firePointEvent('mouseOut');

			if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
				this.setState();
				chart.hoverPoint = null;
			}
		},

		/**
		 * Import events from the series' and point's options. Only do it on
		 * demand, to save processing time on hovering.
		 */
		importEvents: function () {
			if (!this.hasImportedEvents) {
				var point = this,
					options = merge(point.series.options.point, point.options),
					events = options.events,
					eventType;

				point.events = events;

				for (eventType in events) {
					addEvent(point, eventType, events[eventType]);
				}
				this.hasImportedEvents = true;

			}
		},

		/**
		 * Set the point's state
		 * @param {String} state
		 */
		setState: function (state, move) {
			var point = this,
				plotX = point.plotX,
				plotY = point.plotY,
				series = point.series,
				stateOptions = series.options.states,
				markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
				normalDisabled = markerOptions && !markerOptions.enabled,
				markerStateOptions = markerOptions && markerOptions.states[state],
				stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
				stateMarkerGraphic = series.stateMarkerGraphic,
				pointMarker = point.marker || {},
				chart = series.chart,
				radius,
				halo = series.halo,
				haloOptions,
				newSymbol,
				pointAttr;

			state = state || NORMAL_STATE; // empty string
			pointAttr = point.pointAttr[state] || series.pointAttr[state];

			if (
					// already has this state
					(state === point.state && !move) ||
					// selected points don't respond to hover
					(point.selected && state !== SELECT_STATE) ||
					// series' state options is disabled
					(stateOptions[state] && stateOptions[state].enabled === false) ||
					// general point marker's state options is disabled
					(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
					// individual point marker's state options is disabled
					(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

				) {
				return;
			}

			// apply hover styles to the existing point
			if (point.graphic) {
				radius = markerOptions && point.graphic.symbolName && pointAttr.r;
				point.graphic.attr(merge(
					pointAttr,
					radius ? { // new symbol attributes (#507, #612)
						x: plotX - radius,
						y: plotY - radius,
						width: 2 * radius,
						height: 2 * radius
					} : {}
				));

				// Zooming in from a range with no markers to a range with markers
				if (stateMarkerGraphic) {
					stateMarkerGraphic.hide();
				}
			} else {
				// if a graphic is not applied to each point in the normal state, create a shared
				// graphic for the hover state
				if (state && markerStateOptions) {
					radius = markerStateOptions.radius;
					newSymbol = pointMarker.symbol || series.symbol;

					// If the point has another symbol than the previous one, throw away the
					// state marker graphic and force a new one (#1459)
					if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
						stateMarkerGraphic = stateMarkerGraphic.destroy();
					}

					// Add a new state marker graphic
					if (!stateMarkerGraphic) {
						if (newSymbol) {
							series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
								newSymbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius
							)
							.attr(pointAttr)
							.add(series.markerGroup);
							stateMarkerGraphic.currentSymbol = newSymbol;
						}

					// Move the existing graphic
					} else {
						stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
							x: plotX - radius,
							y: plotY - radius
						});
					}
				}

				if (stateMarkerGraphic) {
					stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
					stateMarkerGraphic.element.point = point; // #4310
				}
			}

			// Show me your halo
			haloOptions = stateOptions[state] && stateOptions[state].halo;
			if (haloOptions && haloOptions.size) {
				if (!halo) {
					series.halo = halo = chart.renderer.path()
						.add(chart.seriesGroup);
				}
				halo.attr(extend({
					fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
				}, haloOptions.attributes))[move ? 'animate' : 'attr']({
					d: point.haloPath(haloOptions.size)
				});
			} else if (halo) {
				halo.attr({ d: [] });
			}

			point.state = state;
		},

		haloPath: function (size) {
			var series = this.series,
				chart = series.chart,
				plotBox = series.getPlotBox(),
				inverted = chart.inverted;

			return chart.renderer.symbols.circle(
				plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
				plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
				size * 2, 
				size * 2
			);
		}
	});

	/*
	 * Extend the Series object with interaction
	 */

	extend(Series.prototype, {
		/**
		 * Series mouse over handler
		 */
		onMouseOver: function () {
			var series = this,
				chart = series.chart,
				hoverSeries = chart.hoverSeries;

			// set normal state to previous series
			if (hoverSeries && hoverSeries !== series) {
				hoverSeries.onMouseOut();
			}

			// trigger the event, but to save processing time,
			// only if defined
			if (series.options.events.mouseOver) {
				fireEvent(series, 'mouseOver');
			}

			// hover this
			series.setState(HOVER_STATE);
			chart.hoverSeries = series;
		},

		/**
		 * Series mouse out handler
		 */
		onMouseOut: function () {
			// trigger the event only if listeners exist
			var series = this,
				options = series.options,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

			// trigger mouse out on the point, which must be in this series
			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			// fire the mouse out event
			if (series && options.events.mouseOut) {
				fireEvent(series, 'mouseOut');
			}


			// hide the tooltip
			if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.hide();
			}

			// set normal state
			series.setState();
		},

		/**
		 * Set the state of the graph
		 */
		setState: function (state) {
			var series = this,
				options = series.options,
				graph = series.graph,
				stateOptions = options.states,
				lineWidth = options.lineWidth,
				attribs,
				i = 0;

			state = state || NORMAL_STATE;

			if (series.state !== state) {
				series.state = state;

				if (stateOptions[state] && stateOptions[state].enabled === false) {
					return;
				}

				if (state) {
					lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
				}

				if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
					attribs = {
						'stroke-width': lineWidth
					};
					// use attr because animate will cause any other animation on the graph to stop
					graph.attr(attribs);
					while (series['zoneGraph' + i]) {
						series['zoneGraph' + i].attr(attribs);
						i = i + 1;
					}
				}
			}
		},

		/**
		 * Set the visibility of the graph
		 *
		 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
		 *				the visibility is toggled.
		 */
		setVisible: function (vis, redraw) {
			var series = this,
				chart = series.chart,
				legendItem = series.legendItem,
				showOrHide,
				ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
				oldVisibility = series.visible;

			// if called without an argument, toggle visibility
			series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
			showOrHide = vis ? 'show' : 'hide';

			// show or hide elements
			each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
				if (series[key]) {
					series[key][showOrHide]();
				}
			});


			// hide tooltip (#1361)
			if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
				series.onMouseOut();
			}


			if (legendItem) {
				chart.legend.colorizeItem(series, vis);
			}


			// rescale or adapt to resized chart
			series.isDirty = true;
			// in a stack, all other series are affected
			if (series.options.stacking) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.options.stacking && otherSeries.visible) {
						otherSeries.isDirty = true;
					}
				});
			}

			// show or hide linked series
			each(series.linkedSeries, function (otherSeries) {
				otherSeries.setVisible(vis, false);
			});

			if (ignoreHiddenSeries) {
				chart.isDirtyBox = true;
			}
			if (redraw !== false) {
				chart.redraw();
			}

			fireEvent(series, showOrHide);
		},

		/**
		 * Show the graph
		 */
		show: function () {
			this.setVisible(true);
		},

		/**
		 * Hide the graph
		 */
		hide: function () {
			this.setVisible(false);
		},


		/**
		 * Set the selected state of the graph
		 *
		 * @param selected {Boolean} True to select the series, false to unselect. If
		 *				UNDEFINED, the selection state is toggled.
		 */
		select: function (selected) {
			var series = this;
			// if called without an argument, toggle
			series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

			if (series.checkbox) {
				series.checkbox.checked = selected;
			}

			fireEvent(series, selected ? 'select' : 'unselect');
		},

		drawTracker: TrackerMixin.drawTrackerGraph
	});
	// global variables
	extend(Highcharts, {
		
		// Constructors
		Color: Color,
		Point: Point,
		Tick: Tick,	
		Renderer: Renderer,
		SVGElement: SVGElement,
		SVGRenderer: SVGRenderer,
		
		// Various
		arrayMin: arrayMin,
		arrayMax: arrayMax,
		charts: charts,
		dateFormat: dateFormat,
		error: error,
		format: format,
		pathAnim: pathAnim,
		getOptions: getOptions,
		hasBidiBug: hasBidiBug,
		isTouchDevice: isTouchDevice,
		setOptions: setOptions,
		addEvent: addEvent,
		removeEvent: removeEvent,
		createElement: createElement,
		discardElement: discardElement,
		css: css,
		each: each,
		map: map,
		merge: merge,
		splat: splat,
		extendClass: extendClass,
		pInt: pInt,
		svg: hasSVG,
		canvas: useCanVG,
		vml: !hasSVG && !useCanVG,
		product: PRODUCT,
		version: VERSION
	});

	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = Highcharts

/***/ }
/******/ ])
});

},{"react":184,"react/addons":10}],10:[function(require,module,exports){
'use strict';

var warning = require('fbjs/lib/warning');
warning(
  false,
  // Require examples in this string must be split to prevent React's
  // build tools from mistaking them for real requires.
  // Otherwise the build tools will attempt to build a 'react-addons-{addon}' module.
  'require' + "('react/addons') is deprecated. " +
  'Access using require' + "('react-addons-{addon}') instead."
);

module.exports = require('./lib/ReactWithAddons');

},{"./lib/ReactWithAddons":107,"fbjs/lib/warning":183}],11:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusUtils
 * @typechecks static-only
 */

'use strict';

var ReactMount = require('./ReactMount');

var findDOMNode = require('./findDOMNode');
var focusNode = require('fbjs/lib/focusNode');

var Mixin = {
  componentDidMount: function () {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

var AutoFocusUtils = {
  Mixin: Mixin,

  focusDOMComponent: function () {
    focusNode(ReactMount.getNode(this._rootNodeID));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactMount":81,"./findDOMNode":132,"fbjs/lib/focusNode":165}],12:[function(require,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var keyOf = require('fbjs/lib/keyOf');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventConstants":24,"./EventPropagators":28,"./FallbackCompositionState":29,"./SyntheticCompositionEvent":113,"./SyntheticInputEvent":117,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/keyOf":176}],13:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],14:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactPerf = require('./ReactPerf');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function (styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function (node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
  setValueForStyles: 'setValueForStyles'
});

module.exports = CSSPropertyOperations;
}).call(this,require('_process'))

},{"./CSSProperty":13,"./ReactPerf":87,"./dangerousStyleValue":129,"_process":2,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/camelizeStyleName":159,"fbjs/lib/hyphenateStyleName":170,"fbjs/lib/memoizeStringOnly":178,"fbjs/lib/warning":183}],15:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
}).call(this,require('_process'))

},{"./Object.assign":33,"./PooledClass":34,"_process":2,"fbjs/lib/invariant":171}],16:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventConstants":24,"./EventPluginHub":25,"./EventPropagators":28,"./ReactUpdates":105,"./SyntheticEvent":115,"./getEventTarget":138,"./isEventSupported":143,"./isTextInputElement":144,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/keyOf":176}],17:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function () {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;
},{}],18:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = require('./Danger');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');
var ReactPerf = require('./ReactPerf');

var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var invariant = require('fbjs/lib/invariant');

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function (updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup;
    // markupList is either a list of markup or just a list of elements
    if (markupList.length && typeof markupList[0] === 'string') {
      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
    } else {
      renderedMarkup = markupList;
    }

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.SET_MARKUP:
          setInnerHTML(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
  updateTextContent: 'updateTextContent'
});

module.exports = DOMChildrenOperations;
}).call(this,require('_process'))

},{"./Danger":21,"./ReactMultiChildUpdateTypes":83,"./ReactPerf":87,"./setInnerHTML":148,"./setTextContent":149,"_process":2,"fbjs/lib/invariant":171}],19:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };

      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseAttribute:
   *   Whether the property must be accessed and mutated using `*Attribute()`.
   *   (This includes anything that fails `<propName> in <element>`.)
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasSideEffects:
   *   Whether or not setting a value causes side effects such as triggering
   *   resources to be loaded or text selection changes. If true, we read from
   *   the DOM before updating to ensure that the value is only set if it has
   *   changed.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function (nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],20:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactPerf = require('./ReactPerf');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

// Simplified subset
var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
      } else if (propertyInfo.mustUseAttribute) {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = propertyInfo.propertyName;
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseAttribute) {
        node.removeAttribute(propertyInfo.attributeName);
      } else {
        var propName = propertyInfo.propertyName;
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  }

};

ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
  setValueForProperty: 'setValueForProperty',
  setValueForAttribute: 'setValueForAttribute',
  deleteValueForProperty: 'deleteValueForProperty'
});

module.exports = DOMPropertyOperations;
}).call(this,require('_process'))

},{"./DOMProperty":19,"./ReactPerf":87,"./quoteAttributeValueForBrowser":146,"_process":2,"fbjs/lib/warning":183}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var getMarkupWrap = require('fbjs/lib/getMarkupWrap');
var invariant = require('fbjs/lib/invariant');

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

    var newChild;
    if (typeof markup === 'string') {
      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    } else {
      newChild = markup;
    }
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/createNodesFromMarkup":162,"fbjs/lib/emptyFunction":163,"fbjs/lib/getMarkupWrap":167,"fbjs/lib/invariant":171}],22:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require('fbjs/lib/keyOf');

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"fbjs/lib/keyOf":176}],23:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var ReactMount = require('./ReactMount');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    var fromID = '';
    var toID = '';
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      fromID = topLevelTargetID;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
      if (to) {
        toID = ReactMount.getID(to);
      } else {
        to = win;
      }
      to = to || win;
    } else {
      from = win;
      to = topLevelTarget;
      toID = topLevelTargetID;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventConstants":24,"./EventPropagators":28,"./ReactMount":81,"./SyntheticMouseEvent":119,"fbjs/lib/keyOf":176}],24:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topAbort: null,
  topBlur: null,
  topCanPlay: null,
  topCanPlayThrough: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topDurationChange: null,
  topEmptied: null,
  topEncrypted: null,
  topEnded: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topLoadedData: null,
  topLoadedMetadata: null,
  topLoadStart: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topPause: null,
  topPlay: null,
  topPlaying: null,
  topProgress: null,
  topRateChange: null,
  topReset: null,
  topScroll: null,
  topSeeked: null,
  topSeeking: null,
  topSelectionChange: null,
  topStalled: null,
  topSubmit: null,
  topSuspend: null,
  topTextInput: null,
  topTimeUpdate: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topVolumeChange: null,
  topWaiting: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"fbjs/lib/keyMirror":175}],25:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function (InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function () {
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function (id, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function (id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
}).call(this,require('_process'))

},{"./EventPluginRegistry":26,"./EventPluginUtils":27,"./ReactErrorUtils":70,"./accumulateInto":125,"./forEachAccumulated":134,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],26:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],27:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require('./EventConstants');
var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function (InjectedMount) {
    injection.Mount = InjectedMount;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, simulated, listener, domID) {
  var type = event.type || 'unknown-event';
  event.currentTarget = injection.Mount.getNode(domID);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
  }
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function (id) {
    return injection.Mount.getNode(id);
  },
  getID: function (node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;
}).call(this,require('_process'))

},{"./EventConstants":24,"./ReactErrorUtils":70,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],28:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');

var warning = require('fbjs/lib/warning');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
}).call(this,require('_process'))

},{"./EventConstants":24,"./EventPluginHub":25,"./accumulateInto":125,"./forEachAccumulated":134,"_process":2,"fbjs/lib/warning":183}],29:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./Object.assign":33,"./PooledClass":34,"./getTextContentAccessor":141}],30:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    challenge: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    inputMode: MUST_USE_ATTRIBUTE,
    integrity: null,
    is: MUST_USE_ATTRIBUTE,
    keyParams: MUST_USE_ATTRIBUTE,
    keyType: MUST_USE_ATTRIBUTE,
    kind: null,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    nonce: MUST_USE_ATTRIBUTE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcLang: null,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    summary: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,
    wrap: null,

    /**
     * RDFa Properties
     */
    about: MUST_USE_ATTRIBUTE,
    datatype: MUST_USE_ATTRIBUTE,
    inlist: MUST_USE_ATTRIBUTE,
    prefix: MUST_USE_ATTRIBUTE,
    // property is also supported for OpenGraph in meta tags.
    property: MUST_USE_ATTRIBUTE,
    resource: MUST_USE_ATTRIBUTE,
    'typeof': MUST_USE_ATTRIBUTE,
    vocab: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: null,
    autoCorrect: null,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: null,
    // color is for Safari mask-icon link
    color: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: null,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: MUST_USE_ATTRIBUTE,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    autoSave: 'autosave',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":19,"fbjs/lib/ExecutionEnvironment":157}],31:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedStateMixin
 * @typechecks static-only
 */

'use strict';

var ReactLink = require('./ReactLink');
var ReactStateSetters = require('./ReactStateSetters');

/**
 * A simple mixin around ReactLink.forState().
 */
var LinkedStateMixin = {
  /**
   * Create a ReactLink that's linked to part of this component's state. The
   * ReactLink will have the current value of this.state[key] and will call
   * setState() when a change is requested.
   *
   * @param {string} key state key to update. Note: you may want to use keyOf()
   * if you're using Google Closure Compiler advanced mode.
   * @return {ReactLink} ReactLink instance linking to the state.
   */
  linkState: function (key) {
    return new ReactLink(this.state[key], ReactStateSetters.createStateKeySetter(this, key));
  }
};

module.exports = LinkedStateMixin;
},{"./ReactLink":79,"./ReactStateSetters":99}],32:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = require('./ReactPropTypes');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: ReactPropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
}).call(this,require('_process'))

},{"./ReactPropTypeLocations":90,"./ReactPropTypes":91,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],33:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;
},{}],34:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],35:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOM = require('./ReactDOM');
var ReactDOMServer = require('./ReactDOMServer');
var ReactIsomorphic = require('./ReactIsomorphic');

var assign = require('./Object.assign');
var deprecated = require('./deprecated');

// `version` will be added here by ReactIsomorphic.
var React = {};

assign(React, ReactIsomorphic);

assign(React, {
  // ReactDOM
  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

  // ReactDOMServer
  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
});

React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

module.exports = React;
},{"./Object.assign":33,"./ReactDOM":49,"./ReactDOMServer":59,"./ReactIsomorphic":78,"./deprecated":130}],36:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = require('./ReactInstanceMap');

var findDOMNode = require('./findDOMNode');
var warning = require('fbjs/lib/warning');

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function () {
    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;
}).call(this,require('_process'))

},{"./ReactInstanceMap":77,"./findDOMNode":132,"_process":2,"fbjs/lib/warning":183}],37:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ReactPerf = require('./ReactPerf');
var ViewportMetrics = require('./ViewportMetrics');

var assign = require('./Object.assign');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
  putListener: 'putListener',
  deleteListener: 'deleteListener'
});

module.exports = ReactBrowserEventEmitter;
},{"./EventConstants":24,"./EventPluginHub":25,"./EventPluginRegistry":26,"./Object.assign":33,"./ReactEventEmitterMixin":71,"./ReactPerf":87,"./ViewportMetrics":124,"./isEventSupported":143}],38:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroup
 */

'use strict';

var React = require('./React');

var assign = require('./Object.assign');

var ReactTransitionGroup = require('./ReactTransitionGroup');
var ReactCSSTransitionGroupChild = require('./ReactCSSTransitionGroupChild');

function createTransitionTimeoutPropValidator(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;

  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

        // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
          return new Error(timeoutPropName + ' must be a number (in milliseconds)');
        }
    }
  };
}

var ReactCSSTransitionGroup = React.createClass({
  displayName: 'ReactCSSTransitionGroup',

  propTypes: {
    transitionName: ReactCSSTransitionGroupChild.propTypes.name,

    transitionAppear: React.PropTypes.bool,
    transitionEnter: React.PropTypes.bool,
    transitionLeave: React.PropTypes.bool,
    transitionAppearTimeout: createTransitionTimeoutPropValidator('Appear'),
    transitionEnterTimeout: createTransitionTimeoutPropValidator('Enter'),
    transitionLeaveTimeout: createTransitionTimeoutPropValidator('Leave')
  },

  getDefaultProps: function () {
    return {
      transitionAppear: false,
      transitionEnter: true,
      transitionLeave: true
    };
  },

  _wrapChild: function (child) {
    // We need to provide this childFactory so that
    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
    // leave while it is leaving.
    return React.createElement(ReactCSSTransitionGroupChild, {
      name: this.props.transitionName,
      appear: this.props.transitionAppear,
      enter: this.props.transitionEnter,
      leave: this.props.transitionLeave,
      appearTimeout: this.props.transitionAppearTimeout,
      enterTimeout: this.props.transitionEnterTimeout,
      leaveTimeout: this.props.transitionLeaveTimeout
    }, child);
  },

  render: function () {
    return React.createElement(ReactTransitionGroup, assign({}, this.props, { childFactory: this._wrapChild }));
  }
});

module.exports = ReactCSSTransitionGroup;
},{"./Object.assign":33,"./React":35,"./ReactCSSTransitionGroupChild":39,"./ReactTransitionGroup":103}],39:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroupChild
 */

'use strict';

var React = require('./React');
var ReactDOM = require('./ReactDOM');

var CSSCore = require('fbjs/lib/CSSCore');
var ReactTransitionEvents = require('./ReactTransitionEvents');

var onlyChild = require('./onlyChild');

// We don't remove the element from the DOM until we receive an animationend or
// transitionend event. If the user screws up and forgets to add an animation
// their node will be stuck in the DOM forever, so we detect if an animation
// does not start and if it doesn't, we just call the end listener immediately.
var TICK = 17;

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  propTypes: {
    name: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.shape({
      enter: React.PropTypes.string,
      leave: React.PropTypes.string,
      active: React.PropTypes.string
    }), React.PropTypes.shape({
      enter: React.PropTypes.string,
      enterActive: React.PropTypes.string,
      leave: React.PropTypes.string,
      leaveActive: React.PropTypes.string,
      appear: React.PropTypes.string,
      appearActive: React.PropTypes.string
    })]).isRequired,

    // Once we require timeouts to be specified, we can remove the
    // boolean flags (appear etc.) and just accept a number
    // or a bool for the timeout flags (appearTimeout etc.)
    appear: React.PropTypes.bool,
    enter: React.PropTypes.bool,
    leave: React.PropTypes.bool,
    appearTimeout: React.PropTypes.number,
    enterTimeout: React.PropTypes.number,
    leaveTimeout: React.PropTypes.number
  },

  transition: function (animationType, finishCallback, userSpecifiedDelay) {
    var node = ReactDOM.findDOMNode(this);

    if (!node) {
      if (finishCallback) {
        finishCallback();
      }
      return;
    }

    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
    var timeout = null;

    var endListener = function (e) {
      if (e && e.target !== node) {
        return;
      }

      clearTimeout(timeout);

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (finishCallback) {
        finishCallback();
      }
    };

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClass(activeClassName);

    // If the user specified a timeout delay.
    if (userSpecifiedDelay) {
      // Clean-up the animation after the specified delay
      timeout = setTimeout(endListener, userSpecifiedDelay);
      this.transitionTimeouts.push(timeout);
    } else {
      // DEPRECATED: this listener will be removed in a future version of react
      ReactTransitionEvents.addEndEventListener(node, endListener);
    }
  },

  queueClass: function (className) {
    this.classNameQueue.push(className);

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
    }
  },

  flushClassNameQueue: function () {
    if (this.isMounted()) {
      this.classNameQueue.forEach(CSSCore.addClass.bind(CSSCore, ReactDOM.findDOMNode(this)));
    }
    this.classNameQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function () {
    this.classNameQueue = [];
    this.transitionTimeouts = [];
  },

  componentWillUnmount: function () {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.transitionTimeouts.forEach(function (timeout) {
      clearTimeout(timeout);
    });
  },

  componentWillAppear: function (done) {
    if (this.props.appear) {
      this.transition('appear', done, this.props.appearTimeout);
    } else {
      done();
    }
  },

  componentWillEnter: function (done) {
    if (this.props.enter) {
      this.transition('enter', done, this.props.enterTimeout);
    } else {
      done();
    }
  },

  componentWillLeave: function (done) {
    if (this.props.leave) {
      this.transition('leave', done, this.props.leaveTimeout);
    } else {
      done();
    }
  },

  render: function () {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;
},{"./React":35,"./ReactDOM":49,"./ReactTransitionEvents":102,"./onlyChild":145,"fbjs/lib/CSSCore":155}],40:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

function instantiateChild(childInstances, child, name) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, null);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))

},{"./ReactReconciler":93,"./instantiateReactComponent":142,"./shouldUpdateReactComponent":151,"./traverseAllChildren":152,"_process":2,"fbjs/lib/warning":183}],41:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":34,"./ReactElement":66,"./traverseAllChildren":152,"fbjs/lib/emptyFunction":163}],42:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var keyMirror = require('fbjs/lib/keyMirror');
var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

var warnedSetProps = false;
function warnSetProps() {
  if (!warnedSetProps) {
    warnedSetProps = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
  }
}

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = (name in RESERVED_SPEC_KEYS);
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = (name in Constructor);
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function (partialProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueSetProps(this, partialProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function (newProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueReplaceProps(this, newProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function () {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context, updater) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactComponent":43,"./ReactElement":66,"./ReactNoopUpdateQueue":85,"./ReactPropTypeLocationNames":89,"./ReactPropTypeLocations":90,"_process":2,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171,"fbjs/lib/keyMirror":175,"fbjs/lib/keyOf":176,"fbjs/lib/warning":183}],43:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call render again at the top level.']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
}).call(this,require('_process'))

},{"./ReactNoopUpdateQueue":85,"./canDefineProperty":127,"_process":2,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],44:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactMount = require('./ReactMount');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;
},{"./ReactDOMIDOperations":54,"./ReactMount":81}],45:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],46:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentWithPureRenderMixin
 */

'use strict';

var shallowCompare = require('./shallowCompare');

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function (nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;
},{"./shallowCompare":150}],47:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactPerf = require('./ReactPerf');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  return Component(this.props, this.context, this.updater);
};

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst;
    var renderedElement;

    // This is a way to detect if Component is a stateless arrow function
    // component, which is not newable. It might not be 100% reliable but is
    // something we can do until we start detecting that Component extends
    // React.Component. We already assume that typeof Component === 'function'.
    var canInstantiate = ('prototype' in Component);

    if (canInstantiate) {
      if (process.env.NODE_ENV !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
      }
    }

    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
      renderedElement = inst;
      inst = new StatelessComponent(Component);
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
      } else {
        // We support ES6 inheriting from React.Component, the module pattern,
        // and stateless components, but not ES6 classes that don't extend
        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    if (inst.componentWillMount) {
      inst.componentWillMount();
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement);

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function () {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      inst.componentWillUnmount();
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;
    this._instance = null;

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var maskedContext = null;
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if (process.env.NODE_ENV !== 'production') {
        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // top-level render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
    var nextProps;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement === nextParentElement) {
      // Skip checking prop types again -- we don't read inst.props to avoid
      // warning for DOM component props in this upgrade
      nextProps = nextParentElement.props;
    } else {
      nextProps = this._processProps(nextParentElement.props);
      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (inst instanceof StatelessComponent) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactComponentEnvironment":45,"./ReactCurrentOwner":48,"./ReactElement":66,"./ReactInstanceMap":77,"./ReactPerf":87,"./ReactPropTypeLocationNames":89,"./ReactPropTypeLocations":90,"./ReactReconciler":93,"./ReactUpdateQueue":104,"./shouldUpdateReactComponent":151,"_process":2,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],48:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],49:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
/* eslint-enable camelcase */
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":48,"./ReactDOMTextComponent":60,"./ReactDefaultInjection":63,"./ReactInstanceHandles":76,"./ReactMount":81,"./ReactPerf":87,"./ReactReconciler":93,"./ReactUpdates":105,"./ReactVersion":106,"./findDOMNode":132,"./renderSubtreeIntoContainer":147,"_process":2,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/warning":183}],50:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var mouseListenerNames = {
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,

  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
};

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = {
  getNativeProps: function (inst, props, context) {
    if (!props.disabled) {
      return props;
    }

    // Copy the props, except the mouse listeners
    var nativeProps = {};
    for (var key in props) {
      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
        nativeProps[key] = props[key];
      }
    }

    return nativeProps;
  }
};

module.exports = ReactDOMButton;
},{}],51:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventConstants = require('./EventConstants');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMButton = require('./ReactDOMButton');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactMount = require('./ReactMount');
var ReactMultiChild = require('./ReactMultiChild');
var ReactPerf = require('./ReactPerf');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var keyOf = require('fbjs/lib/keyOf');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var CHILDREN = keyOf({ children: null });
var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });

var ELEMENT_NODE_TYPE = 1;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

var legacyPropsDescriptor;
if (process.env.NODE_ENV !== 'production') {
  legacyPropsDescriptor = {
    props: {
      enumerable: false,
      get: function () {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
        return component._currentElement.props;
      }
    }
  };
}

function legacyGetDOMNode() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return this;
}

function legacyIsMounted() {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return !!component;
}

function legacySetStateEtc() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
}

function legacySetProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function legacyReplaceProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined becauses undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (process.env.NODE_ENV !== 'production') {
    if (voidElementTags[component._tag]) {
      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
  var node = ReactMount.getNode(inst._rootNodeID);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

  switch (inst._tag) {
    case 'iframe':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
      break;
  }
}

function mountReadyInputWrapper() {
  ReactDOMInput.mountReadyWrapper(this);
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

// NOTE: menuitem's close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContextDev(context, inst) {
  // Pass down our tag name to child components for validation purposes
  context = assign({}, context);
  var info = context[validateDOMNesting.ancestorInfoContextKey];
  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  return context;
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag.toLowerCase();
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._nodeWithLegacyProperties = null;
  if (process.env.NODE_ENV !== 'production') {
    this._unprocessedContextDev = null;
    this._processedContextDev = null;
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'button':
        props = ReactDOMButton.getNativeProps(this, props, context);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, context);
        props = ReactDOMInput.getNativeProps(this, props, context);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, context);
        props = ReactDOMOption.getNativeProps(this, props, context);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, context);
        props = ReactDOMSelect.getNativeProps(this, props, context);
        context = ReactDOMSelect.processChildContext(this, props, context);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, context);
        props = ReactDOMTextarea.getNativeProps(this, props, context);
        break;
    }

    assertValidProps(this, props);
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      this._unprocessedContextDev = context;
      this._processedContextDev = processChildContextDev(context, this);
      context = this._processedContextDev;
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement(this._currentElement.type);
      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
      // Populate node cache
      ReactMount.getID(el);
      this._updateDOMProperties({}, props, transaction, el);
      this._createInitialChildren(transaction, props, context, el);
      mountImage = el;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
      // falls through
      case 'button':
      case 'select':
      case 'textarea':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (propKey !== CHILDREN) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, el) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        setInnerHTML(el, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        setTextContent(el, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          el.appendChild(mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'button':
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case 'input':
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    if (process.env.NODE_ENV !== 'production') {
      // If the context is reference-equal to the old one, pass down the same
      // processed object so the update bailout in ReactReconciler behaves
      // correctly (and identically in dev and prod). See #5005.
      if (this._unprocessedContextDev !== context) {
        this._unprocessedContextDev = context;
        this._processedContextDev = processChildContextDev(context, this);
      }
      context = this._processedContextDev;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction, null);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (!canDefineProperty && this._nodeWithLegacyProperties) {
      this._nodeWithLegacyProperties.props = nextProps;
    }

    if (this._tag === 'select') {
      // <select> value update needs to occur after <option> children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        if (propKey === CHILDREN) {
          nextProp = null;
        }
        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertantly setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      if (!node) {
        node = ReactMount.getNode(this._rootNodeID);
      }
      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
        ReactDOMInput.unmountWrapper(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
        break;
    }

    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._wrapperState = null;
    if (this._nodeWithLegacyProperties) {
      var node = this._nodeWithLegacyProperties;
      node._reactInternalComponent = null;
      this._nodeWithLegacyProperties = null;
    }
  },

  getPublicInstance: function () {
    if (!this._nodeWithLegacyProperties) {
      var node = ReactMount.getNode(this._rootNodeID);

      node._reactInternalComponent = this;
      node.getDOMNode = legacyGetDOMNode;
      node.isMounted = legacyIsMounted;
      node.setState = legacySetStateEtc;
      node.replaceState = legacySetStateEtc;
      node.forceUpdate = legacySetStateEtc;
      node.setProps = legacySetProps;
      node.replaceProps = legacyReplaceProps;

      if (process.env.NODE_ENV !== 'production') {
        if (canDefineProperty) {
          Object.defineProperties(node, legacyPropsDescriptor);
        } else {
          // updateComponent will update this property on subsequent renders
          node.props = this._currentElement.props;
        }
      } else {
        // updateComponent will update this property on subsequent renders
        node.props = this._currentElement.props;
      }

      this._nodeWithLegacyProperties = node;
    }
    return this._nodeWithLegacyProperties;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
}).call(this,require('_process'))

},{"./AutoFocusUtils":11,"./CSSPropertyOperations":14,"./DOMProperty":19,"./DOMPropertyOperations":20,"./EventConstants":24,"./Object.assign":33,"./ReactBrowserEventEmitter":37,"./ReactComponentBrowserEnvironment":44,"./ReactDOMButton":50,"./ReactDOMInput":55,"./ReactDOMOption":56,"./ReactDOMSelect":57,"./ReactDOMTextarea":61,"./ReactMount":81,"./ReactMultiChild":82,"./ReactPerf":87,"./ReactUpdateQueue":104,"./canDefineProperty":127,"./escapeTextContentForBrowser":131,"./isEventSupported":143,"./setInnerHTML":148,"./setTextContent":149,"./validateDOMNesting":154,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/keyOf":176,"fbjs/lib/shallowEqual":181,"fbjs/lib/warning":183}],52:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 * @typechecks static-only
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');

var mapObject = require('fbjs/lib/mapObject');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if (process.env.NODE_ENV !== 'production') {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  image: 'image',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOMFactories;
}).call(this,require('_process'))

},{"./ReactElement":66,"./ReactElementValidator":67,"_process":2,"fbjs/lib/mapObject":177}],53:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFeatureFlags
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: false
};

module.exports = ReactDOMFeatureFlags;
},{}],54:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var invariant = require('fbjs/lib/invariant');

/**
 * Errors for properties that should not be updated with `updatePropertyByID()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;
}).call(this,require('_process'))

},{"./DOMChildrenOperations":18,"./DOMPropertyOperations":20,"./ReactMount":81,"./ReactPerf":87,"_process":2,"fbjs/lib/invariant":171}],55:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var instancesByReactID = {};

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getNativeProps: function (inst, props, context) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var nativeProps = assign({}, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null,
      onChange: _handleChange.bind(inst)
    };
  },

  mountReadyWrapper: function (inst) {
    // Can't be in mountWrapper or else server rendering leaks.
    instancesByReactID[inst._rootNodeID] = inst;
  },

  unmountWrapper: function (inst) {
    delete instancesByReactID[inst._rootNodeID];
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactMount.getNode(this._rootNodeID);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React with non-React.
      var otherID = ReactMount.getID(otherNode);
      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
      var otherInstance = instancesByReactID[otherID];
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
}).call(this,require('_process'))

},{"./LinkedValueUtils":32,"./Object.assign":33,"./ReactDOMIDOperations":54,"./ReactMount":81,"./ReactUpdates":105,"_process":2,"fbjs/lib/invariant":171}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactDOMSelect = require('./ReactDOMSelect');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, context) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via context
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + props.value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  getNativeProps: function (inst, props, context) {
    var nativeProps = assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      nativeProps.selected = inst._wrapperState.selected;
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    nativeProps.children = content;
    return nativeProps;
  }

};

module.exports = ReactDOMOption;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactChildren":41,"./ReactDOMSelect":57,"_process":2,"fbjs/lib/warning":183}],57:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, props, value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    if (props.multiple) {
      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactMount.getNode(inst._rootNodeID).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  valueContextKey: valueContextKey,

  getNativeProps: function (inst, props, context) {
    return assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };
  },

  processChildContext: function (inst, props, context) {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var childContext = assign({}, context);
    childContext[valueContextKey] = inst._wrapperState.initialValue;
    return childContext;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  this._wrapperState.pendingUpdate = true;
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
}).call(this,require('_process'))

},{"./LinkedValueUtils":32,"./Object.assign":33,"./ReactMount":81,"./ReactUpdates":105,"_process":2,"fbjs/lib/warning":183}],58:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":140,"./getTextContentAccessor":141,"fbjs/lib/ExecutionEnvironment":157}],59:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactServerRendering = require('./ReactServerRendering');
var ReactVersion = require('./ReactVersion');

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  version: ReactVersion
};

module.exports = ReactDOMServer;
},{"./ReactDefaultInjection":63,"./ReactServerRendering":97,"./ReactVersion":106}],60:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactMount = require('./ReactMount');

var assign = require('./Object.assign');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setTextContent = require('./setTextContent');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (props) {
  // This constructor and its argument is currently used by mocks.
};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement('span');
      DOMPropertyOperations.setAttributeForID(el, rootID);
      // Populate node cache
      ReactMount.getID(el);
      setTextContent(el, this._stringText);
      return el;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this in a `span` for the reasons stated above, but
        // since this is a situation where React won't take over (static pages),
        // we can simply return the text as it is.
        return escapedText;
      }

      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var node = ReactMount.getNode(this._rootNodeID);
        DOMChildrenOperations.updateTextContent(node, nextStringText);
      }
    }
  },

  unmountComponent: function () {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;
}).call(this,require('_process'))

},{"./DOMChildrenOperations":18,"./DOMPropertyOperations":20,"./Object.assign":33,"./ReactComponentBrowserEnvironment":44,"./ReactMount":81,"./escapeTextContentForBrowser":131,"./setTextContent":149,"./validateDOMNesting":154,"_process":2}],61:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getNativeProps: function (inst, props, context) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    var nativeProps = assign({}, props, {
      defaultValue: undefined,
      value: undefined,
      children: inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(props);

    inst._wrapperState = {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue),
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
}).call(this,require('_process'))

},{"./LinkedValueUtils":32,"./Object.assign":33,"./ReactDOMIDOperations":54,"./ReactUpdates":105,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],62:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./Object.assign":33,"./ReactUpdates":105,"./Transaction":123,"fbjs/lib/emptyFunction":163}],63:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var ClientReactRootIndex = require('./ClientReactRootIndex');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactBrowserComponentMixin = require('./ReactBrowserComponentMixin');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SelectEventPlugin = require('./SelectEventPlugin');
var ServerReactRootIndex = require('./ServerReactRootIndex');
var SimpleEventPlugin = require('./SimpleEventPlugin');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if (process.env.NODE_ENV !== 'production') {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = require('./ReactDefaultPerf');
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};
}).call(this,require('_process'))

},{"./BeforeInputEventPlugin":12,"./ChangeEventPlugin":16,"./ClientReactRootIndex":17,"./DefaultEventPluginOrder":22,"./EnterLeaveEventPlugin":23,"./HTMLDOMPropertyConfig":30,"./ReactBrowserComponentMixin":36,"./ReactComponentBrowserEnvironment":44,"./ReactDOMComponent":51,"./ReactDOMTextComponent":60,"./ReactDefaultBatchingStrategy":62,"./ReactDefaultPerf":64,"./ReactEventListener":72,"./ReactInjection":74,"./ReactInstanceHandles":76,"./ReactMount":81,"./ReactReconcileTransaction":92,"./SVGDOMPropertyConfig":108,"./SelectEventPlugin":109,"./ServerReactRootIndex":110,"./SimpleEventPlugin":111,"_process":2,"fbjs/lib/ExecutionEnvironment":157}],64:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDefaultPerfAnalysis = require('./ReactDefaultPerfAnalysis');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var performanceNow = require('fbjs/lib/performanceNow');

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function () {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function () {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function () {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function (measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result.type = item.type;
      result.args = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function (id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function (moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0,
          created: {}
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          var id = args[0];
          if (typeof id === 'object') {
            id = ReactMount.getID(args[0]);
          }
          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          entry.created[rootNodeID] = true;
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;
},{"./DOMProperty":19,"./ReactDefaultPerfAnalysis":65,"./ReactMount":81,"./ReactPerf":87,"fbjs/lib/performanceNow":180}],65:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = require('./Object.assign');

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  SET_MARKUP: 'set innerHTML',
  TEXT_CONTENT: 'set textContent',
  'setValueForProperty': 'update attribute',
  'setValueForAttribute': 'update attribute',
  'deleteValueForProperty': 'remove attribute',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  measurements.forEach(function (measurement) {
    Object.keys(measurement.writes).forEach(function (id) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    });
  });
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    // check if component newly created
    if (measurement.created[id]) {
      isDirty = true;
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;
},{"./Object.assign":33}],66:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    Object.freeze(element.props);
    Object.freeze(element);
  }

  return element;
};

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

  if (process.env.NODE_ENV !== 'production') {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }

  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactCurrentOwner":48,"./canDefineProperty":127,"_process":2}],67:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactCurrentOwner = require('./ReactCurrentOwner');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
  if (addenda === null) {
    // we already showed the warning
    return;
  }
  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} messageType A key used for de-duping warnings.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 * @returns {?object} A set of addenda to use in the warning message, or null
 * if the warning has already been shown before (and shouldn't be shown again).
 */
function getAddendaForKeyUse(messageType, element, parentType) {
  var addendum = getDeclarationErrorAddendum();
  if (!addendum) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      addendum = ' Check the top-level render call using <' + parentName + '>.';
    }
  }

  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
  if (memoizer[addendum]) {
    return null;
  }
  memoizer[addendum] = true;

  var addenda = {
    parentOrOwner: addendum,
    url: ' See https://fb.me/react-warning-keys for more information.',
    childOwner: null
  };

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  return addenda;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":48,"./ReactElement":66,"./ReactPropTypeLocationNames":89,"./ReactPropTypeLocations":90,"./canDefineProperty":127,"./getIteratorFn":139,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],68:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactReconciler = require('./ReactReconciler');

var assign = require('./Object.assign');

var placeholderElement;

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function (component) {
    placeholderElement = ReactElement.createElement(component);
  }
};

var ReactEmptyComponent = function (instantiate) {
  this._currentElement = null;
  this._rootNodeID = null;
  this._renderedComponent = instantiate(placeholderElement);
};
assign(ReactEmptyComponent.prototype, {
  construct: function (element) {},
  mountComponent: function (rootID, transaction, context) {
    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
    this._rootNodeID = rootID;
    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
  },
  receiveComponent: function () {},
  unmountComponent: function (rootID, transaction, context) {
    ReactReconciler.unmountComponent(this._renderedComponent);
    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
    this._rootNodeID = null;
    this._renderedComponent = null;
  }
});

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{"./Object.assign":33,"./ReactElement":66,"./ReactEmptyComponentRegistry":69,"./ReactReconciler":93}],69:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponentRegistry
 */

'use strict';

// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIDsRegistry = {};

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

var ReactEmptyComponentRegistry = {
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID,
  deregisterNullComponentID: deregisterNullComponentID
};

module.exports = ReactEmptyComponentRegistry;
},{}],70:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {?String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a, b) {
  try {
    return func(a, b);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
    return undefined;
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
      var boundFunc = func.bind(null, a, b);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
}).call(this,require('_process'))

},{"_process":2}],71:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":25}],72:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  // TODO: Re-enable event.path handling
  //
  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
  //   // New browsers have a path attribute on native events
  //   handleTopLevelWithPath(bookKeeping);
  // } else {
  //   // Legacy browsers don't have a path attribute on native events
  //   handleTopLevelWithoutPath(bookKeeping);
  // }

  void handleTopLevelWithPath; // temporarily unused
  handleTopLevelWithoutPath(bookKeeping);
}

// Legacy browsers don't have a path attribute on native events
function handleTopLevelWithoutPath(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// New browsers have a path attribute on native events
function handleTopLevelWithPath(bookKeeping) {
  var path = bookKeeping.nativeEvent.path;
  var currentNativeTarget = path[0];
  var eventsFired = 0;
  for (var i = 0; i < path.length; i++) {
    var currentPathElement = path[i];
    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
      currentNativeTarget = path[i + 1];
    }
    // TODO: slow
    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
    if (reactParent === currentPathElement) {
      var currentPathElementID = ReactMount.getID(currentPathElement);
      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
      bookKeeping.ancestors.push(currentPathElement);

      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
      eventsFired++;
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

      // Jump to the root of this React render tree
      while (currentPathElementID !== newRootID) {
        i++;
        currentPathElement = path[i];
        currentPathElementID = ReactMount.getID(currentPathElement);
      }
    }
  }
  if (eventsFired === 0) {
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./Object.assign":33,"./PooledClass":34,"./ReactInstanceHandles":76,"./ReactMount":81,"./ReactUpdates":105,"./getEventTarget":138,"fbjs/lib/EventListener":156,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/getUnboundedScrollPosition":168}],73:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactFragment
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * We used to allow keyed objects to serve as a collection of ReactElements,
 * or nested sets. This allowed us a way to explicitly key a set a fragment of
 * components. This is now being replaced with an opaque data structure.
 * The upgrade path is to call React.addons.createFragment({ key: value }) to
 * create a keyed fragment. The resulting data structure is an array.
 */

var numericPropertyRegex = /^\d+$/;

var warnedAboutNumeric = false;

var ReactFragment = {
  // Wrap a keyed object in an opaque proxy that warns you if you access any
  // of its properties.
  create: function (object) {
    if (typeof object !== 'object' || !object || Array.isArray(object)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment only accepts a single object. Got: %s', object) : undefined;
      return object;
    }
    if (ReactElement.isValidElement(object)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : undefined;
      return object;
    }

    !(object.nodeType !== 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.addons.createFragment(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(false) : undefined;

    var result = [];

    for (var key in object) {
      if (process.env.NODE_ENV !== 'production') {
        if (!warnedAboutNumeric && numericPropertyRegex.test(key)) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment(...): Child objects should have ' + 'non-numeric keys so ordering is preserved.') : undefined;
          warnedAboutNumeric = true;
        }
      }
      ReactChildren.mapIntoWithKeyPrefixInternal(object[key], result, key, emptyFunction.thatReturnsArgument);
    }

    return result;
  }
};

module.exports = ReactFragment;
}).call(this,require('_process'))

},{"./ReactChildren":41,"./ReactElement":66,"_process":2,"fbjs/lib/emptyFunction":163,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],74:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactClass = require('./ReactClass');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactNativeComponent = require('./ReactNativeComponent');
var ReactPerf = require('./ReactPerf');
var ReactRootIndex = require('./ReactRootIndex');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":19,"./EventPluginHub":25,"./ReactBrowserEventEmitter":37,"./ReactClass":42,"./ReactComponentEnvironment":45,"./ReactEmptyComponent":68,"./ReactNativeComponent":84,"./ReactPerf":87,"./ReactRootIndex":95,"./ReactUpdates":105}],75:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":58,"fbjs/lib/containsNode":160,"fbjs/lib/focusNode":165,"fbjs/lib/getActiveElement":166}],76:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = require('./ReactRootIndex');

var invariant = require('fbjs/lib/invariant');

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 10000;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {*} arg Argument to invoke the callback with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; /* until break */id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function () {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function (rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function (id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function (targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;
}).call(this,require('_process'))

},{"./ReactRootIndex":95,"_process":2,"fbjs/lib/invariant":171}],77:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var assign = require('./Object.assign');
var onlyChild = require('./onlyChild');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactChildren":41,"./ReactClass":42,"./ReactComponent":43,"./ReactDOMFactories":52,"./ReactElement":66,"./ReactElementValidator":67,"./ReactPropTypes":91,"./ReactVersion":106,"./onlyChild":145,"_process":2}],79:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLink
 * @typechecks static-only
 */

'use strict';

/**
 * ReactLink encapsulates a common pattern in which a component wants to modify
 * a prop received from its parent. ReactLink allows the parent to pass down a
 * value coupled with a callback that, when invoked, expresses an intent to
 * modify that value. For example:
 *
 * React.createClass({
 *   getInitialState: function() {
 *     return {value: ''};
 *   },
 *   render: function() {
 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
 *     return <input valueLink={valueLink} />;
 *   },
 *   _handleValueChange: function(newValue) {
 *     this.setState({value: newValue});
 *   }
 * });
 *
 * We have provided some sugary mixins to make the creation and
 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
 */

var React = require('./React');

/**
 * @param {*} value current value of the link
 * @param {function} requestChange callback to request a change
 */
function ReactLink(value, requestChange) {
  this.value = value;
  this.requestChange = requestChange;
}

/**
 * Creates a PropType that enforces the ReactLink API and optionally checks the
 * type of the value being passed inside the link. Example:
 *
 * MyComponent.propTypes = {
 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
 * }
 */
function createLinkTypeChecker(linkType) {
  var shapes = {
    value: typeof linkType === 'undefined' ? React.PropTypes.any.isRequired : linkType.isRequired,
    requestChange: React.PropTypes.func.isRequired
  };
  return React.PropTypes.shape(shapes);
}

ReactLink.PropTypes = {
  link: createLinkTypeChecker
};

module.exports = ReactLink;
},{"./React":35}],80:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags and self-closing tags)
    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":126}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var containsNode = require('fbjs/lib/containsNode');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if (process.env.NODE_ENV !== 'production') {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if (ReactDOMFeatureFlags.useCreateElement) {
    context = assign({}, context);
    if (container.nodeType === DOC_NODE_TYPE) {
      context[ownerDocumentContextKey] = container;
    } else {
      context[ownerDocumentContextKey] = container.ownerDocument;
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* forceHTML */shouldReuseMarkup);
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(node) {
  var reactRootID = getReactRootID(node);
  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
}

/**
 * Returns the first (deepest) ancestor of a node which is rendered by this copy
 * of React.
 */
function findFirstReactDOMImpl(node) {
  // This node might be from another React instance, so we make sure not to
  // examine the node cache here
  for (; node && node.parentNode !== node; node = node.parentNode) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      continue;
    }
    var nodeID = internalGetID(node);
    if (!nodeID) {
      continue;
    }
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

    // If containersByReactRootID contains the container we find by crawling up
    // the tree, we know that this instance of React rendered the node.
    // nb. isValid's strategy (with containsNode) does not work because render
    // trees may be nested and we don't want a false positive in that case.
    var current = node;
    var lastID;
    do {
      lastID = internalGetID(current);
      current = current.parentNode;
      if (current == null) {
        // The passed-in node has been detached from the container it was
        // originally rendered into.
        return null;
      }
    } while (lastID !== reactRootID);

    if (current === containersByReactRootID[reactRootID]) {
      return node;
    }
  }
  return null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var TopLevelWrapper = function () {};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  // this.props is actually a ReactElement
  return this.props;
};

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function (nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function (container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var containerID = internalGetID(container);
      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
      }

      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if (process.env.NODE_ENV !== 'production') {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function (id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if (process.env.NODE_ENV !== 'production') {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        process.env.NODE_ENV !== 'production' ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function (id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component rendered by this copy of React.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function (node) {
    return findFirstReactDOMImpl(node);
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function (ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    if (process.env.NODE_ENV !== 'production') {
      // This will throw on the next line; give an early warning
      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
    }

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      container.appendChild(markup);
    } else {
      setInnerHTML(container, markup);
    }
  },

  ownerDocumentContextKey: ownerDocumentContextKey,

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  isValid: isValid,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;
}).call(this,require('_process'))

},{"./DOMProperty":19,"./Object.assign":33,"./ReactBrowserEventEmitter":37,"./ReactCurrentOwner":48,"./ReactDOMFeatureFlags":53,"./ReactElement":66,"./ReactEmptyComponentRegistry":69,"./ReactInstanceHandles":76,"./ReactInstanceMap":77,"./ReactMarkupChecksum":80,"./ReactPerf":87,"./ReactReconciler":93,"./ReactUpdateQueue":104,"./ReactUpdates":105,"./instantiateReactComponent":142,"./setInnerHTML":148,"./shouldUpdateReactComponent":151,"./validateDOMNesting":154,"_process":2,"fbjs/lib/containsNode":160,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],82:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var flattenChildren = require('./flattenChildren');

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueInsertMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    content: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the markup of a node.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function enqueueSetMarkup(parentID, markup) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.SET_MARKUP,
    markupIndex: null,
    content: markup,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    content: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
      var nextChildren;
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements);
          } finally {
            ReactCurrentOwner.current = null;
          }
          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements);
      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChild(prevChildren[name]);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        this.setMarkup(nextMarkup);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildrenElements, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChild(prevChild);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChild(prevChildren[name]);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function () {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, mountImage) {
      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function (textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Sets this markup string.
     *
     * @param {string} markup Markup to set.
     * @protected
     */
    setMarkup: function (markup) {
      enqueueSetMarkup(this._rootNodeID, markup);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;
}).call(this,require('_process'))

},{"./ReactChildReconciler":40,"./ReactComponentEnvironment":45,"./ReactCurrentOwner":48,"./ReactMultiChildUpdateTypes":83,"./ReactReconciler":93,"./flattenChildren":133,"_process":2}],83:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  SET_MARKUP: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"fbjs/lib/keyMirror":175}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
}).call(this,require('_process'))

},{"./Object.assign":33,"_process":2,"fbjs/lib/invariant":171}],85:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnTDZ(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnTDZ(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnTDZ(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnTDZ(publicInstance, 'setState');
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    warnTDZ(publicInstance, 'setProps');
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    warnTDZ(publicInstance, 'replaceProps');
  }

};

module.exports = ReactNoopUpdateQueue;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/warning":183}],86:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],87:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function (object, objectName, methodNames) {
    if (process.env.NODE_ENV !== 'production') {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function (objName, fnName, func) {
    if (process.env.NODE_ENV !== 'production') {
      var measuredFunc = null;
      var wrapper = function () {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function (measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;
}).call(this,require('_process'))

},{"_process":2}],88:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTransferer
 */

'use strict';

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var joinClasses = require('fbjs/lib/joinClasses');

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function (props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function (a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return assign({}, b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function (oldProps, newProps) {
    return transferInto(assign({}, oldProps), newProps);
  }

};

module.exports = ReactPropTransferer;
},{"./Object.assign":33,"fbjs/lib/emptyFunction":163,"fbjs/lib/joinClasses":174}],89:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":2}],90:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"fbjs/lib/keyMirror":175}],91:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return '<<anonymous>>';
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":66,"./ReactPropTypeLocationNames":89,"./getIteratorFn":139,"fbjs/lib/emptyFunction":163}],92:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactInputSelection = require('./ReactInputSelection');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(forceHTML) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":15,"./Object.assign":33,"./PooledClass":34,"./ReactBrowserEventEmitter":37,"./ReactDOMFeatureFlags":53,"./ReactInputSelection":75,"./Transaction":123}],93:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require('./ReactRef');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
},{"./ReactRef":94}],94:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;

  return(
    // This has a few false positives w/r/t empty components.
    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
  );
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":86}],95:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function (_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;
},{}],96:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerBatchingStrategy
 * @typechecks
 */

'use strict';

var ReactServerBatchingStrategy = {
  isBatchingUpdates: false,
  batchedUpdates: function (callback) {
    // Don't do anything here. During the server rendering we don't want to
    // schedule any updates. We will simply ignore them.
  }
};

module.exports = ReactServerBatchingStrategy;
},{}],97:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactServerBatchingStrategy = require('./ReactServerBatchingStrategy');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};
}).call(this,require('_process'))

},{"./ReactDefaultBatchingStrategy":62,"./ReactElement":66,"./ReactInstanceHandles":76,"./ReactMarkupChecksum":80,"./ReactServerBatchingStrategy":96,"./ReactServerRenderingTransaction":98,"./ReactUpdates":105,"./instantiateReactComponent":142,"_process":2,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171}],98:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = require('./PooledClass');
var CallbackQueue = require('./CallbackQueue');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = false;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./CallbackQueue":15,"./Object.assign":33,"./PooledClass":34,"./Transaction":123,"fbjs/lib/emptyFunction":163}],99:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactStateSetters
 */

'use strict';

var ReactStateSetters = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * @param {ReactCompositeComponent} component
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (component, funcReturningState) {
    return function (a, b, c, d, e, f) {
      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
      if (partialState) {
        component.setState(partialState);
      }
    };
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {ReactCompositeComponent} component
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (component, key) {
    // Memoize the setters.
    var cache = component.__keySetters || (component.__keySetters = {});
    return cache[key] || (cache[key] = createStateKeySetter(component, key));
  }
};

function createStateKeySetter(component, key) {
  // Partial state is allocated outside of the function closure so it can be
  // reused with every call, avoiding memory allocation when this function
  // is called.
  var partialState = {};
  return function stateKeySetter(value) {
    partialState[key] = value;
    component.setState(partialState);
  };
}

ReactStateSetters.Mixin = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateSetter(function(xValue) {
   *     return {x: xValue};
   *   })(1);
   *
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (funcReturningState) {
    return ReactStateSetters.createStateSetter(this, funcReturningState);
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateKeySetter('x')(1);
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (key) {
    return ReactStateSetters.createStateKeySetter(this, key);
  }
};

module.exports = ReactStateSetters;
},{}],100:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTestUtils
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var React = require('./React');
var ReactDOM = require('./ReactDOM');
var ReactElement = require('./ReactElement');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var findDOMNode = require('./findDOMNode');
var invariant = require('fbjs/lib/invariant');

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

/**
 * @class ReactTestUtils
 */

function findAllInRenderedTreeInternal(inst, test) {
  if (!inst || !inst.getPublicInstance) {
    return [];
  }
  var publicInst = inst.getPublicInstance();
  var ret = test(publicInst) ? [publicInst] : [];
  var currentElement = inst._currentElement;
  if (ReactTestUtils.isDOMComponent(publicInst)) {
    var renderedChildren = inst._renderedChildren;
    var key;
    for (key in renderedChildren) {
      if (!renderedChildren.hasOwnProperty(key)) {
        continue;
      }
      ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
    }
  } else if (ReactElement.isValidElement(currentElement) && typeof currentElement.type === 'function') {
    ret = ret.concat(findAllInRenderedTreeInternal(inst._renderedComponent, test));
  }
  return ret;
}

/**
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */
var ReactTestUtils = {
  renderIntoDocument: function (instance) {
    var div = document.createElement('div');
    // None of our tests actually require attaching the container to the
    // DOM, and doing so creates a mess that we rely on test isolation to
    // clean up, so we're going to stop honoring the name of this method
    // (and probably rename it eventually) if no problems arise.
    // document.documentElement.appendChild(div);
    return ReactDOM.render(instance, div);
  },

  isElement: function (element) {
    return ReactElement.isValidElement(element);
  },

  isElementOfType: function (inst, convenienceConstructor) {
    return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
  },

  isDOMComponent: function (inst) {
    return !!(inst && inst.nodeType === 1 && inst.tagName);
  },

  isDOMComponentElement: function (inst) {
    return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
  },

  isCompositeComponent: function (inst) {
    if (ReactTestUtils.isDOMComponent(inst)) {
      // Accessing inst.setState warns; just return false as that'll be what
      // this returns when we have DOM nodes as refs directly
      return false;
    }
    return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
  },

  isCompositeComponentWithType: function (inst, type) {
    if (!ReactTestUtils.isCompositeComponent(inst)) {
      return false;
    }
    var internalInstance = ReactInstanceMap.get(inst);
    var constructor = internalInstance._currentElement.type;

    return constructor === type;
  },

  isCompositeComponentElement: function (inst) {
    if (!ReactElement.isValidElement(inst)) {
      return false;
    }
    // We check the prototype of the type that will get mounted, not the
    // instance itself. This is a future proof way of duck typing.
    var prototype = inst.type.prototype;
    return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
  },

  isCompositeComponentElementWithType: function (inst, type) {
    var internalInstance = ReactInstanceMap.get(inst);
    var constructor = internalInstance._currentElement.type;

    return !!(ReactTestUtils.isCompositeComponentElement(inst) && constructor === type);
  },

  getRenderedChildOfCompositeComponent: function (inst) {
    if (!ReactTestUtils.isCompositeComponent(inst)) {
      return null;
    }
    var internalInstance = ReactInstanceMap.get(inst);
    return internalInstance._renderedComponent.getPublicInstance();
  },

  findAllInRenderedTree: function (inst, test) {
    if (!inst) {
      return [];
    }
    !ReactTestUtils.isCompositeComponent(inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findAllInRenderedTree(...): instance must be a composite component') : invariant(false) : undefined;
    return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the class name matching `className`.
   * @return {array} an array of all the matches.
   */
  scryRenderedDOMComponentsWithClass: function (root, classNames) {
    if (!Array.isArray(classNames)) {
      classNames = classNames.split(/\s+/);
    }
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      if (ReactTestUtils.isDOMComponent(inst)) {
        var className = inst.className;
        if (typeof className !== 'string') {
          // SVG, probably.
          className = inst.getAttribute('class') || '';
        }
        var classList = className.split(/\s+/);
        return classNames.every(function (name) {
          return classList.indexOf(name) !== -1;
        });
      }
      return false;
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithClass: function (root, className) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match ' + '(found: ' + all.length + ') for class:' + className);
    }
    return all[0];
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the tag name matching `tagName`.
   * @return {array} an array of all the matches.
   */
  scryRenderedDOMComponentsWithTag: function (root, tagName) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithTag: function (root, tagName) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for tag:' + tagName);
    }
    return all[0];
  },

  /**
   * Finds all instances of components with type equal to `componentType`.
   * @return {array} an array of all the matches.
   */
  scryRenderedComponentsWithType: function (root, componentType) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
    });
  },

  /**
   * Same as `scryRenderedComponentsWithType` but expects there to be one result
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactComponent} The one match.
   */
  findRenderedComponentWithType: function (root, componentType) {
    var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for componentType:' + componentType + ' (found ' + all.length + ')');
    }
    return all[0];
  },

  /**
   * Pass a mocked component module to this method to augment it with
   * useful methods that allow it to be used as a dummy React component.
   * Instead of rendering as usual, the component will become a simple
   * <div> containing any provided children.
   *
   * @param {object} module the mock function object exported from a
   *                        module that defines the component to be mocked
   * @param {?string} mockTagName optional dummy root tag name to return
   *                              from render method (overrides
   *                              module.mockTagName if provided)
   * @return {object} the ReactTestUtils object (for chaining)
   */
  mockComponent: function (module, mockTagName) {
    mockTagName = mockTagName || module.mockTagName || 'div';

    module.prototype.render.mockImplementation(function () {
      return React.createElement(mockTagName, null, this.props.children);
    });

    return this;
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occurred
   * on an `Element` node.
   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`
   * @param {!Element} node The dom to simulate an event occurring on.
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
    fakeNativeEvent.target = node;
    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occurred
   * on the `ReactDOMComponent` `comp`.
   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`.
   * @param {!ReactDOMComponent} comp
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
    ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
  },

  nativeTouchData: function (x, y) {
    return {
      touches: [{ pageX: x, pageY: y }]
    };
  },

  createRenderer: function () {
    return new ReactShallowRenderer();
  },

  Simulate: null,
  SimulateNative: {}
};

/**
 * @class ReactShallowRenderer
 */
var ReactShallowRenderer = function () {
  this._instance = null;
};

ReactShallowRenderer.prototype.getRenderOutput = function () {
  return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
};

var NoopInternalComponent = function (element) {
  this._renderedOutput = element;
  this._currentElement = element;
};

NoopInternalComponent.prototype = {

  mountComponent: function () {},

  receiveComponent: function (element) {
    this._renderedOutput = element;
    this._currentElement = element;
  },

  unmountComponent: function () {},

  getPublicInstance: function () {
    return null;
  }
};

var ShallowComponentWrapper = function () {};
assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: function (element) {
    return new NoopInternalComponent(element);
  },
  _replaceNodeWithMarkupByID: function () {},
  _renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext
});

ReactShallowRenderer.prototype.render = function (element, context) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Invalid component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : invariant(false) : undefined;
  !(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Shallow rendering works only with custom ' + 'components, not primitives (%s). Instead of calling `.render(el)` and ' + 'inspecting the rendered output, look at `el.props` directly instead.', element.type) : invariant(false) : undefined;

  if (!context) {
    context = emptyObject;
  }
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(false);
  this._render(element, transaction, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
};

ReactShallowRenderer.prototype.unmount = function () {
  if (this._instance) {
    this._instance.unmountComponent();
  }
};

ReactShallowRenderer.prototype._render = function (element, transaction, context) {
  if (this._instance) {
    this._instance.receiveComponent(element, transaction, context);
  } else {
    var rootID = ReactInstanceHandles.createReactRootID();
    var instance = new ShallowComponentWrapper(element.type);
    instance.construct(element);

    instance.mountComponent(rootID, transaction, context);

    this._instance = instance;
  }
};

/**
 * Exports:
 *
 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */
function makeSimulator(eventType) {
  return function (domComponentOrNode, eventData) {
    var node;
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      node = findDOMNode(domComponentOrNode);
    } else if (domComponentOrNode.tagName) {
      node = domComponentOrNode;
    }

    var dispatchConfig = ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType];

    var fakeNativeEvent = new Event();
    fakeNativeEvent.target = node;
    // We don't use SyntheticEvent.getPooled in order to not have to worry about
    // properly destroying any properties assigned from `eventData` upon release
    var event = new SyntheticEvent(dispatchConfig, ReactMount.getID(node), fakeNativeEvent, node);
    assign(event, eventData);

    if (dispatchConfig.phasedRegistrationNames) {
      EventPropagators.accumulateTwoPhaseDispatches(event);
    } else {
      EventPropagators.accumulateDirectDispatches(event);
    }

    ReactUpdates.batchedUpdates(function () {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue(true);
    });
  };
}

function buildSimulators() {
  ReactTestUtils.Simulate = {};

  var eventType;
  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
    /**
     * @param {!Element|ReactDOMComponent} domComponentOrNode
     * @param {?object} eventData Fake event data to use in SyntheticEvent.
     */
    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  }
}

// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
EventPluginHub.injection.injectEventPluginOrder = function () {
  oldInjectEventPluginOrder.apply(this, arguments);
  buildSimulators();
};
var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
EventPluginHub.injection.injectEventPluginsByName = function () {
  oldInjectEventPlugins.apply(this, arguments);
  buildSimulators();
};

buildSimulators();

/**
 * Exports:
 *
 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
 * - ... (All keys from `EventConstants.topLevelTypes`)
 *
 * Note: Top level event types are a subset of the entire set of handler types
 * (which include a broader set of "synthetic" events). For example, onDragDone
 * is a synthetic event. Except when testing an event plugin or React's event
 * handling code specifically, you probably want to use ReactTestUtils.Simulate
 * to dispatch synthetic events.
 */

function makeNativeSimulator(eventType) {
  return function (domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    assign(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
    } else if (domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
    }
  };
}

Object.keys(topLevelTypes).forEach(function (eventType) {
  // Event type is stored as 'topClick' - we transform that to 'click'
  var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
  /**
   * @param {!Element|ReactDOMComponent} domComponentOrNode
   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
   */
  ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
});

module.exports = ReactTestUtils;
}).call(this,require('_process'))

},{"./EventConstants":24,"./EventPluginHub":25,"./EventPropagators":28,"./Object.assign":33,"./React":35,"./ReactBrowserEventEmitter":37,"./ReactCompositeComponent":47,"./ReactDOM":49,"./ReactElement":66,"./ReactInstanceHandles":76,"./ReactInstanceMap":77,"./ReactMount":81,"./ReactUpdates":105,"./SyntheticEvent":115,"./findDOMNode":132,"_process":2,"fbjs/lib/emptyObject":164,"fbjs/lib/invariant":171}],101:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactTransitionChildMapping
 */

'use strict';

var flattenChildren = require('./flattenChildren');

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around flattenChildren().
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  getChildMapping: function (children) {
    if (!children) {
      return children;
    }
    return flattenChildren(children);
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function (prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;
},{"./flattenChildren":133}],102:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionEvents
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;
},{"fbjs/lib/ExecutionEnvironment":157}],103:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionGroup
 */

'use strict';

var React = require('./React');
var ReactTransitionChildMapping = require('./ReactTransitionChildMapping');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

var ReactTransitionGroup = React.createClass({
  displayName: 'ReactTransitionGroup',

  propTypes: {
    component: React.PropTypes.any,
    childFactory: React.PropTypes.func
  },

  getDefaultProps: function () {
    return {
      component: 'span',
      childFactory: emptyFunction.thatReturnsArgument
    };
  },

  getInitialState: function () {
    return {
      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
    };
  },

  componentWillMount: function () {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  },

  componentDidMount: function () {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  },

  componentWillReceiveProps: function (nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  },

  componentDidUpdate: function () {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },

  performAppear: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  },

  _handleDoneAppearing: function (key) {
    var component = this.refs[key];
    if (component.componentDidAppear) {
      component.componentDidAppear();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully appeared. Remove it.
      this.performLeave(key);
    }
  },

  performEnter: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  },

  _handleDoneEntering: function (key) {
    var component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  },

  performLeave: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  },

  _handleDoneLeaving: function (key) {
    var component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      this.setState(function (state) {
        var newChildren = assign({}, state.children);
        delete newChildren[key];
        return { children: newChildren };
      });
    }
  },

  render: function () {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(React.cloneElement(this.props.childFactory(child), { ref: key, key: key }));
      }
    }
    return React.createElement(this.props.component, this.props, childrenToRender);
  }
});

module.exports = ReactTransitionGroup;
},{"./Object.assign":33,"./React":35,"./ReactTransitionChildMapping":101,"fbjs/lib/emptyFunction":163}],104:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
  },

  enqueueSetPropsInternal: function (internalInstance, partialProps) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    var props = assign({}, element.props, partialProps);
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
  },

  enqueueReplacePropsInternal: function (internalInstance, props) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactCurrentOwner":48,"./ReactElement":66,"./ReactInstanceMap":77,"./ReactUpdates":105,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],105:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
}).call(this,require('_process'))

},{"./CallbackQueue":15,"./Object.assign":33,"./PooledClass":34,"./ReactPerf":87,"./ReactReconciler":93,"./Transaction":123,"_process":2,"fbjs/lib/invariant":171}],106:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '0.14.3';
},{}],107:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactWithAddons
 */

/**
 * This module exists purely in the open source project, and is meant as a way
 * to create a separate standalone build of React. This build has "addons", or
 * functionality we've built and think might be useful but doesn't have a good
 * place to live inside React core.
 */

'use strict';

var LinkedStateMixin = require('./LinkedStateMixin');
var React = require('./React');
var ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');
var ReactCSSTransitionGroup = require('./ReactCSSTransitionGroup');
var ReactFragment = require('./ReactFragment');
var ReactTransitionGroup = require('./ReactTransitionGroup');
var ReactUpdates = require('./ReactUpdates');

var cloneWithProps = require('./cloneWithProps');
var shallowCompare = require('./shallowCompare');
var update = require('./update');
var warning = require('fbjs/lib/warning');

var warnedAboutBatchedUpdates = false;

React.addons = {
  CSSTransitionGroup: ReactCSSTransitionGroup,
  LinkedStateMixin: LinkedStateMixin,
  PureRenderMixin: ReactComponentWithPureRenderMixin,
  TransitionGroup: ReactTransitionGroup,

  batchedUpdates: function () {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(warnedAboutBatchedUpdates, 'React.addons.batchedUpdates is deprecated. Use ' + 'ReactDOM.unstable_batchedUpdates instead.') : undefined;
      warnedAboutBatchedUpdates = true;
    }
    return ReactUpdates.batchedUpdates.apply(this, arguments);
  },
  cloneWithProps: cloneWithProps,
  createFragment: ReactFragment.create,
  shallowCompare: shallowCompare,
  update: update
};

if (process.env.NODE_ENV !== 'production') {
  React.addons.Perf = require('./ReactDefaultPerf');
  React.addons.TestUtils = require('./ReactTestUtils');
}

module.exports = React;
}).call(this,require('_process'))

},{"./LinkedStateMixin":31,"./React":35,"./ReactCSSTransitionGroup":38,"./ReactComponentWithPureRenderMixin":46,"./ReactDefaultPerf":64,"./ReactFragment":73,"./ReactTestUtils":100,"./ReactTransitionGroup":103,"./ReactUpdates":105,"./cloneWithProps":128,"./shallowCompare":150,"./update":153,"_process":2,"fbjs/lib/warning":183}],108:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;
},{"./DOMProperty":19}],109:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');
var shallowEqual = require('fbjs/lib/shallowEqual');

var topLevelTypes = EventConstants.topLevelTypes;

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case topLevelTypes.topSelectionChange:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventConstants":24,"./EventPropagators":28,"./ReactInputSelection":75,"./SyntheticEvent":115,"./isTextInputElement":144,"fbjs/lib/ExecutionEnvironment":157,"fbjs/lib/getActiveElement":166,"fbjs/lib/keyOf":176,"fbjs/lib/shallowEqual":181}],110:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function () {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;
},{}],111:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactMount = require('./ReactMount');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  abort: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAbort: true }),
      captured: keyOf({ onAbortCapture: true })
    }
  },
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  canPlay: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlay: true }),
      captured: keyOf({ onCanPlayCapture: true })
    }
  },
  canPlayThrough: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlayThrough: true }),
      captured: keyOf({ onCanPlayThroughCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  durationChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDurationChange: true }),
      captured: keyOf({ onDurationChangeCapture: true })
    }
  },
  emptied: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEmptied: true }),
      captured: keyOf({ onEmptiedCapture: true })
    }
  },
  encrypted: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEncrypted: true }),
      captured: keyOf({ onEncryptedCapture: true })
    }
  },
  ended: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEnded: true }),
      captured: keyOf({ onEndedCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  loadedData: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedData: true }),
      captured: keyOf({ onLoadedDataCapture: true })
    }
  },
  loadedMetadata: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedMetadata: true }),
      captured: keyOf({ onLoadedMetadataCapture: true })
    }
  },
  loadStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadStart: true }),
      captured: keyOf({ onLoadStartCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  pause: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPause: true }),
      captured: keyOf({ onPauseCapture: true })
    }
  },
  play: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlay: true }),
      captured: keyOf({ onPlayCapture: true })
    }
  },
  playing: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlaying: true }),
      captured: keyOf({ onPlayingCapture: true })
    }
  },
  progress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onProgress: true }),
      captured: keyOf({ onProgressCapture: true })
    }
  },
  rateChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onRateChange: true }),
      captured: keyOf({ onRateChangeCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  seeked: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeked: true }),
      captured: keyOf({ onSeekedCapture: true })
    }
  },
  seeking: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeking: true }),
      captured: keyOf({ onSeekingCapture: true })
    }
  },
  stalled: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onStalled: true }),
      captured: keyOf({ onStalledCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  suspend: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSuspend: true }),
      captured: keyOf({ onSuspendCapture: true })
    }
  },
  timeUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTimeUpdate: true }),
      captured: keyOf({ onTimeUpdateCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  volumeChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onVolumeChange: true }),
      captured: keyOf({ onVolumeChangeCapture: true })
    }
  },
  waiting: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWaiting: true }),
      captured: keyOf({ onWaitingCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topAbort: eventTypes.abort,
  topBlur: eventTypes.blur,
  topCanPlay: eventTypes.canPlay,
  topCanPlayThrough: eventTypes.canPlayThrough,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topDurationChange: eventTypes.durationChange,
  topEmptied: eventTypes.emptied,
  topEncrypted: eventTypes.encrypted,
  topEnded: eventTypes.ended,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topLoadedData: eventTypes.loadedData,
  topLoadedMetadata: eventTypes.loadedMetadata,
  topLoadStart: eventTypes.loadStart,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topPause: eventTypes.pause,
  topPlay: eventTypes.play,
  topPlaying: eventTypes.playing,
  topProgress: eventTypes.progress,
  topRateChange: eventTypes.rateChange,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSeeked: eventTypes.seeked,
  topSeeking: eventTypes.seeking,
  topStalled: eventTypes.stalled,
  topSubmit: eventTypes.submit,
  topSuspend: eventTypes.suspend,
  topTimeUpdate: eventTypes.timeUpdate,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topVolumeChange: eventTypes.volumeChange,
  topWaiting: eventTypes.waiting,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topAbort:
      case topLevelTypes.topCanPlay:
      case topLevelTypes.topCanPlayThrough:
      case topLevelTypes.topDurationChange:
      case topLevelTypes.topEmptied:
      case topLevelTypes.topEncrypted:
      case topLevelTypes.topEnded:
      case topLevelTypes.topError:
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topLoadedData:
      case topLevelTypes.topLoadedMetadata:
      case topLevelTypes.topLoadStart:
      case topLevelTypes.topPause:
      case topLevelTypes.topPlay:
      case topLevelTypes.topPlaying:
      case topLevelTypes.topProgress:
      case topLevelTypes.topRateChange:
      case topLevelTypes.topReset:
      case topLevelTypes.topSeeked:
      case topLevelTypes.topSeeking:
      case topLevelTypes.topStalled:
      case topLevelTypes.topSubmit:
      case topLevelTypes.topSuspend:
      case topLevelTypes.topTimeUpdate:
      case topLevelTypes.topVolumeChange:
      case topLevelTypes.topWaiting:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
}).call(this,require('_process'))

},{"./EventConstants":24,"./EventPropagators":28,"./ReactMount":81,"./SyntheticClipboardEvent":112,"./SyntheticDragEvent":114,"./SyntheticEvent":115,"./SyntheticFocusEvent":116,"./SyntheticKeyboardEvent":118,"./SyntheticMouseEvent":119,"./SyntheticTouchEvent":120,"./SyntheticUIEvent":121,"./SyntheticWheelEvent":122,"./getEventCharCode":135,"_process":2,"fbjs/lib/EventListener":156,"fbjs/lib/emptyFunction":163,"fbjs/lib/invariant":171,"fbjs/lib/keyOf":176}],112:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":115}],113:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":115}],114:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":119}],115:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;
  this.target = nativeEventTarget;
  this.currentTarget = nativeEventTarget;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;
}).call(this,require('_process'))

},{"./Object.assign":33,"./PooledClass":34,"_process":2,"fbjs/lib/emptyFunction":163,"fbjs/lib/warning":183}],116:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":121}],117:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":115}],118:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":121,"./getEventCharCode":135,"./getEventKey":136,"./getEventModifierState":137}],119:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":121,"./ViewportMetrics":124,"./getEventModifierState":137}],120:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":121,"./getEventModifierState":137}],121:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":115,"./getEventTarget":138}],122:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":119}],123:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occurred.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],124:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],125:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
}).call(this,require('_process'))

},{"_process":2,"fbjs/lib/invariant":171}],126:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    for (; i < Math.min(i + 4096, m); i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],127:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
}).call(this,require('_process'))

},{"_process":2}],128:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule cloneWithProps
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTransferer = require('./ReactPropTransferer');

var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var CHILDREN_PROP = keyOf({ children: null });

var didDeprecatedWarn = false;

/**
 * Sometimes you want to change the props of a child passed to you. Usually
 * this is to add a CSS class.
 *
 * @param {ReactElement} child child element you'd like to clone
 * @param {object} props props you'd like to modify. className and style will be
 * merged automatically.
 * @return {ReactElement} a clone of child with props merged in.
 * @deprecated
 */
function cloneWithProps(child, props) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(didDeprecatedWarn, 'cloneWithProps(...) is deprecated. ' + 'Please use React.cloneElement instead.') : undefined;
    didDeprecatedWarn = true;
    process.env.NODE_ENV !== 'production' ? warning(!child.ref, 'You are calling cloneWithProps() on a child with a ref. This is ' + 'dangerous because you\'re creating a new child which will not be ' + 'added as a ref to its parent.') : undefined;
  }

  var newProps = ReactPropTransferer.mergeProps(props, child.props);

  // Use `child.props.children` if it is provided.
  if (!newProps.hasOwnProperty(CHILDREN_PROP) && child.props.hasOwnProperty(CHILDREN_PROP)) {
    newProps.children = child.props.children;
  }

  // The current API doesn't retain _owner, which is why this
  // doesn't use ReactElement.cloneAndReplaceProps.
  return ReactElement.createElement(child.type, newProps);
}

module.exports = cloneWithProps;
}).call(this,require('_process'))

},{"./ReactElement":66,"./ReactPropTransferer":88,"_process":2,"fbjs/lib/keyOf":176,"fbjs/lib/warning":183}],129:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":13}],130:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule deprecated
 */

'use strict';

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

/**
 * This will log a single deprecation notice per function and forward the call
 * on to the new API.
 *
 * @param {string} fnName The name of the function
 * @param {string} newModule The module that fn will exist in
 * @param {string} newPackage The module that fn will exist in
 * @param {*} ctx The context this forwarded call should run in
 * @param {function} fn The function to forward on to
 * @return {function} The function that will warn once and then call fn
 */
function deprecated(fnName, newModule, newPackage, ctx, fn) {
  var warned = false;
  if (process.env.NODE_ENV !== 'production') {
    var newFn = function () {
      process.env.NODE_ENV !== 'production' ? warning(warned,
      // Require examples in this string must be split to prevent React's
      // build tools from mistaking them for real requires.
      // Otherwise the build tools will attempt to build a '%s' module.
      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
      warned = true;
      return fn.apply(ctx, arguments);
    };
    // We need to make sure all properties of the original fn are copied over.
    // In particular, this is needed to support PropTypes
    return assign(newFn, fn);
  }

  return fn;
}

module.exports = deprecated;
}).call(this,require('_process'))

},{"./Object.assign":33,"_process":2,"fbjs/lib/warning":183}],131:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],132:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMount = require('./ReactMount');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
  !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":48,"./ReactInstanceMap":77,"./ReactMount":81,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],133:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./traverseAllChildren":152,"_process":2,"fbjs/lib/warning":183}],134:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],135:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],136:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":135}],137:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],138:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],139:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */
var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],140:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],141:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":157}],142:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactNativeComponent = require('./ReactNativeComponent');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function () {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  if (node === null || node === false) {
    instance = new ReactEmptyComponent(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
}).call(this,require('_process'))

},{"./Object.assign":33,"./ReactCompositeComponent":47,"./ReactEmptyComponent":68,"./ReactNativeComponent":84,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],143:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":157}],144:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
}

module.exports = isTextInputElement;
},{}],145:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":66,"_process":2,"fbjs/lib/invariant":171}],146:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":131}],147:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":81}],148:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function (node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function (node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;
},{"fbjs/lib/ExecutionEnvironment":157}],149:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":131,"./setInnerHTML":148,"fbjs/lib/ExecutionEnvironment":157}],150:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
},{"fbjs/lib/shallowEqual":181}],151:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;
},{}],152:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} text Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":48,"./ReactElement":66,"./ReactInstanceHandles":76,"./getIteratorFn":139,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/warning":183}],153:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule update
 */

/* global hasOwnProperty:true */

'use strict';

var assign = require('./Object.assign');
var keyOf = require('fbjs/lib/keyOf');
var invariant = require('fbjs/lib/invariant');
var hasOwnProperty = ({}).hasOwnProperty;

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return assign(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = keyOf({ $push: null });
var COMMAND_UNSHIFT = keyOf({ $unshift: null });
var COMMAND_SPLICE = keyOf({ $splice: null });
var COMMAND_SET = keyOf({ $set: null });
var COMMAND_MERGE = keyOf({ $merge: null });
var COMMAND_APPLY = keyOf({ $apply: null });

var ALL_COMMANDS_LIST = [COMMAND_PUSH, COMMAND_UNSHIFT, COMMAND_SPLICE, COMMAND_SET, COMMAND_MERGE, COMMAND_APPLY];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function (command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  !Array.isArray(value) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected target of %s to be an array; got %s.', command, value) : invariant(false) : undefined;
  var specValue = spec[command];
  !Array.isArray(specValue) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array; got %s. ' + 'Did you forget to wrap your parameter in an array?', command, specValue) : invariant(false) : undefined;
}

function update(value, spec) {
  !(typeof spec === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): You provided a key path to update() that did not contain one ' + 'of %s. Did you forget to include {%s: ...}?', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : invariant(false) : undefined;

  if (hasOwnProperty.call(spec, COMMAND_SET)) {
    !(Object.keys(spec).length === 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot have more than one key in an object with %s', COMMAND_SET) : invariant(false) : undefined;

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    !(mergeObj && typeof mergeObj === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): %s expects a spec of type \'object\'; got %s', COMMAND_MERGE, mergeObj) : invariant(false) : undefined;
    !(nextValue && typeof nextValue === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): %s expects a target of type \'object\'; got %s', COMMAND_MERGE, nextValue) : invariant(false) : undefined;
    assign(nextValue, spec[COMMAND_MERGE]);
  }

  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function (item) {
      nextValue.push(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function (item) {
      nextValue.unshift(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
    !Array.isArray(value) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s target to be an array; got %s', COMMAND_SPLICE, value) : invariant(false) : undefined;
    !Array.isArray(spec[COMMAND_SPLICE]) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
    spec[COMMAND_SPLICE].forEach(function (args) {
      !Array.isArray(args) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
    !(typeof spec[COMMAND_APPLY] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be a function; got %s.', COMMAND_APPLY, spec[COMMAND_APPLY]) : invariant(false) : undefined;
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;
}).call(this,require('_process'))

},{"./Object.assign":33,"_process":2,"fbjs/lib/invariant":171,"fbjs/lib/keyOf":176}],154:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
}).call(this,require('_process'))

},{"./Object.assign":33,"_process":2,"fbjs/lib/emptyFunction":163,"fbjs/lib/warning":183}],155:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSCore
 * @typechecks
 */

'use strict';

var invariant = require('./invariant');

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function (element, className) {
    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSSCore.addClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function (element, className) {
    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
        .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function (element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @return {boolean} true if the element has the class, false if not
   */
  hasClass: function (element, className) {
    !!/\s/.test(className) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'CSS.hasClass takes only a single class name.') : invariant(false) : undefined;
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;
}).call(this,require('_process'))

},{"./invariant":171,"_process":2}],156:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function () {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function () {}
};

module.exports = EventListener;
}).call(this,require('_process'))

},{"./emptyFunction":163,"_process":2}],157:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],158:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],159:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":158}],160:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;
},{"./isTextNode":173}],161:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var toArray = require('./toArray');

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return(
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./toArray":182}],162:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":157,"./createArrayFromMixed":161,"./getMarkupWrap":167,"./invariant":171,"_process":2}],163:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],164:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

'use strict';

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":2}],165:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],166:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not yet defined.
 */
'use strict';

function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }

  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],167:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

/*eslint-disable fb-www/unsafe-html */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":157,"./invariant":171,"_process":2}],168:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],169:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],170:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":169}],171:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":2}],172:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],173:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":172}],174:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

'use strict';

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} className
 * @return {string}
 */
function joinClasses(className /*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;
},{}],175:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require('./invariant');

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function (obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":171,"_process":2}],176:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function (oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],177:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],178:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],179:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":157}],180:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = require('./performance');
var curPerformance = performance;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!curPerformance || !curPerformance.now) {
  curPerformance = Date;
}

var performanceNow = curPerformance.now.bind(curPerformance);

module.exports = performanceNow;
},{"./performance":179}],181:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 * @typechecks
 * 
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],182:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;
}).call(this,require('_process'))

},{"./invariant":171,"_process":2}],183:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  warning = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":163,"_process":2}],184:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":35}],185:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');

var InputActions = {

    upsert: function(input) {
        AppDispatcher.dispatch({
            actionType: input.actionType,
            modelKey: input.modelKey,
            modelValue: input.modelValue
        });
    }

};

module.exports = InputActions;

},{"../dispatcher/AppDispatcher":201}],186:[function(require,module,exports){
var React = require('react');
var ReactDOM = require('react-dom');
var MainComponent = require('./components/MainComponent');

ReactDOM.render(React.createElement(MainComponent, null), document.getElementById('app'));
},{"./components/MainComponent":189,"react":184,"react-dom":8}],187:[function(require,module,exports){
var React = require('react');
var InputActions = require('../../actions/InputActions');

var InputComponent = React.createClass({displayName: "InputComponent",
    _onInputChange: function(){
        var input = React.findDOMNode(this.refs.input).value.trim();
        if(input === ''){
            input = undefined; //deleted their input; resort to undefined||defaults
        }
        if(this.props.isValid(input)){
            if(input !== undefined){
                input = this.props.convert(input);
            }
            InputActions.upsert({
                actionType: this.props.actionType,
                modelKey: this.props.id,
                modelValue: input
            });
        }
    },
    render: function() {
        var before, after;
        if(this.props.addOnBeforeInput === undefined || this.props.addOnBeforeInput){
            before = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }else{
            after = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }
        var required = this.props.required ? ' required' : '';
        return (
            React.createElement("div", null, 
                React.createElement("label", {className: "label label-default" + required, htmlFor: this.props.id}, this.props.label), 
                React.createElement("div", {className: "input-group"}, 
                    before, 
                    React.createElement("input", {
                        className: "form-control", 
                        id: this.props.id, 
                        type: this.props.type, 
                        name: this.props.id, 
                        placeholder: this.props.default, 
                        onChange: this._onInputChange, 
                        ref: "input"}
                    ), 
                    after
                )
            )
        );
    }
});

module.exports = InputComponent;

},{"../../actions/InputActions":185,"react":184}],188:[function(require,module,exports){
var React = require('react');
var InputComponent = require('./InputComponent');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var ScenarioInputDefinitions = require('../../defines/ScenarioInputDefinitions');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        var inputs = ScenarioInputDefinitions.get();
        inputs = inputs.concat(MonthlyCostInputDefinitions.get());
        var inputComponents;
        if(inputs !== undefined && inputs.length > 0) {
            inputComponents = inputs.map(function (e) {
                return (
                    React.createElement(InputComponent, {
                        key: e.id, 
                        id: e.id, 
                        actionType: e.actionType, 
                        type: e.type, 
                        label: e.label, 
                        default: e.default, 
                        required: e.required, 
                        addOnBeforeInput: e.addOnBeforeInput||true, 
                        addOn: e.addOn, 
                        isValid: e.isValid, 
                        convert: e.convert}
                        )
                );
            });
        }
        return (
            React.createElement("div", {className: "inputList"}, 
                inputComponents
            )
        );
    }
});

module.exports = MainComponent;

},{"../../defines/MonthlyCostInputDefinitions":198,"../../defines/ScenarioInputDefinitions":199,"./InputComponent":187,"react":184}],189:[function(require,module,exports){
var React = require('react');
var TitleComponent = require('./TitleComponent/TitleComponent');
var InputListComponent = require('./InputListComponent/InputListComponent');
var ResultListComponent = require('./ResultListComponent/ResultListComponent');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        return (
            React.createElement("div", {className: "mainComponent"}, 
                React.createElement(TitleComponent, null), 
                React.createElement(InputListComponent, null), 
                React.createElement(ResultListComponent, null)
            )
        );
    }
});

module.exports = MainComponent;
},{"./InputListComponent/InputListComponent":188,"./ResultListComponent/ResultListComponent":194,"./TitleComponent/TitleComponent":195,"react":184}],190:[function(require,module,exports){
var React = require('react');
var Highcharts = require('react-highcharts');

var IncomeBreakdownComponent = React.createClass({displayName: "IncomeBreakdownComponent",
    render: function() {
        var incomeBreakDownChart;

        if(this.props.monthlyIncome > 0) {

            var breakdowns = [
                {
                    label: 'Take home',
                    value: (this.props.netIncome / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Expenses',
                    value: (this.props.monthlyExpenses / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Monthly Car Cost',
                    value: (this.props.monthlyCarCost / this.props.monthlyIncome) * 100
                }
            ];

            var data = [];
            breakdowns.forEach(function (e) {
                if (e.value > 0) {
                    data.push([e.label, e.value]);
                }
            });

            var config = {
                chart: {
                    plotBackgroundColor: null,
                    plotBorderWidth: 0,
                    plotShadow: false
                },
                title: {
                    text: 'Income<br>Breakdown',
                    align: 'center',
                    verticalAlign: 'middle',
                    y: 40
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
                },
                plotOptions: {
                    pie: {
                        dataLabels: {
                            enabled: true,
                            distance: -50,
                            style: {
                                fontWeight: 'bold',
                                color: 'white',
                                textShadow: '0px 1px 2px black'
                            }
                        },
                        startAngle: -90,
                        endAngle: 90,
                        center: ['50%', '75%']
                    }
                },
                series: [{
                    type: 'pie',
                    name: 'Income Breakdown',
                    innerSize: '50%',
                    data: data
                }]
            };
            incomeBreakDownChart = React.createElement(Highcharts, {config: config});
        }
        return (
            React.createElement("div", null, 
                incomeBreakDownChart
            )
        );
    }
});

module.exports = IncomeBreakdownComponent;
},{"react":184,"react-highcharts":9}],191:[function(require,module,exports){
var React = require('react');

var NetIncomeTextComponent = React.createClass({displayName: "NetIncomeTextComponent",
    render: function() {
        return (
            React.createElement("div", null, 
                React.createElement("h2", {className: "well centerText"}, "Take Home Per Month After Expenses And Car Payment $", this.props.netIncome.toFixed(2)), ";"
            )
        );
    }
});

module.exports = NetIncomeTextComponent;

},{"react":184}],192:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../../../constants/InputActionConstants');
var InputStore = require('../../../../stores/InputStore');

var SafetyNetOverTimeComponent = React.createClass({displayName: "SafetyNetOverTimeComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var safetyNetEffectText;

        if(this.state.inputs.safetyNet > 0){
            var monthsOfSafetyNetEffect = 12;
            var overTime = [];
            for(var i=1; i<=monthsOfSafetyNetEffect; i++){
                overTime[i] = (this.state.inputs.safetyNet + (this.props.netIncome * i));
            }
            safetyNetEffectText = React.createElement("h2", {className: "well centerText"}, "After 6 Months Your Safety Net Would Be At $", overTime[6].toFixed(2));
        }

        return (
            React.createElement("div", null, 
                safetyNetEffectText
            )
        );
    }
});

module.exports = SafetyNetOverTimeComponent;

},{"../../../../constants/InputActionConstants":197,"../../../../stores/InputStore":202,"react":184}],193:[function(require,module,exports){
var React = require('react');

var InputActionConstants = require('../../../constants/InputActionConstants');
var InputStore = require('../../../stores/InputStore');
var Validators = require('../../../util/Validators');
var ScenarioInputDefinitions = require('../../../defines/ScenarioInputDefinitions');

var IncomeBreakdownComponent = require('./NetIncomeBasedComponents/IncomeBreakdownComponent');
var NetIncomeTextComponent = require('./NetIncomeBasedComponents/NetIncomeTextComponent');
var SafetyNetOverTimeComponent = require('./NetIncomeBasedComponents/SafetyNetOverTimeComponent');

var listenToActions = [
    InputActionConstants.MONTHLY_INCOME_CHANGE,
    InputActionConstants.MONTHLY_EXPENSES_CHANGE
];

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.addChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    componentWillUnmount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.removeChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var incomeBreakdownComponent;
        var netIncomeTextComponent;
        var safetyNetOverTimeComponent;

        if(Validators.validateRequiredInputsExist(ScenarioInputDefinitions.get(), this.state.inputs)){
            var netIncome = this.state.inputs.monthlyIncome - this.state.inputs.monthlyExpenses - this.props.monthlyCarCost;
            incomeBreakdownComponent = React.createElement(IncomeBreakdownComponent, {
                netIncome: netIncome, 
                monthlyIncome: this.state.inputs.monthlyIncome, 
                monthlyCarCost: this.props.monthlyCarCost, 
                monthlyExpenses: this.state.inputs.monthlyExpenses}
            );
            netIncomeTextComponent = React.createElement(NetIncomeTextComponent, {netIncome: netIncome});
            safetyNetOverTimeComponent = React.createElement(SafetyNetOverTimeComponent, {netIncome: netIncome});
        }
        return (
            React.createElement("div", null, 
                incomeBreakdownComponent, 
                netIncomeTextComponent, 
                safetyNetOverTimeComponent
            )
        );
    }
});

module.exports = ResultListComponent;
},{"../../../constants/InputActionConstants":197,"../../../defines/ScenarioInputDefinitions":199,"../../../stores/InputStore":202,"../../../util/Validators":204,"./NetIncomeBasedComponents/IncomeBreakdownComponent":190,"./NetIncomeBasedComponents/NetIncomeTextComponent":191,"./NetIncomeBasedComponents/SafetyNetOverTimeComponent":192,"react":184}],194:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../constants/InputActionConstants');
var InputStore = require('../../stores/InputStore');
var Validators = require('../../util/Validators');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var Calculations = require('../../util/Calculations');
var NetIncomeBasedListComponent = require('./ResultComponents/NetIncomeBasedListComponent');

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        if(Validators.validateRequiredInputsExist(MonthlyCostInputDefinitions.get(), this.state.inputs)){
            var monthlyCarCost = Calculations.monthlyCost(
                this.state.inputs.vehiclePrice,
                this.state.inputs.downPayment,
                this.state.inputs.tradeIn,
                this.state.inputs.interestRate,
                this.state.inputs.salesTax,
                this.state.inputs.term
            );
            return (
                React.createElement("div", null, 
                    React.createElement("div", {id: "monthlyCost"}, 
                        React.createElement("h2", {className: "well centerText"}, "Car Payment $", monthlyCarCost, "/month")
                    ), 
                    React.createElement(NetIncomeBasedListComponent, {monthlyCarCost: monthlyCarCost})
                )
            );
        }
        return (
            React.createElement("div", null)
        );
    }
});

module.exports = ResultListComponent;
},{"../../constants/InputActionConstants":197,"../../defines/MonthlyCostInputDefinitions":198,"../../stores/InputStore":202,"../../util/Calculations":203,"../../util/Validators":204,"./ResultComponents/NetIncomeBasedListComponent":193,"react":184}],195:[function(require,module,exports){
var React = require('react');
//var ReactCSSTransitionGroup = require('react/addons/CSSTransitionGroup');
var TitleDefinitions = require('../../defines/TitleDefinitions');
var titleIntervalTime = 10000;
var titleUpdateInterval;

// https://github.com/facebook/react/issues/1326
var InputComponent = React.createClass({displayName: "InputComponent",
    getInitialState: function(){
        var titles = TitleDefinitions.get();
        return {
            title: titles[Math.floor((Math.random() * (titles.length)))]
        };
    },
    componentDidMount: function(){
        var self = this;
        titleUpdateInterval = setInterval(function(){
            var titles = TitleDefinitions.get();
            self.setState({
                title: titles[Math.floor((Math.random() * (titles.length)))]
            });
        }, titleIntervalTime);
    },
    componentWillUnmount: function(){
        clearInterval(titleUpdateInterval);
    },
    render: function() {
        return (
            React.createElement("div", {className: "title"}, 
                React.createElement("div", {key: this.state.title}, 
                    React.createElement("h5", {key: "title", className: "centerText"}, this.state.title)
                )
            )
        );
    }
});

module.exports = InputComponent;
},{"../../defines/TitleDefinitions":200,"react":184}],196:[function(require,module,exports){
module.exports = {
    MONTHLY_INCOME_DEFAULT: 0,
    MONTHLY_EXPENSES_DEFAULT: 0,
    SAFETY_NET_DEFAULT: 0,
    VEHICLE_PRICE_DEFAULT: undefined, //only required field for app to do basic func
    DOWN_PAYMENT_DEFAULT: 0,
    TRADE_IN_DEFAULT: 0,
    SALES_TAX_DEFAULT: 5.1,
    INTEREST_RATE_DEFAULT: 2.9,
    TERM_DEFAULT: 72
};

},{}],197:[function(require,module,exports){
var keyMirror = require('keymirror');

module.exports = keyMirror({
    MONTHLY_COST_INPUT_CHANGE: null,
    MONTHLY_INCOME_CHANGE: null,
    MONTHLY_EXPENSES_CHANGE: null,
    SAFETY_NET_CHANGE: null
});

},{"keymirror":6}],198:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActions = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'vehiclePrice',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Vehicle Price',
            default: DefaultInputConstants.VEHICLE_PRICE_DEFAULT,
            required: DefaultInputConstants.VEHICLE_PRICE_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'downPayment',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Down Payment',
            default: DefaultInputConstants.DOWN_PAYMENT_DEFAULT,
            required: DefaultInputConstants.DOWN_PAYMENT_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'tradeIn',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Trade In',
            default: DefaultInputConstants.TRADE_IN_DEFAULT,
            required: DefaultInputConstants.TRADE_IN_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'salesTax',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Sales Tax',
            default: DefaultInputConstants.SALES_TAX_DEFAULT,
            required: DefaultInputConstants.SALES_TAX_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'interestRate',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Interest Rate (APR)',
            default: DefaultInputConstants.INTEREST_RATE_DEFAULT,
            required: DefaultInputConstants.INTEREST_RATE_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'term',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Term (Months)',
            default: DefaultInputConstants.TERM_DEFAULT,
            required: DefaultInputConstants.TERM_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: 'months',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":196,"../constants/InputActionConstants":197,"../util/Validators":204}],199:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActionConstants = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'monthlyIncome',
            actionType: InputActionConstants.MONTHLY_INCOME_CHANGE,
            type: 'number',
            label: 'Monthly Income',
            default: DefaultInputConstants.MONTHLY_INCOME_DEFAULT,
            required: DefaultInputConstants.MONTHLY_INCOME_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'monthlyExpenses',
            actionType: InputActionConstants.MONTHLY_EXPENSES_CHANGE,
            type: 'number',
            label: 'Monthly Expenses',
            default: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT,
            required: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'safetyNet',
            actionType: InputActionConstants.SAFETY_NET_CHANGE,
            type: 'number',
            label: 'Savings / Safety Net',
            default: DefaultInputConstants.SAFETY_NET_DEFAULT,
            required: DefaultInputConstants.SAFETY_NET_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":196,"../constants/InputActionConstants":197,"../util/Validators":204}],200:[function(require,module,exports){
module.exports.get = function(){
    return [
        "It's Worth It. Sign. Trust Me.",
        "It's Only 5K Less Than A Mortgage.",
        "Can You Really Put A Price On Fun?",
        "Retirement Is Still 40 Years Out.",
        "When In Doubt Get A V8.",
        "Adrenaline Is Priceless.",
        "Life Is Too Short To Drive A Boring Car.",
        "Just Cut Back On Eating Out."
    ]
};
},{}],201:[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;

module.exports = new Dispatcher();

},{"flux":3}],202:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var InputActionConstants = require('../constants/InputActionConstants');
var assign = require('object-assign');

var _inputs = {};

var InputStore = assign({}, EventEmitter.prototype, {

    get: function(key){
        return _inputs[key];
    },
    getAll: function() {
        return _inputs;
    },

    emitMonthlyCostInputChange: function() {
        this.emit(InputActionConstants.MONTHLY_COST_INPUT_CHANGE);
    },

    emitScenarioChange: function(scenarioActionTypeConstant) {
        this.emit(scenarioActionTypeConstant);
    },

    addChangeListener: function(TypeOfChange, callback) {
        this.on(TypeOfChange, callback);
    },
    removeChangeListener: function(TypeOfChange, callback) {
        this.removeListener(TypeOfChange, callback);
    }

});

AppDispatcher.register(function(action) {

    switch(action.actionType) {
        case InputActionConstants.MONTHLY_COST_INPUT_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitMonthlyCostInputChange();
            break;
        case InputActionConstants.MONTHLY_INCOME_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.MONTHLY_EXPENSES_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.SAFETY_NET_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        default:
        // no op
    }

});

module.exports = InputStore;

},{"../constants/InputActionConstants":197,"../dispatcher/AppDispatcher":201,"events":1,"object-assign":7}],203:[function(require,module,exports){
module.exports.monthlyCost = function(vehiclePrice, downPayment, tradeIn, interestRate, salesTax, term){
    var adjustedInterestRatePercent = interestRate * .01;
    var adjustedSalesTaxPercent = salesTax * .01; // 2.9 => .029
    var salesTaxAmount = vehiclePrice * adjustedSalesTaxPercent;
    var netCost = vehiclePrice + salesTaxAmount - downPayment - tradeIn;
    var rate = adjustedInterestRatePercent / 12;
    var rateCalc = (rate * Math.pow((1 + rate), term))/(Math.pow((1 + rate), term) - 1);
    return parseFloat((netCost * rateCalc).toFixed(2));
};

},{}],204:[function(require,module,exports){
/*
  undefined's are ok, defaults are set for inputs (and if no default, calc simply isn't made)
 */
module.exports.validateNumberInput = function(input){
    try{
        if(input === undefined){
            return true;
        }else{
            parseInt(input);
        }
        return true;
    }catch(e){
        return false;
    }
};
module.exports.validatePercentInput = function(percent){
    try{
        if(percent === undefined){
            return true;
        }else{
            return !isNaN(parseFloat(percent));
        }
    }catch(e){
        return false;
    }
};
module.exports.validateRequiredInputsExist = function(inputDefinitions, inputModels){
    var isValid = true;
    inputDefinitions.forEach(function(e){
        if(inputModels[e.id] === undefined){
            if(e.default !== undefined){
                inputModels[e.id] = e.default;
            }else{
                isValid = false;
            }
        }
    });
    return isValid;
};

},{}]},{},[186])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9rZXltaXJyb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtaGlnaGNoYXJ0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9hZGRvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGFuZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRTdGF0ZU1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET00uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RMaW5rLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UGVyZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHJhbnNmZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJvb3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTdGF0ZVNldHRlcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VGVzdFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkV2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uR3JvdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFdpdGhBZGRvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jbG9uZVdpdGhQcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGVwcmVjYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaGFsbG93Q29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3VwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9DU1NDb3JlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2pvaW5DbGFzc2VzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9rZXlNaXJyb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2tleU9mLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9tYXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxhY3Rpb25zXFxJbnB1dEFjdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcYXBwLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXElucHV0TGlzdENvbXBvbmVudFxcSW5wdXRDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcSW5wdXRMaXN0Q29tcG9uZW50XFxJbnB1dExpc3RDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcTWFpbkNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZENvbXBvbmVudHNcXEluY29tZUJyZWFrZG93bkNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZENvbXBvbmVudHNcXE5ldEluY29tZVRleHRDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0Q29tcG9uZW50c1xcTmV0SW5jb21lQmFzZWRDb21wb25lbnRzXFxTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZExpc3RDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0TGlzdENvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxUaXRsZUNvbXBvbmVudFxcVGl0bGVDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29uc3RhbnRzXFxEZWZhdWx0SW5wdXRWYWx1ZUNvbnN0YW50cy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb25zdGFudHNcXElucHV0QWN0aW9uQ29uc3RhbnRzLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGRlZmluZXNcXE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxkZWZpbmVzXFxTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcZGVmaW5lc1xcVGl0bGVEZWZpbml0aW9ucy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxkaXNwYXRjaGVyXFxBcHBEaXNwYXRjaGVyLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXHN0b3Jlc1xcSW5wdXRTdG9yZS5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFx1dGlsXFxDYWxjdWxhdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcdXRpbFxcVmFsaWRhdG9ycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2o4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7O0FDSEEsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLDZCQUE2QixDQUFDLENBQUM7O0FBRTNELElBQUksWUFBWSxHQUFHOztJQUVmLE1BQU0sRUFBRSxTQUFTLEtBQUssRUFBRTtRQUNwQixhQUFhLENBQUMsUUFBUSxDQUFDO1lBQ25CLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7WUFDeEIsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVO1NBQy9CLENBQUMsQ0FBQztBQUNYLEtBQUs7O0FBRUwsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWTs7O0FDZDdCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDcEMsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7O0FBRTFELFFBQVEsQ0FBQyxNQUFNLENBQUMsb0JBQUMsYUFBYSxFQUFBLElBQUEsQ0FBRyxDQUFBLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOztBQ0puRSxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7O0FBRXpELElBQUksb0NBQW9DLDhCQUFBO0lBQ3BDLGNBQWMsRUFBRSxVQUFVO1FBQ3RCLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDNUQsR0FBRyxLQUFLLEtBQUssRUFBRSxDQUFDO1lBQ1osS0FBSyxHQUFHLFNBQVMsQ0FBQztTQUNyQjtRQUNELEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsR0FBRyxLQUFLLEtBQUssU0FBUyxDQUFDO2dCQUNuQixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDckM7WUFDRCxZQUFZLENBQUMsTUFBTSxDQUFDO2dCQUNoQixVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVO2dCQUNqQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixVQUFVLEVBQUUsS0FBSzthQUNwQixDQUFDLENBQUM7U0FDTjtLQUNKO0lBQ0QsTUFBTSxFQUFFLFdBQVc7UUFDZixJQUFJLE1BQU0sRUFBRSxLQUFLLENBQUM7UUFDbEIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDO1lBQ3hFLE1BQU0sR0FBRyxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLG1CQUFvQixDQUFBLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFhLENBQUEsQ0FBQztTQUMxRSxJQUFJO1lBQ0QsS0FBSyxHQUFHLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsbUJBQW9CLENBQUEsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQWEsQ0FBQSxDQUFDO1NBQ3pFO1FBQ0QsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0RDtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7Z0JBQ0Qsb0JBQUEsT0FBTSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBRSxxQkFBcUIsR0FBRyxRQUFRLEVBQUMsQ0FBQyxPQUFBLEVBQU8sQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUksQ0FBQSxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBYyxDQUFBLEVBQUE7Z0JBQ3RHLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsYUFBYyxDQUFBLEVBQUE7b0JBQ3hCLE1BQU0sRUFBQztvQkFDUixvQkFBQSxPQUFNLEVBQUEsQ0FBQTt3QkFDRixTQUFBLEVBQVMsQ0FBQyxjQUFBLEVBQWM7d0JBQ3hCLEVBQUEsRUFBRSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDO3dCQUNsQixJQUFBLEVBQUksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBQzt3QkFDdEIsSUFBQSxFQUFJLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUM7d0JBQ3BCLFdBQUEsRUFBVyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFDO3dCQUNoQyxRQUFBLEVBQVEsQ0FBRSxJQUFJLENBQUMsY0FBYyxFQUFDO3dCQUM5QixHQUFBLEVBQUcsQ0FBQyxPQUFPLENBQUE7b0JBQ2IsQ0FBQSxFQUFBO29CQUNELEtBQU07Z0JBQ0wsQ0FBQTtZQUNKLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjOzs7QUNqRC9CLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNqRCxJQUFJLDJCQUEyQixHQUFHLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0FBQ3ZGLElBQUksd0JBQXdCLEdBQUcsT0FBTyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7O0FBRWpGLElBQUksbUNBQW1DLDZCQUFBO0lBQ25DLE1BQU0sRUFBRSxXQUFXO1FBQ2YsSUFBSSxNQUFNLEdBQUcsd0JBQXdCLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDNUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsMkJBQTJCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUMxRCxJQUFJLGVBQWUsQ0FBQztRQUNwQixHQUFHLE1BQU0sS0FBSyxTQUFTLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDMUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ3RDO29CQUNJLG9CQUFDLGNBQWMsRUFBQSxDQUFBO3dCQUNYLEdBQUEsRUFBRyxDQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUM7d0JBQ1YsRUFBQSxFQUFFLENBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQzt3QkFDVCxVQUFBLEVBQVUsQ0FBRSxDQUFDLENBQUMsVUFBVSxFQUFDO3dCQUN6QixJQUFBLEVBQUksQ0FBRSxDQUFDLENBQUMsSUFBSSxFQUFDO3dCQUNiLEtBQUEsRUFBSyxDQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUM7d0JBQ2YsT0FBQSxFQUFPLENBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBQzt3QkFDbkIsUUFBQSxFQUFRLENBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBQzt3QkFDckIsZ0JBQUEsRUFBZ0IsQ0FBRSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxFQUFDO3dCQUMzQyxLQUFBLEVBQUssQ0FBRSxDQUFDLENBQUMsS0FBSyxFQUFDO3dCQUNmLE9BQUEsRUFBTyxDQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUM7d0JBQ25CLE9BQUEsRUFBTyxDQUFFLENBQUMsQ0FBQyxPQUFRLENBQUE7d0JBQ2pCLENBQUE7a0JBQ1I7YUFDTCxDQUFDLENBQUM7U0FDTjtRQUNEO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxXQUFZLENBQUEsRUFBQTtnQkFDdEIsZUFBZ0I7WUFDZixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBYTs7O0FDckM5QixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7QUFDaEUsSUFBSSxrQkFBa0IsR0FBRyxPQUFPLENBQUMseUNBQXlDLENBQUMsQ0FBQztBQUM1RSxJQUFJLG1CQUFtQixHQUFHLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDOztBQUUvRSxJQUFJLG1DQUFtQyw2QkFBQTtJQUNuQyxNQUFNLEVBQUUsV0FBVztRQUNmO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxlQUFnQixDQUFBLEVBQUE7Z0JBQzNCLG9CQUFDLGNBQWMsRUFBQSxJQUFBLENBQUcsQ0FBQSxFQUFBO2dCQUNsQixvQkFBQyxrQkFBa0IsRUFBQSxJQUFBLENBQUcsQ0FBQSxFQUFBO2dCQUN0QixvQkFBQyxtQkFBbUIsRUFBQSxJQUFBLENBQUcsQ0FBQTtZQUNyQixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDOztBQ2pCL0IsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOztBQUU3QyxJQUFJLDhDQUE4Qyx3Q0FBQTtJQUM5QyxNQUFNLEVBQUUsV0FBVztBQUN2QixRQUFRLElBQUksb0JBQW9CLENBQUM7O0FBRWpDLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUU7O1lBRTdCLElBQUksVUFBVSxHQUFHO2dCQUNiO29CQUNJLEtBQUssRUFBRSxXQUFXO29CQUNsQixLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxHQUFHO2lCQUNqRTtnQkFDRDtvQkFDSSxLQUFLLEVBQUUsVUFBVTtvQkFDakIsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksR0FBRztpQkFDdkU7Z0JBQ0Q7b0JBQ0ksS0FBSyxFQUFFLGtCQUFrQjtvQkFDekIsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksR0FBRztpQkFDdEU7QUFDakIsYUFBYSxDQUFDOztZQUVGLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUNkLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUU7b0JBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQ2pDO0FBQ2pCLGFBQWEsQ0FBQyxDQUFDOztZQUVILElBQUksTUFBTSxHQUFHO2dCQUNULEtBQUssRUFBRTtvQkFDSCxtQkFBbUIsRUFBRSxJQUFJO29CQUN6QixlQUFlLEVBQUUsQ0FBQztvQkFDbEIsVUFBVSxFQUFFLEtBQUs7aUJBQ3BCO2dCQUNELEtBQUssRUFBRTtvQkFDSCxJQUFJLEVBQUUscUJBQXFCO29CQUMzQixLQUFLLEVBQUUsUUFBUTtvQkFDZixhQUFhLEVBQUUsUUFBUTtvQkFDdkIsQ0FBQyxFQUFFLEVBQUU7aUJBQ1I7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFdBQVcsRUFBRSwrQ0FBK0M7aUJBQy9EO2dCQUNELFdBQVcsRUFBRTtvQkFDVCxHQUFHLEVBQUU7d0JBQ0QsVUFBVSxFQUFFOzRCQUNSLE9BQU8sRUFBRSxJQUFJOzRCQUNiLFFBQVEsRUFBRSxDQUFDLEVBQUU7NEJBQ2IsS0FBSyxFQUFFO2dDQUNILFVBQVUsRUFBRSxNQUFNO2dDQUNsQixLQUFLLEVBQUUsT0FBTztnQ0FDZCxVQUFVLEVBQUUsbUJBQW1COzZCQUNsQzt5QkFDSjt3QkFDRCxVQUFVLEVBQUUsQ0FBQyxFQUFFO3dCQUNmLFFBQVEsRUFBRSxFQUFFO3dCQUNaLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7cUJBQ3pCO2lCQUNKO2dCQUNELE1BQU0sRUFBRSxDQUFDO29CQUNMLElBQUksRUFBRSxLQUFLO29CQUNYLElBQUksRUFBRSxrQkFBa0I7b0JBQ3hCLFNBQVMsRUFBRSxLQUFLO29CQUNoQixJQUFJLEVBQUUsSUFBSTtpQkFDYixDQUFDO2FBQ0wsQ0FBQztZQUNGLG9CQUFvQixHQUFHLG9CQUFDLFVBQVUsRUFBQSxDQUFBLENBQUMsTUFBQSxFQUFNLEdBQUksTUFBUSxDQUFhLENBQUEsQ0FBQztTQUN0RTtRQUNEO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtnQkFDQSxvQkFBcUI7WUFDcEIsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLHdCQUF3QixDQUFDOztBQy9FMUMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUU3QixJQUFJLDRDQUE0QyxzQ0FBQTtJQUM1QyxNQUFNLEVBQUUsV0FBVztRQUNmO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtnQkFDRCxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFrQixDQUFBLEVBQUEsc0RBQUEsRUFBcUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBTyxDQUFBLEVBQUEsR0FBQTtBQUFBLFlBQ3hILENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxzQkFBc0I7OztBQ1p2QyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsNENBQTRDLENBQUMsQ0FBQztBQUNqRixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQzs7QUFFMUQsSUFBSSxnREFBZ0QsMENBQUE7SUFDaEQsY0FBYyxFQUFFLFdBQVc7UUFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNWLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUMsQ0FBQztLQUNOO0lBQ0QsaUJBQWlCLEVBQUUsV0FBVztRQUMxQixVQUFVLENBQUMsaUJBQWlCLENBQUMsb0JBQW9CLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQzdGO0lBQ0Qsb0JBQW9CLEVBQUUsV0FBVztRQUM3QixVQUFVLENBQUMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ2hHO0lBQ0QsZUFBZSxFQUFFLFdBQVc7UUFDeEIsT0FBTztZQUNILE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUM7S0FDTDtJQUNELE1BQU0sRUFBRSxXQUFXO0FBQ3ZCLFFBQVEsSUFBSSxtQkFBbUIsQ0FBQzs7UUFFeEIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLElBQUksdUJBQXVCLEdBQUcsRUFBRSxDQUFDO1lBQ2pDLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztZQUNsQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ3pDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM1RTtZQUNELG1CQUFtQixHQUFHLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQWtCLENBQUEsRUFBQSw4Q0FBQSxFQUE2QyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBTyxDQUFBLENBQUM7QUFDNUksU0FBUzs7UUFFRDtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7Z0JBQ0EsbUJBQW9CO1lBQ25CLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRywwQkFBMEI7OztBQ3pDM0MsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUU3QixJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO0FBQzlFLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBQ3ZELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBQ3JELElBQUksd0JBQXdCLEdBQUcsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7O0FBRXBGLElBQUksd0JBQXdCLEdBQUcsT0FBTyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7QUFDOUYsSUFBSSxzQkFBc0IsR0FBRyxPQUFPLENBQUMsbURBQW1ELENBQUMsQ0FBQztBQUMxRixJQUFJLDBCQUEwQixHQUFHLE9BQU8sQ0FBQyx1REFBdUQsQ0FBQyxDQUFDOztBQUVsRyxJQUFJLGVBQWUsR0FBRztJQUNsQixvQkFBb0IsQ0FBQyxxQkFBcUI7SUFDMUMsb0JBQW9CLENBQUMsdUJBQXVCO0FBQ2hELENBQUMsQ0FBQzs7QUFFRixJQUFJLHlDQUF5QyxtQ0FBQTtJQUN6QyxjQUFjLEVBQUUsV0FBVztRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ1YsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQyxDQUFDO0tBQ047SUFDRCxpQkFBaUIsRUFBRSxXQUFXO1FBQzFCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixlQUFlLENBQUMsT0FBTyxDQUFDLFNBQVMsa0JBQWtCLENBQUM7WUFDaEQsVUFBVSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUN6RSxDQUFDLENBQUM7S0FDTjtJQUNELG9CQUFvQixFQUFFLFdBQVc7UUFDN0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLGVBQWUsQ0FBQyxPQUFPLENBQUMsU0FBUyxrQkFBa0IsQ0FBQztZQUNoRCxVQUFVLENBQUMsb0JBQW9CLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQzVFLENBQUMsQ0FBQztLQUNOO0lBQ0QsZUFBZSxFQUFFLFdBQVc7UUFDeEIsT0FBTztZQUNILE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUM7S0FDTDtJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2YsSUFBSSx3QkFBd0IsQ0FBQztRQUM3QixJQUFJLHNCQUFzQixDQUFDO0FBQ25DLFFBQVEsSUFBSSwwQkFBMEIsQ0FBQzs7UUFFL0IsR0FBRyxVQUFVLENBQUMsMkJBQTJCLENBQUMsd0JBQXdCLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN6RixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDO1lBQ2hILHdCQUF3QixHQUFHLG9CQUFDLHdCQUF3QixFQUFBLENBQUE7Z0JBQ2hELFNBQUEsRUFBUyxDQUFFLFNBQVMsRUFBQztnQkFDckIsYUFBQSxFQUFhLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFDO2dCQUMvQyxjQUFBLEVBQWMsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBQztnQkFDMUMsZUFBQSxFQUFlLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsZUFBZ0IsQ0FBQTtZQUNyRCxDQUFBLENBQUM7WUFDSCxzQkFBc0IsR0FBRyxvQkFBQyxzQkFBc0IsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUsU0FBVSxDQUFBLENBQUcsQ0FBQSxDQUFDO1lBQzFFLDBCQUEwQixHQUFHLG9CQUFDLDBCQUEwQixFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBRSxTQUFVLENBQUEsQ0FBRyxDQUFBLENBQUM7U0FDckY7UUFDRDtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7Z0JBQ0Esd0JBQXdCLEVBQUM7Z0JBQ3pCLHNCQUFzQixFQUFDO2dCQUN2QiwwQkFBMkI7WUFDMUIsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLG1CQUFtQixDQUFDOztBQ2pFckMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksb0JBQW9CLEdBQUcsT0FBTyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7QUFDM0UsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDcEQsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDbEQsSUFBSSwyQkFBMkIsR0FBRyxPQUFPLENBQUMsMkNBQTJDLENBQUMsQ0FBQztBQUN2RixJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUN0RCxJQUFJLDJCQUEyQixHQUFHLE9BQU8sQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDOztBQUU1RixJQUFJLHlDQUF5QyxtQ0FBQTtJQUN6QyxjQUFjLEVBQUUsV0FBVztRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ1YsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQyxDQUFDO0tBQ047SUFDRCxpQkFBaUIsRUFBRSxXQUFXO1FBQzFCLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsQ0FBQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDckc7SUFDRCxvQkFBb0IsRUFBRSxXQUFXO1FBQzdCLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxvQkFBb0IsQ0FBQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDeEc7SUFDRCxlQUFlLEVBQUUsV0FBVztRQUN4QixPQUFPO1lBQ0gsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQztLQUNMO0lBQ0QsTUFBTSxFQUFFLFdBQVc7UUFDZixHQUFHLFVBQVUsQ0FBQywyQkFBMkIsQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVGLElBQUksY0FBYyxHQUFHLFlBQVksQ0FBQyxXQUFXO2dCQUN6QyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxZQUFZO2dCQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXO2dCQUM3QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPO2dCQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxZQUFZO2dCQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRO2dCQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJO2FBQ3pCLENBQUM7WUFDRjtnQkFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO29CQUNELG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsRUFBQSxFQUFFLENBQUMsYUFBYyxDQUFBLEVBQUE7d0JBQ2xCLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQWtCLENBQUEsRUFBQSxlQUFBLEVBQWMsY0FBYyxFQUFDLFFBQVcsQ0FBQTtvQkFDdEUsQ0FBQSxFQUFBO29CQUNOLG9CQUFDLDJCQUEyQixFQUFBLENBQUEsQ0FBQyxjQUFBLEVBQWMsQ0FBRSxjQUFlLENBQUEsQ0FBRyxDQUFBO2dCQUM3RCxDQUFBO2NBQ1I7U0FDTDtRQUNEO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQU8sQ0FBQTtVQUNiO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLG1CQUFtQixDQUFDOztBQ2xEckMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLDJFQUEyRTtBQUMzRSxJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ2pFLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO0FBQzlCLElBQUksbUJBQW1CLENBQUM7O0FBRXhCLGdEQUFnRDtBQUNoRCxJQUFJLG9DQUFvQyw4QkFBQTtJQUNwQyxlQUFlLEVBQUUsVUFBVTtRQUN2QixJQUFJLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNwQyxPQUFPO1lBQ0gsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUMvRCxDQUFDO0tBQ0w7SUFDRCxpQkFBaUIsRUFBRSxVQUFVO1FBQ3pCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixtQkFBbUIsR0FBRyxXQUFXLENBQUMsVUFBVTtZQUN4QyxJQUFJLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNWLEtBQUssRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7YUFDL0QsQ0FBQyxDQUFDO1NBQ04sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0Qsb0JBQW9CLEVBQUUsVUFBVTtRQUM1QixhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUN0QztJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2Y7WUFDSSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLE9BQVEsQ0FBQSxFQUFBO2dCQUNuQixvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLEdBQUEsRUFBRyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBTyxDQUFBLEVBQUE7b0JBQ3hCLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUMsT0FBQSxFQUFPLENBQUMsU0FBQSxFQUFTLENBQUMsWUFBYSxDQUFBLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFXLENBQUE7Z0JBQzVELENBQUE7WUFDSixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDOztBQ3JDaEMsTUFBTSxDQUFDLE9BQU8sR0FBRztJQUNiLHNCQUFzQixFQUFFLENBQUM7SUFDekIsd0JBQXdCLEVBQUUsQ0FBQztJQUMzQixrQkFBa0IsRUFBRSxDQUFDO0lBQ3JCLHFCQUFxQixFQUFFLFNBQVM7SUFDaEMsb0JBQW9CLEVBQUUsQ0FBQztJQUN2QixnQkFBZ0IsRUFBRSxDQUFDO0lBQ25CLGlCQUFpQixFQUFFLEdBQUc7SUFDdEIscUJBQXFCLEVBQUUsR0FBRztJQUMxQixZQUFZLEVBQUUsRUFBRTtDQUNuQjs7O0FDVkQsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUVyQyxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztJQUN2Qix5QkFBeUIsRUFBRSxJQUFJO0lBQy9CLHFCQUFxQixFQUFFLElBQUk7SUFDM0IsdUJBQXVCLEVBQUUsSUFBSTtJQUM3QixpQkFBaUIsRUFBRSxJQUFJO0NBQzFCLENBQUM7OztBQ1BGLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLFVBQVU7SUFDM0IsSUFBSSxxQkFBcUIsR0FBRyxPQUFPLENBQUMseUNBQXlDLENBQUMsQ0FBQztJQUMvRSxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsbUNBQW1DLENBQUMsQ0FBQztJQUNoRSxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUMvQyxJQUFJLE1BQU0sR0FBRztRQUNUO1lBQ0ksRUFBRSxFQUFFLGNBQWM7WUFDbEIsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsZUFBZTtZQUN0QixPQUFPLEVBQUUscUJBQXFCLENBQUMscUJBQXFCO1lBQ3BELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxxQkFBcUIsS0FBSyxTQUFTO1lBQ25FLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztRQUNEO1lBQ0ksRUFBRSxFQUFFLGFBQWE7WUFDakIsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsY0FBYztZQUNyQixPQUFPLEVBQUUscUJBQXFCLENBQUMsb0JBQW9CO1lBQ25ELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxvQkFBb0IsS0FBSyxTQUFTO1lBQ2xFLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztRQUNEO1lBQ0ksRUFBRSxFQUFFLFNBQVM7WUFDYixVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxVQUFVO1lBQ2pCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxnQkFBZ0I7WUFDL0MsUUFBUSxFQUFFLHFCQUFxQixDQUFDLGdCQUFnQixLQUFLLFNBQVM7WUFDOUQsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsVUFBVTtZQUNkLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLFdBQVc7WUFDbEIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLGlCQUFpQjtZQUNoRCxRQUFRLEVBQUUscUJBQXFCLENBQUMsaUJBQWlCLEtBQUssU0FBUztZQUMvRCxnQkFBZ0IsRUFBRSxLQUFLO1lBQ3ZCLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxvQkFBb0I7WUFDeEMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUNoRDtRQUNEO1lBQ0ksRUFBRSxFQUFFLGNBQWM7WUFDbEIsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUscUJBQXFCO1lBQzVCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxxQkFBcUI7WUFDcEQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLHFCQUFxQixLQUFLLFNBQVM7WUFDbkUsZ0JBQWdCLEVBQUUsS0FBSztZQUN2QixLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsb0JBQW9CO1lBQ3hDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDaEQ7UUFDRDtZQUNJLEVBQUUsRUFBRSxNQUFNO1lBQ1YsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsZUFBZTtZQUN0QixPQUFPLEVBQUUscUJBQXFCLENBQUMsWUFBWTtZQUMzQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsWUFBWSxLQUFLLFNBQVM7WUFDMUQsZ0JBQWdCLEVBQUUsS0FBSztZQUN2QixLQUFLLEVBQUUsUUFBUTtZQUNmLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7S0FDSixDQUFDO0lBQ0YsT0FBTyxNQUFNLENBQUM7Q0FDakI7OztBQzVFRCxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxVQUFVO0lBQzNCLElBQUkscUJBQXFCLEdBQUcsT0FBTyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDL0UsSUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsbUNBQW1DLENBQUMsQ0FBQztJQUN4RSxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUMvQyxJQUFJLE1BQU0sR0FBRztRQUNUO1lBQ0ksRUFBRSxFQUFFLGVBQWU7WUFDbkIsVUFBVSxFQUFFLG9CQUFvQixDQUFDLHFCQUFxQjtZQUN0RCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxnQkFBZ0I7WUFDdkIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLHNCQUFzQjtZQUNyRCxRQUFRLEVBQUUscUJBQXFCLENBQUMsc0JBQXNCLEtBQUssU0FBUztZQUNwRSxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7UUFDRDtZQUNJLEVBQUUsRUFBRSxpQkFBaUI7WUFDckIsVUFBVSxFQUFFLG9CQUFvQixDQUFDLHVCQUF1QjtZQUN4RCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxrQkFBa0I7WUFDekIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLHdCQUF3QjtZQUN2RCxRQUFRLEVBQUUscUJBQXFCLENBQUMsd0JBQXdCLEtBQUssU0FBUztZQUN0RSxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7UUFDRDtZQUNJLEVBQUUsRUFBRSxXQUFXO1lBQ2YsVUFBVSxFQUFFLG9CQUFvQixDQUFDLGlCQUFpQjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxzQkFBc0I7WUFDN0IsT0FBTyxFQUFFLHFCQUFxQixDQUFDLGtCQUFrQjtZQUNqRCxRQUFRLEVBQUUscUJBQXFCLENBQUMsa0JBQWtCLEtBQUssU0FBUztZQUNoRSxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7S0FDSixDQUFDO0lBQ0YsT0FBTyxNQUFNLENBQUM7Q0FDakI7OztBQ3hDRCxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxVQUFVO0lBQzNCLE9BQU87UUFDSCxnQ0FBZ0M7UUFDaEMsb0NBQW9DO1FBQ3BDLG9DQUFvQztRQUNwQyxtQ0FBbUM7UUFDbkMseUJBQXlCO1FBQ3pCLDBCQUEwQjtRQUMxQiwwQ0FBMEM7UUFDMUMsOEJBQThCO0tBQ2pDO0NBQ0osQ0FBQzs7QUNYRixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDOztBQUU1QyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksVUFBVSxFQUFFOzs7QUNGakMsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFDM0QsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUNsRCxJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0FBQ3hFLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7QUFFdEMsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVqQixJQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsRUFBRSxFQUFFLFlBQVksQ0FBQyxTQUFTLEVBQUU7O0lBRWhELEdBQUcsRUFBRSxTQUFTLEdBQUcsQ0FBQztRQUNkLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZCO0lBQ0QsTUFBTSxFQUFFLFdBQVc7UUFDZixPQUFPLE9BQU8sQ0FBQztBQUN2QixLQUFLOztJQUVELDBCQUEwQixFQUFFLFdBQVc7UUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQ2xFLEtBQUs7O0lBRUQsa0JBQWtCLEVBQUUsU0FBUywwQkFBMEIsRUFBRTtRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFDOUMsS0FBSzs7SUFFRCxpQkFBaUIsRUFBRSxTQUFTLFlBQVksRUFBRSxRQUFRLEVBQUU7UUFDaEQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDbkM7SUFDRCxvQkFBb0IsRUFBRSxTQUFTLFlBQVksRUFBRSxRQUFRLEVBQUU7UUFDbkQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDcEQsS0FBSzs7QUFFTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxhQUFhLENBQUMsUUFBUSxDQUFDLFNBQVMsTUFBTSxFQUFFOztJQUVwQyxPQUFPLE1BQU0sQ0FBQyxVQUFVO1FBQ3BCLEtBQUssb0JBQW9CLENBQUMseUJBQXlCO1lBQy9DLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUM3QyxVQUFVLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztZQUN4QyxNQUFNO1FBQ1YsS0FBSyxvQkFBb0IsQ0FBQyxxQkFBcUI7WUFDM0MsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1lBQzdDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakQsTUFBTTtRQUNWLEtBQUssb0JBQW9CLENBQUMsdUJBQXVCO1lBQzdDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUM3QyxVQUFVLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pELE1BQU07UUFDVixLQUFLLG9CQUFvQixDQUFDLGlCQUFpQjtZQUN2QyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDN0MsVUFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqRCxNQUFNO0FBQ2xCLFFBQVEsUUFBUTs7QUFFaEIsS0FBSzs7QUFFTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVU7OztBQzFEM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsU0FBUyxZQUFZLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQztJQUNuRyxJQUFJLDJCQUEyQixHQUFHLFlBQVksR0FBRyxHQUFHLENBQUM7SUFDckQsSUFBSSx1QkFBdUIsR0FBRyxRQUFRLEdBQUcsR0FBRyxDQUFDO0lBQzdDLElBQUksY0FBYyxHQUFHLFlBQVksR0FBRyx1QkFBdUIsQ0FBQztJQUM1RCxJQUFJLE9BQU8sR0FBRyxZQUFZLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxPQUFPLENBQUM7SUFDcEUsSUFBSSxJQUFJLEdBQUcsMkJBQTJCLEdBQUcsRUFBRSxDQUFDO0lBQzVDLElBQUksUUFBUSxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEYsT0FBTyxVQUFVLENBQUMsQ0FBQyxPQUFPLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3REOzs7QUNSRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEdBQUcsU0FBUyxLQUFLLENBQUM7SUFDaEQsR0FBRztRQUNDLEdBQUcsS0FBSyxLQUFLLFNBQVMsQ0FBQztZQUNuQixPQUFPLElBQUksQ0FBQztTQUNmLElBQUk7WUFDRCxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkI7UUFDRCxPQUFPLElBQUksQ0FBQztLQUNmLE1BQU0sQ0FBQyxDQUFDO1FBQ0wsT0FBTyxLQUFLLENBQUM7S0FDaEI7Q0FDSixDQUFDO0FBQ0YsTUFBTSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLE9BQU8sQ0FBQztJQUNuRCxHQUFHO1FBQ0MsR0FBRyxPQUFPLEtBQUssU0FBUyxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1NBQ2YsSUFBSTtZQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDdEM7S0FDSixNQUFNLENBQUMsQ0FBQztRQUNMLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0NBQ0osQ0FBQztBQUNGLE1BQU0sQ0FBQyxPQUFPLENBQUMsMkJBQTJCLEdBQUcsU0FBUyxnQkFBZ0IsRUFBRSxXQUFXLENBQUM7SUFDaEYsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ25CLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNoQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssU0FBUyxDQUFDO1lBQy9CLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUM7Z0JBQ3ZCLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQzthQUNqQyxJQUFJO2dCQUNELE9BQU8sR0FBRyxLQUFLLENBQUM7YUFDbkI7U0FDSjtLQUNKLENBQUMsQ0FBQztJQUNILE9BQU8sT0FBTyxDQUFDO0NBQ2xCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9EaXNwYXRjaGVyJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIFxuICogQHByZXZlbnRNdW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIF9wcmVmaXggPSAnSURfJztcblxuLyoqXG4gKiBEaXNwYXRjaGVyIGlzIHVzZWQgdG8gYnJvYWRjYXN0IHBheWxvYWRzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLiBUaGlzIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSBnZW5lcmljIHB1Yi1zdWIgc3lzdGVtcyBpbiB0d28gd2F5czpcbiAqXG4gKiAgIDEpIENhbGxiYWNrcyBhcmUgbm90IHN1YnNjcmliZWQgdG8gcGFydGljdWxhciBldmVudHMuIEV2ZXJ5IHBheWxvYWQgaXNcbiAqICAgICAgZGlzcGF0Y2hlZCB0byBldmVyeSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICogICAyKSBDYWxsYmFja3MgY2FuIGJlIGRlZmVycmVkIGluIHdob2xlIG9yIHBhcnQgdW50aWwgb3RoZXIgY2FsbGJhY2tzIGhhdmVcbiAqICAgICAgYmVlbiBleGVjdXRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBoeXBvdGhldGljYWwgZmxpZ2h0IGRlc3RpbmF0aW9uIGZvcm0sIHdoaWNoXG4gKiBzZWxlY3RzIGEgZGVmYXVsdCBjaXR5IHdoZW4gYSBjb3VudHJ5IGlzIHNlbGVjdGVkOlxuICpcbiAqICAgdmFyIGZsaWdodERpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcigpO1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY291bnRyeSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ291bnRyeVN0b3JlID0ge2NvdW50cnk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2l0eSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ2l0eVN0b3JlID0ge2NpdHk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGJhc2UgZmxpZ2h0IHByaWNlIG9mIHRoZSBzZWxlY3RlZCBjaXR5XG4gKiAgIHZhciBGbGlnaHRQcmljZVN0b3JlID0ge3ByaWNlOiBudWxsfVxuICpcbiAqIFdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlIHNlbGVjdGVkIGNpdHksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NpdHktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENpdHk6ICdwYXJpcydcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGBDaXR5U3RvcmVgOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NpdHktdXBkYXRlJykge1xuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBwYXlsb2FkLnNlbGVjdGVkQ2l0eTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvdW50cnksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NvdW50cnktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENvdW50cnk6ICdhdXN0cmFsaWEnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBib3RoIHN0b3JlczpcbiAqXG4gKiAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgIGNhc2UgJ2NpdHktdXBkYXRlJzpcbiAqICAgICAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NpdHlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBnZXRGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgYGNvdW50cnktdXBkYXRlYCBwYXlsb2FkIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBpbnZva2UgdGhlIHN0b3JlcydcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGluIG9yZGVyOiBgQ291bnRyeVN0b3JlYCwgYENpdHlTdG9yZWAsIHRoZW5cbiAqIGBGbGlnaHRQcmljZVN0b3JlYC5cbiAqL1xuXG52YXIgRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuX2lzUGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX2xhc3RJRCA9IDE7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIGV2ZXJ5IGRpc3BhdGNoZWQgcGF5bG9hZC4gUmV0dXJuc1xuICAgKiBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgd2FpdEZvcigpYC5cbiAgICovXG5cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IF9wcmVmaXggKyB0aGlzLl9sYXN0SUQrKztcbiAgICB0aGlzLl9jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgYmFzZWQgb24gaXRzIHRva2VuLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihpZCkge1xuICAgICF0aGlzLl9jYWxsYmFja3NbaWRdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIudW5yZWdpc3RlciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJywgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiB3YWl0Rm9yKGlkcykge1xuICAgICF0aGlzLl9pc0Rpc3BhdGNoaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBNdXN0IGJlIGludm9rZWQgd2hpbGUgZGlzcGF0Y2hpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgIXRoaXMuX2lzSGFuZGxlZFtpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgJyArICd3YWl0aW5nIGZvciBgJXNgLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgIXRoaXMuX2NhbGxiYWNrc1tpZF0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIHBheWxvYWQgdG8gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKHBheWxvYWQpIHtcbiAgICAhIXRoaXMuX2lzRGlzcGF0Y2hpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGlzcGF0Y2guZGlzcGF0Y2goLi4uKTogQ2Fubm90IGRpc3BhdGNoIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9zdG9wRGlzcGF0Y2hpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgRGlzcGF0Y2hlciBjdXJyZW50bHkgZGlzcGF0Y2hpbmcuXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBpc0Rpc3BhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Rpc3BhdGNoaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjYWxsYmFjayBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWQuIEFsc28gZG8gc29tZSBpbnRlcm5hbFxuICAgKiBib29ra2VlcGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9pbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjayhpZCkge1xuICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0odGhpcy5fcGVuZGluZ1BheWxvYWQpO1xuICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgYm9va2tlZXBpbmcgbmVlZGVkIHdoZW4gZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5fc3RhcnREaXNwYXRjaGluZyA9IGZ1bmN0aW9uIF9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpIHtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzSGFuZGxlZFtpZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ1BheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMuX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLl9zdG9wRGlzcGF0Y2hpbmcgPSBmdW5jdGlvbiBfc3RvcERpc3BhdGNoaW5nKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUGF5bG9hZDtcbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIERpc3BhdGNoZXI7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50IFZpb2xhdGlvbjogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIFRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBvd25FbnVtZXJhYmxlS2V5cyhvYmopIHtcblx0dmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0a2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG5cdH1cblxuXHRyZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiBwcm9wSXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpO1xuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIGtleXM7XG5cdHZhciB0byA9IFRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gYXJndW1lbnRzW3NdO1xuXHRcdGtleXMgPSBvd25FbnVtZXJhYmxlS2V5cyhPYmplY3QoZnJvbSkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QvYWRkb25zXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QvYWRkb25zXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhpZ2hjaGFydHNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0L2FkZG9uc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiSGlnaGNoYXJ0c1wiXSA9IGZhY3Rvcnkocm9vdFtcInJlYWN0XCJdLCByb290W1wicmVhY3QvYWRkb25zXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge2dsb2JhbC5IaWdoY2hhcnRzQWRhcHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBIaWdoY2hhcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMykuYWRkb25zLnVwZGF0ZTtcblx0bW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgZGlzcGxheU5hbWU6ICdIaWdoY2hhcnRzJyxcblxuXHQgIHJlbmRlckNoYXJ0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMucHJvcHMuY29uZmlnKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlnIGhhcyB0byBiZSBzcGVjaWZpZWQsIGZvciB0aGUgSGlnaGNoYXJ0IGNvbXBvbmVudCcpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5wcm9wcy5jb25maWc7XG5cdCAgICB2YXIgbm9kZSA9IHRoaXMucmVmcy5jaGFydC5nZXRET01Ob2RlKCk7XG5cblx0ICAgIGlmICghY29uZmlnLmNoYXJ0KSB7XG5cdCAgICAgIGNvbmZpZyA9IHVwZGF0ZShjb25maWcsIHtjaGFydDogeyRzZXQ6IHt9fX0pXG5cdCAgICB9XG5cblx0ICAgIGNvbmZpZyA9IHVwZGF0ZShjb25maWcsIHtjaGFydDoge3JlbmRlclRvOiB7JHNldDogbm9kZX19fSk7XG5cblx0ICAgIHRoaXMuY2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydChjb25maWcpO1xuXHQgIH0sXG5cblx0ICBnZXRDaGFydDogZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAoIXRoaXMuY2hhcnQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoYXJ0KCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCcpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2hhcnQ7XG5cdCAgfSxcblxuXHQgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG5cdCAgfSxcblx0ICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJjaGFydFwiLCByZWY6IFwiY2hhcnRcIn0pXG5cdCAgfVxuXHR9KTtcblxuXHRtb2R1bGUuZXhwb3J0cy5IaWdoY2hhcnRzID0gSGlnaGNoYXJ0cztcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovLFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIEBsaWNlbnNlIEBwcm9kdWN0Lm5hbWVAIEpTIHZAcHJvZHVjdC52ZXJzaW9uQCAoQHByb2R1Y3QuZGF0ZUApXG5cdCAqXG5cdCAqIFN0YW5kYWxvbmUgSGlnaGNoYXJ0cyBGcmFtZXdvcmtcblx0ICpcblx0ICogTGljZW5zZTogTUlUIExpY2Vuc2Vcblx0ICovXG5cblxuXHQvKmdsb2JhbCBIaWdoY2hhcnRzICovXG5cdHZhciBIaWdoY2hhcnRzQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XG5cblx0dmFyIFVOREVGSU5FRCxcblx0XHRkb2MgPSBkb2N1bWVudCxcblx0XHRlbXB0eUFycmF5ID0gW10sXG5cdFx0dGltZXJzID0gW10sXG5cdFx0dGltZXJJZCxcblx0XHRhbmltU2V0dGVycyA9IHt9LFxuXHRcdEZ4O1xuXG5cdE1hdGguZWFzZUluT3V0U2luZSA9IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIC1jIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogdCAvIGQpIC0gMSkgKyBiO1xuXHR9O1xuXG5cblxuXHQvKipcblx0ICogRXh0ZW5kIGdpdmVuIG9iamVjdCB3aXRoIGN1c3RvbSBldmVudHNcblx0ICovXG5cdGZ1bmN0aW9uIGF1Z21lbnQob2JqKSB7XG5cdFx0ZnVuY3Rpb24gcmVtb3ZlT25lRXZlbnQoZWwsIHR5cGUsIGZuKSB7XG5cdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gSUVSZW1vdmVPbmVFdmVudChlbCwgdHlwZSwgZm4pIHtcblx0XHRcdGZuID0gZWwuSENQcm94aWVkTWV0aG9kc1tmbi50b1N0cmluZygpXTtcblx0XHRcdGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlQWxsRXZlbnRzKGVsLCB0eXBlKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gZWwuSENFdmVudHMsXG5cdFx0XHRcdHJlbW92ZSxcblx0XHRcdFx0dHlwZXMsXG5cdFx0XHRcdGxlbixcblx0XHRcdFx0bjtcblxuXHRcdFx0aWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0cmVtb3ZlID0gcmVtb3ZlT25lRXZlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRcdHJlbW92ZSA9IElFUmVtb3ZlT25lRXZlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47IC8vIGJyZWFrIG9uIG5vbi1ET00gZXZlbnRzXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0dHlwZXMgPSB7fTtcblx0XHRcdFx0dHlwZXNbdHlwZV0gPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZXMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobiBpbiB0eXBlcykge1xuXHRcdFx0XHRpZiAoZXZlbnRzW25dKSB7XG5cdFx0XHRcdFx0bGVuID0gZXZlbnRzW25dLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAobGVuLS0pIHtcblx0XHRcdFx0XHRcdHJlbW92ZShlbCwgbiwgZXZlbnRzW25dW2xlbl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghb2JqLkhDRXh0ZW5kZWQpIHtcblx0XHRcdEhpZ2hjaGFydHMuZXh0ZW5kKG9iaiwge1xuXHRcdFx0XHRIQ0V4dGVuZGVkOiB0cnVlLFxuXG5cdFx0XHRcdEhDRXZlbnRzOiB7fSxcblxuXHRcdFx0XHRiaW5kOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcblx0XHRcdFx0XHR2YXIgZWwgPSB0aGlzLFxuXHRcdFx0XHRcdFx0ZXZlbnRzID0gdGhpcy5IQ0V2ZW50cyxcblx0XHRcdFx0XHRcdHdyYXBwZWRGbjtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBET00gZXZlbnRzIGluIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0XHRcdGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuLCBmYWxzZSk7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgb2xkIElFIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkge1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR3cmFwcGVkRm4gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudCB8fCB3aW5kb3c7IC8vICMyODIwXG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoZWwsIGUpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKCFlbC5IQ1Byb3hpZWRNZXRob2RzKSB7XG5cdFx0XHRcdFx0XHRcdGVsLkhDUHJveGllZE1ldGhvZHMgPSB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbGluayB3cmFwcGVkIGZuIHdpdGggb3JpZ2luYWwgZm4sIHNvIHdlIGNhbiBnZXQgdGhpcyBpbiByZW1vdmVFdmVudFxuXHRcdFx0XHRcdFx0ZWwuSENQcm94aWVkTWV0aG9kc1tmbi50b1N0cmluZygpXSA9IHdyYXBwZWRGbjtcblxuXHRcdFx0XHRcdFx0ZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIHdyYXBwZWRGbik7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoZXZlbnRzW25hbWVdID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdGV2ZW50c1tuYW1lXSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV2ZW50c1tuYW1lXS5wdXNoKGZuKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHRcdFx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdFx0XHRpbmRleDtcblxuXHRcdFx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdFx0XHRldmVudHMgPSB0aGlzLkhDRXZlbnRzW25hbWVdIHx8IFtdO1xuXHRcdFx0XHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gSGlnaGNoYXJ0c0FkYXB0ZXIuaW5BcnJheShmbiwgZXZlbnRzKTtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLkhDRXZlbnRzW25hbWVdID0gZXZlbnRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRyZW1vdmVPbmVFdmVudCh0aGlzLCBuYW1lLCBmbik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5hdHRhY2hFdmVudCkge1xuXHRcdFx0XHRcdFx0XHRcdElFUmVtb3ZlT25lRXZlbnQodGhpcywgbmFtZSwgZm4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVBbGxFdmVudHModGhpcywgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuSENFdmVudHNbbmFtZV0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVtb3ZlQWxsRXZlbnRzKHRoaXMpO1xuXHRcdFx0XHRcdFx0dGhpcy5IQ0V2ZW50cyA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuXHRcdFx0XHRcdHZhciBldmVudHMgPSB0aGlzLkhDRXZlbnRzW25hbWVdIHx8IFtdLFxuXHRcdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0XHRcdGxlbiA9IGV2ZW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQsXG5cdFx0XHRcdFx0XHRmbjtcblxuXHRcdFx0XHRcdC8vIEF0dGFjaCBhIHNpbXBsZSBwcmV2ZW50RGVmYXVsdCBmdW5jdGlvbiB0byBza2lwIGRlZmF1bHQgaGFuZGxlciBpZiBjYWxsZWRcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGFyZ3MuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGZuID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRcdFx0XHQvLyBhcmdzIGlzIG5ldmVyIG51bGwgaGVyZVxuXHRcdFx0XHRcdFx0aWYgKGFyZ3Muc3RvcHBlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGFyZ3MucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblx0XHRcdFx0XHRcdGFyZ3MudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgdHlwZSBpcyBub3Qgc2V0LCB3ZSdyZSBydW5uaW5nIGEgY3VzdG9tIGV2ZW50ICgjMjI5NykuIElmIGl0IGlzIHNldCxcblx0XHRcdFx0XHRcdC8vIHdlJ3JlIHJ1bm5pbmcgYSBicm93c2VyIGV2ZW50LCBhbmQgc2V0dGluZyBpdCB3aWxsIGNhdXNlIGVuIGVycm9yIGluXG5cdFx0XHRcdFx0XHQvLyBJRTggKCMyNDY1KS5cblx0XHRcdFx0XHRcdGlmICghYXJncy50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdGFyZ3MudHlwZSA9IG5hbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaGFuZGxlciByZXR1cm4gZmFsc2UsIHByZXZlbnQgdGhlIGRlZmF1bHQgaGFuZGxlciBmcm9tIGV4ZWN1dGluZ1xuXHRcdFx0XHRcdFx0aWYgKGZuLmNhbGwodGhpcywgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdGFyZ3MucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBhZGFwdGVyLiBUaGlzIGlzIHJ1biBvbmNlIGFzIEhpZ2hjaGFydHMgaXMgZmlyc3QgcnVuLlxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChwYXRoQW5pbSkge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIENvbXBhdGliaWxpdHkgc2VjdGlvbiB0byBhZGQgc3VwcG9ydCBmb3IgbGVnYWN5IElFLiBUaGlzIGNhbiBiZSByZW1vdmVkIGlmIG9sZCBJRSBcblx0XHRcdCAqIHN1cHBvcnQgaXMgbm90IG5lZWRlZC5cblx0XHRcdCAqL1xuXHRcdFx0aWYgKCFkb2MuZGVmYXVsdFZpZXcpIHtcblx0XHRcdFx0dGhpcy5fZ2V0U3R5bGUgPSBmdW5jdGlvbiAoZWwsIHByb3ApIHtcblx0XHRcdFx0XHR2YXIgdmFsO1xuXHRcdFx0XHRcdGlmIChlbC5zdHlsZVtwcm9wXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsLnN0eWxlW3Byb3BdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocHJvcCA9PT0gJ29wYWNpdHknKSB7XG5cdFx0XHRcdFx0XHRcdHByb3AgPSAnZmlsdGVyJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqL1xuXHRcdFx0XHRcdFx0dmFsID0gZWwuY3VycmVudFN0eWxlW3Byb3AucmVwbGFjZSgvXFwtKFxcdykvZywgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIudG9VcHBlckNhc2UoKTsgfSldO1xuXHRcdFx0XHRcdFx0aWYgKHByb3AgPT09ICdmaWx0ZXInKSB7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHRcdC9hbHBoYVxcKG9wYWNpdHk9KFswLTldKylcXCkvLCBcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAoYSwgYikgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBiIC8gMTAwOyBcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsID09PSAnJyA/IDEgOiB2YWw7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5hZGFwdGVyUnVuID0gZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0XHRcdHZhciBhbGlhcyA9IHsgd2lkdGg6ICdjbGllbnRXaWR0aCcsIGhlaWdodDogJ2NsaWVudEhlaWdodCcgfVttZXRob2RdO1xuXG5cdFx0XHRcdFx0aWYgKGFsaWFzKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnN0eWxlLnpvb20gPSAxO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1bYWxpYXNdIC0gMiAqIHBhcnNlSW50KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbGVtLCAncGFkZGluZycpLCAxMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG5cdFx0XHRcdHRoaXMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIGxlZ2FjeVxuXHRcdFx0XHRcdHZhciBpID0gMCwgXG5cdFx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0XHRcdFx0dGhpcy5pbkFycmF5ID0gZnVuY3Rpb24gKGl0ZW0sIGFycikge1xuXHRcdFx0XHRcdHZhciBsZW4sIFxuXHRcdFx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdFx0XHRpZiAoYXJyKSB7XG5cdFx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdFx0XHRcdHRoaXMuZ3JlcCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICghIWNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKSkge1xuXHRcdFx0XHRcdFx0XHRyZXQucHVzaChlbGVtZW50c1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8tLS0gRW5kIGNvbXBhdGliaWxpdHkgc2VjdGlvbiAtLS1cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0YXJ0IG9mIGFuaW1hdGlvbiBzcGVjaWZpYyBjb2RlXG5cdFx0XHQgKi9cblx0XHRcdEZ4ID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIHByb3ApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHRcdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHRcdH07XG5cdFx0XHRGeC5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgc3R5bGVzLFxuXHRcdFx0XHRcdFx0cGF0aHMgPSB0aGlzLnBhdGhzLFxuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdFx0XHRcdGVsZW1lbGVtID0gZWxlbS5lbGVtZW50OyAvLyBpZiBkZXN0cm95ZWQsIGl0IGlzIG51bGxcblxuXHRcdFx0XHRcdC8vIEFuaW1hdGlvbiBzZXR0ZXIgZGVmaW5lZCBmcm9tIG91dHNpZGVcblx0XHRcdFx0XHRpZiAoYW5pbVNldHRlcnNbdGhpcy5wcm9wXSkge1xuXHRcdFx0XHRcdFx0YW5pbVNldHRlcnNbdGhpcy5wcm9wXSh0aGlzKTtcblxuXHRcdFx0XHRcdC8vIEFuaW1hdGluZyBhIHBhdGggZGVmaW5pdGlvbiBvbiBTVkdFbGVtZW50XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwYXRocyAmJiBlbGVtZWxlbSkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRyKCdkJywgcGF0aEFuaW0uc3RlcChwYXRoc1swXSwgcGF0aHNbMV0sIHRoaXMubm93LCB0aGlzLnRvRCkpO1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXIgYW5pbWF0aW9ucyBvbiBTVkdFbGVtZW50XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlbGVtLmF0dHIpIHtcblx0XHRcdFx0XHRcdGlmIChlbGVtZWxlbSkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLmF0dHIodGhpcy5wcm9wLCB0aGlzLm5vdyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBIVE1MIHN0eWxlc1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0XHRcdHN0eWxlc1t0aGlzLnByb3BdID0gdGhpcy5ub3cgKyB0aGlzLnVuaXQ7XG5cdFx0XHRcdFx0XHRIaWdoY2hhcnRzLmNzcyhlbGVtLCBzdHlsZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0ZXApIHtcblx0XHRcdFx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGN1c3RvbTogZnVuY3Rpb24gKGZyb20sIHRvLCB1bml0KSB7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdFx0dCA9IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzZWxmLnN0ZXAoZ290b0VuZCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aTtcblxuXHRcdFx0XHRcdHRoaXMuc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5zdGFydCA9IGZyb207XG5cdFx0XHRcdFx0dGhpcy5lbmQgPSB0bztcblx0XHRcdFx0XHR0aGlzLnVuaXQgPSB1bml0O1xuXHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydDtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAwO1xuXG5cdFx0XHRcdFx0dC5lbGVtID0gdGhpcy5lbGVtO1xuXG5cdFx0XHRcdFx0aWYgKHQoKSAmJiB0aW1lcnMucHVzaCh0KSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGltZXJJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXRpbWVyc1tpXSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCF0aW1lcnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgMTMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSArbmV3IERhdGUoKSxcblx0XHRcdFx0XHRcdHJldCxcblx0XHRcdFx0XHRcdGRvbmUsXG5cdFx0XHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGVsZW0uc3RvcEFuaW1hdGlvbiB8fCAoZWxlbS5hdHRyICYmICFlbGVtLmVsZW1lbnQpKSB7IC8vICMyNjE2LCBlbGVtZW50IGluY2x1ZGluZyBmbGFnIGlzIGRlc3Ryb3llZFxuXHRcdFx0XHRcdFx0cmV0ID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGdvdG9FbmQgfHwgdCA+PSBvcHRpb25zLmR1cmF0aW9uICsgdGhpcy5zdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5lbmQ7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAxO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmN1ckFuaW1bdGhpcy5wcm9wXSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Zm9yIChpIGluIG9wdGlvbnMuY3VyQW5pbSkge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5jdXJBbmltW2ldICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZS5jYWxsKGVsZW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgbiA9IHQgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSBuIC8gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdHRoaXMucG9zID0gb3B0aW9ucy5lYXNpbmcobiwgMCwgMSwgb3B0aW9ucy5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aGlzLm5vdyA9IHRoaXMuc3RhcnQgKyAoKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0aGlzLnBvcyk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0cmV0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgYWRhcHRlciBhbmltYXRlIG1ldGhvZFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIHByb3AsIG9wdCkge1xuXHRcdFx0XHR2YXIgc3RhcnQsXG5cdFx0XHRcdFx0dW5pdCA9ICcnLFxuXHRcdFx0XHRcdGVuZCxcblx0XHRcdFx0XHRmeCxcblx0XHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRcdG5hbWU7XG5cblx0XHRcdFx0ZWwuc3RvcEFuaW1hdGlvbiA9IGZhbHNlOyAvLyByZWFkeSBmb3IgbmV3XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBvcHQgIT09ICdvYmplY3QnIHx8IG9wdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0b3B0ID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGFyZ3NbMl0sXG5cdFx0XHRcdFx0XHRlYXNpbmc6IGFyZ3NbM10sXG5cdFx0XHRcdFx0XHRjb21wbGV0ZTogYXJnc1s0XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiBvcHQuZHVyYXRpb24gIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0b3B0LmR1cmF0aW9uID0gNDAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdC5lYXNpbmcgPSBNYXRoW29wdC5lYXNpbmddIHx8IE1hdGguZWFzZUluT3V0U2luZTtcblx0XHRcdFx0b3B0LmN1ckFuaW0gPSBIaWdoY2hhcnRzLmV4dGVuZCh7fSwgcHJvcCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gcHJvcCkge1xuXHRcdFx0XHRcdGZ4ID0gbmV3IEZ4KGVsLCBvcHQsIG5hbWUpO1xuXHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkJykge1xuXHRcdFx0XHRcdFx0ZngucGF0aHMgPSBwYXRoQW5pbS5pbml0KFxuXHRcdFx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRcdFx0ZWwuZCxcblx0XHRcdFx0XHRcdFx0cHJvcC5kXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0ZngudG9EID0gcHJvcC5kO1xuXHRcdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0ZW5kID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsLmF0dHIpIHtcblx0XHRcdFx0XHRcdHN0YXJ0ID0gZWwuYXR0cihuYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbCwgbmFtZSkpIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAobmFtZSAhPT0gJ29wYWNpdHknKSB7XG5cdFx0XHRcdFx0XHRcdHVuaXQgPSAncHgnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0XHRpZiAoIWVuZCkge1xuXHRcdFx0XHRcdFx0ZW5kID0gcHJvcFtuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnguY3VzdG9tKHN0YXJ0LCBlbmQsIHVuaXQpO1xuXHRcdFx0XHR9XHRcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIG1ldGhvZCB0byByZXR1cm4gQ1NTIHZhbHVlIGZvciBnaXZlbiBlbGVtZW50IGFuZCBwcm9wZXJ0eVxuXHRcdCAqL1xuXHRcdF9nZXRTdHlsZTogZnVuY3Rpb24gKGVsLCBwcm9wKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIHVuZGVmaW5lZCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGFuaW1hdGlvbiBzZXR0ZXIgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHlcblx0XHQgKi9cblx0XHRhZGRBbmltU2V0dGVyOiBmdW5jdGlvbiAocHJvcCwgZm4pIHtcblx0XHRcdGFuaW1TZXR0ZXJzW3Byb3BdID0gZm47XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERvd25sb2FkcyBhIHNjcmlwdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayB3aGVuIGRvbmUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmlwdExvY2F0aW9uXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKi9cblx0XHRnZXRTY3JpcHQ6IGZ1bmN0aW9uIChzY3JpcHRMb2NhdGlvbiwgY2FsbGJhY2spIHtcblx0XHRcdC8vIFdlIGNhbm5vdCBhc3N1bWUgdGhhdCBBc3NldHMgY2xhc3MgZnJvbSBtb290b29scy1tb3JlIGlzIGF2YWlsYWJsZSBzbyBpbnN0ZWFkIGluc2VydCBhIHNjcmlwdCB0YWcgdG8gZG93bmxvYWQgc2NyaXB0LlxuXHRcdFx0dmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcblx0XHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuXHRcdFx0c2NyaXB0LnNyYyA9IHNjcmlwdExvY2F0aW9uO1xuXHRcdFx0c2NyaXB0Lm9ubG9hZCA9IGNhbGxiYWNrO1xuXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgaW5kZXggb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgbm90IGZvdW5kXG5cdFx0ICovXG5cdFx0aW5BcnJheTogZnVuY3Rpb24gKGl0ZW0sIGFycikge1xuXHRcdFx0cmV0dXJuIGFyci5pbmRleE9mID8gYXJyLmluZGV4T2YoaXRlbSkgOiBlbXB0eUFycmF5LmluZGV4T2YuY2FsbChhcnIsIGl0ZW0pO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEEgZGlyZWN0IGxpbmsgdG8gYWRhcHRlciBtZXRob2RzXG5cdFx0ICovXG5cdFx0YWRhcHRlclJ1bjogZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbGVtLCBtZXRob2QpLCAxMCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdGdyZXA6IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRcdHJldHVybiBlbXB0eUFycmF5LmZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1hcCBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdG1hcDogZnVuY3Rpb24gKGFyciwgZm4pIHtcblx0XHRcdHZhciByZXN1bHRzID0gW10sIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSBmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBlbGVtZW50J3Mgb2Zmc2V0IHBvc2l0aW9uLCBjb3JyZWN0ZWQgYnkgb3ZlcmZsb3c6YXV0by4gTG9vc2VseSBiYXNlZCBvbiBqUXVlcnkncyBvZmZzZXQgbWV0aG9kLlxuXHRcdCAqL1xuXHRcdG9mZnNldDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHR2YXIgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0Ym94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogYm94LnRvcCAgKyAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wKSAgLSAoZG9jRWxlbS5jbGllbnRUb3AgIHx8IDApLFxuXHRcdFx0XHRsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0KSAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMClcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdCAqL1xuXHRcdGFkZEV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuKSB7XG5cdFx0XHRhdWdtZW50KGVsKS5iaW5kKHR5cGUsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGV2ZW50IGFkZGVkIHdpdGggYWRkRXZlbnRcblx0XHQgKi9cblx0XHRyZW1vdmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBmbikge1xuXHRcdFx0YXVnbWVudChlbCkudW5iaW5kKHR5cGUsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmlyZSBhbiBldmVudCBvbiBhIGN1c3RvbSBvYmplY3Rcblx0XHQgKi9cblx0XHRmaXJlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZXZlbnRBcmd1bWVudHMsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdFx0dmFyIGU7XG5cblx0XHRcdGlmIChkb2MuY3JlYXRlRXZlbnQgJiYgKGVsLmRpc3BhdGNoRXZlbnQgfHwgZWwuZmlyZUV2ZW50KSkge1xuXHRcdFx0XHRlID0gZG9jLmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcblx0XHRcdFx0ZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdGUudGFyZ2V0ID0gZWw7XG5cblx0XHRcdFx0SGlnaGNoYXJ0cy5leHRlbmQoZSwgZXZlbnRBcmd1bWVudHMpO1xuXG5cdFx0XHRcdGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7XG5cdFx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbC5maXJlRXZlbnQodHlwZSwgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmIChlbC5IQ0V4dGVuZGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdGV2ZW50QXJndW1lbnRzID0gZXZlbnRBcmd1bWVudHMgfHwge307XG5cdFx0XHRcdGVsLnRyaWdnZXIodHlwZSwgZXZlbnRBcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnRBcmd1bWVudHMgJiYgZXZlbnRBcmd1bWVudHMuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRkZWZhdWx0RnVuY3Rpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHRcdGRlZmF1bHRGdW5jdGlvbihldmVudEFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHdhc2hNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU3RvcCBydW5uaW5nIGFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdHN0b3A6IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0ZWwuc3RvcEFuaW1hdGlvbiA9IHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgZm9yIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LiBQYXJhbWV0ZXJzIGFyZSByZXZlcnNlZCBjb21wYXJlZCB0byBqUXVlcnkuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRlYWNoOiBmdW5jdGlvbiAoYXJyLCBmbikgeyAvLyBtb2Rlcm4gYnJvd3NlcnNcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyciwgZm4pO1xuXHRcdH1cblx0fTtcblx0fSgpKTtcblxuXG5cdC8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzQWRhcHRlclxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuXHQvLyBAY29tcGlsYXRpb25fbGV2ZWwgU0lNUExFX09QVElNSVpBVElPTlNcblxuXHQvKipcblx0ICogQGxpY2Vuc2UgSGlnaGNoYXJ0cyBKUyB2NC4xLjctbW9kaWZpZWQgKClcblx0ICpcblx0ICogKGMpIDIwMDktMjAxNCBUb3JzdGVpbiBIb25zaVxuXHQgKlxuXHQgKiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuXHQgKi9cblxuXHQvLyBKU0xpbnQgb3B0aW9uczpcblx0LypnbG9iYWwgSGlnaGNoYXJ0cywgSGlnaGNoYXJ0c0FkYXB0ZXIsIGRvY3VtZW50LCB3aW5kb3csIG5hdmlnYXRvciwgc2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWwsIGNsZWFyVGltZW91dCwgc2V0VGltZW91dCwgbG9jYXRpb24sIGpRdWVyeSwgJCwgY29uc29sZSwgZWFjaCwgZ3JlcCAqL1xuXHQvKmpzbGludCBhc3M6IHRydWUsIHNsb3BweTogdHJ1ZSwgZm9yaW46IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBub21lbjogdHJ1ZSwgdmFyczogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBuZXdjYXA6IHRydWUsIGJyb3dzZXI6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCB3aGl0ZTogdHJ1ZSAqL1xuXHQoZnVuY3Rpb24gKCkge1xuXHQvLyBlbmNhcHN1bGF0ZWQgdmFyaWFibGVzXG5cdHZhciBVTkRFRklORUQsXG5cdFx0ZG9jID0gZG9jdW1lbnQsXG5cdFx0d2luID0gd2luZG93LFxuXHRcdG1hdGggPSBNYXRoLFxuXHRcdG1hdGhSb3VuZCA9IG1hdGgucm91bmQsXG5cdFx0bWF0aEZsb29yID0gbWF0aC5mbG9vcixcblx0XHRtYXRoQ2VpbCA9IG1hdGguY2VpbCxcblx0XHRtYXRoTWF4ID0gbWF0aC5tYXgsXG5cdFx0bWF0aE1pbiA9IG1hdGgubWluLFxuXHRcdG1hdGhBYnMgPSBtYXRoLmFicyxcblx0XHRtYXRoQ29zID0gbWF0aC5jb3MsXG5cdFx0bWF0aFNpbiA9IG1hdGguc2luLFxuXHRcdG1hdGhQSSA9IG1hdGguUEksXG5cdFx0ZGVnMnJhZCA9IG1hdGhQSSAqIDIgLyAzNjAsXG5cblxuXHRcdC8vIHNvbWUgdmFyaWFibGVzXG5cdFx0dXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0XHRpc09wZXJhID0gd2luLm9wZXJhLFxuXHRcdGlzSUUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWlzT3BlcmEsXG5cdFx0ZG9jTW9kZTggPSBkb2MuZG9jdW1lbnRNb2RlID09PSA4LFxuXHRcdGlzV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCksXG5cdFx0aXNGaXJlZm94ID0gL0ZpcmVmb3gvLnRlc3QodXNlckFnZW50KSxcblx0XHRpc1RvdWNoRGV2aWNlID0gLyhNb2JpbGV8QW5kcm9pZHxXaW5kb3dzIFBob25lKS8udGVzdCh1c2VyQWdlbnQpLFxuXHRcdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0aGFzU1ZHID0gISFkb2MuY3JlYXRlRWxlbWVudE5TICYmICEhZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdzdmcnKS5jcmVhdGVTVkdSZWN0LFxuXHRcdGhhc0JpZGlCdWcgPSBpc0ZpcmVmb3ggJiYgcGFyc2VJbnQodXNlckFnZW50LnNwbGl0KCdGaXJlZm94LycpWzFdLCAxMCkgPCA0LCAvLyBpc3N1ZSAjMzhcblx0XHR1c2VDYW5WRyA9ICFoYXNTVkcgJiYgIWlzSUUgJiYgISFkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblx0XHRSZW5kZXJlcixcblx0XHRoYXNUb3VjaCxcblx0XHRzeW1ib2xTaXplcyA9IHt9LFxuXHRcdGlkQ291bnRlciA9IDAsXG5cdFx0Z2FyYmFnZUJpbixcblx0XHRkZWZhdWx0T3B0aW9ucyxcblx0XHRkYXRlRm9ybWF0LCAvLyBmdW5jdGlvblxuXHRcdGdsb2JhbEFuaW1hdGlvbixcblx0XHRwYXRoQW5pbSxcblx0XHR0aW1lVW5pdHMsXG5cdFx0bm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFVOREVGSU5FRDsgfSxcblx0XHRjaGFydHMgPSBbXSxcblx0XHRjaGFydENvdW50ID0gMCxcblx0XHRQUk9EVUNUID0gJ0hpZ2hjaGFydHMnLFxuXHRcdFZFUlNJT04gPSAnNC4xLjctbW9kaWZpZWQnLFxuXG5cdFx0Ly8gc29tZSBjb25zdGFudHMgZm9yIGZyZXF1ZW50bHkgdXNlZCBzdHJpbmdzXG5cdFx0RElWID0gJ2RpdicsXG5cdFx0QUJTT0xVVEUgPSAnYWJzb2x1dGUnLFxuXHRcdFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcblx0XHRISURERU4gPSAnaGlkZGVuJyxcblx0XHRQUkVGSVggPSAnaGlnaGNoYXJ0cy0nLFxuXHRcdFZJU0lCTEUgPSAndmlzaWJsZScsXG5cdFx0UFggPSAncHgnLFxuXHRcdE5PTkUgPSAnbm9uZScsXG5cdFx0TSA9ICdNJyxcblx0XHRMID0gJ0wnLFxuXHRcdG51bVJlZ2V4ID0gL15bMC05XSskLyxcblx0XHROT1JNQUxfU1RBVEUgPSAnJyxcblx0XHRIT1ZFUl9TVEFURSA9ICdob3ZlcicsXG5cdFx0U0VMRUNUX1NUQVRFID0gJ3NlbGVjdCcsXG5cdFx0bWFyZ2luTmFtZXMgPSBbJ3Bsb3RUb3AnLCAnbWFyZ2luUmlnaHQnLCAnbWFyZ2luQm90dG9tJywgJ3Bsb3RMZWZ0J10sXG5cdFx0XG5cdFx0Ly8gT2JqZWN0IGZvciBleHRlbmRpbmcgQXhpc1xuXHRcdEF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbixcblxuXHRcdC8vIGNvbnN0YW50cyBmb3IgYXR0cmlidXRlc1xuXHRcdFNUUk9LRV9XSURUSCA9ICdzdHJva2Utd2lkdGgnLFxuXG5cdFx0Ly8gdGltZSBtZXRob2RzLCBjaGFuZ2VkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IFVUQyBpcyB1c2VkXG5cdFx0RGF0ZSwgIC8vIEFsbG93IHVzaW5nIGEgZGlmZmVyZW50IERhdGUgY2xhc3Ncblx0XHRtYWtlVGltZSxcblx0XHR0aW1lem9uZU9mZnNldCxcblx0XHRnZXRUaW1lem9uZU9mZnNldCxcblx0XHRnZXRNaW51dGVzLFxuXHRcdGdldEhvdXJzLFxuXHRcdGdldERheSxcblx0XHRnZXREYXRlLFxuXHRcdGdldE1vbnRoLFxuXHRcdGdldEZ1bGxZZWFyLFxuXHRcdHNldE1pbGxpc2Vjb25kcyxcblx0XHRzZXRTZWNvbmRzLFxuXHRcdHNldE1pbnV0ZXMsXG5cdFx0c2V0SG91cnMsXG5cdFx0c2V0RGF0ZSxcblx0XHRzZXRNb250aCxcblx0XHRzZXRGdWxsWWVhcixcblxuXG5cdFx0Ly8gbG9va3VwIG92ZXIgdGhlIHR5cGVzIGFuZCB0aGUgYXNzb2NpYXRlZCBjbGFzc2VzXG5cdFx0c2VyaWVzVHlwZXMgPSB7fSxcblx0XHRIaWdoY2hhcnRzO1xuXG5cdC8vIFRoZSBIaWdoY2hhcnRzIG5hbWVzcGFjZVxuXHRIaWdoY2hhcnRzID0gd2luLkhpZ2hjaGFydHMgPSB3aW4uSGlnaGNoYXJ0cyA/IGVycm9yKDE2LCB0cnVlKSA6IHt9O1xuXG5cdEhpZ2hjaGFydHMuc2VyaWVzVHlwZXMgPSBzZXJpZXNUeXBlcztcblxuXHQvKipcblx0ICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBtZW1iZXJzIG9mIGFub3RoZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGFkZCB0byB0aGUgZmlyc3Qgb25lXG5cdCAqL1xuXHR2YXIgZXh0ZW5kID0gSGlnaGNoYXJ0cy5leHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdHZhciBuO1xuXHRcdGlmICghYSkge1xuXHRcdFx0YSA9IHt9O1xuXHRcdH1cblx0XHRmb3IgKG4gaW4gYikge1xuXHRcdFx0YVtuXSA9IGJbbl07XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcdFxuXHQvKipcblx0ICogRGVlcCBtZXJnZSB0d28gb3IgbW9yZSBvYmplY3RzIGFuZCByZXR1cm4gYSB0aGlyZCBvYmplY3QuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuXHQgKiB0cnVlLCB0aGUgY29udGVudHMgb2YgdGhlIHNlY29uZCBvYmplY3QgaXMgY29waWVkIGludG8gdGhlIGZpcnN0IG9iamVjdC5cblx0ICogUHJldmlvdXNseSB0aGlzIGZ1bmN0aW9uIHJlZGlyZWN0ZWQgdG8galF1ZXJ5LmV4dGVuZCh0cnVlKSwgYnV0IHRoaXMgaGFkIHR3byBsaW1pdGF0aW9ucy5cblx0ICogRmlyc3QsIGl0IGRlZXAgbWVyZ2VkIGFycmF5cywgd2hpY2ggbGVhZCB0byB3b3JrYXJvdW5kcyBpbiBIaWdoY2hhcnRzLiBTZWNvbmQsXG5cdCAqIGl0IGNvcGllZCBwcm9wZXJ0aWVzIGZyb20gZXh0ZW5kZWQgcHJvdG90eXBlcy4gXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZSgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRsZW4sXG5cdFx0XHRyZXQgPSB7fSxcblx0XHRcdGRvQ29weSA9IGZ1bmN0aW9uIChjb3B5LCBvcmlnaW5hbCkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleTtcblxuXHRcdFx0XHQvLyBBbiBvYmplY3QgaXMgcmVwbGFjaW5nIGEgcHJpbWl0aXZlXG5cdFx0XHRcdGlmICh0eXBlb2YgY29weSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGtleSBpbiBvcmlnaW5hbCkge1xuXHRcdFx0XHRcdGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG9yaWdpbmFsW2tleV07XG5cblx0XHRcdFx0XHRcdC8vIENvcHkgdGhlIGNvbnRlbnRzIG9mIG9iamVjdHMsIGJ1dCBub3QgYXJyYXlzIG9yIERPTSBub2Rlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0XHRcdFx0XHRcdGtleSAhPT0gJ3JlbmRlclRvJyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlba2V5XSA9IGRvQ29weShjb3B5W2tleV0gfHwge30sIHZhbHVlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFByaW1pdGl2ZXMgYW5kIGFycmF5cyBhcmUgY29waWVkIG92ZXIgZGlyZWN0bHlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlba2V5XSA9IG9yaWdpbmFsW2tleV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb3B5O1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIHRydWUsIGNvcHkgaW50byB0aGUgZXhpc3Rpbmcgb2JqZWN0LiBVc2VkIGluIHNldE9wdGlvbnMuXG5cdFx0aWYgKGFyZ3NbMF0gPT09IHRydWUpIHtcblx0XHRcdHJldCA9IGFyZ3NbMV07XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMik7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIGVhY2ggYXJndW1lbnQsIGV4dGVuZCB0aGUgcmV0dXJuXG5cdFx0bGVuID0gYXJncy5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRyZXQgPSBkb0NvcHkocmV0LCBhcmdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IGZvciBwYXJzZUludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWFnIE1hZ25pdHVkZVxuXHQgKi9cblx0ZnVuY3Rpb24gcEludChzLCBtYWcpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQocywgbWFnIHx8IDEwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBmb3Igc3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N0cmluZyhzKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBmb3Igb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuXHRcdHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgZm9yIGFycmF5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICovXG5cdGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGZvciBudW1iZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IG5cblx0ICovXG5cdGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcblx0XHRyZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nMmxpbihudW0pIHtcblx0XHRyZXR1cm4gbWF0aC5sb2cobnVtKSAvIG1hdGguTE4xMDtcblx0fVxuXHRmdW5jdGlvbiBsaW4ybG9nKG51bSkge1xuXHRcdHJldHVybiBtYXRoLnBvdygxMCwgbnVtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgbGFzdCBvY2N1cmVuY2Ugb2YgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHQgKiBAcGFyYW0ge01peGVkfSBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBlcmFzZShhcnIsIGl0ZW0pIHtcblx0XHR2YXIgaSA9IGFyci5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKGFycltpXSA9PT0gaXRlbSkge1xuXHRcdFx0XHRhcnIuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9yZXR1cm4gYXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZC4gTGlrZSBNb29Ub29scycgJC5kZWZpbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZpbmVkKG9iaikge1xuXHRcdHJldHVybiBvYmogIT09IFVOREVGSU5FRCAmJiBvYmogIT09IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IG9yIGdldCBhbiBhdHRyaWJ1dGUgb3IgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMuIENhbid0IHVzZSBqUXVlcnkgYXR0ciBiZWNhdXNlXG5cdCAqIGl0IGF0dGVtcHRzIHRvIHNldCBleHBhbmRvIHByb3BlcnRpZXMgb24gdGhlIFNWRyBlbGVtZW50LCB3aGljaCBpcyBub3QgYWxsb3dlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhlIGF0dHJpYnV0ZShzKVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3AgVGhlIHByb3BlcnR5IG9yIGFuIGFiamVjdCBvZiBrZXktdmFsdWUgcGFpcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBpZiBhIHNpbmdsZSBwcm9wZXJ0eSBpcyBzZXRcblx0ICovXG5cdGZ1bmN0aW9uIGF0dHIoZWxlbSwgcHJvcCwgdmFsdWUpIHtcblx0XHR2YXIga2V5LFxuXHRcdFx0cmV0O1xuXG5cdFx0Ly8gaWYgdGhlIHByb3AgaXMgYSBzdHJpbmdcblx0XHRpZiAoaXNTdHJpbmcocHJvcCkpIHtcblx0XHRcdC8vIHNldCB0aGUgdmFsdWVcblx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSkge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG5cblx0XHRcdC8vIGdldCB0aGUgdmFsdWVcblx0XHRcdH0gZWxzZSBpZiAoZWxlbSAmJiBlbGVtLmdldEF0dHJpYnV0ZSkgeyAvLyBlbGVtIG5vdCBkZWZpbmVkIHdoZW4gcHJpbnRpbmcgcGllIGRlbW8uLi5cblx0XHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9XG5cblx0XHQvLyBlbHNlIGlmIHByb3AgaXMgZGVmaW5lZCwgaXQgaXMgYSBoYXNoIG9mIGtleS92YWx1ZSBwYWlyc1xuXHRcdH0gZWxzZSBpZiAoZGVmaW5lZChwcm9wKSAmJiBpc09iamVjdChwcm9wKSkge1xuXHRcdFx0Zm9yIChrZXkgaW4gcHJvcCkge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShrZXksIHByb3Bba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cblx0LyoqXG5cdCAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYW4gYXJyYXksIGFuZCBpZiBub3QsIG1ha2UgaXQgaW50byBhbiBhcnJheS4gTGlrZVxuXHQgKiBNb29Ub29scycgJC5zcGxhdC5cblx0ICovXG5cdGZ1bmN0aW9uIHNwbGF0KG9iaikge1xuXHRcdHJldHVybiBpc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgdGhhdCBpcyBkZWZpbmVkLiBMaWtlIE1vb1Rvb2xzJyAkLnBpY2suXG5cdCAqL1xuXHR2YXIgcGljayA9IEhpZ2hjaGFydHMucGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGksXG5cdFx0XHRhcmcsXG5cdFx0XHRsZW5ndGggPSBhcmdzLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGFyZyA9IGFyZ3NbaV07XG5cdFx0XHRpZiAoYXJnICE9PSBVTkRFRklORUQgJiYgYXJnICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBhcmc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgQ1NTIG9uIGEgZ2l2ZW4gZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBTdHlsZSBvYmplY3Qgd2l0aCBjYW1lbCBjYXNlIHByb3BlcnR5IG5hbWVzXG5cdCAqL1xuXHRmdW5jdGlvbiBjc3MoZWwsIHN0eWxlcykge1xuXHRcdGlmIChpc0lFICYmICFoYXNTVkcpIHsgLy8gIzI2ODZcblx0XHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLm9wYWNpdHkgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRzdHlsZXMuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9JyArIChzdHlsZXMub3BhY2l0eSAqIDEwMCkgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4dGVuZChlbC5zdHlsZSwgc3R5bGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlcyBhbmQgc3R5bGVzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnNcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBub3BhZFxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJpYnMsIHN0eWxlcywgcGFyZW50LCBub3BhZCkge1xuXHRcdHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG5cdFx0aWYgKGF0dHJpYnMpIHtcblx0XHRcdGV4dGVuZChlbCwgYXR0cmlicyk7XG5cdFx0fVxuXHRcdGlmIChub3BhZCkge1xuXHRcdFx0Y3NzKGVsLCB7cGFkZGluZzogMCwgYm9yZGVyOiBOT05FLCBtYXJnaW46IDB9KTtcblx0XHR9XG5cdFx0aWYgKHN0eWxlcykge1xuXHRcdFx0Y3NzKGVsLCBzdHlsZXMpO1xuXHRcdH1cblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gZWw7XG5cdH1cblxuXHQvKipcblx0ICogRXh0ZW5kIGEgcHJvdG90eXBlZCBjbGFzcyBieSBuZXcgbWVtYmVyc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtZW1iZXJzXG5cdCAqL1xuXHRmdW5jdGlvbiBleHRlbmRDbGFzcyhwYXJlbnQsIG1lbWJlcnMpIHtcblx0XHR2YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gVU5ERUZJTkVEOyB9O1xuXHRcdG9iamVjdC5wcm90b3R5cGUgPSBuZXcgcGFyZW50KCk7XG5cdFx0ZXh0ZW5kKG9iamVjdC5wcm90b3R5cGUsIG1lbWJlcnMpO1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHQvKipcblx0ICogUGFkIGEgc3RyaW5nIHRvIGEgZ2l2ZW4gbGVuZ3RoIGJ5IGFkZGluZyAwIHRvIHRoZSBiZWdpbm5pbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG5cdCAqL1xuXHRmdW5jdGlvbiBwYWQobnVtYmVyLCBsZW5ndGgpIHtcblx0XHQvLyBDcmVhdGUgYW4gYXJyYXkgb2YgdGhlIHJlbWFpbmluZyBsZW5ndGggKzEgYW5kIGpvaW4gaXQgd2l0aCAwJ3Ncblx0XHRyZXR1cm4gbmV3IEFycmF5KChsZW5ndGggfHwgMikgKyAxIC0gU3RyaW5nKG51bWJlcikubGVuZ3RoKS5qb2luKDApICsgbnVtYmVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIGxlbmd0aCBiYXNlZCBvbiBlaXRoZXIgdGhlIGludGVnZXIgdmFsdWUsIG9yIGEgcGVyY2VudGFnZSBvZiBhIGJhc2UuXG5cdCAqL1xuXHRmdW5jdGlvbiByZWxhdGl2ZUxlbmd0aCAodmFsdWUsIGJhc2UpIHtcblx0XHRyZXR1cm4gKC8lJC8pLnRlc3QodmFsdWUpID8gYmFzZSAqIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogV3JhcCBhIG1ldGhvZCB3aXRoIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHksIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIGNvbnRleHQgb2JqZWN0IHRoYXQgdGhlIG1ldGhvZCBiZWxvbmdzIHRvIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gZXh0ZW5kXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgQSB3cmFwcGVyIGZ1bmN0aW9uIGNhbGxiYWNrLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuXHQgKiBhcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIGV4Y2VwdCB0aGF0IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyB1bnNoaWZ0ZWQgYW5kIHBhc3NlZCBhcyB0aGUgZmlyc3QgXG5cdCAqIGFyZ3VtZW50LiBcblx0ICovXG5cdHZhciB3cmFwID0gSGlnaGNoYXJ0cy53cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kLCBmdW5jKSB7XG5cdFx0dmFyIHByb2NlZWQgPSBvYmpbbWV0aG9kXTtcblx0XHRvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGFyZ3MudW5zaGlmdChwcm9jZWVkKTtcblx0XHRcdHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH07XG5cdH07XG5cblxuXHRmdW5jdGlvbiBnZXRUWk9mZnNldCh0aW1lc3RhbXApIHtcblx0XHRyZXR1cm4gKChnZXRUaW1lem9uZU9mZnNldCAmJiBnZXRUaW1lem9uZU9mZnNldCh0aW1lc3RhbXApKSB8fCB0aW1lem9uZU9mZnNldCB8fCAwKSAqIDYwMDAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGh0dHA6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RyZnRpbWUucGhwXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcGl0YWxpemVcblx0ICovXG5cdGRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0LCB0aW1lc3RhbXAsIGNhcGl0YWxpemUpIHtcblx0XHRpZiAoIWRlZmluZWQodGltZXN0YW1wKSB8fCBpc05hTih0aW1lc3RhbXApKSB7XG5cdFx0XHRyZXR1cm4gJ0ludmFsaWQgZGF0ZSc7XG5cdFx0fVxuXHRcdGZvcm1hdCA9IHBpY2soZm9ybWF0LCAnJVktJW0tJWQgJUg6JU06JVMnKTtcblxuXHRcdHZhciBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wIC0gZ2V0VFpPZmZzZXQodGltZXN0YW1wKSksXG5cdFx0XHRrZXksIC8vIHVzZWQgaW4gZm9yIGNvbnN0dWN0IGJlbG93XG5cdFx0XHQvLyBnZXQgdGhlIGJhc2ljIHRpbWUgdmFsdWVzXG5cdFx0XHRob3VycyA9IGRhdGVbZ2V0SG91cnNdKCksXG5cdFx0XHRkYXkgPSBkYXRlW2dldERheV0oKSxcblx0XHRcdGRheU9mTW9udGggPSBkYXRlW2dldERhdGVdKCksXG5cdFx0XHRtb250aCA9IGRhdGVbZ2V0TW9udGhdKCksXG5cdFx0XHRmdWxsWWVhciA9IGRhdGVbZ2V0RnVsbFllYXJdKCksXG5cdFx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdGxhbmdXZWVrZGF5cyA9IGxhbmcud2Vla2RheXMsXG5cblx0XHRcdC8vIExpc3QgYWxsIGZvcm1hdCBrZXlzLiBDdXN0b20gZm9ybWF0cyBjYW4gYmUgYWRkZWQgZnJvbSB0aGUgb3V0c2lkZS4gXG5cdFx0XHRyZXBsYWNlbWVudHMgPSBleHRlbmQoe1xuXG5cdFx0XHRcdC8vIERheVxuXHRcdFx0XHQnYSc6IGxhbmdXZWVrZGF5c1tkYXldLnN1YnN0cigwLCAzKSwgLy8gU2hvcnQgd2Vla2RheSwgbGlrZSAnTW9uJ1xuXHRcdFx0XHQnQSc6IGxhbmdXZWVrZGF5c1tkYXldLCAvLyBMb25nIHdlZWtkYXksIGxpa2UgJ01vbmRheSdcblx0XHRcdFx0J2QnOiBwYWQoZGF5T2ZNb250aCksIC8vIFR3byBkaWdpdCBkYXkgb2YgdGhlIG1vbnRoLCAwMSB0byAzMVxuXHRcdFx0XHQnZSc6IGRheU9mTW9udGgsIC8vIERheSBvZiB0aGUgbW9udGgsIDEgdGhyb3VnaCAzMVxuXHRcdFx0XHQndyc6IGRheSxcblxuXHRcdFx0XHQvLyBXZWVrIChub25lIGltcGxlbWVudGVkKVxuXHRcdFx0XHQvLydXJzogd2Vla051bWJlcigpLFxuXG5cdFx0XHRcdC8vIE1vbnRoXG5cdFx0XHRcdCdiJzogbGFuZy5zaG9ydE1vbnRoc1ttb250aF0sIC8vIFNob3J0IG1vbnRoLCBsaWtlICdKYW4nXG5cdFx0XHRcdCdCJzogbGFuZy5tb250aHNbbW9udGhdLCAvLyBMb25nIG1vbnRoLCBsaWtlICdKYW51YXJ5J1xuXHRcdFx0XHQnbSc6IHBhZChtb250aCArIDEpLCAvLyBUd28gZGlnaXQgbW9udGggbnVtYmVyLCAwMSB0aHJvdWdoIDEyXG5cblx0XHRcdFx0Ly8gWWVhclxuXHRcdFx0XHQneSc6IGZ1bGxZZWFyLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIpLCAvLyBUd28gZGlnaXRzIHllYXIsIGxpa2UgMDkgZm9yIDIwMDlcblx0XHRcdFx0J1knOiBmdWxsWWVhciwgLy8gRm91ciBkaWdpdHMgeWVhciwgbGlrZSAyMDA5XG5cblx0XHRcdFx0Ly8gVGltZVxuXHRcdFx0XHQnSCc6IHBhZChob3VycyksIC8vIFR3byBkaWdpdHMgaG91cnMgaW4gMjRoIGZvcm1hdCwgMDAgdGhyb3VnaCAyM1xuXHRcdFx0XHQnSSc6IHBhZCgoaG91cnMgJSAxMikgfHwgMTIpLCAvLyBUd28gZGlnaXRzIGhvdXJzIGluIDEyaCBmb3JtYXQsIDAwIHRocm91Z2ggMTFcblx0XHRcdFx0J2wnOiAoaG91cnMgJSAxMikgfHwgMTIsIC8vIEhvdXJzIGluIDEyaCBmb3JtYXQsIDEgdGhyb3VnaCAxMlxuXHRcdFx0XHQnTSc6IHBhZChkYXRlW2dldE1pbnV0ZXNdKCkpLCAvLyBUd28gZGlnaXRzIG1pbnV0ZXMsIDAwIHRocm91Z2ggNTlcblx0XHRcdFx0J3AnOiBob3VycyA8IDEyID8gJ0FNJyA6ICdQTScsIC8vIFVwcGVyIGNhc2UgQU0gb3IgUE1cblx0XHRcdFx0J1AnOiBob3VycyA8IDEyID8gJ2FtJyA6ICdwbScsIC8vIExvd2VyIGNhc2UgQU0gb3IgUE1cblx0XHRcdFx0J1MnOiBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpLCAvLyBUd28gZGlnaXRzIHNlY29uZHMsIDAwIHRocm91Z2ggIDU5XG5cdFx0XHRcdCdMJzogcGFkKG1hdGhSb3VuZCh0aW1lc3RhbXAgJSAxMDAwKSwgMykgLy8gTWlsbGlzZWNvbmRzIChuYW1pbmcgZnJvbSBSdWJ5KVxuXHRcdFx0fSwgSGlnaGNoYXJ0cy5kYXRlRm9ybWF0cyk7XG5cblxuXHRcdC8vIGRvIHRoZSByZXBsYWNlc1xuXHRcdGZvciAoa2V5IGluIHJlcGxhY2VtZW50cykge1xuXHRcdFx0d2hpbGUgKGZvcm1hdC5pbmRleE9mKCclJyArIGtleSkgIT09IC0xKSB7IC8vIHJlZ2V4IHdvdWxkIGRvIGl0IGluIG9uZSBsaW5lLCBidXQgdGhpcyBpcyBmYXN0ZXJcblx0XHRcdFx0Zm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnICsga2V5LCB0eXBlb2YgcmVwbGFjZW1lbnRzW2tleV0gPT09ICdmdW5jdGlvbicgPyByZXBsYWNlbWVudHNba2V5XSh0aW1lc3RhbXApIDogcmVwbGFjZW1lbnRzW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9wdGlvbmFsbHkgY2FwaXRhbGl6ZSB0aGUgc3RyaW5nIGFuZCByZXR1cm5cblx0XHRyZXR1cm4gY2FwaXRhbGl6ZSA/IGZvcm1hdC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGZvcm1hdC5zdWJzdHIoMSkgOiBmb3JtYXQ7XG5cdH07XG5cblx0LyoqIFxuXHQgKiBGb3JtYXQgYSBzaW5nbGUgdmFyaWFibGUuIFNpbWlsYXIgdG8gc3ByaW50Ziwgd2l0aG91dCB0aGUgJSBwcmVmaXguXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXRTaW5nbGUoZm9ybWF0LCB2YWwpIHtcblx0XHR2YXIgZmxvYXRSZWdleCA9IC9mJC8sXG5cdFx0XHRkZWNSZWdleCA9IC9cXC4oWzAtOV0pLyxcblx0XHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdFx0ZGVjaW1hbHM7XG5cblx0XHRpZiAoZmxvYXRSZWdleC50ZXN0KGZvcm1hdCkpIHsgLy8gZmxvYXRcblx0XHRcdGRlY2ltYWxzID0gZm9ybWF0Lm1hdGNoKGRlY1JlZ2V4KTtcblx0XHRcdGRlY2ltYWxzID0gZGVjaW1hbHMgPyBkZWNpbWFsc1sxXSA6IC0xO1xuXHRcdFx0aWYgKHZhbCAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWwgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdChcblx0XHRcdFx0XHR2YWwsXG5cdFx0XHRcdFx0ZGVjaW1hbHMsXG5cdFx0XHRcdFx0bGFuZy5kZWNpbWFsUG9pbnQsXG5cdFx0XHRcdFx0Zm9ybWF0LmluZGV4T2YoJywnKSA+IC0xID8gbGFuZy50aG91c2FuZHNTZXAgOiAnJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSBkYXRlRm9ybWF0KGZvcm1hdCwgdmFsKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtYXQgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgc3Vic2V0IG9mIHRoZSBydWxlcyBvZiBQeXRob24ncyBTdHJpbmcuZm9ybWF0IG1ldGhvZC5cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdChzdHIsIGN0eCkge1xuXHRcdHZhciBzcGxpdHRlciA9ICd7Jyxcblx0XHRcdGlzSW5zaWRlID0gZmFsc2UsXG5cdFx0XHRzZWdtZW50LFxuXHRcdFx0dmFsdWVBbmRGb3JtYXQsXG5cdFx0XHRwYXRoLFxuXHRcdFx0aSxcblx0XHRcdGxlbixcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aW5kZXg7XG5cdFx0XG5cdFx0d2hpbGUgKChpbmRleCA9IHN0ci5pbmRleE9mKHNwbGl0dGVyKSkgIT09IC0xKSB7XG5cdFx0XHRcblx0XHRcdHNlZ21lbnQgPSBzdHIuc2xpY2UoMCwgaW5kZXgpO1xuXHRcdFx0aWYgKGlzSW5zaWRlKSB7IC8vIHdlJ3JlIG9uIHRoZSBjbG9zaW5nIGJyYWNrZXQgbG9va2luZyBiYWNrXG5cdFx0XHRcdFxuXHRcdFx0XHR2YWx1ZUFuZEZvcm1hdCA9IHNlZ21lbnQuc3BsaXQoJzonKTtcblx0XHRcdFx0cGF0aCA9IHZhbHVlQW5kRm9ybWF0LnNoaWZ0KCkuc3BsaXQoJy4nKTsgLy8gZ2V0IGZpcnN0IGFuZCBsZWF2ZSBmb3JtYXRcblx0XHRcdFx0bGVuID0gcGF0aC5sZW5ndGg7XG5cdFx0XHRcdHZhbCA9IGN0eDtcblxuXHRcdFx0XHQvLyBBc3NpZ24gZGVlcGVyIHBhdGhzXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHZhbCA9IHZhbFtwYXRoW2ldXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcm1hdCB0aGUgcmVwbGFjZW1lbnRcblx0XHRcdFx0aWYgKHZhbHVlQW5kRm9ybWF0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhbCA9IGZvcm1hdFNpbmdsZSh2YWx1ZUFuZEZvcm1hdC5qb2luKCc6JyksIHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQdXNoIHRoZSByZXN1bHQgYW5kIGFkdmFuY2UgdGhlIGN1cnNvclxuXHRcdFx0XHRyZXQucHVzaCh2YWwpO1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldC5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHN0ciA9IHN0ci5zbGljZShpbmRleCArIDEpOyAvLyB0aGUgcmVzdFxuXHRcdFx0aXNJbnNpZGUgPSAhaXNJbnNpZGU7IC8vIHRvZ2dsZVxuXHRcdFx0c3BsaXR0ZXIgPSBpc0luc2lkZSA/ICd9JyA6ICd7JzsgLy8gbm93IGxvb2sgZm9yIG5leHQgbWF0Y2hpbmcgYnJhY2tldFxuXHRcdH1cblx0XHRyZXQucHVzaChzdHIpO1xuXHRcdHJldHVybiByZXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBtYWduaXR1ZGUgb2YgYSBudW1iZXJcblx0ICovXG5cdGZ1bmN0aW9uIGdldE1hZ25pdHVkZShudW0pIHtcblx0XHRyZXR1cm4gbWF0aC5wb3coMTAsIG1hdGhGbG9vcihtYXRoLmxvZyhudW0pIC8gbWF0aC5MTjEwKSk7XG5cdH1cblxuXHQvKipcblx0ICogVGFrZSBhbiBpbnRlcnZhbCBhbmQgbm9ybWFsaXplIGl0IHRvIG11bHRpcGxlcyBvZiAxLCAyLCAyLjUgYW5kIDVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG11bHRpcGxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWFnbml0dWRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVUaWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIG11bHRpcGxlcywgbWFnbml0dWRlLCBhbGxvd0RlY2ltYWxzLCBwcmV2ZW50RXhjZWVkKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWQsIFxuXHRcdFx0aSxcblx0XHRcdHJldEludGVydmFsID0gaW50ZXJ2YWw7XG5cblx0XHQvLyByb3VuZCB0byBhIHRlbmZvbGQgb2YgMSwgMiwgMi41IG9yIDVcblx0XHRtYWduaXR1ZGUgPSBwaWNrKG1hZ25pdHVkZSwgMSk7XG5cdFx0bm9ybWFsaXplZCA9IGludGVydmFsIC8gbWFnbml0dWRlO1xuXG5cdFx0Ly8gbXVsdGlwbGVzIGZvciBhIGxpbmVhciBzY2FsZVxuXHRcdGlmICghbXVsdGlwbGVzKSB7XG5cdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgMi41LCA1LCAxMF07XG5cblx0XHRcdC8vIHRoZSBhbGxvd0RlY2ltYWxzIG9wdGlvblxuXHRcdFx0aWYgKGFsbG93RGVjaW1hbHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChtYWduaXR1ZGUgPT09IDEpIHtcblx0XHRcdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgNSwgMTBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hZ25pdHVkZSA8PSAwLjEpIHtcblx0XHRcdFx0XHRtdWx0aXBsZXMgPSBbMSAvIG1hZ25pdHVkZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBub3JtYWxpemUgdGhlIGludGVydmFsIHRvIHRoZSBuZWFyZXN0IG11bHRpcGxlXG5cdFx0Zm9yIChpID0gMDsgaSA8IG11bHRpcGxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmV0SW50ZXJ2YWwgPSBtdWx0aXBsZXNbaV07XG5cdFx0XHRpZiAoKHByZXZlbnRFeGNlZWQgJiYgcmV0SW50ZXJ2YWwgKiBtYWduaXR1ZGUgPj0gaW50ZXJ2YWwpIHx8IC8vIG9ubHkgYWxsb3cgdGljayBhbW91bnRzIHNtYWxsZXIgdGhhbiBuYXR1cmFsXG5cdFx0XHRcdCghcHJldmVudEV4Y2VlZCAmJiAobm9ybWFsaXplZCA8PSAobXVsdGlwbGVzW2ldICsgKG11bHRpcGxlc1tpICsgMV0gfHwgbXVsdGlwbGVzW2ldKSkgLyAyKSkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbXVsdGlwbHkgYmFjayB0byB0aGUgY29ycmVjdCBtYWduaXR1ZGVcblx0XHRyZXRJbnRlcnZhbCAqPSBtYWduaXR1ZGU7XG5cdFx0XG5cdFx0cmV0dXJuIHJldEludGVydmFsO1xuXHR9XG5cblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdGhhdCBzb3J0cyBhbiBvYmplY3QgYXJyYXkgYW5kIGtlZXBpbmcgdGhlIG9yZGVyIG9mIGVxdWFsIGl0ZW1zLlxuXHQgKiBFQ01BIHNjcmlwdCBzdGFuZGFyZCBkb2VzIG5vdCBzcGVjaWZ5IHRoZSBiZWhhdmlvdXIgd2hlbiBpdGVtcyBhcmUgZXF1YWwuXG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgc29ydEZ1bmN0aW9uKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG5cdFx0XHRzb3J0VmFsdWUsXG5cdFx0XHRpO1xuXG5cdFx0Ly8gQWRkIGluZGV4IHRvIGVhY2ggaXRlbVxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0YXJyW2ldLnNzX2kgPSBpOyAvLyBzdGFibGUgc29ydCBpbmRleFxuXHRcdH1cblxuXHRcdGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRzb3J0VmFsdWUgPSBzb3J0RnVuY3Rpb24oYSwgYik7XG5cdFx0XHRyZXR1cm4gc29ydFZhbHVlID09PSAwID8gYS5zc19pIC0gYi5zc19pIDogc29ydFZhbHVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGluZGV4IGZyb20gaXRlbXNcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRlbGV0ZSBhcnJbaV0uc3NfaTsgLy8gc3RhYmxlIHNvcnQgaW5kZXhcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTm9uLXJlY3Vyc2l2ZSBtZXRob2QgdG8gZmluZCB0aGUgbG93ZXN0IG1lbWJlciBvZiBhbiBhcnJheS4gTWF0aC5taW4gcmFpc2VzIGEgbWF4aW11bVxuXHQgKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuXHQgKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5TWluKGRhdGEpIHtcblx0XHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdFx0bWluID0gZGF0YVswXTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChkYXRhW2ldIDwgbWluKSB7XG5cdFx0XHRcdG1pbiA9IGRhdGFbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHQvKipcblx0ICogTm9uLXJlY3Vyc2l2ZSBtZXRob2QgdG8gZmluZCB0aGUgbG93ZXN0IG1lbWJlciBvZiBhbiBhcnJheS4gTWF0aC5taW4gcmFpc2VzIGEgbWF4aW11bVxuXHQgKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuXHQgKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5TWF4KGRhdGEpIHtcblx0XHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdFx0bWF4ID0gZGF0YVswXTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChkYXRhW2ldID4gbWF4KSB7XG5cdFx0XHRcdG1heCA9IGRhdGFbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXg7XG5cdH1cblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdGhhdCBkZXN0cm95cyBhbnkgU1ZHRWxlbWVudCBvciBWTUxFbGVtZW50IHRoYXQgYXJlIHByb3BlcnRpZXMgb24gdGhlIGdpdmVuIG9iamVjdC5cblx0ICogSXQgbG9vcHMgYWxsIHByb3BlcnRpZXMgYW5kIGludm9rZXMgZGVzdHJveSBpZiB0aGVyZSBpcyBhIGRlc3Ryb3kgbWV0aG9kLiBUaGUgcHJvcGVydHkgaXNcblx0ICogdGhlbiBkZWxldGUnZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGRlc3Ryb3kgcHJvcGVydGllcyBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gRXhjZXB0aW9uLCBkbyBub3QgZGVzdHJveSB0aGlzIHByb3BlcnR5LCBvbmx5IGRlbGV0ZSBpdC5cblx0ICovXG5cdGZ1bmN0aW9uIGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKG9iaiwgZXhjZXB0KSB7XG5cdFx0dmFyIG47XG5cdFx0Zm9yIChuIGluIG9iaikge1xuXHRcdFx0Ly8gSWYgdGhlIG9iamVjdCBpcyBub24tbnVsbCBhbmQgZGVzdHJveSBpcyBkZWZpbmVkXG5cdFx0XHRpZiAob2JqW25dICYmIG9ialtuXSAhPT0gZXhjZXB0ICYmIG9ialtuXS5kZXN0cm95KSB7XG5cdFx0XHRcdC8vIEludm9rZSB0aGUgZGVzdHJveVxuXHRcdFx0XHRvYmpbbl0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZWxldGUgdGhlIHByb3BlcnR5IGZyb20gdGhlIG9iamVjdC5cblx0XHRcdGRlbGV0ZSBvYmpbbl07XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogRGlzY2FyZCBhbiBlbGVtZW50IGJ5IG1vdmluZyBpdCB0byB0aGUgYmluIGFuZCBkZWxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSBIVE1MIG5vZGUgdG8gZGlzY2FyZFxuXHQgKi9cblx0ZnVuY3Rpb24gZGlzY2FyZEVsZW1lbnQoZWxlbWVudCkge1xuXHRcdC8vIGNyZWF0ZSBhIGdhcmJhZ2UgYmluIGVsZW1lbnQsIG5vdCBwYXJ0IG9mIHRoZSBET01cblx0XHRpZiAoIWdhcmJhZ2VCaW4pIHtcblx0XHRcdGdhcmJhZ2VCaW4gPSBjcmVhdGVFbGVtZW50KERJVik7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZSB0aGUgbm9kZSBhbmQgZW1wdHkgYmluXG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdGdhcmJhZ2VCaW4uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0fVxuXHRcdGdhcmJhZ2VCaW4uaW5uZXJIVE1MID0gJyc7XG5cdH1cblxuXHQvKipcblx0ICogUHJvdmlkZSBlcnJvciBtZXNzYWdlcyBmb3IgZGVidWdnaW5nLCB3aXRoIGxpbmtzIHRvIG9ubGluZSBleHBsYW5hdGlvbiBcblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yIChjb2RlLCBzdG9wKSB7XG5cdFx0dmFyIG1zZyA9ICdIaWdoY2hhcnRzIGVycm9yICMnICsgY29kZSArICc6IHd3dy5oaWdoY2hhcnRzLmNvbS9lcnJvcnMvJyArIGNvZGU7XG5cdFx0aWYgKHN0b3ApIHtcblx0XHRcdHRocm93IG1zZztcblx0XHR9XG5cdFx0Ly8gZWxzZSAuLi5cblx0XHRpZiAod2luLmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpeCBKUyByb3VuZCBvZmYgZmxvYXQgZXJyb3JzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1cblx0ICovXG5cdGZ1bmN0aW9uIGNvcnJlY3RGbG9hdChudW0sIHByZWMpIHtcblx0XHRyZXR1cm4gcGFyc2VGbG9hdChcblx0XHRcdG51bS50b1ByZWNpc2lvbihwcmVjIHx8IDE0KVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBnbG9iYWwgYW5pbWF0aW9uIHRvIGVpdGhlciBhIGdpdmVuIHZhbHVlLCBvciBmYWxsIGJhY2sgdG8gdGhlXG5cdCAqIGdpdmVuIGNoYXJ0J3MgYW5pbWF0aW9uIG9wdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpIHtcblx0XHRnbG9iYWxBbmltYXRpb24gPSBwaWNrKGFuaW1hdGlvbiwgY2hhcnQuYW5pbWF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdGltZSB1bml0IGxvb2t1cFxuXHQgKi9cblx0dGltZVVuaXRzID0ge1xuXHRcdG1pbGxpc2Vjb25kOiAxLFxuXHRcdHNlY29uZDogMTAwMCxcblx0XHRtaW51dGU6IDYwMDAwLFxuXHRcdGhvdXI6IDM2MDAwMDAsXG5cdFx0ZGF5OiAyNCAqIDM2MDAwMDAsXG5cdFx0d2VlazogNyAqIDI0ICogMzYwMDAwMCxcblx0XHRtb250aDogMjggKiAyNCAqIDM2MDAwMDAsXG5cdFx0eWVhcjogMzY0ICogMjQgKiAzNjAwMDAwXG5cdH07XG5cblxuXHQvKipcblx0ICogRm9ybWF0IGEgbnVtYmVyIGFuZCByZXR1cm4gYSBzdHJpbmcgYmFzZWQgb24gaW5wdXQgc2V0dGluZ3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBUaGUgaW5wdXQgbnVtYmVyIHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbHMgVGhlIGFtb3VudCBvZiBkZWNpbWFsc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGVjUG9pbnQgVGhlIGRlY2ltYWwgcG9pbnQsIGRlZmF1bHRzIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gdGhlIGxhbmcgb3B0aW9uc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGhvdXNhbmRzU2VwIFRoZSB0aG91c2FuZHMgc2VwYXJhdG9yLCBkZWZhdWx0cyB0byB0aGUgb25lIGdpdmVuIGluIHRoZSBsYW5nIG9wdGlvbnNcblx0ICovXG5cdEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24gKG51bWJlciwgZGVjaW1hbHMsIGRlY1BvaW50LCB0aG91c2FuZHNTZXApIHtcblx0XHR2YXIgbGFuZyA9IGRlZmF1bHRPcHRpb25zLmxhbmcsXG5cdFx0XHQvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldC90ZWNoYmxvZy9hcnRpY2xlL2phdmFzY3JpcHRfZXF1aXZhbGVudF9mb3JfcGhwc19udW1iZXJfZm9ybWF0L1xuXHRcdFx0biA9ICtudW1iZXIgfHwgMCxcblx0XHRcdGMgPSBkZWNpbWFscyA9PT0gLTEgP1xuXHRcdFx0XHRtYXRoTWluKChuLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXSB8fCAnJykubGVuZ3RoLCAyMCkgOiAvLyBQcmVzZXJ2ZSBkZWNpbWFscy4gTm90IGh1Z2UgbnVtYmVycyAoIzM3OTMpLlxuXHRcdFx0XHQoaXNOYU4oZGVjaW1hbHMgPSBtYXRoQWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHMpLFxuXHRcdFx0ZCA9IGRlY1BvaW50ID09PSB1bmRlZmluZWQgPyBsYW5nLmRlY2ltYWxQb2ludCA6IGRlY1BvaW50LFxuXHRcdFx0dCA9IHRob3VzYW5kc1NlcCA9PT0gdW5kZWZpbmVkID8gbGFuZy50aG91c2FuZHNTZXAgOiB0aG91c2FuZHNTZXAsXG5cdFx0XHRzID0gbiA8IDAgPyBcIi1cIiA6IFwiXCIsXG5cdFx0XHRpID0gU3RyaW5nKHBJbnQobiA9IG1hdGhBYnMobikudG9GaXhlZChjKSkpLFxuXHRcdFx0aiA9IGkubGVuZ3RoID4gMyA/IGkubGVuZ3RoICUgMyA6IDA7XG5cblx0XHRyZXR1cm4gKHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6IFwiXCIpICsgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csIFwiJDFcIiArIHQpICtcblx0XHRcdFx0KGMgPyBkICsgbWF0aEFicyhuIC0gaSkudG9GaXhlZChjKS5zbGljZSgyKSA6IFwiXCIpKTtcblx0fTtcblx0LyoqXG5cdCAqIFBhdGggaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0gdXNlZCBhY3Jvc3MgYWRhcHRlcnNcblx0ICovXG5cdHBhdGhBbmltID0ge1xuXHRcdC8qKlxuXHRcdCAqIFByZXBhcmUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgc28gdGhhdCB0aGUgcGF0aCBjYW4gYmUgYW5pbWF0ZWQgb25lIHRvIG9uZVxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChlbGVtLCBmcm9tRCwgdG9EKSB7XG5cdFx0XHRmcm9tRCA9IGZyb21EIHx8ICcnO1xuXHRcdFx0dmFyIHNoaWZ0ID0gZWxlbS5zaGlmdCxcblx0XHRcdFx0YmV6aWVyID0gZnJvbUQuaW5kZXhPZignQycpID4gLTEsXG5cdFx0XHRcdG51bVBhcmFtcyA9IGJlemllciA/IDcgOiAzLFxuXHRcdFx0XHRlbmRMZW5ndGgsXG5cdFx0XHRcdHNsaWNlLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRzdGFydCA9IGZyb21ELnNwbGl0KCcgJyksXG5cdFx0XHRcdGVuZCA9IFtdLmNvbmNhdCh0b0QpLCAvLyBjb3B5XG5cdFx0XHRcdHN0YXJ0QmFzZUxpbmUsXG5cdFx0XHRcdGVuZEJhc2VMaW5lLFxuXHRcdFx0XHRzaXhpZnkgPSBmdW5jdGlvbiAoYXJyKSB7IC8vIGluIHNwbGluZXMgbWFrZSBtb3ZlIHBvaW50cyBoYXZlIHNpeCBwYXJhbWV0ZXJzIGxpa2UgYmV6aWVyIGN1cnZlc1xuXHRcdFx0XHRcdGkgPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IE0pIHtcblx0XHRcdFx0XHRcdFx0YXJyLnNwbGljZShpICsgMSwgMCwgYXJyW2kgKyAxXSwgYXJyW2kgKyAyXSwgYXJyW2kgKyAxXSwgYXJyW2kgKyAyXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRpZiAoYmV6aWVyKSB7XG5cdFx0XHRcdHNpeGlmeShzdGFydCk7XG5cdFx0XHRcdHNpeGlmeShlbmQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwdWxsIG91dCB0aGUgYmFzZSBsaW5lcyBiZWZvcmUgcGFkZGluZ1xuXHRcdFx0aWYgKGVsZW0uaXNBcmVhKSB7XG5cdFx0XHRcdHN0YXJ0QmFzZUxpbmUgPSBzdGFydC5zcGxpY2Uoc3RhcnQubGVuZ3RoIC0gNiwgNik7XG5cdFx0XHRcdGVuZEJhc2VMaW5lID0gZW5kLnNwbGljZShlbmQubGVuZ3RoIC0gNiwgNik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHNoaWZ0aW5nIHBvaW50cywgcHJlcGVuZCBhIGR1bW15IHBvaW50IHRvIHRoZSBlbmQgcGF0aFxuXHRcdFx0aWYgKHNoaWZ0IDw9IGVuZC5sZW5ndGggLyBudW1QYXJhbXMgJiYgc3RhcnQubGVuZ3RoID09PSBlbmQubGVuZ3RoKSB7XG5cdFx0XHRcdHdoaWxlIChzaGlmdC0tKSB7XG5cdFx0XHRcdFx0ZW5kID0gW10uY29uY2F0KGVuZCkuc3BsaWNlKDAsIG51bVBhcmFtcykuY29uY2F0KGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsZW0uc2hpZnQgPSAwOyAvLyByZXNldCBmb3IgZm9sbG93aW5nIGFuaW1hdGlvbnNcblxuXHRcdFx0Ly8gY29weSBhbmQgYXBwZW5kIGxhc3QgcG9pbnQgdW50aWwgdGhlIGxlbmd0aCBtYXRjaGVzIHRoZSBlbmQgbGVuZ3RoXG5cdFx0XHRpZiAoc3RhcnQubGVuZ3RoKSB7XG5cdFx0XHRcdGVuZExlbmd0aCA9IGVuZC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChzdGFydC5sZW5ndGggPCBlbmRMZW5ndGgpIHtcblxuXHRcdFx0XHRcdC8vYmV6aWVyICYmIHNpeGlmeShzdGFydCk7XG5cdFx0XHRcdFx0c2xpY2UgPSBbXS5jb25jYXQoc3RhcnQpLnNwbGljZShzdGFydC5sZW5ndGggLSBudW1QYXJhbXMsIG51bVBhcmFtcyk7XG5cdFx0XHRcdFx0aWYgKGJlemllcikgeyAvLyBkaXNhYmxlIGZpcnN0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRcdHNsaWNlW251bVBhcmFtcyAtIDZdID0gc2xpY2VbbnVtUGFyYW1zIC0gMl07XG5cdFx0XHRcdFx0XHRzbGljZVtudW1QYXJhbXMgLSA1XSA9IHNsaWNlW251bVBhcmFtcyAtIDFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0LmNvbmNhdChzbGljZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXJ0QmFzZUxpbmUpIHsgLy8gYXBwZW5kIHRoZSBiYXNlIGxpbmVzIGZvciBhcmVhc1xuXHRcdFx0XHRzdGFydCA9IHN0YXJ0LmNvbmNhdChzdGFydEJhc2VMaW5lKTtcblx0XHRcdFx0ZW5kID0gZW5kLmNvbmNhdChlbmRCYXNlTGluZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3N0YXJ0LCBlbmRdO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbnRlcnBvbGF0ZSBlYWNoIHZhbHVlIG9mIHRoZSBwYXRoIGFuZCByZXR1cm4gdGhlIGFycmF5XG5cdFx0ICovXG5cdFx0c3RlcDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBvcywgY29tcGxldGUpIHtcblx0XHRcdHZhciByZXQgPSBbXSxcblx0XHRcdFx0aSA9IHN0YXJ0Lmxlbmd0aCxcblx0XHRcdFx0c3RhcnRWYWw7XG5cblx0XHRcdGlmIChwb3MgPT09IDEpIHsgLy8gbGFuZCBvbiB0aGUgZmluYWwgcGF0aCB3aXRob3V0IGFkanVzdG1lbnQgcG9pbnRzIGFwcGVuZGVkIGluIHRoZSBlbmRzXG5cdFx0XHRcdHJldCA9IGNvbXBsZXRlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09IGVuZC5sZW5ndGggJiYgcG9zIDwgMSkge1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0c3RhcnRWYWwgPSBwYXJzZUZsb2F0KHN0YXJ0W2ldKTtcblx0XHRcdFx0XHRyZXRbaV0gPVxuXHRcdFx0XHRcdFx0aXNOYU4oc3RhcnRWYWwpID8gLy8gYSBsZXR0ZXIgaW5zdHJ1Y3Rpb24gbGlrZSBNIG9yIExcblx0XHRcdFx0XHRcdFx0c3RhcnRbaV0gOlxuXHRcdFx0XHRcdFx0XHRwb3MgKiAocGFyc2VGbG9hdChlbmRbaV0gLSBzdGFydFZhbCkpICsgc3RhcnRWYWw7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHsgLy8gaWYgYW5pbWF0aW9uIGlzIGZpbmlzaGVkIG9yIGxlbmd0aCBub3QgbWF0Y2hpbmcsIGxhbmQgb24gcmlnaHQgdmFsdWVcblx0XHRcdFx0cmV0ID0gZW5kO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG5cblx0KGZ1bmN0aW9uICgkKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgSGlnaGNoYXJ0c0FkYXB0ZXIgZm9yIGpRdWVyeVxuXHRcdCAqL1xuXHRcdHdpbi5IaWdoY2hhcnRzQWRhcHRlciA9IHdpbi5IaWdoY2hhcnRzQWRhcHRlciB8fCAoJCAmJiB7XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogSW5pdGlhbGl6ZSB0aGUgYWRhcHRlciBieSBhcHBseWluZyBzb21lIGV4dGVuc2lvbnMgdG8galF1ZXJ5XG5cdFx0XHQgKi9cblx0XHRcdGluaXQ6IGZ1bmN0aW9uIChwYXRoQW5pbSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZXh0ZW5kIHRoZSBhbmltYXRlIGZ1bmN0aW9uIHRvIGFsbG93IFNWRyBhbmltYXRpb25zXG5cdFx0XHRcdHZhciBGeCA9ICQuZng7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiB0cnVlKi8vKiBhbGxvdyB1bnVzZWQgcGFyYW0geCBpbiB0aGlzIGZ1bmN0aW9uICovXG5cdFx0XHRcdCQuZXh0ZW5kKCQuZWFzaW5nLCB7XG5cdFx0XHRcdFx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XHRcdFxuXHRcdFx0XHQvLyBleHRlbmQgc29tZSBtZXRob2RzIHRvIGNoZWNrIGZvciBlbGVtLmF0dHIsIHdoaWNoIG1lYW5zIGl0IGlzIGEgSGlnaGNoYXJ0cyBTVkcgb2JqZWN0XG5cdFx0XHRcdCQuZWFjaChbJ2N1cicsICdfZGVmYXVsdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnb3BhY2l0eSddLCBmdW5jdGlvbiAoaSwgZm4pIHtcblx0XHRcdFx0XHR2YXIgb2JqID0gRnguc3RlcCxcblx0XHRcdFx0XHRcdGJhc2U7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBIYW5kbGUgZGlmZmVyZW50IHBhcmVudCBvYmplY3RzXG5cdFx0XHRcdFx0aWYgKGZuID09PSAnY3VyJykge1xuXHRcdFx0XHRcdFx0b2JqID0gRngucHJvdG90eXBlOyAvLyAnY3VyJywgdGhlIGdldHRlciwgcmVsYXRlcyB0byBGeC5wcm90b3R5cGVcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGZuID09PSAnX2RlZmF1bHQnICYmICQuVHdlZW4pIHsgLy8galF1ZXJ5IDEuOCBtb2RlbFxuXHRcdFx0XHRcdFx0b2JqID0gJC5Ud2Vlbi5wcm9wSG9va3NbZm5dO1xuXHRcdFx0XHRcdFx0Zm4gPSAnc2V0Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0XHQvLyBPdmVyd3JpdGUgdGhlIG1ldGhvZFxuXHRcdFx0XHRcdGJhc2UgPSBvYmpbZm5dO1xuXHRcdFx0XHRcdGlmIChiYXNlKSB7IC8vIHN0ZXAud2lkdGggYW5kIHN0ZXAuaGVpZ2h0IGRvbid0IGV4aXN0IGluIGpRdWVyeSA8IDEuN1xuXHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgdGhlIGV4dGVuZGVkIGZ1bmN0aW9uIHJlcGxhY2VtZW50XG5cdFx0XHRcdFx0XHRvYmpbZm5dID0gZnVuY3Rpb24gKGZ4KSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGVsZW07XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBGeC5wcm90b3R5cGUuY3VyIGRvZXMgbm90IHVzZSBmeCBhcmd1bWVudFxuXHRcdFx0XHRcdFx0XHRmeCA9IGkgPyBmeCA6IHRoaXM7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcnVuIGFuaW1hdGlvbnMgb24gdGV4dHVhbCBwcm9wZXJ0aWVzIGxpa2UgYWxpZ24gKCMxODIxKVxuXHRcdFx0XHRcdFx0XHRpZiAoZngucHJvcCA9PT0gJ2FsaWduJykge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIHNob3J0Y3V0XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBmeC5lbGVtO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS4gVGhlIG90aGVyIG9uZXMgYXJlIHNldHRlcnNcblx0XHRcdFx0XHRcdFx0Ly8gYW5kIHJldHVybmluZyBhIHZhbHVlIGhhcyBubyBlZmZlY3QuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmF0dHIgPyAvLyBpcyBTVkcgZWxlbWVudCB3cmFwcGVyXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5hdHRyKGZ4LnByb3AsIGZuID09PSAnY3VyJyA/IFVOREVGSU5FRCA6IGZ4Lm5vdykgOiAvLyBhcHBseSB0aGUgU1ZHIHdyYXBwZXIncyBtZXRob2Rcblx0XHRcdFx0XHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIHVzZSBqUXVlcnkncyBidWlsdC1pbiBtZXRob2Rcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBFeHRlbmQgdGhlIG9wYWNpdHkgZ2V0dGVyLCBuZWVkZWQgZm9yIGZhZGluZyBvcGFjaXR5IHdpdGggSUU5IGFuZCBqUXVlcnkgMS4xMCtcblx0XHRcdFx0d3JhcCgkLmNzc0hvb2tzLm9wYWNpdHksICdnZXQnLCBmdW5jdGlvbiAocHJvY2VlZCwgZWxlbSwgY29tcHV0ZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5hdHRyID8gKGVsZW0ub3BhY2l0eSB8fCAwKSA6IHByb2NlZWQuY2FsbCh0aGlzLCBlbGVtLCBjb21wdXRlZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRGVmaW5lIHRoZSBzZXR0ZXIgZnVuY3Rpb24gZm9yIGQgKHBhdGggZGVmaW5pdGlvbnMpXG5cdFx0XHRcdHRoaXMuYWRkQW5pbVNldHRlcignZCcsIGZ1bmN0aW9uIChmeCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gZnguZWxlbSxcblx0XHRcdFx0XHRcdGVuZHM7XG5cdFx0XHRcblx0XHRcdFx0XHQvLyBOb3JtYWxseSBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSBzZXQgaW4gc3RhdGUgPT0gMCwgYnV0IHNvbWV0aW1lcyxcblx0XHRcdFx0XHQvLyBmb3IgcmVhc29ucyB1bmtub3duLCB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBQZXJoYXBzIHN0YXRlID09IDAgaXMgc2tpcHBlZFxuXHRcdFx0XHRcdC8vIGluIHRoZXNlIGNhc2VzXG5cdFx0XHRcdFx0aWYgKCFmeC5zdGFydGVkKSB7XG5cdFx0XHRcdFx0XHRlbmRzID0gcGF0aEFuaW0uaW5pdChlbGVtLCBlbGVtLmQsIGVsZW0udG9EKTtcblx0XHRcdFx0XHRcdGZ4LnN0YXJ0ID0gZW5kc1swXTtcblx0XHRcdFx0XHRcdGZ4LmVuZCA9IGVuZHNbMV07XG5cdFx0XHRcdFx0XHRmeC5zdGFydGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0XHQvLyBJbnRlcnBvbGF0ZSBlYWNoIHZhbHVlIG9mIHRoZSBwYXRoXG5cdFx0XHRcdFx0ZWxlbS5hdHRyKCdkJywgcGF0aEFuaW0uc3RlcChmeC5zdGFydCwgZnguZW5kLCBmeC5wb3MsIGVsZW0udG9EKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFV0aWxpdHkgZm9yIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LiBQYXJhbWV0ZXJzIGFyZSByZXZlcnNlZCBjb21wYXJlZCB0byBqUXVlcnkuXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHRcdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy5lYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2ggP1xuXHRcdFx0XHRcdGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0XHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJyLCBmbik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9IDogXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbGVnYWN5XG5cdFx0XHRcdFx0XHR2YXIgaSwgXG5cdFx0XHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFJlZ2lzdGVyIEhpZ2hjaGFydHMgYXMgYSBwbHVnaW4gaW4gdGhlIHJlc3BlY3RpdmUgZnJhbWV3b3JrXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLmZuLmhpZ2hjaGFydHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnN0ciA9ICdDaGFydCcsIC8vIGRlZmF1bHQgY29uc3RydWN0b3Jcblx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRvcHRpb25zLFxuXHRcdFx0XHRcdFx0cmV0LFxuXHRcdFx0XHRcdFx0Y2hhcnQ7XG5cblx0XHRcdFx0XHRpZiAodGhpc1swXSkge1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNTdHJpbmcoYXJnc1swXSkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3RyID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMgPSBhcmdzWzBdO1xuXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgdGhlIGNoYXJ0XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucyAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdC8qanNsaW50IHVudXNlZDpmYWxzZSovXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuY2hhcnQgPSBvcHRpb25zLmNoYXJ0IHx8IHt9O1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLmNoYXJ0LnJlbmRlclRvID0gdGhpc1swXTtcblx0XHRcdFx0XHRcdFx0Y2hhcnQgPSBuZXcgSGlnaGNoYXJ0c1tjb25zdHJdKG9wdGlvbnMsIGFyZ3NbMV0pO1xuXHRcdFx0XHRcdFx0XHRyZXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0XHQvKmpzbGludCB1bnVzZWQ6dHJ1ZSovXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFdoZW4gY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycyBvciB3aXRoIHRoZSByZXR1cm4gYXJndW1lbnQsIGdldCBhIHByZWRlZmluZWQgY2hhcnRcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gY2hhcnRzW2F0dHIodGhpc1swXSwgJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fTtcblxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGQgYW4gYW5pbWF0aW9uIHNldHRlciBmb3IgYSBzcGVjaWZpYyBwcm9wZXJ0eVxuXHRcdFx0ICovXG5cdFx0XHRhZGRBbmltU2V0dGVyOiBmdW5jdGlvbiAocHJvcCwgc2V0dGVyKSB7XG5cdFx0XHRcdC8vIGpRdWVyeSAxLjggc3R5bGVcblx0XHRcdFx0aWYgKCQuVHdlZW4pIHtcblx0XHRcdFx0XHQkLlR3ZWVuLnByb3BIb29rc1twcm9wXSA9IHtcblx0XHRcdFx0XHRcdHNldDogc2V0dGVyXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gcHJlIDEuOFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZnguc3RlcFtwcm9wXSA9IHNldHRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEb3dubG9hZHMgYSBzY3JpcHQgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgd2hlbiBkb25lLlxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmlwdExvY2F0aW9uXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdFx0ICovXG5cdFx0XHRnZXRTY3JpcHQ6ICQuZ2V0U2NyaXB0LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybiB0aGUgaW5kZXggb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgbm90IGZvdW5kXG5cdFx0XHQgKi9cblx0XHRcdGluQXJyYXk6ICQuaW5BcnJheSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIGRpcmVjdCBsaW5rIHRvIGpRdWVyeSBtZXRob2RzLiBNb29Ub29scyBhbmQgUHJvdG90eXBlIGFkYXB0ZXJzIG11c3QgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggY2FzZSBvZiBtZXRob2QuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbSBUaGUgSFRNTCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFdoaWNoIG1ldGhvZCB0byBydW4gb24gdGhlIHdyYXBwZWQgZWxlbWVudFxuXHRcdFx0ICovXG5cdFx0XHRhZGFwdGVyUnVuOiBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kKSB7XG5cdFx0XHRcdHJldHVybiAkKGVsZW0pW21ldGhvZF0oKTtcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbHRlciBhbiBhcnJheVxuXHRcdFx0ICovXG5cdFx0XHRncmVwOiAkLmdyZXAsXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIE1hcCBhbiBhcnJheVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdFx0ICovXG5cdFx0XHRtYXA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG5cdFx0XHRcdC8vcmV0dXJuIGpRdWVyeS5tYXAoYXJyLCBmbik7XG5cdFx0XHRcdHZhciByZXN1bHRzID0gW10sXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFxuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogR2V0IHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZVxuXHRcdFx0ICovXG5cdFx0XHRvZmZzZXQ6IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0XHRyZXR1cm4gJChlbCkub2Zmc2V0KCk7XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBBIEhUTUwgZWxlbWVudCBvciBjdXN0b20gb2JqZWN0XG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHR5cGVcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBldmVudCBoYW5kbGVyXG5cdFx0XHQgKi9cblx0XHRcdGFkZEV2ZW50OiBmdW5jdGlvbiAoZWwsIGV2ZW50LCBmbikge1xuXHRcdFx0XHQkKGVsKS5iaW5kKGV2ZW50LCBmbik7XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZW1vdmUgZXZlbnQgYWRkZWQgd2l0aCBhZGRFdmVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsIFRoZSBvYmplY3Rcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgVGhlIGV2ZW50IHR5cGUuIExlYXZlIGJsYW5rIHRvIHJlbW92ZSBhbGwgZXZlbnRzLlxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlXG5cdFx0XHQgKi9cblx0XHRcdHJlbW92ZUV2ZW50OiBmdW5jdGlvbiAoZWwsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuXHRcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBqUXVlcnkgaXNzdWUgd2l0aCB1bmJpbmRpbmcgY3VzdG9tIGV2ZW50czpcblx0XHRcdFx0Ly8gaHR0cDovL2ZvcnVtLmpRdWVyeS5jb20vdG9waWMvamF2YXNjcmlwdC1lcnJvci13aGVuLXVuYmluZGluZy1hLWN1c3RvbS1ldmVudC11c2luZy1qUXVlcnktMS00LTJcblx0XHRcdFx0dmFyIGZ1bmMgPSBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdkZXRhY2hFdmVudCc7XG5cdFx0XHRcdGlmIChkb2NbZnVuY10gJiYgZWwgJiYgIWVsW2Z1bmNdKSB7XG5cdFx0XHRcdFx0ZWxbZnVuY10gPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQkKGVsKS51bmJpbmQoZXZlbnRUeXBlLCBoYW5kbGVyKTtcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZpcmUgYW4gZXZlbnQgb24gYSBjdXN0b20gb2JqZWN0XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmd1bWVudHNcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRGdW5jdGlvblxuXHRcdFx0ICovXG5cdFx0XHRmaXJlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZXZlbnRBcmd1bWVudHMsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KHR5cGUpLFxuXHRcdFx0XHRcdGRldGFjaGVkVHlwZSA9ICdkZXRhY2hlZCcgKyB0eXBlLFxuXHRcdFx0XHRcdGRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0XG5cdFx0XHRcdC8vIFJlbW92ZSB3YXJuaW5ncyBpbiBDaHJvbWUgd2hlbiBhY2Nlc3NpbmcgcmV0dXJuVmFsdWUgKCMyNzkwKSwgbGF5ZXJYIGFuZCBsYXllclkuIEFsdGhvdWdoIEhpZ2hjaGFydHNcblx0XHRcdFx0Ly8gbmV2ZXIgdXNlcyB0aGVzZSBwcm9wZXJ0aWVzLCBDaHJvbWUgaW5jbHVkZXMgdGhlbSBpbiB0aGUgZGVmYXVsdCBjbGljayBldmVudCBhbmRcblx0XHRcdFx0Ly8gcmFpc2VzIHRoZSB3YXJuaW5nIHdoZW4gdGhleSBhcmUgY29waWVkIG92ZXIgaW4gdGhlIGV4dGVuZCBzdGF0ZW1lbnQgYmVsb3cuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFRvIGF2b2lkIHByb2JsZW1zIGluIElFIChzZWUgIzEwMTApIHdoZXJlIHdlIGNhbm5vdCBkZWxldGUgdGhlIHByb3BlcnRpZXMgYW5kIGF2b2lkXG5cdFx0XHRcdC8vIHRlc3RpbmcgaWYgdGhleSBhcmUgdGhlcmUgKHdhcm5pbmcgaW4gY2hyb21lKSB0aGUgb25seSBvcHRpb24gaXMgdG8gdGVzdCBpZiBydW5uaW5nIElFLlxuXHRcdFx0XHRpZiAoIWlzSUUgJiYgZXZlbnRBcmd1bWVudHMpIHtcblx0XHRcdFx0XHRkZWxldGUgZXZlbnRBcmd1bWVudHMubGF5ZXJYO1xuXHRcdFx0XHRcdGRlbGV0ZSBldmVudEFyZ3VtZW50cy5sYXllclk7XG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLnJldHVyblZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdGV4dGVuZChldmVudCwgZXZlbnRBcmd1bWVudHMpO1xuXHRcdFxuXHRcdFx0XHQvLyBQcmV2ZW50IGpRdWVyeSBmcm9tIHRyaWdnZXJpbmcgdGhlIG9iamVjdCBtZXRob2QgdGhhdCBpcyBuYW1lZCB0aGVcblx0XHRcdFx0Ly8gc2FtZSBhcyB0aGUgZXZlbnQuIEZvciBleGFtcGxlLCBpZiB0aGUgZXZlbnQgaXMgJ3NlbGVjdCcsIGpRdWVyeVxuXHRcdFx0XHQvLyBhdHRlbXB0cyBjYWxsaW5nIGVsLnNlbGVjdCBhbmQgaXQgZ29lcyBpbnRvIGEgbG9vcC5cblx0XHRcdFx0aWYgKGVsW3R5cGVdKSB7XG5cdFx0XHRcdFx0ZWxbZGV0YWNoZWRUeXBlXSA9IGVsW3R5cGVdO1xuXHRcdFx0XHRcdGVsW3R5cGVdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQvLyBXcmFwIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24gaW4gdHJ5L2NhdGNoIGJsb2NrcyBpblxuXHRcdFx0XHQvLyBvcmRlciB0byBwcmV2ZW50IEpTIGVycm9ycyB3aGVuIGNhbmNlbGxpbmcgZXZlbnRzIG9uIG5vbi1ET01cblx0XHRcdFx0Ly8gb2JqZWN0cy4gIzYxNS5cblx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovXG5cdFx0XHRcdCQuZWFjaChbJ3ByZXZlbnREZWZhdWx0JywgJ3N0b3BQcm9wYWdhdGlvbiddLCBmdW5jdGlvbiAoaSwgZm4pIHtcblx0XHRcdFx0XHR2YXIgYmFzZSA9IGV2ZW50W2ZuXTtcblx0XHRcdFx0XHRldmVudFtmbl0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRiYXNlLmNhbGwoZXZlbnQpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZm4gPT09ICdwcmV2ZW50RGVmYXVsdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XG5cdFx0XHRcdC8vIHRyaWdnZXIgaXRcblx0XHRcdFx0JChlbCkudHJpZ2dlcihldmVudCk7XG5cdFx0XG5cdFx0XHRcdC8vIGF0dGFjaCB0aGUgbWV0aG9kXG5cdFx0XHRcdGlmIChlbFtkZXRhY2hlZFR5cGVdKSB7XG5cdFx0XHRcdFx0ZWxbdHlwZV0gPSBlbFtkZXRhY2hlZFR5cGVdO1xuXHRcdFx0XHRcdGVsW2RldGFjaGVkVHlwZV0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdGlmIChkZWZhdWx0RnVuY3Rpb24gJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmICFkZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0ZGVmYXVsdEZ1bmN0aW9uKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFeHRlbnNpb24gbWV0aG9kIG5lZWRlZCBmb3IgTW9vVG9vbHNcblx0XHRcdCAqL1xuXHRcdFx0d2FzaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHZhciByZXQgPSBlLm9yaWdpbmFsRXZlbnQgfHwgZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbXB1dGVkIGJ5IGpRdWVyeSwgbmVlZGVkIGJ5IElFOFxuXHRcdFx0XHRpZiAocmV0LnBhZ2VYID09PSBVTkRFRklORUQpIHsgLy8gIzEyMzZcblx0XHRcdFx0XHRyZXQucGFnZVggPSBlLnBhZ2VYO1xuXHRcdFx0XHRcdHJldC5wYWdlWSA9IGUucGFnZVk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbmltYXRlIGEgSFRNTCBlbGVtZW50IG9yIFNWRyBlbGVtZW50IHdyYXBwZXJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgalF1ZXJ5LWxpa2UgYW5pbWF0aW9uIG9wdGlvbnM6IGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXG5cdFx0XHQgKi9cblx0XHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChlbCwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciAkZWwgPSAkKGVsKTtcblx0XHRcdFx0aWYgKCFlbC5zdHlsZSkge1xuXHRcdFx0XHRcdGVsLnN0eWxlID0ge307IC8vICMxODgxXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhcmFtcy5kKSB7XG5cdFx0XHRcdFx0ZWwudG9EID0gcGFyYW1zLmQ7IC8vIGtlZXAgdGhlIGFycmF5IGZvcm0gZm9yIHBhdGhzLCB1c2VkIGluICQuZnguc3RlcC5kXG5cdFx0XHRcdFx0cGFyYW1zLmQgPSAxOyAvLyBiZWNhdXNlIGluIGpRdWVyeSwgYW5pbWF0aW5nIHRvIGFuIGFycmF5IGhhcyBhIGRpZmZlcmVudCBtZWFuaW5nXG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0JGVsLnN0b3AoKTtcblx0XHRcdFx0aWYgKHBhcmFtcy5vcGFjaXR5ICE9PSBVTkRFRklORUQgJiYgZWwuYXR0cikge1xuXHRcdFx0XHRcdHBhcmFtcy5vcGFjaXR5ICs9ICdweCc7IC8vIGZvcmNlIGpRdWVyeSB0byB1c2Ugc2FtZSBsb2dpYyBhcyB3aWR0aCBhbmQgaGVpZ2h0ICgjMjE2MSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbC5oYXNBbmltID0gMTsgLy8gIzMzNDJcblx0XHRcdFx0JGVsLmFuaW1hdGUocGFyYW1zLCBvcHRpb25zKTtcblx0XHRcblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3AgcnVubmluZyBhbmltYXRpb25cblx0XHRcdCAqL1xuXHRcdFx0c3RvcDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdGlmIChlbC5oYXNBbmltKSB7IC8vICMzMzQyLCBtZW1vcnkgbGVhayBvbiBjYWxsaW5nICQoZWwpIGZyb20gZGVzdHJveVxuXHRcdFx0XHRcdCQoZWwpLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KHdpbi5qUXVlcnkpKTtcblxuXG5cdC8vIGNoZWNrIGZvciBhIGN1c3RvbSBIaWdoY2hhcnRzQWRhcHRlciBkZWZpbmVkIHByaW9yIHRvIHRoaXMgZmlsZVxuXHR2YXIgZ2xvYmFsQWRhcHRlciA9IHdpbi5IaWdoY2hhcnRzQWRhcHRlcixcblx0XHRhZGFwdGVyID0gZ2xvYmFsQWRhcHRlciB8fCB7fTtcblx0XHRcblx0Ly8gSW5pdGlhbGl6ZSB0aGUgYWRhcHRlclxuXHRpZiAoZ2xvYmFsQWRhcHRlcikge1xuXHRcdGdsb2JhbEFkYXB0ZXIuaW5pdC5jYWxsKGdsb2JhbEFkYXB0ZXIsIHBhdGhBbmltKTtcblx0fVxuXG5cblx0Ly8gVXRpbGl0eSBmdW5jdGlvbnMuIElmIHRoZSBIaWdoY2hhcnRzQWRhcHRlciBpcyBub3QgZGVmaW5lZCwgYWRhcHRlciBpcyBhbiBlbXB0eSBvYmplY3Rcblx0Ly8gYW5kIGFsbCB0aGUgdXRpbGl0eSBmdW5jdGlvbnMgd2lsbCBiZSBudWxsLiBJbiB0aGF0IGNhc2UgdGhleSBhcmUgcG9wdWxhdGVkIGJ5IHRoZVxuXHQvLyBkZWZhdWx0IGFkYXB0ZXJzIGJlbG93LlxuXHR2YXIgYWRhcHRlclJ1biA9IGFkYXB0ZXIuYWRhcHRlclJ1bixcblx0XHRnZXRTY3JpcHQgPSBhZGFwdGVyLmdldFNjcmlwdCxcblx0XHRpbkFycmF5ID0gYWRhcHRlci5pbkFycmF5LFxuXHRcdGVhY2ggPSBIaWdoY2hhcnRzLmVhY2ggPSBhZGFwdGVyLmVhY2gsXG5cdFx0Z3JlcCA9IGFkYXB0ZXIuZ3JlcCxcblx0XHRvZmZzZXQgPSBhZGFwdGVyLm9mZnNldCxcblx0XHRtYXAgPSBhZGFwdGVyLm1hcCxcblx0XHRhZGRFdmVudCA9IGFkYXB0ZXIuYWRkRXZlbnQsXG5cdFx0cmVtb3ZlRXZlbnQgPSBhZGFwdGVyLnJlbW92ZUV2ZW50LFxuXHRcdGZpcmVFdmVudCA9IGFkYXB0ZXIuZmlyZUV2ZW50LFxuXHRcdHdhc2hNb3VzZUV2ZW50ID0gYWRhcHRlci53YXNoTW91c2VFdmVudCxcblx0XHRhbmltYXRlID0gYWRhcHRlci5hbmltYXRlLFxuXHRcdHN0b3AgPSBhZGFwdGVyLnN0b3A7XG5cblxuXG5cdC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogSGFuZGxlIHRoZSBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdGNvbG9yczogWycjN2NiNWVjJywgJyM0MzQzNDgnLCAnIzkwZWQ3ZCcsICcjZjdhMzVjJywgXG5cdFx0XHQgICAgJyM4MDg1ZTknLCAnI2YxNWM4MCcsICcjZTRkMzU0JywgJyMyYjkwOGYnLCAnI2Y0NWI1YicsICcjOTFlOGUxJ10sXG5cdFx0c3ltYm9sczogWydjaXJjbGUnLCAnZGlhbW9uZCcsICdzcXVhcmUnLCAndHJpYW5nbGUnLCAndHJpYW5nbGUtZG93biddLFxuXHRcdGxhbmc6IHtcblx0XHRcdGxvYWRpbmc6ICdMb2FkaW5nLi4uJyxcblx0XHRcdG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLFxuXHRcdFx0XHRcdCdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcblx0XHRcdHNob3J0TW9udGhzOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG5cdFx0XHR3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdFx0ZGVjaW1hbFBvaW50OiAnLicsXG5cdFx0XHRudW1lcmljU3ltYm9sczogWydrJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRSddLCAvLyBTSSBwcmVmaXhlcyB1c2VkIGluIGF4aXMgbGFiZWxzXG5cdFx0XHRyZXNldFpvb206ICdSZXNldCB6b29tJyxcblx0XHRcdHJlc2V0Wm9vbVRpdGxlOiAnUmVzZXQgem9vbSBsZXZlbCAxOjEnLFxuXHRcdFx0dGhvdXNhbmRzU2VwOiAnICdcblx0XHR9LFxuXHRcdGdsb2JhbDoge1xuXHRcdFx0dXNlVVRDOiB0cnVlLFxuXHRcdFx0Ly90aW1lem9uZU9mZnNldDogMCxcblx0XHRcdGNhbnZhc1Rvb2xzVVJMOiAnaHR0cDovL2NvZGUuaGlnaGNoYXJ0cy5jb20vNC4xLjctbW9kaWZpZWQvbW9kdWxlcy9jYW52YXMtdG9vbHMuanMnLFxuXHRcdFx0Vk1MUmFkaWFsR3JhZGllbnRVUkw6ICdodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS80LjEuNy1tb2RpZmllZC9nZngvdm1sLXJhZGlhbC1ncmFkaWVudC5wbmcnXG5cdFx0fSxcblx0XHRjaGFydDoge1xuXHRcdFx0Ly9hbmltYXRpb246IHRydWUsXG5cdFx0XHQvL2FsaWduVGlja3M6IGZhbHNlLFxuXHRcdFx0Ly9yZWZsb3c6IHRydWUsXG5cdFx0XHQvL2NsYXNzTmFtZTogbnVsbCxcblx0XHRcdC8vZXZlbnRzOiB7IGxvYWQsIHNlbGVjdGlvbiB9LFxuXHRcdFx0Ly9tYXJnaW46IFtudWxsXSxcblx0XHRcdC8vbWFyZ2luVG9wOiBudWxsLFxuXHRcdFx0Ly9tYXJnaW5SaWdodDogbnVsbCxcblx0XHRcdC8vbWFyZ2luQm90dG9tOiBudWxsLFxuXHRcdFx0Ly9tYXJnaW5MZWZ0OiBudWxsLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICcjNDU3MkE3Jyxcblx0XHRcdC8vYm9yZGVyV2lkdGg6IDAsXG5cdFx0XHRib3JkZXJSYWRpdXM6IDAsXG5cdFx0XHRkZWZhdWx0U2VyaWVzVHlwZTogJ2xpbmUnLFxuXHRcdFx0aWdub3JlSGlkZGVuU2VyaWVzOiB0cnVlLFxuXHRcdFx0Ly9pbnZlcnRlZDogZmFsc2UsXG5cdFx0XHQvL3NoYWRvdzogZmFsc2UsXG5cdFx0XHRzcGFjaW5nOiBbMTAsIDEwLCAxNSwgMTBdLFxuXHRcdFx0Ly9zcGFjaW5nVG9wOiAxMCxcblx0XHRcdC8vc3BhY2luZ1JpZ2h0OiAxMCxcblx0XHRcdC8vc3BhY2luZ0JvdHRvbTogMTUsXG5cdFx0XHQvL3NwYWNpbmdMZWZ0OiAxMCxcblx0XHRcdC8vc3R5bGU6IHtcblx0XHRcdC8vXHRmb250RmFtaWx5OiAnXCJMdWNpZGEgR3JhbmRlXCIsIFwiTHVjaWRhIFNhbnMgVW5pY29kZVwiLCBWZXJkYW5hLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJywgLy8gZGVmYXVsdCBmb250XG5cdFx0XHQvL1x0Zm9udFNpemU6ICcxMnB4J1xuXHRcdFx0Ly99LFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAnI0ZGRkZGRicsXG5cdFx0XHQvL3Bsb3RCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cdFx0XHRwbG90Qm9yZGVyQ29sb3I6ICcjQzBDMEMwJyxcblx0XHRcdC8vcGxvdEJvcmRlcldpZHRoOiAwLFxuXHRcdFx0Ly9wbG90U2hhZG93OiBmYWxzZSxcblx0XHRcdC8vem9vbVR5cGU6ICcnXG5cdFx0XHRyZXNldFpvb21CdXR0b246IHtcblx0XHRcdFx0dGhlbWU6IHtcblx0XHRcdFx0XHR6SW5kZXg6IDIwXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdFx0YWxpZ246ICdyaWdodCcsXG5cdFx0XHRcdFx0eDogLTEwLFxuXHRcdFx0XHRcdC8vdmVydGljYWxBbGlnbjogJ3RvcCcsXG5cdFx0XHRcdFx0eTogMTBcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZWxhdGl2ZVRvOiAncGxvdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRpdGxlOiB7XG5cdFx0XHR0ZXh0OiAnQ2hhcnQgdGl0bGUnLFxuXHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0Ly8gZmxvYXRpbmc6IGZhbHNlLFxuXHRcdFx0bWFyZ2luOiAxNSxcblx0XHRcdC8vIHg6IDAsXG5cdFx0XHQvLyB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcblx0XHRcdC8vIHk6IG51bGwsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyMzMzMzMzMnLFxuXHRcdFx0XHRmb250U2l6ZTogJzE4cHgnXG5cdFx0XHR9XG5cblx0XHR9LFxuXHRcdHN1YnRpdGxlOiB7XG5cdFx0XHR0ZXh0OiAnJyxcblx0XHRcdGFsaWduOiAnY2VudGVyJyxcblx0XHRcdC8vIGZsb2F0aW5nOiBmYWxzZVxuXHRcdFx0Ly8geDogMCxcblx0XHRcdC8vIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdFx0Ly8geTogbnVsbCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzU1NTU1NSdcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cGxvdE9wdGlvbnM6IHtcblx0XHRcdGxpbmU6IHsgLy8gYmFzZSBzZXJpZXMgb3B0aW9uc1xuXHRcdFx0XHRhbGxvd1BvaW50U2VsZWN0OiBmYWxzZSxcblx0XHRcdFx0c2hvd0NoZWNrYm94OiBmYWxzZSxcblx0XHRcdFx0YW5pbWF0aW9uOiB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IDEwMDBcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly9jb25uZWN0TnVsbHM6IGZhbHNlLFxuXHRcdFx0XHQvL2N1cnNvcjogJ2RlZmF1bHQnLFxuXHRcdFx0XHQvL2NsaXA6IHRydWUsXG5cdFx0XHRcdC8vZGFzaFN0eWxlOiBudWxsLFxuXHRcdFx0XHQvL2VuYWJsZU1vdXNlVHJhY2tpbmc6IHRydWUsXG5cdFx0XHRcdGV2ZW50czoge30sXG5cdFx0XHRcdC8vbGVnZW5kSW5kZXg6IDAsXG5cdFx0XHRcdC8vbGluZWNhcDogJ3JvdW5kJyxcblx0XHRcdFx0bGluZVdpZHRoOiAyLFxuXHRcdFx0XHQvL3NoYWRvdzogZmFsc2UsXG5cdFx0XHRcdC8vIHN0YWNraW5nOiBudWxsLFxuXHRcdFx0XHRtYXJrZXI6IHtcblx0XHRcdFx0XHQvL2VuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdFx0Ly9zeW1ib2w6IG51bGwsXG5cdFx0XHRcdFx0bGluZVdpZHRoOiAwLFxuXHRcdFx0XHRcdHJhZGl1czogNCxcblx0XHRcdFx0XHRsaW5lQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0XHQvL2ZpbGxDb2xvcjogbnVsbCxcblx0XHRcdFx0XHRzdGF0ZXM6IHsgLy8gc3RhdGVzIGZvciBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoUGx1czogMSxcblx0XHRcdFx0XHRcdFx0cmFkaXVzUGx1czogMlxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRcdFx0XHRmaWxsQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0XHRcdFx0bGluZUNvbG9yOiAnIzAwMDAwMCcsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogMlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cG9pbnQ6IHtcblx0XHRcdFx0XHRldmVudHM6IHt9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhdGFMYWJlbHM6IHtcblx0XHRcdFx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHRcdFx0Ly8gZGVmZXI6IHRydWUsXG5cdFx0XHRcdFx0Ly8gZW5hYmxlZDogZmFsc2UsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy55ID09PSBudWxsID8gJycgOiBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh0aGlzLnksIC0xKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRjb2xvcjogJ2NvbnRyYXN0Jyxcblx0XHRcdFx0XHRcdGZvbnRTaXplOiAnMTFweCcsXG5cdFx0XHRcdFx0XHRmb250V2VpZ2h0OiAnYm9sZCcsXG5cdFx0XHRcdFx0XHR0ZXh0U2hhZG93OiAnMCAwIDZweCBjb250cmFzdCwgMCAwIDNweCBjb250cmFzdCdcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHZlcnRpY2FsQWxpZ246ICdib3R0b20nLCAvLyBhYm92ZSBzaW5ndWxhciBwb2ludFxuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHQvLyBiYWNrZ3JvdW5kQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHQvLyBib3JkZXJDb2xvcjogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdC8vIGJvcmRlclJhZGl1czogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdC8vIGJvcmRlcldpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0cGFkZGluZzogNVxuXHRcdFx0XHRcdC8vIHNoYWRvdzogZmFsc2Vcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3JvcFRocmVzaG9sZDogMzAwLCAvLyBkcmF3IHBvaW50cyBvdXRzaWRlIHRoZSBwbG90IGFyZWEgd2hlbiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpcyBsZXNzIHRoYW4gdGhpc1xuXHRcdFx0XHRwb2ludFJhbmdlOiAwLFxuXHRcdFx0XHQvL3BvaW50U3RhcnQ6IDAsXG5cdFx0XHRcdC8vcG9pbnRJbnRlcnZhbDogMSxcblx0XHRcdFx0Ly9zaG93SW5MZWdlbmQ6IG51bGwsIC8vIGF1dG86IHRydWUgZm9yIHN0YW5kYWxvbmUgc2VyaWVzLCBmYWxzZSBmb3IgbGlua2VkIHNlcmllc1xuXHRcdFx0XHRzdGF0ZXM6IHsgLy8gc3RhdGVzIGZvciB0aGUgZW50aXJlIHNlcmllc1xuXHRcdFx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdFx0XHQvL2VuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoUGx1czogMSxcblx0XHRcdFx0XHRcdG1hcmtlcjoge1xuXHRcdFx0XHRcdFx0XHQvLyBsaW5lV2lkdGg6IGJhc2UgKyAxLFxuXHRcdFx0XHRcdFx0XHQvLyByYWRpdXM6IGJhc2UgKyAxXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aGFsbzoge1xuXHRcdFx0XHRcdFx0XHRzaXplOiAxMCxcblx0XHRcdFx0XHRcdFx0b3BhY2l0eTogMC4yNVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRtYXJrZXI6IHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdGlja3lUcmFja2luZzogdHJ1ZSxcblx0XHRcdFx0Ly90b29sdGlwOiB7XG5cdFx0XHRcdFx0Ly9wb2ludEZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Q0Y8L3NwYW4+IHtzZXJpZXMubmFtZX06IDxiPntwb2ludC55fTwvYj4nXG5cdFx0XHRcdFx0Ly92YWx1ZURlY2ltYWxzOiBudWxsLFxuXHRcdFx0XHRcdC8veERhdGVGb3JtYXQ6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdFx0XHQvL3ZhbHVlUHJlZml4OiAnJyxcblx0XHRcdFx0XHQvL3lTdWZmaXg6ICcnXHRcdFx0XHRcblx0XHRcdFx0Ly99XG5cdFx0XHRcdHR1cmJvVGhyZXNob2xkOiAxMDAwXG5cdFx0XHRcdC8vIHpJbmRleDogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGFiZWxzOiB7XG5cdFx0XHQvL2l0ZW1zOiBbXSxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdC8vZm9udDogZGVmYXVsdEZvbnQsXG5cdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0Y29sb3I6ICcjM0U1NzZGJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGVnZW5kOiB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0Ly9mbG9hdGluZzogZmFsc2UsXG5cdFx0XHRsYXlvdXQ6ICdob3Jpem9udGFsJyxcblx0XHRcdGxhYmVsRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5hbWU7XG5cdFx0XHR9LFxuXHRcdFx0Ly9ib3JkZXJXaWR0aDogMCxcblx0XHRcdGJvcmRlckNvbG9yOiAnIzkwOTA5MCcsXG5cdFx0XHRib3JkZXJSYWRpdXM6IDAsXG5cdFx0XHRuYXZpZ2F0aW9uOiB7XG5cdFx0XHRcdC8vIGFuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdFx0YWN0aXZlQ29sb3I6ICcjMjc0YjZkJyxcblx0XHRcdFx0Ly8gYXJyb3dTaXplOiAxMlxuXHRcdFx0XHRpbmFjdGl2ZUNvbG9yOiAnI0NDQydcblx0XHRcdFx0Ly8gc3R5bGU6IHt9IC8vIHRleHQgc3R5bGVzXG5cdFx0XHR9LFxuXHRcdFx0Ly8gbWFyZ2luOiAyMCxcblx0XHRcdC8vIHJldmVyc2VkOiBmYWxzZSxcblx0XHRcdHNoYWRvdzogZmFsc2UsXG5cdFx0XHQvLyBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cdFx0XHQvKnN0eWxlOiB7XG5cdFx0XHRcdHBhZGRpbmc6ICc1cHgnXG5cdFx0XHR9LCovXG5cdFx0XHRpdGVtU3R5bGU6IHtcdFx0XHRcblx0XHRcdFx0Y29sb3I6ICcjMzMzMzMzJyxcblx0XHRcdFx0Zm9udFNpemU6ICcxMnB4Jyxcblx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnXG5cdFx0XHR9LFxuXHRcdFx0aXRlbUhvdmVyU3R5bGU6IHtcblx0XHRcdFx0Ly9jdXJzb3I6ICdwb2ludGVyJywgcmVtb3ZlZCBhcyBvZiAjNjAxXG5cdFx0XHRcdGNvbG9yOiAnIzAwMCdcblx0XHRcdH0sXG5cdFx0XHRpdGVtSGlkZGVuU3R5bGU6IHtcblx0XHRcdFx0Y29sb3I6ICcjQ0NDJ1xuXHRcdFx0fSxcblx0XHRcdGl0ZW1DaGVja2JveFN0eWxlOiB7XG5cdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0d2lkdGg6ICcxM3B4JywgLy8gZm9yIElFIHByZWNpc2lvblxuXHRcdFx0XHRoZWlnaHQ6ICcxM3B4J1xuXHRcdFx0fSxcblx0XHRcdC8vIGl0ZW1XaWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0Ly8gc3ltYm9sUmFkaXVzOiAwLFxuXHRcdFx0Ly8gc3ltYm9sV2lkdGg6IDE2LFxuXHRcdFx0c3ltYm9sUGFkZGluZzogNSxcblx0XHRcdHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxuXHRcdFx0Ly8gd2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiAwLFxuXHRcdFx0dGl0bGU6IHtcblx0XHRcdFx0Ly90ZXh0OiBudWxsLFxuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGZvbnRXZWlnaHQ6ICdib2xkJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XHRcdFx0XG5cdFx0fSxcblxuXHRcdGxvYWRpbmc6IHtcblx0XHRcdC8vIGhpZGVEdXJhdGlvbjogMTAwLFxuXHRcdFx0bGFiZWxTdHlsZToge1xuXHRcdFx0XHRmb250V2VpZ2h0OiAnYm9sZCcsXG5cdFx0XHRcdHBvc2l0aW9uOiBSRUxBVElWRSxcblx0XHRcdFx0dG9wOiAnNDUlJ1xuXHRcdFx0fSxcblx0XHRcdC8vIHNob3dEdXJhdGlvbjogMCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRcdHRleHRBbGlnbjogJ2NlbnRlcidcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dG9vbHRpcDoge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdGFuaW1hdGlvbjogaGFzU1ZHLFxuXHRcdFx0Ly9jcm9zc2hhaXJzOiBudWxsLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgyNDksIDI0OSwgMjQ5LCAuODUpJyxcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdFx0Ym9yZGVyUmFkaXVzOiAzLFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6IHsgXG5cdFx0XHRcdG1pbGxpc2Vjb25kOiAnJUEsICViICVlLCAlSDolTTolUy4lTCcsXG5cdFx0XHRcdHNlY29uZDogJyVBLCAlYiAlZSwgJUg6JU06JVMnLFxuXHRcdFx0XHRtaW51dGU6ICclQSwgJWIgJWUsICVIOiVNJyxcblx0XHRcdFx0aG91cjogJyVBLCAlYiAlZSwgJUg6JU0nLFxuXHRcdFx0XHRkYXk6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdFx0d2VlazogJ1dlZWsgZnJvbSAlQSwgJWIgJWUsICVZJyxcblx0XHRcdFx0bW9udGg6ICclQiAlWScsXG5cdFx0XHRcdHllYXI6ICclWSdcblx0XHRcdH0sXG5cdFx0XHRmb290ZXJGb3JtYXQ6ICcnLFxuXHRcdFx0Ly9mb3JtYXR0ZXI6IGRlZmF1bHRGb3JtYXR0ZXIsXG5cdFx0XHRoZWFkZXJGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPntwb2ludC5rZXl9PC9zcGFuPjxici8+Jyxcblx0XHRcdHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVDRjwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50Lnl9PC9iPjxici8+Jyxcblx0XHRcdHNoYWRvdzogdHJ1ZSxcblx0XHRcdC8vc2hhcGU6ICdjYWxsb3V0Jyxcblx0XHRcdC8vc2hhcmVkOiBmYWxzZSxcblx0XHRcdHNuYXA6IGlzVG91Y2hEZXZpY2UgPyAyNSA6IDEwLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Y29sb3I6ICcjMzMzMzMzJyxcblx0XHRcdFx0Y3Vyc29yOiAnZGVmYXVsdCcsXG5cdFx0XHRcdGZvbnRTaXplOiAnMTJweCcsXG5cdFx0XHRcdHBhZGRpbmc6ICc4cHgnLFxuXHRcdFx0XHR3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuXHRcdFx0fVxuXHRcdFx0Ly94RGF0ZUZvcm1hdDogJyVBLCAlYiAlZSwgJVknLFxuXHRcdFx0Ly92YWx1ZURlY2ltYWxzOiBudWxsLFxuXHRcdFx0Ly92YWx1ZVByZWZpeDogJycsXG5cdFx0XHQvL3ZhbHVlU3VmZml4OiAnJ1xuXHRcdH0sXG5cblx0XHRjcmVkaXRzOiB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0dGV4dDogJ0hpZ2hjaGFydHMuY29tJyxcblx0XHRcdGhyZWY6ICdodHRwOi8vd3d3LmhpZ2hjaGFydHMuY29tJyxcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGFsaWduOiAncmlnaHQnLFxuXHRcdFx0XHR4OiAtMTAsXG5cdFx0XHRcdHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxuXHRcdFx0XHR5OiAtNVxuXHRcdFx0fSxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGN1cnNvcjogJ3BvaW50ZXInLFxuXHRcdFx0XHRjb2xvcjogJyM5MDkwOTAnLFxuXHRcdFx0XHRmb250U2l6ZTogJzlweCdcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXG5cblx0Ly8gU2VyaWVzIGRlZmF1bHRzXG5cdHZhciBkZWZhdWx0UGxvdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucy5wbG90T3B0aW9ucyxcblx0XHRkZWZhdWx0U2VyaWVzT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9ucy5saW5lO1xuXG5cdC8vIHNldCB0aGUgZGVmYXVsdCB0aW1lIG1ldGhvZHNcblx0c2V0VGltZU1ldGhvZHMoKTtcblxuXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdGltZSBtZXRob2RzIGdsb2JhbGx5IGJhc2VkIG9uIHRoZSB1c2VVVEMgb3B0aW9uLiBUaW1lIG1ldGhvZCBjYW4gYmUgZWl0aGVyXG5cdCAqIGxvY2FsIHRpbWUgb3IgVVRDIChkZWZhdWx0KS5cblx0ICovXG5cdGZ1bmN0aW9uIHNldFRpbWVNZXRob2RzKCkge1xuXHRcdHZhciBnbG9iYWxPcHRpb25zID0gZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLFxuXHRcdFx0dXNlVVRDID0gZ2xvYmFsT3B0aW9ucy51c2VVVEMsXG5cdFx0XHRHRVQgPSB1c2VVVEMgPyAnZ2V0VVRDJyA6ICdnZXQnLFxuXHRcdFx0U0VUID0gdXNlVVRDID8gJ3NldFVUQycgOiAnc2V0JztcblxuXG5cdFx0RGF0ZSA9IGdsb2JhbE9wdGlvbnMuRGF0ZSB8fCB3aW5kb3cuRGF0ZTtcblx0XHR0aW1lem9uZU9mZnNldCA9IHVzZVVUQyAmJiBnbG9iYWxPcHRpb25zLnRpbWV6b25lT2Zmc2V0O1xuXHRcdGdldFRpbWV6b25lT2Zmc2V0ID0gdXNlVVRDICYmIGdsb2JhbE9wdGlvbnMuZ2V0VGltZXpvbmVPZmZzZXQ7XG5cdFx0bWFrZVRpbWUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG5cdFx0XHR2YXIgZDtcblx0XHRcdGlmICh1c2VVVEMpIHtcblx0XHRcdFx0ZCA9IERhdGUuVVRDLmFwcGx5KDAsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGQgKz0gZ2V0VFpPZmZzZXQoZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkID0gbmV3IERhdGUoXG5cdFx0XHRcdFx0eWVhcixcblx0XHRcdFx0XHRtb250aCxcblx0XHRcdFx0XHRwaWNrKGRhdGUsIDEpLFxuXHRcdFx0XHRcdHBpY2soaG91cnMsIDApLFxuXHRcdFx0XHRcdHBpY2sobWludXRlcywgMCksXG5cdFx0XHRcdFx0cGljayhzZWNvbmRzLCAwKVxuXHRcdFx0XHQpLmdldFRpbWUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkO1xuXHRcdH07XG5cdFx0Z2V0TWludXRlcyA9ICAgICAgR0VUICsgJ01pbnV0ZXMnO1xuXHRcdGdldEhvdXJzID0gICAgICAgIEdFVCArICdIb3Vycyc7XG5cdFx0Z2V0RGF5ID0gICAgICAgICAgR0VUICsgJ0RheSc7XG5cdFx0Z2V0RGF0ZSA9ICAgICAgICAgR0VUICsgJ0RhdGUnO1xuXHRcdGdldE1vbnRoID0gICAgICAgIEdFVCArICdNb250aCc7XG5cdFx0Z2V0RnVsbFllYXIgPSAgICAgR0VUICsgJ0Z1bGxZZWFyJztcblx0XHRzZXRNaWxsaXNlY29uZHMgPSBTRVQgKyAnTWlsbGlzZWNvbmRzJztcblx0XHRzZXRTZWNvbmRzID0gICAgICBTRVQgKyAnU2Vjb25kcyc7XG5cdFx0c2V0TWludXRlcyA9ICAgICAgU0VUICsgJ01pbnV0ZXMnO1xuXHRcdHNldEhvdXJzID0gICAgICAgIFNFVCArICdIb3Vycyc7XG5cdFx0c2V0RGF0ZSA9ICAgICAgICAgU0VUICsgJ0RhdGUnO1xuXHRcdHNldE1vbnRoID0gICAgICAgIFNFVCArICdNb250aCc7XG5cdFx0c2V0RnVsbFllYXIgPSAgICAgU0VUICsgJ0Z1bGxZZWFyJztcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlIHRoZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCBjdXN0b20gb3B0aW9ucyBhbmQgcmV0dXJuIHRoZSBuZXcgb3B0aW9ucyBzdHJ1Y3R1cmVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG5ldyBjdXN0b20gb3B0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0XG5cdFx0Ly8gQ29weSBpbiB0aGUgZGVmYXVsdCBvcHRpb25zXG5cdFx0ZGVmYXVsdE9wdGlvbnMgPSBtZXJnZSh0cnVlLCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XG5cdFx0Ly8gQXBwbHkgVVRDXG5cdFx0c2V0VGltZU1ldGhvZHMoKTtcblxuXHRcdHJldHVybiBkZWZhdWx0T3B0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHVwZGF0ZWQgZGVmYXVsdCBvcHRpb25zLiBVbnRpbCAzLjAuNywgbWVyZWx5IGV4cG9zaW5nIGRlZmF1bHRPcHRpb25zIGZvciBvdXRzaWRlIG1vZHVsZXNcblx0ICogd2Fzbid0IGVub3VnaCBiZWNhdXNlIHRoZSBzZXRPcHRpb25zIG1ldGhvZCBjcmVhdGVkIGEgbmV3IG9iamVjdC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuXHR9XG5cblxuXHQvKipcblx0ICogSGFuZGxlIGNvbG9yIG9wZXJhdGlvbnMuIFRoZSBvYmplY3QgbWV0aG9kcyBhcmUgY2hhaW5hYmxlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGlucHV0IGNvbG9yIGluIGVpdGhlciByYmdhIG9yIGhleCBmb3JtYXRcblx0ICovXG5cdHZhciByZ2JhUmVnRXggPSAvcmdiYVxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV0/KD86XFwuWzAtOV0rKT8pXFxzKlxcKS8sXG5cdFx0aGV4UmVnRXggPSAvIyhbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pKFthLWZBLUYwLTldezJ9KS8sXG5cdFx0cmdiUmVnRXggPSAvcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvO1xuXG5cdHZhciBDb2xvciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRcdC8vIGRlY2xhcmUgdmFyaWFibGVzXG5cdFx0dmFyIHJnYmEgPSBbXSwgcmVzdWx0LCBzdG9wcztcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlIHRoZSBpbnB1dCBjb2xvciB0byByZ2JhIGFycmF5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW5pdChpbnB1dCkge1xuXG5cdFx0XHQvLyBHcmFkaWVudHNcblx0XHRcdGlmIChpbnB1dCAmJiBpbnB1dC5zdG9wcykge1xuXHRcdFx0XHRzdG9wcyA9IG1hcChpbnB1dC5zdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0XHRyZXR1cm4gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBTb2xpZCBjb2xvcnNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJnYmFcblx0XHRcdFx0cmVzdWx0ID0gcmdiYVJlZ0V4LmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSksIHBJbnQocmVzdWx0WzJdKSwgcEludChyZXN1bHRbM10pLCBwYXJzZUZsb2F0KHJlc3VsdFs0XSwgMTApXTtcblx0XHRcdFx0fSBlbHNlIHsgXG5cdFx0XHRcdFx0Ly8gaGV4XG5cdFx0XHRcdFx0cmVzdWx0ID0gaGV4UmVnRXguZXhlYyhpbnB1dCk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSwgMTYpLCBwSW50KHJlc3VsdFsyXSwgMTYpLCBwSW50KHJlc3VsdFszXSwgMTYpLCAxXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmdiXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSByZ2JSZWdFeC5leGVjKGlucHV0KTtcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSksIHBJbnQocmVzdWx0WzJdKSwgcEludChyZXN1bHRbM10pLCAxXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cdFx0XG5cblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBjb2xvciBhIHNwZWNpZmllZCBmb3JtYXRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0KGZvcm1hdCkge1xuXHRcdFx0dmFyIHJldDtcblxuXHRcdFx0aWYgKHN0b3BzKSB7XG5cdFx0XHRcdHJldCA9IG1lcmdlKGlucHV0KTtcblx0XHRcdFx0cmV0LnN0b3BzID0gW10uY29uY2F0KHJldC5zdG9wcyk7XG5cdFx0XHRcdGVhY2goc3RvcHMsIGZ1bmN0aW9uIChzdG9wLCBpKSB7XG5cdFx0XHRcdFx0cmV0LnN0b3BzW2ldID0gW3JldC5zdG9wc1tpXVswXSwgc3RvcC5nZXQoZm9ybWF0KV07XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBpdCdzIE5hTiBpZiBncmFkaWVudCBjb2xvcnMgb24gYSBjb2x1bW4gY2hhcnRcblx0XHRcdH0gZWxzZSBpZiAocmdiYSAmJiAhaXNOYU4ocmdiYVswXSkpIHtcblx0XHRcdFx0aWYgKGZvcm1hdCA9PT0gJ3JnYicpIHtcblx0XHRcdFx0XHRyZXQgPSAncmdiKCcgKyByZ2JhWzBdICsgJywnICsgcmdiYVsxXSArICcsJyArIHJnYmFbMl0gKyAnKSc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnYScpIHtcblx0XHRcdFx0XHRyZXQgPSByZ2JhWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9ICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0ID0gaW5wdXQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEJyaWdodGVuIHRoZSBjb2xvclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJyaWdodGVuKGFscGhhKSB7XG5cdFx0XHRpZiAoc3RvcHMpIHtcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0XHRzdG9wLmJyaWdodGVuKGFscGhhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoYWxwaGEpICYmIGFscGhhICE9PSAwKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdFx0cmdiYVtpXSArPSBwSW50KGFscGhhICogMjU1KTtcblxuXHRcdFx0XHRcdGlmIChyZ2JhW2ldIDwgMCkge1xuXHRcdFx0XHRcdFx0cmdiYVtpXSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZ2JhW2ldID4gMjU1KSB7XG5cdFx0XHRcdFx0XHRyZ2JhW2ldID0gMjU1O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgY29sb3IncyBvcGFjaXR5IHRvIGEgZ2l2ZW4gYWxwaGEgdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzZXRPcGFjaXR5KGFscGhhKSB7XG5cdFx0XHRyZ2JhWzNdID0gYWxwaGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplOiBwYXJzZSB0aGUgaW5wdXRcblx0XHRpbml0KGlucHV0KTtcblxuXHRcdC8vIHB1YmxpYyBtZXRob2RzXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0YnJpZ2h0ZW46IGJyaWdodGVuLFxuXHRcdFx0cmdiYTogcmdiYSxcblx0XHRcdHNldE9wYWNpdHk6IHNldE9wYWNpdHksXG5cdFx0XHRyYXc6IGlucHV0XG5cdFx0fTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBIHdyYXBwZXIgb2JqZWN0IGZvciBTVkcgZWxlbWVudHNcblx0ICovXG5cdGZ1bmN0aW9uIFNWR0VsZW1lbnQoKSB7fVxuXG5cdFNWR0VsZW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFxuXHRcdC8vIERlZmF1bHQgYmFzZSBmb3IgYW5pbWF0aW9uXG5cdFx0b3BhY2l0eTogMSxcblx0XHQvLyBGb3IgbGFiZWxzLCB0aGVzZSBDU1MgcHJvcGVydGllcyBhcmUgYXBwbGllZCB0byB0aGUgPHRleHQ+IG5vZGUgZGlyZWN0bHlcblx0XHR0ZXh0UHJvcHM6IFsnZm9udFNpemUnLCAnZm9udFdlaWdodCcsICdmb250RmFtaWx5JywgJ2ZvbnRTdHlsZScsICdjb2xvcicsIFxuXHRcdFx0J2xpbmVIZWlnaHQnLCAnd2lkdGgnLCAndGV4dERlY29yYXRpb24nLCAndGV4dE92ZXJmbG93JywgJ3RleHRTaGFkb3cnXSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBTVkcgcmVuZGVyZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyZXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAocmVuZGVyZXIsIG5vZGVOYW1lKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXM7XG5cdFx0XHR3cmFwcGVyLmVsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3NwYW4nID9cblx0XHRcdFx0Y3JlYXRlRWxlbWVudChub2RlTmFtZSkgOlxuXHRcdFx0XHRkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgbm9kZU5hbWUpO1xuXHRcdFx0d3JhcHBlci5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBhIGdpdmVuIGF0dHJpYnV0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucyBUaGUgc2FtZSBvcHRpb25zIGFzIGluIGpRdWVyeSBhbmltYXRpb25cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSBGdW5jdGlvbiB0byBwZXJmb3JtIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucywgY29tcGxldGUpIHtcblx0XHRcdHZhciBhbmltT3B0aW9ucyA9IHBpY2sob3B0aW9ucywgZ2xvYmFsQW5pbWF0aW9uLCB0cnVlKTtcblx0XHRcdHN0b3AodGhpcyk7IC8vIHN0b3AgcmVnYXJkbGVzcyBvZiBhbmltYXRpb24gYWN0dWFsbHkgcnVubmluZywgb3IgcmV2ZXJ0aW5nIHRvIC5hdHRyICgjNjA3KVxuXHRcdFx0aWYgKGFuaW1PcHRpb25zKSB7XG5cdFx0XHRcdGFuaW1PcHRpb25zID0gbWVyZ2UoYW5pbU9wdGlvbnMsIHt9KTsgLy8jMjYyNVxuXHRcdFx0XHRpZiAoY29tcGxldGUpIHsgLy8gYWxsb3dzIHVzaW5nIGEgY2FsbGJhY2sgd2l0aCB0aGUgZ2xvYmFsIGFuaW1hdGlvbiB3aXRob3V0IG92ZXJ3cml0aW5nIGl0XG5cdFx0XHRcdFx0YW5pbU9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmltYXRlKHRoaXMsIHBhcmFtcywgYW5pbU9wdGlvbnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hdHRyKHBhcmFtcywgbnVsbCwgY29tcGxldGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEJ1aWxkIGFuIFNWRyBncmFkaWVudCBvdXQgb2YgYSBjb21tb24gSmF2YVNjcmlwdCBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqL1xuXHRcdGNvbG9yR3JhZGllbnQ6IGZ1bmN0aW9uIChjb2xvciwgcHJvcCwgZWxlbSkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0Y29sb3JPYmplY3QsXG5cdFx0XHRcdGdyYWROYW1lLFxuXHRcdFx0XHRncmFkQXR0cixcblx0XHRcdFx0Z3JhZGllbnRzLFxuXHRcdFx0XHRncmFkaWVudE9iamVjdCxcblx0XHRcdFx0c3RvcHMsXG5cdFx0XHRcdHN0b3BDb2xvcixcblx0XHRcdFx0c3RvcE9wYWNpdHksXG5cdFx0XHRcdHJhZGlhbFJlZmVyZW5jZSxcblx0XHRcdFx0bixcblx0XHRcdFx0aWQsXG5cdFx0XHRcdGtleSA9IFtdO1xuXG5cdFx0XHQvLyBBcHBseSBsaW5lYXIgb3IgcmFkaWFsIGdyYWRpZW50c1xuXHRcdFx0aWYgKGNvbG9yLmxpbmVhckdyYWRpZW50KSB7XG5cdFx0XHRcdGdyYWROYW1lID0gJ2xpbmVhckdyYWRpZW50Jztcblx0XHRcdH0gZWxzZSBpZiAoY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdFx0Z3JhZE5hbWUgPSAncmFkaWFsR3JhZGllbnQnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3JhZE5hbWUpIHtcblx0XHRcdFx0Z3JhZEF0dHIgPSBjb2xvcltncmFkTmFtZV07XG5cdFx0XHRcdGdyYWRpZW50cyA9IHJlbmRlcmVyLmdyYWRpZW50cztcblx0XHRcdFx0c3RvcHMgPSBjb2xvci5zdG9wcztcblx0XHRcdFx0cmFkaWFsUmVmZXJlbmNlID0gZWxlbS5yYWRpYWxSZWZlcmVuY2U7XG5cblx0XHRcdFx0Ly8gS2VlcCA8IDIuMiBrb21wYXRpYmlsaXR5XG5cdFx0XHRcdGlmIChpc0FycmF5KGdyYWRBdHRyKSkge1xuXHRcdFx0XHRcdGNvbG9yW2dyYWROYW1lXSA9IGdyYWRBdHRyID0ge1xuXHRcdFx0XHRcdFx0eDE6IGdyYWRBdHRyWzBdLFxuXHRcdFx0XHRcdFx0eTE6IGdyYWRBdHRyWzFdLFxuXHRcdFx0XHRcdFx0eDI6IGdyYWRBdHRyWzJdLFxuXHRcdFx0XHRcdFx0eTI6IGdyYWRBdHRyWzNdLFxuXHRcdFx0XHRcdFx0Z3JhZGllbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb3JyZWN0IHRoZSByYWRpYWwgZ3JhZGllbnQgZm9yIHRoZSByYWRpYWwgcmVmZXJlbmNlIHN5c3RlbVxuXHRcdFx0XHRpZiAoZ3JhZE5hbWUgPT09ICdyYWRpYWxHcmFkaWVudCcgJiYgcmFkaWFsUmVmZXJlbmNlICYmICFkZWZpbmVkKGdyYWRBdHRyLmdyYWRpZW50VW5pdHMpKSB7XG5cdFx0XHRcdFx0Z3JhZEF0dHIgPSBtZXJnZShncmFkQXR0ciwge1xuXHRcdFx0XHRcdFx0Y3g6IChyYWRpYWxSZWZlcmVuY2VbMF0gLSByYWRpYWxSZWZlcmVuY2VbMl0gLyAyKSArIGdyYWRBdHRyLmN4ICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdFx0Y3k6IChyYWRpYWxSZWZlcmVuY2VbMV0gLSByYWRpYWxSZWZlcmVuY2VbMl0gLyAyKSArIGdyYWRBdHRyLmN5ICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdFx0cjogZ3JhZEF0dHIuciAqIHJhZGlhbFJlZmVyZW5jZVsyXSxcblx0XHRcdFx0XHRcdGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEJ1aWxkIHRoZSB1bmlxdWUga2V5IHRvIGRldGVjdCB3aGV0aGVyIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgKCMxMjgyKVxuXHRcdFx0XHRmb3IgKG4gaW4gZ3JhZEF0dHIpIHtcblx0XHRcdFx0XHRpZiAobiAhPT0gJ2lkJykge1xuXHRcdFx0XHRcdFx0a2V5LnB1c2gobiwgZ3JhZEF0dHJbbl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKG4gaW4gc3RvcHMpIHtcblx0XHRcdFx0XHRrZXkucHVzaChzdG9wc1tuXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0ga2V5LmpvaW4oJywnKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBhIGdyYWRpZW50IG9iamVjdCB3aXRoIHRoZSBzYW1lIGNvbmZpZyBvYmplY3QgaXMgY3JlYXRlZCB3aXRoaW4gdGhpcyByZW5kZXJlclxuXHRcdFx0XHRpZiAoZ3JhZGllbnRzW2tleV0pIHtcblx0XHRcdFx0XHRpZCA9IGdyYWRpZW50c1trZXldLmF0dHIoJ2lkJyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFNldCB0aGUgaWQgYW5kIGNyZWF0ZSB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGdyYWRBdHRyLmlkID0gaWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKztcblx0XHRcdFx0XHRncmFkaWVudHNba2V5XSA9IGdyYWRpZW50T2JqZWN0ID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChncmFkTmFtZSlcblx0XHRcdFx0XHRcdC5hdHRyKGdyYWRBdHRyKVxuXHRcdFx0XHRcdFx0LmFkZChyZW5kZXJlci5kZWZzKTtcblxuXG5cdFx0XHRcdFx0Ly8gVGhlIGdyYWRpZW50IG5lZWRzIHRvIGtlZXAgYSBsaXN0IG9mIHN0b3BzIHRvIGJlIGFibGUgdG8gZGVzdHJveSB0aGVtXG5cdFx0XHRcdFx0Z3JhZGllbnRPYmplY3Quc3RvcHMgPSBbXTtcblx0XHRcdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuXHRcdFx0XHRcdFx0dmFyIHN0b3BPYmplY3Q7XG5cdFx0XHRcdFx0XHRpZiAoc3RvcFsxXS5pbmRleE9mKCdyZ2JhJykgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Y29sb3JPYmplY3QgPSBDb2xvcihzdG9wWzFdKTtcblx0XHRcdFx0XHRcdFx0c3RvcENvbG9yID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblx0XHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3BbMV07XG5cdFx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0b3BPYmplY3QgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzdG9wJykuYXR0cih7XG5cdFx0XHRcdFx0XHRcdG9mZnNldDogc3RvcFswXSxcblx0XHRcdFx0XHRcdFx0J3N0b3AtY29sb3InOiBzdG9wQ29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdG9wLW9wYWNpdHknOiBzdG9wT3BhY2l0eVxuXHRcdFx0XHRcdFx0fSkuYWRkKGdyYWRpZW50T2JqZWN0KTtcblxuXHRcdFx0XHRcdFx0Ly8gQWRkIHRoZSBzdG9wIGVsZW1lbnQgdG8gdGhlIGdyYWRpZW50XG5cdFx0XHRcdFx0XHRncmFkaWVudE9iamVjdC5zdG9wcy5wdXNoKHN0b3BPYmplY3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGdyYWRpZW50IG9iamVjdFxuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShwcm9wLCAndXJsKCcgKyByZW5kZXJlci51cmwgKyAnIycgKyBpZCArICcpJyk7XG5cdFx0XHR9IFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBhIHBvbHlmaWxsIHRvIHRoZSB0ZXh0LXN0cm9rZSBDU1MgcHJvcGVydHksIGJ5IGNvcHlpbmcgdGhlIHRleHQgZWxlbWVudFxuXHRcdCAqIGFuZCBhcHBseSBzdHJva2VzIHRvIHRoZSBjb3B5LlxuXHRcdCAqXG5cdFx0ICogZG9jczogdXBkYXRlIGRlZmF1bHQsIGRvY3VtZW50IHRoZSBwb2x5ZmlsbCBhbmQgdGhlIGxpbWl0YXRpb25zIG9uIGhleCBjb2xvcnMgYW5kIHBpeGVsIHZhbHVlcywgZG9jdW1lbnQgY29udHJhc3QgcHNldWRvLWNvbG9yXG5cdFx0ICogVE9ETzogXG5cdFx0ICogLSB1cGRhdGUgZGVmYXVsdHNcblx0XHQgKi9cblx0XHRhcHBseVRleHRTaGFkb3c6IGZ1bmN0aW9uICh0ZXh0U2hhZG93KSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0dHNwYW5zLFxuXHRcdFx0XHRoYXNDb250cmFzdCA9IHRleHRTaGFkb3cuaW5kZXhPZignY29udHJhc3QnKSAhPT0gLTEsXG5cdFx0XHRcdHN0eWxlcyA9IHt9LFxuXHRcdFx0XHQvLyBJRTEwIGFuZCBJRTExIHJlcG9ydCB0ZXh0U2hhZG93IGluIGVsZW0uc3R5bGUgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCB3b3JrLiBDaGVja1xuXHRcdFx0XHQvLyB0aGlzIGFnYWluIHdpdGggbmV3IElFIHJlbGVhc2UuIEluIGV4cG9ydHMsIHRoZSByZW5kZXJpbmcgaXMgcGFzc2VkIHRvIFBoYW50b21KUy4gXG5cdFx0XHRcdHN1cHBvcnRzID0gdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQgfHwgKGVsZW0uc3R5bGUudGV4dFNoYWRvdyAhPT0gVU5ERUZJTkVEICYmICFpc0lFKTtcblxuXHRcdFx0Ly8gV2hlbiB0aGUgdGV4dCBzaGFkb3cgaXMgc2V0IHRvIGNvbnRyYXN0LCB1c2UgZGFyayBzdHJva2UgZm9yIGxpZ2h0IHRleHQgYW5kIHZpY2UgdmVyc2Fcblx0XHRcdGlmIChoYXNDb250cmFzdCkge1xuXHRcdFx0XHRzdHlsZXMudGV4dFNoYWRvdyA9IHRleHRTaGFkb3cgPSB0ZXh0U2hhZG93LnJlcGxhY2UoL2NvbnRyYXN0L2csIHRoaXMucmVuZGVyZXIuZ2V0Q29udHJhc3QoZWxlbS5zdHlsZS5maWxsKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhZmFyaSB3aXRoIHJldGluYSBkaXNwbGF5cyBhcyB3ZWxsIGFzIFBoYW50b21KUyBidWcgKCMzOTc0KS4gRmlyZWZveCBkb2VzIG5vdCB0b2xlcmF0ZSB0aGlzLFxuXHRcdFx0Ly8gaXQgcmVtb3ZlcyB0aGUgdGV4dCBzaGFkb3dzLlxuXHRcdFx0aWYgKGlzV2ViS2l0KSB7XG5cdFx0XHRcdHN0eWxlcy50ZXh0UmVuZGVyaW5nID0gJ2dlb21ldHJpY1ByZWNpc2lvbic7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFNlbGVjdGl2ZSBzaWRlLWJ5LXNpZGUgdGVzdGluZyBpbiBzdXBwb3J0ZWQgYnJvd3NlciAoaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzczTDFwdHJoLylcblx0XHRcdGlmIChlbGVtLnRleHRDb250ZW50LmluZGV4T2YoJzIuJykgPT09IDApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZVsndGV4dC1zaGFkb3cnXSA9ICdub25lJztcblx0XHRcdFx0c3VwcG9ydHMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vICovXG5cblx0XHRcdC8vIE5vIHJlYXNvbiB0byBwb2x5ZmlsbCwgd2UndmUgZ290IG5hdGl2ZSBzdXBwb3J0XG5cdFx0XHRpZiAoc3VwcG9ydHMpIHtcblx0XHRcdFx0Y3NzKGVsZW0sIHN0eWxlcyk7IC8vIEFwcGx5IGFsdGVyZWQgdGV4dFNoYWRvdyBvciB0ZXh0UmVuZGVyaW5nIHdvcmthcm91bmRcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5mYWtlVFMgPSB0cnVlOyAvLyBGYWtlIHRleHQgc2hhZG93XG5cblx0XHRcdFx0Ly8gSW4gb3JkZXIgdG8gZ2V0IHRoZSByaWdodCB5IHBvc2l0aW9uIG9mIHRoZSBjbG9uZXMsIFxuXHRcdFx0XHQvLyBjb3B5IG92ZXIgdGhlIHkgc2V0dGVyXG5cdFx0XHRcdHRoaXMueVNldHRlciA9IHRoaXMueFNldHRlcjtcblxuXHRcdFx0XHR0c3BhbnMgPSBbXS5zbGljZS5jYWxsKGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RzcGFuJykpO1xuXHRcdFx0XHRlYWNoKHRleHRTaGFkb3cuc3BsaXQoL1xccz8sXFxzPy9nKSwgZnVuY3Rpb24gKHRleHRTaGFkb3cpIHtcblx0XHRcdFx0XHR2YXIgZmlyc3RDaGlsZCA9IGVsZW0uZmlyc3RDaGlsZCxcblx0XHRcdFx0XHRcdGNvbG9yLFxuXHRcdFx0XHRcdFx0c3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGV4dFNoYWRvdyA9IHRleHRTaGFkb3cuc3BsaXQoJyAnKTtcblx0XHRcdFx0XHRjb2xvciA9IHRleHRTaGFkb3dbdGV4dFNoYWRvdy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdC8vIEFwcHJveGltYXRlbHkgdHVuZSB0aGUgc2V0dGluZ3MgdG8gdGhlIHRleHQtc2hhZG93IGJlaGF2aW91clxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGV4dFNoYWRvd1t0ZXh0U2hhZG93Lmxlbmd0aCAtIDJdO1xuXG5cdFx0XHRcdFx0aWYgKHN0cm9rZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRlYWNoKHRzcGFucywgZnVuY3Rpb24gKHRzcGFuLCB5KSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbG9uZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBMZXQgdGhlIGZpcnN0IGxpbmUgc3RhcnQgYXQgdGhlIGNvcnJlY3QgWCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRpZiAoeSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZSgneCcsIGVsZW0uZ2V0QXR0cmlidXRlKCd4JykpO1xuXHRcdFx0XHRcdFx0XHRcdHkgPSBlbGVtLmdldEF0dHJpYnV0ZSgneScpO1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZSgneScsIHkgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCd5JywgMCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbG9uZSBhbmQgYXBwbHkgc2hhZG93IHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSB0c3Bhbi5jbG9uZU5vZGUoMSk7XG5cdFx0XHRcdFx0XHRcdGF0dHIoY2xvbmUsIHtcblx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyAndGV4dC1zaGFkb3cnLFxuXHRcdFx0XHRcdFx0XHRcdCdmaWxsJzogY29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0J3N0cm9rZSc6IGNvbG9yLFxuXHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utb3BhY2l0eSc6IDEgLyBtYXRoTWF4KHBJbnQoc3Ryb2tlV2lkdGgpLCAzKSxcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCdcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5zZXJ0QmVmb3JlKGNsb25lLCBmaXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBvciBnZXQgYSBnaXZlbiBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGhhc2hcblx0XHQgKiBAcGFyYW0ge01peGVkfFVuZGVmaW5lZH0gdmFsXG5cdFx0ICovXG5cdFx0YXR0cjogZnVuY3Rpb24gKGhhc2gsIHZhbCwgY29tcGxldGUpIHtcblx0XHRcdHZhciBrZXksXG5cdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRoYXNTZXRTeW1ib2xTaXplLFxuXHRcdFx0XHRyZXQgPSB0aGlzLFxuXHRcdFx0XHRza2lwQXR0cjtcblxuXHRcdFx0Ly8gc2luZ2xlIGtleS12YWx1ZSBwYWlyXG5cdFx0XHRpZiAodHlwZW9mIGhhc2ggPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdGtleSA9IGhhc2g7XG5cdFx0XHRcdGhhc2ggPSB7fTtcblx0XHRcdFx0aGFzaFtrZXldID0gdmFsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1c2VkIGFzIGEgZ2V0dGVyOiBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgc2Vjb25kIGlzIHVuZGVmaW5lZFxuXHRcdFx0aWYgKHR5cGVvZiBoYXNoID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXQgPSAodGhpc1toYXNoICsgJ0dldHRlciddIHx8IHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcywgaGFzaCwgZWxlbWVudCk7XG5cdFx0XHRcblx0XHRcdC8vIHNldHRlclxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKGtleSBpbiBoYXNoKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBoYXNoW2tleV07XG5cdFx0XHRcdFx0c2tpcEF0dHIgPSBmYWxzZTtcblxuXG5cblx0XHRcdFx0XHRpZiAodGhpcy5zeW1ib2xOYW1lICYmIC9eKHh8eXx3aWR0aHxoZWlnaHR8cnxzdGFydHxlbmR8aW5uZXJSfGFuY2hvclh8YW5jaG9yWSkvLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdFx0aWYgKCFoYXNTZXRTeW1ib2xTaXplKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3ltYm9sQXR0cihoYXNoKTtcblx0XHRcdFx0XHRcdFx0aGFzU2V0U3ltYm9sU2l6ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRza2lwQXR0ciA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMucm90YXRpb24gJiYgKGtleSA9PT0gJ3gnIHx8IGtleSA9PT0gJ3knKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghc2tpcEF0dHIpIHtcblx0XHRcdFx0XHRcdCh0aGlzW2tleSArICdTZXR0ZXInXSB8fCB0aGlzLl9kZWZhdWx0U2V0dGVyKS5jYWxsKHRoaXMsIHZhbHVlLCBrZXksIGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hhZG93cyAmJiAvXih3aWR0aHxoZWlnaHR8dmlzaWJpbGl0eXx4fHl8ZHx0cmFuc2Zvcm18Y3h8Y3l8cikkLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlU2hhZG93cyhrZXksIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgdHJhbnNmb3JtLiBEbyB0aGlzIG91dHNpZGUgdGhlIGxvb3AgdG8gcHJldmVudCByZWR1bmRhbnQgdXBkYXRpbmcgZm9yIGJhdGNoIHNldHRpbmdcblx0XHRcdFx0Ly8gb2YgYXR0cmlidXRlcy5cblx0XHRcdFx0aWYgKHRoaXMuZG9UcmFuc2Zvcm0pIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0XHRcdHRoaXMuZG9UcmFuc2Zvcm0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIGFjY29yZGFuY2Ugd2l0aCBhbmltYXRlLCBydW4gYSBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZVNoYWRvd3M6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHR2YXIgc2hhZG93cyA9IHRoaXMuc2hhZG93cyxcblx0XHRcdFx0aSA9IHNoYWRvd3MubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzaGFkb3dzW2ldLnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0a2V5ID09PSAnaGVpZ2h0JyA/XG5cdFx0XHRcdFx0XHRtYXRoTWF4KHZhbHVlIC0gKHNoYWRvd3NbaV0uY3V0SGVpZ2h0IHx8IDApLCAwKSA6XG5cdFx0XHRcdFx0XHRrZXkgPT09ICdkJyA/IHRoaXMuZCA6IHZhbHVlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuXHRcdCAqL1xuXHRcdGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0Y3VycmVudENsYXNzTmFtZSA9IGF0dHIoZWxlbWVudCwgJ2NsYXNzJykgfHwgJyc7XG5cblx0XHRcdGlmIChjdXJyZW50Q2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gLTEpIHtcblx0XHRcdFx0YXR0cihlbGVtZW50LCAnY2xhc3MnLCBjdXJyZW50Q2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0LyogaGFzQ2xhc3MgYW5kIHJlbW92ZUNsYXNzIGFyZSBub3QgKHlldCkgbmVlZGVkXG5cdFx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRcdHJldHVybiBhdHRyKHRoaXMuZWxlbWVudCwgJ2NsYXNzJykuaW5kZXhPZihjbGFzc05hbWUpICE9PSAtMTtcblx0XHR9LFxuXHRcdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRhdHRyKHRoaXMuZWxlbWVudCwgJ2NsYXNzJywgYXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycpLnJlcGxhY2UoY2xhc3NOYW1lLCAnJykpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHQqL1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgb25lIG9mIHRoZSBzeW1ib2wgc2l6ZSBhZmZlY3RpbmcgcGFyYW1ldGVycyBhcmUgY2hhbmdlZCxcblx0XHQgKiBjaGVjayBhbGwgdGhlIG90aGVycyBvbmx5IG9uY2UgZm9yIGVhY2ggY2FsbCB0byBhbiBlbGVtZW50J3Ncblx0XHQgKiAuYXR0cigpIG1ldGhvZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG5cdFx0ICovXG5cdFx0c3ltYm9sQXR0cjogZnVuY3Rpb24gKGhhc2gpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcztcblxuXHRcdFx0ZWFjaChbJ3gnLCAneScsICdyJywgJ3N0YXJ0JywgJ2VuZCcsICd3aWR0aCcsICdoZWlnaHQnLCAnaW5uZXJSJywgJ2FuY2hvclgnLCAnYW5jaG9yWSddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdHdyYXBwZXJba2V5XSA9IHBpY2soaGFzaFtrZXldLCB3cmFwcGVyW2tleV0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRcdGQ6IHdyYXBwZXIucmVuZGVyZXIuc3ltYm9sc1t3cmFwcGVyLnN5bWJvbE5hbWVdKFxuXHRcdFx0XHRcdHdyYXBwZXIueCxcblx0XHRcdFx0XHR3cmFwcGVyLnksXG5cdFx0XHRcdFx0d3JhcHBlci53aWR0aCxcblx0XHRcdFx0XHR3cmFwcGVyLmhlaWdodCxcblx0XHRcdFx0XHR3cmFwcGVyXG5cdFx0XHRcdClcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBhIGNsaXBwaW5nIHBhdGggdG8gdGhpcyBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcblx0XHQgKi9cblx0XHRjbGlwOiBmdW5jdGlvbiAoY2xpcFJlY3QpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBSZWN0ID8gJ3VybCgnICsgdGhpcy5yZW5kZXJlci51cmwgKyAnIycgKyBjbGlwUmVjdC5pZCArICcpJyA6IE5PTkUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG5lZWRlZCBmb3IgZHJhd2luZyBhIHJlY3RhbmdsZSBjcmlzcGx5IGFuZCByZXR1cm4gdGhlXG5cdFx0ICogY2FsY3VsYXRlZCBhdHRyaWJ1dGVzXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKi9cblx0XHRjcmlzcDogZnVuY3Rpb24gKHJlY3QpIHtcblxuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRrZXksXG5cdFx0XHRcdGF0dHJpYnMgPSB7fSxcblx0XHRcdFx0bm9ybWFsaXplcixcblx0XHRcdFx0c3Ryb2tlV2lkdGggPSByZWN0LnN0cm9rZVdpZHRoIHx8IHdyYXBwZXIuc3Ryb2tlV2lkdGggfHwgMDtcblxuXHRcdFx0bm9ybWFsaXplciA9IG1hdGhSb3VuZChzdHJva2VXaWR0aCkgJSAyIC8gMjsgLy8gbWF0aFJvdW5kIGJlY2F1c2Ugc3Ryb2tlV2lkdGggY2FuIHNvbWV0aW1lcyBoYXZlIHJvdW5kb2ZmIGVycm9yc1xuXG5cdFx0XHQvLyBub3JtYWxpemUgZm9yIGNyaXNwIGVkZ2VzXG5cdFx0XHRyZWN0LnggPSBtYXRoRmxvb3IocmVjdC54IHx8IHdyYXBwZXIueCB8fCAwKSArIG5vcm1hbGl6ZXI7XG5cdFx0XHRyZWN0LnkgPSBtYXRoRmxvb3IocmVjdC55IHx8IHdyYXBwZXIueSB8fCAwKSArIG5vcm1hbGl6ZXI7XG5cdFx0XHRyZWN0LndpZHRoID0gbWF0aEZsb29yKChyZWN0LndpZHRoIHx8IHdyYXBwZXIud2lkdGggfHwgMCkgLSAyICogbm9ybWFsaXplcik7XG5cdFx0XHRyZWN0LmhlaWdodCA9IG1hdGhGbG9vcigocmVjdC5oZWlnaHQgfHwgd3JhcHBlci5oZWlnaHQgfHwgMCkgLSAyICogbm9ybWFsaXplcik7XG5cdFx0XHRyZWN0LnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cblx0XHRcdGZvciAoa2V5IGluIHJlY3QpIHtcblx0XHRcdFx0aWYgKHdyYXBwZXJba2V5XSAhPT0gcmVjdFtrZXldKSB7IC8vIG9ubHkgc2V0IGF0dHJpYnV0ZSBpZiBjaGFuZ2VkXG5cdFx0XHRcdFx0d3JhcHBlcltrZXldID0gYXR0cmlic1trZXldID0gcmVjdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhdHRyaWJzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgc3R5bGVzIGZvciB0aGUgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcblx0XHQgKi9cblx0XHRjc3M6IGZ1bmN0aW9uIChzdHlsZXMpIHtcblx0XHRcdHZhciBlbGVtV3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdG9sZFN0eWxlcyA9IGVsZW1XcmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0bmV3U3R5bGVzID0ge30sXG5cdFx0XHRcdGVsZW0gPSBlbGVtV3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHR0ZXh0V2lkdGgsXG5cdFx0XHRcdG4sXG5cdFx0XHRcdHNlcmlhbGl6ZWRDc3MgPSAnJyxcblx0XHRcdFx0aHlwaGVuYXRlLFxuXHRcdFx0XHRoYXNOZXcgPSAhb2xkU3R5bGVzO1xuXG5cdFx0XHQvLyBjb252ZXJ0IGxlZ2FjeVxuXHRcdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMuY29sb3IpIHtcblx0XHRcdFx0c3R5bGVzLmZpbGwgPSBzdHlsZXMuY29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgZXhpc3Rpbmcgc3R5bGVzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlICgjMjY0MClcblx0XHRcdGlmIChvbGRTdHlsZXMpIHtcblx0XHRcdFx0Zm9yIChuIGluIHN0eWxlcykge1xuXHRcdFx0XHRcdGlmIChzdHlsZXNbbl0gIT09IG9sZFN0eWxlc1tuXSkge1xuXHRcdFx0XHRcdFx0bmV3U3R5bGVzW25dID0gc3R5bGVzW25dO1xuXHRcdFx0XHRcdFx0aGFzTmV3ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNOZXcpIHtcblx0XHRcdFx0dGV4dFdpZHRoID0gZWxlbVdyYXBwZXIudGV4dFdpZHRoID0gXG5cdFx0XHRcdFx0KHN0eWxlcyAmJiBzdHlsZXMud2lkdGggJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dCcgJiYgcEludChzdHlsZXMud2lkdGgpKSB8fCBcblx0XHRcdFx0XHRlbGVtV3JhcHBlci50ZXh0V2lkdGg7IC8vICMzNTAxXG5cblx0XHRcdFx0Ly8gTWVyZ2UgdGhlIG5ldyBzdHlsZXMgd2l0aCB0aGUgb2xkIG9uZXNcblx0XHRcdFx0aWYgKG9sZFN0eWxlcykge1xuXHRcdFx0XHRcdHN0eWxlcyA9IGV4dGVuZChcblx0XHRcdFx0XHRcdG9sZFN0eWxlcyxcblx0XHRcdFx0XHRcdG5ld1N0eWxlc1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cdFx0XG5cblx0XHRcdFx0Ly8gc3RvcmUgb2JqZWN0XG5cdFx0XHRcdGVsZW1XcmFwcGVyLnN0eWxlcyA9IHN0eWxlcztcblxuXHRcdFx0XHRpZiAodGV4dFdpZHRoICYmICh1c2VDYW5WRyB8fCAoIWhhc1NWRyAmJiBlbGVtV3JhcHBlci5yZW5kZXJlci5mb3JFeHBvcnQpKSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBzdHlsZXMud2lkdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXJpYWxpemUgYW5kIHNldCBzdHlsZSBhdHRyaWJ1dGVcblx0XHRcdFx0aWYgKGlzSUUgJiYgIWhhc1NWRykge1xuXHRcdFx0XHRcdGNzcyhlbGVtV3JhcHBlci5lbGVtZW50LCBzdHlsZXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqL1xuXHRcdFx0XHRcdGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAnLScgKyBiLnRvTG93ZXJDYXNlKCk7IH07XG5cdFx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcdFx0XHRcdGZvciAobiBpbiBzdHlsZXMpIHtcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZWRDc3MgKz0gbi5yZXBsYWNlKC8oW0EtWl0pL2csIGh5cGhlbmF0ZSkgKyAnOicgKyBzdHlsZXNbbl0gKyAnOyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGF0dHIoZWxlbSwgJ3N0eWxlJywgc2VyaWFsaXplZENzcyk7IC8vICMxODgxXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIHJlLWJ1aWxkIHRleHRcblx0XHRcdFx0aWYgKHRleHRXaWR0aCAmJiBlbGVtV3JhcHBlci5hZGRlZCkge1xuXHRcdFx0XHRcdGVsZW1XcmFwcGVyLnJlbmRlcmVyLmJ1aWxkVGV4dChlbGVtV3JhcHBlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1XcmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdG9uOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0XHR2YXIgc3ZnRWxlbWVudCA9IHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgPSBzdmdFbGVtZW50LmVsZW1lbnQ7XG5cdFx0XHRcblx0XHRcdC8vIHRvdWNoXG5cdFx0XHRpZiAoaGFzVG91Y2ggJiYgZXZlbnRUeXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdGVsZW1lbnQub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcdFx0XHRcblx0XHRcdFx0XHRzdmdFbGVtZW50LnRvdWNoRXZlbnRGaXJlZCA9IERhdGUubm93KCk7XHRcdFx0XHRcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0aGFuZGxlci5jYWxsKGVsZW1lbnQsIGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRlbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh1c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpID09PSAtMSB8fCBEYXRlLm5vdygpIC0gKHN2Z0VsZW1lbnQudG91Y2hFdmVudEZpcmVkIHx8IDApID4gMTEwMCkgeyAvLyAjMjI2OVxuXHRcdFx0XHRcdFx0aGFuZGxlci5jYWxsKGVsZW1lbnQsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNpbXBsZXN0IHBvc3NpYmxlIGV2ZW50IG1vZGVsIGZvciBpbnRlcm5hbCB1c2Vcblx0XHRcdFx0ZWxlbWVudFsnb24nICsgZXZlbnRUeXBlXSA9IGhhbmRsZXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjb29yZGluYXRlcyBuZWVkZWQgdG8gZHJhdyBhIGNvbnNpc3RlbnQgcmFkaWFsIGdyYWRpZW50IGFjcm9zc1xuXHRcdCAqIHBpZSBzbGljZXMgcmVnYXJkbGVzcyBvZiBwb3NpdGlvbmluZyBpbnNpZGUgdGhlIGNoYXJ0LiBUaGUgZm9ybWF0IGlzXG5cdFx0ICogW2NlbnRlclgsIGNlbnRlclksIGRpYW1ldGVyXSBpbiBwaXhlbHMuXG5cdFx0ICovXG5cdFx0c2V0UmFkaWFsUmVmZXJlbmNlOiBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5yYWRpYWxSZWZlcmVuY2UgPSBjb29yZGluYXRlcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNb3ZlIGFuIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuIGJ5IHggYW5kIHkgdmFsdWVzXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoe1xuXHRcdFx0XHR0cmFuc2xhdGVYOiB4LFxuXHRcdFx0XHR0cmFuc2xhdGVZOiB5XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW52ZXJ0IGEgZ3JvdXAsIHJvdGF0ZSBhbmQgZmxpcFxuXHRcdCAqL1xuXHRcdGludmVydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzO1xuXHRcdFx0d3JhcHBlci5pbnZlcnRlZCA9IHRydWU7XG5cdFx0XHR3cmFwcGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBiYXNlZCBvbiBpbnRlcm5hbFxuXHRcdCAqIHByb3BlcnRpZXNcblx0XHQgKi9cblx0XHR1cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0dHJhbnNsYXRlWCA9IHdyYXBwZXIudHJhbnNsYXRlWCB8fCAwLFxuXHRcdFx0XHR0cmFuc2xhdGVZID0gd3JhcHBlci50cmFuc2xhdGVZIHx8IDAsXG5cdFx0XHRcdHNjYWxlWCA9IHdyYXBwZXIuc2NhbGVYLFxuXHRcdFx0XHRzY2FsZVkgPSB3cmFwcGVyLnNjYWxlWSxcblx0XHRcdFx0aW52ZXJ0ZWQgPSB3cmFwcGVyLmludmVydGVkLFxuXHRcdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHRyYW5zZm9ybTtcblxuXHRcdFx0Ly8gZmxpcHBpbmcgYWZmZWN0cyB0cmFuc2xhdGUgYXMgYWRqdXN0bWVudCBmb3IgZmxpcHBpbmcgYXJvdW5kIHRoZSBncm91cCdzIGF4aXNcblx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHR0cmFuc2xhdGVYICs9IHdyYXBwZXIuYXR0cignd2lkdGgnKTtcblx0XHRcdFx0dHJhbnNsYXRlWSArPSB3cmFwcGVyLmF0dHIoJ2hlaWdodCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSB0cmFuc2xhdGUuIE5lYXJseSBhbGwgdHJhbnNmb3JtZWQgZWxlbWVudHMgaGF2ZSB0cmFuc2xhdGlvbiwgc28gaW5zdGVhZFxuXHRcdFx0Ly8gb2YgY2hlY2tpbmcgZm9yIHRyYW5zbGF0ZSA9IDAsIGRvIGl0IGFsd2F5cyAoIzE3NjcsICMxODQ2KS5cblx0XHRcdHRyYW5zZm9ybSA9IFsndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywnICsgdHJhbnNsYXRlWSArICcpJ107XG5cblx0XHRcdC8vIGFwcGx5IHJvdGF0aW9uXG5cdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0dHJhbnNmb3JtLnB1c2goJ3JvdGF0ZSg5MCkgc2NhbGUoLTEsMSknKTtcblx0XHRcdH0gZWxzZSBpZiAocm90YXRpb24pIHsgLy8gdGV4dCByb3RhdGlvblxuXHRcdFx0XHR0cmFuc2Zvcm0ucHVzaCgncm90YXRlKCcgKyByb3RhdGlvbiArICcgJyArIChlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDApICsgJyAnICsgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCkgKyAnKScpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRGVsZXRlIGJCb3ggbWVtbyB3aGVuIHRoZSByb3RhdGlvbiBjaGFuZ2VzXG5cdFx0XHRcdC8vZGVsZXRlIHdyYXBwZXIuYkJveDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgc2NhbGVcblx0XHRcdGlmIChkZWZpbmVkKHNjYWxlWCkgfHwgZGVmaW5lZChzY2FsZVkpKSB7XG5cdFx0XHRcdHRyYW5zZm9ybS5wdXNoKCdzY2FsZSgnICsgcGljayhzY2FsZVgsIDEpICsgJyAnICsgcGljayhzY2FsZVksIDEpICsgJyknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRyYW5zZm9ybS5sZW5ndGgpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybS5qb2luKCcgJykpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQnJpbmcgdGhlIGVsZW1lbnQgdG8gdGhlIGZyb250XG5cdFx0ICovXG5cdFx0dG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBCcmVhayBkb3duIGFsaWdubWVudCBvcHRpb25zIGxpa2UgYWxpZ24sIHZlcnRpY2FsQWxpZ24sIHggYW5kIHlcblx0XHQgKiB0byB4IGFuZCB5IHJlbGF0aXZlIHRvIHRoZSBjaGFydC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBhbGlnbk9wdGlvbnNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsaWduQnlUcmFuc2xhdGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ1tPYmplY3R9IGJveCBUaGUgYm94IHRvIGFsaWduIHRvLCBuZWVkcyBhIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4gdGhlXG5cdFx0ICpcdFx0Ym94IGlzIGEgc3RyaW5nLCBpdCByZWZlcnMgdG8gYW4gb2JqZWN0IGluIHRoZSBSZW5kZXJlci4gRm9yIGV4YW1wbGUsIHdoZW5cblx0XHQgKlx0XHRib3ggaXMgJ3NwYWNpbmdCb3gnLCBpdCByZWZlcnMgdG8gUmVuZGVyZXIuc3BhY2luZ0JveCB3aGljaCBob2xkcyB3aWR0aCwgaGVpZ2h0XG5cdFx0ICpcdFx0eCBhbmQgeSBwcm9wZXJ0aWVzLlxuXHRcdCAqXG5cdFx0ICovXG5cdFx0YWxpZ246IGZ1bmN0aW9uIChhbGlnbk9wdGlvbnMsIGFsaWduQnlUcmFuc2xhdGUsIGJveCkge1xuXHRcdFx0dmFyIGFsaWduLFxuXHRcdFx0XHR2QWxpZ24sXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdGF0dHJpYnMgPSB7fSxcblx0XHRcdFx0YWxpZ25Ubyxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRhbGlnbmVkT2JqZWN0cyA9IHJlbmRlcmVyLmFsaWduZWRPYmplY3RzO1xuXG5cdFx0XHQvLyBGaXJzdCBjYWxsIG9uIGluc3RhbmNpYXRlXG5cdFx0XHRpZiAoYWxpZ25PcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuYWxpZ25PcHRpb25zID0gYWxpZ25PcHRpb25zO1xuXHRcdFx0XHR0aGlzLmFsaWduQnlUcmFuc2xhdGUgPSBhbGlnbkJ5VHJhbnNsYXRlO1xuXHRcdFx0XHRpZiAoIWJveCB8fCBpc1N0cmluZyhib3gpKSB7IC8vIGJveGVzIG90aGVyIHRoYW4gcmVuZGVyZXIgaGFuZGxlIHRoaXMgaW50ZXJuYWxseVxuXHRcdFx0XHRcdHRoaXMuYWxpZ25UbyA9IGFsaWduVG8gPSBib3ggfHwgJ3JlbmRlcmVyJztcblx0XHRcdFx0XHRlcmFzZShhbGlnbmVkT2JqZWN0cywgdGhpcyk7IC8vIHByZXZlbnQgZHVwbGljYXRlcywgbGlrZSBsZWdlbmRHcm91cCBhZnRlciByZXNpemVcblx0XHRcdFx0XHRhbGlnbmVkT2JqZWN0cy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdGJveCA9IG51bGw7IC8vIHJlYXNzaWduIGl0IGJlbG93XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiBjYWxsZWQgb24gcmVzaXplLCBubyBhcmd1bWVudHMgYXJlIHN1cHBsaWVkXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbGlnbk9wdGlvbnMgPSB0aGlzLmFsaWduT3B0aW9ucztcblx0XHRcdFx0YWxpZ25CeVRyYW5zbGF0ZSA9IHRoaXMuYWxpZ25CeVRyYW5zbGF0ZTtcblx0XHRcdFx0YWxpZ25UbyA9IHRoaXMuYWxpZ25Ubztcblx0XHRcdH1cblxuXHRcdFx0Ym94ID0gcGljayhib3gsIHJlbmRlcmVyW2FsaWduVG9dLCByZW5kZXJlcik7XG5cblx0XHRcdC8vIEFzc2lnbiB2YXJpYWJsZXNcblx0XHRcdGFsaWduID0gYWxpZ25PcHRpb25zLmFsaWduO1xuXHRcdFx0dkFsaWduID0gYWxpZ25PcHRpb25zLnZlcnRpY2FsQWxpZ247XG5cdFx0XHR4ID0gKGJveC54IHx8IDApICsgKGFsaWduT3B0aW9ucy54IHx8IDApOyAvLyBkZWZhdWx0OiBsZWZ0IGFsaWduXG5cdFx0XHR5ID0gKGJveC55IHx8IDApICsgKGFsaWduT3B0aW9ucy55IHx8IDApOyAvLyBkZWZhdWx0OiB0b3AgYWxpZ25cblxuXHRcdFx0Ly8gQWxpZ25cblx0XHRcdGlmIChhbGlnbiA9PT0gJ3JpZ2h0JyB8fCBhbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0eCArPSAoYm94LndpZHRoIC0gKGFsaWduT3B0aW9ucy53aWR0aCB8fCAwKSkgL1xuXHRcdFx0XHRcdFx0eyByaWdodDogMSwgY2VudGVyOiAyIH1bYWxpZ25dO1xuXHRcdFx0fVxuXHRcdFx0YXR0cmlic1thbGlnbkJ5VHJhbnNsYXRlID8gJ3RyYW5zbGF0ZVgnIDogJ3gnXSA9IG1hdGhSb3VuZCh4KTtcblxuXG5cdFx0XHQvLyBWZXJ0aWNhbCBhbGlnblxuXHRcdFx0aWYgKHZBbGlnbiA9PT0gJ2JvdHRvbScgfHwgdkFsaWduID09PSAnbWlkZGxlJykge1xuXHRcdFx0XHR5ICs9IChib3guaGVpZ2h0IC0gKGFsaWduT3B0aW9ucy5oZWlnaHQgfHwgMCkpIC9cblx0XHRcdFx0XHRcdCh7IGJvdHRvbTogMSwgbWlkZGxlOiAyIH1bdkFsaWduXSB8fCAxKTtcblxuXHRcdFx0fVxuXHRcdFx0YXR0cmlic1thbGlnbkJ5VHJhbnNsYXRlID8gJ3RyYW5zbGF0ZVknIDogJ3knXSA9IG1hdGhSb3VuZCh5KTtcblxuXHRcdFx0Ly8gQW5pbWF0ZSBvbmx5IGlmIGFscmVhZHkgcGxhY2VkXG5cdFx0XHR0aGlzW3RoaXMucGxhY2VkID8gJ2FuaW1hdGUnIDogJ2F0dHInXShhdHRyaWJzKTtcblx0XHRcdHRoaXMucGxhY2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMuYWxpZ25BdHRyID0gYXR0cmlicztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgYm91bmRpbmcgYm94ICh3aWR0aCwgaGVpZ2h0LCB4IGFuZCB5KSBmb3IgdGhlIGVsZW1lbnRcblx0XHQgKi9cblx0XHRnZXRCQm94OiBmdW5jdGlvbiAocmVsb2FkKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGJCb3gsLy8gPSB3cmFwcGVyLmJCb3gsXG5cdFx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHRzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0cmFkID0gcm90YXRpb24gKiBkZWcycmFkLFxuXHRcdFx0XHR0ZXh0U3RyID0gd3JhcHBlci50ZXh0U3RyLFxuXHRcdFx0XHR0ZXh0U2hhZG93LFxuXHRcdFx0XHRlbGVtU3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuXHRcdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbSxcblx0XHRcdFx0Y2FjaGVLZXk7XG5cblx0XHRcdGlmICh0ZXh0U3RyICE9PSBVTkRFRklORUQpIHtcblxuXHRcdFx0XHQvLyBQcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IGJvdW5kaW5nIGJveFxuXHRcdFx0XHRjYWNoZUtleSA9IFsnJywgcm90YXRpb24gfHwgMCwgc3R5bGVzICYmIHN0eWxlcy5mb250U2l6ZSwgZWxlbWVudC5zdHlsZS53aWR0aF0uam9pbignLCcpO1xuXG5cdFx0XHRcdC8vIFNpbmNlIG51bWJlcnMgYXJlIG1vbm9zcGFjZWQsIGFuZCBudW1lcmljYWwgbGFiZWxzIGFwcGVhciBhIGxvdCBpbiBhIGNoYXJ0LFxuXHRcdFx0XHQvLyB3ZSBhc3N1bWUgdGhhdCBhIGxhYmVsIG9mIG4gY2hhcmFjdGVycyBoYXMgdGhlIHNhbWUgYm91bmRpbmcgYm94IGFzIG90aGVycyBcblx0XHRcdFx0Ly8gb2YgdGhlIHNhbWUgbGVuZ3RoLlxuXHRcdFx0XHRpZiAodGV4dFN0ciA9PT0gJycgfHwgbnVtUmVnZXgudGVzdCh0ZXh0U3RyKSkge1xuXHRcdFx0XHRcdGNhY2hlS2V5ID0gJ251bTonICsgdGV4dFN0ci50b1N0cmluZygpLmxlbmd0aCArIGNhY2hlS2V5O1xuXG5cdFx0XHRcdC8vIENhY2hpbmcgYWxsIHN0cmluZ3MgcmVkdWNlcyByZW5kZXJpbmcgdGltZSBieSA0LTUlLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhY2hlS2V5ID0gdGV4dFN0ciArIGNhY2hlS2V5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWNoZUtleSAmJiAhcmVsb2FkKSB7XG5cdFx0XHRcdGJCb3ggPSByZW5kZXJlci5jYWNoZVtjYWNoZUtleV07XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIGNhY2hlIGZvdW5kXG5cdFx0XHRpZiAoIWJCb3gpIHtcblxuXHRcdFx0XHQvLyBTVkcgZWxlbWVudHNcblx0XHRcdFx0aWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTlMgfHwgcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRcdFx0dHJ5IHsgLy8gRmFpbHMgaW4gRmlyZWZveCBpZiB0aGUgY29udGFpbmVyIGhhcyBkaXNwbGF5OiBub25lLlxuXG5cdFx0XHRcdFx0XHQvLyBXaGVuIHRoZSB0ZXh0IHNoYWRvdyBzaGltIGlzIHVzZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgZmFrZSBzaGFkb3dzXG5cdFx0XHRcdFx0XHQvLyB0byBnZXQgdGhlIGNvcnJlY3QgYm91bmRpbmcgYm94ICgjMzg3Milcblx0XHRcdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltID0gdGhpcy5mYWtlVFMgJiYgZnVuY3Rpb24gKGRpc3BsYXkpIHtcblx0XHRcdFx0XHRcdFx0ZWFjaChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgUFJFRklYICsgJ3RleHQtc2hhZG93JyksIGZ1bmN0aW9uICh0c3Bhbikge1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yICMzODQyLCBGaXJlZm94IHJlcG9ydGluZyB3cm9uZyBib3VuZGluZyBib3ggZm9yIHNoYWRvd3Ncblx0XHRcdFx0XHRcdGlmIChpc0ZpcmVmb3ggJiYgZWxlbVN0eWxlLnRleHRTaGFkb3cpIHtcblx0XHRcdFx0XHRcdFx0dGV4dFNoYWRvdyA9IGVsZW1TdHlsZS50ZXh0U2hhZG93O1xuXHRcdFx0XHRcdFx0XHRlbGVtU3R5bGUudGV4dFNoYWRvdyA9ICcnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0b2dnbGVUZXh0U2hhZG93U2hpbSkge1xuXHRcdFx0XHRcdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbShOT05FKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YkJveCA9IGVsZW1lbnQuZ2V0QkJveCA/XG5cdFx0XHRcdFx0XHRcdC8vIFNWRzogdXNlIGV4dGVuZCBiZWNhdXNlIElFOSBpcyBub3QgYWxsb3dlZCB0byBjaGFuZ2Ugd2lkdGggYW5kIGhlaWdodCBpbiBjYXNlXG5cdFx0XHRcdFx0XHRcdC8vIG9mIHJvdGF0aW9uIChiZWxvdylcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kKHt9LCBlbGVtZW50LmdldEJCb3goKSkgOlxuXHRcdFx0XHRcdFx0XHQvLyBDYW52YXMgcmVuZGVyZXIgYW5kIGxlZ2FjeSBJRSBpbiBleHBvcnQgbW9kZVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodFxuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyAjMzg0MlxuXHRcdFx0XHRcdFx0aWYgKHRleHRTaGFkb3cpIHtcblx0XHRcdFx0XHRcdFx0ZWxlbVN0eWxlLnRleHRTaGFkb3cgPSB0ZXh0U2hhZG93O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0b2dnbGVUZXh0U2hhZG93U2hpbSkge1xuXHRcdFx0XHRcdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbSgnJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cblxuXHRcdFx0XHRcdC8vIElmIHRoZSBiQm94IGlzIG5vdCBzZXQsIHRoZSB0cnktY2F0Y2ggYmxvY2sgYWJvdmUgZmFpbGVkLiBUaGUgb3RoZXIgY29uZGl0aW9uXG5cdFx0XHRcdFx0Ly8gaXMgZm9yIE9wZXJhIHRoYXQgcmV0dXJucyBhIHdpZHRoIG9mIC1JbmZpbml0eSBvbiBoaWRkZW4gZWxlbWVudHMuXG5cdFx0XHRcdFx0aWYgKCFiQm94IHx8IGJCb3gud2lkdGggPCAwKSB7XG5cdFx0XHRcdFx0XHRiQm94ID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly8gVk1MIFJlbmRlcmVyIG9yIHVzZUhUTUwgd2l0aGluIFNWR1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YkJveCA9IHdyYXBwZXIuaHRtbEdldEJCb3goKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJ1ZSBTVkcgZWxlbWVudHMgYXMgd2VsbCBhcyBIVE1MIGVsZW1lbnRzIGluIG1vZGVybiBicm93c2VycyB1c2luZyB0aGUgLnVzZUhUTUwgb3B0aW9uXG5cdFx0XHRcdC8vIG5lZWQgdG8gY29tcGVuc2F0ZWQgZm9yIHJvdGF0aW9uXG5cdFx0XHRcdGlmIChyZW5kZXJlci5pc1NWRykge1xuXHRcdFx0XHRcdHdpZHRoID0gYkJveC53aWR0aDtcblx0XHRcdFx0XHRoZWlnaHQgPSBiQm94LmhlaWdodDtcblxuXHRcdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yIHdyb25nIGJvdW5kaW5nIGJveCBpbiBJRTkgYW5kIElFMTAgKCMxMTAxLCAjMTUwNSwgIzE2NjksICMyNTY4KVxuXHRcdFx0XHRcdGlmIChpc0lFICYmIHN0eWxlcyAmJiBzdHlsZXMuZm9udFNpemUgPT09ICcxMXB4JyAmJiBoZWlnaHQudG9QcmVjaXNpb24oMykgPT09ICcxNi45Jykge1xuXHRcdFx0XHRcdFx0YkJveC5oZWlnaHQgPSBoZWlnaHQgPSAxNDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgZm9yIHJvdGF0ZWQgdGV4dFxuXHRcdFx0XHRcdGlmIChyb3RhdGlvbikge1xuXHRcdFx0XHRcdFx0YkJveC53aWR0aCA9IG1hdGhBYnMoaGVpZ2h0ICogbWF0aFNpbihyYWQpKSArIG1hdGhBYnMod2lkdGggKiBtYXRoQ29zKHJhZCkpO1xuXHRcdFx0XHRcdFx0YkJveC5oZWlnaHQgPSBtYXRoQWJzKGhlaWdodCAqIG1hdGhDb3MocmFkKSkgKyBtYXRoQWJzKHdpZHRoICogbWF0aFNpbihyYWQpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWNoZSBpdFxuXHRcdFx0XHRpZiAoY2FjaGVLZXkpIHtcblx0XHRcdFx0XHRyZW5kZXJlci5jYWNoZVtjYWNoZUtleV0gPSBiQm94O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYkJveDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvdyB0aGUgZWxlbWVudFxuXHRcdCAqL1xuXHRcdHNob3c6IGZ1bmN0aW9uIChpbmhlcml0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKHsgdmlzaWJpbGl0eTogaW5oZXJpdCA/ICdpbmhlcml0JyA6IFZJU0lCTEUgfSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgdGhlIGVsZW1lbnRcblx0XHQgKi9cblx0XHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKHsgdmlzaWJpbGl0eTogSElEREVOIH0pO1xuXHRcdH0sXG5cblx0XHRmYWRlT3V0OiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcblx0XHRcdHZhciBlbGVtV3JhcHBlciA9IHRoaXM7XG5cdFx0XHRlbGVtV3JhcHBlci5hbmltYXRlKHtcblx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0fSwge1xuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24gfHwgMTUwLFxuXHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGVsZW1XcmFwcGVyLmF0dHIoeyB5OiAtOTk5OSB9KTsgLy8gIzMwODgsIGFzc3VtaW5nIHdlJ3JlIG9ubHkgdXNpbmcgdGhpcyBmb3IgdG9vbHRpcHNcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCB0aGUgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fFVuZGVmaW5lZH0gcGFyZW50IENhbiBiZSBhbiBlbGVtZW50LCBhbiBlbGVtZW50IHdyYXBwZXIgb3IgdW5kZWZpbmVkXG5cdFx0ICpcdHRvIGFwcGVuZCB0aGUgZWxlbWVudCB0byB0aGUgcmVuZGVyZXIuYm94LlxuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24gKHBhcmVudCkge1xuXG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRpbnNlcnRlZDtcblxuXHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudEdyb3VwID0gcGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYXJrIGFzIGludmVydGVkXG5cdFx0XHR0aGlzLnBhcmVudEludmVydGVkID0gcGFyZW50ICYmIHBhcmVudC5pbnZlcnRlZDtcblxuXHRcdFx0Ly8gYnVpbGQgZm9ybWF0dGVkIHRleHRcblx0XHRcdGlmICh0aGlzLnRleHRTdHIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZW5kZXJlci5idWlsZFRleHQodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hcmsgYXMgYWRkZWRcblx0XHRcdHRoaXMuYWRkZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBhZGRpbmcgdG8gcmVuZGVyZXIgcm9vdCwgb3Igb3RoZXIgZWxlbWVudHMgaW4gdGhlIGdyb3VwIFxuXHRcdFx0Ly8gaGF2ZSBhIHogaW5kZXgsIHdlIG5lZWQgdG8gaGFuZGxlIGl0XG5cdFx0XHRpZiAoIXBhcmVudCB8fCBwYXJlbnQuaGFuZGxlWiB8fCB0aGlzLnpJbmRleCkge1xuXHRcdFx0XHRpbnNlcnRlZCA9IHRoaXMuekluZGV4U2V0dGVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHpJbmRleCBpcyBub3QgaGFuZGxlZCwgYXBwZW5kIGF0IHRoZSBlbmRcblx0XHRcdGlmICghaW5zZXJ0ZWQpIHtcblx0XHRcdFx0KHBhcmVudCA/IHBhcmVudC5lbGVtZW50IDogcmVuZGVyZXIuYm94KS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyZSBhbiBldmVudCBmb3IgaW50ZXJuYWwgaG9va3Ncblx0XHRcdGlmICh0aGlzLm9uQWRkKSB7XG5cdFx0XHRcdHRoaXMub25BZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBjaGlsZCBlaXRoZXIgYnkgcmVtb3ZlQ2hpbGQgb3IgbW92ZSB0byBnYXJiYWdlQmluLlxuXHRcdCAqIElzc3VlIDQ5MDsgaW4gVk1MIHJlbW92ZUNoaWxkIHJlc3VsdHMgaW4gT3JwaGFuZWQgbm9kZXMgYWNjb3JkaW5nIHRvIHNJRXZlLCBkaXNjYXJkRWxlbWVudCBkb2VzIG5vdC5cblx0XHQgKi9cblx0XHRzYWZlUmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHR2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRcdGlmIChwYXJlbnROb2RlKSB7XG5cdFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgdGhlIGVsZW1lbnQgYW5kIGVsZW1lbnQgd3JhcHBlclxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCB8fCB7fSxcblx0XHRcdFx0c2hhZG93cyA9IHdyYXBwZXIuc2hhZG93cyxcblx0XHRcdFx0cGFyZW50VG9DbGVhbiA9IHdyYXBwZXIucmVuZGVyZXIuaXNTVkcgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NQQU4nICYmIHdyYXBwZXIucGFyZW50R3JvdXAsXG5cdFx0XHRcdGdyYW5kUGFyZW50LFxuXHRcdFx0XHRrZXksXG5cdFx0XHRcdGk7XG5cblx0XHRcdC8vIHJlbW92ZSBldmVudHNcblx0XHRcdGVsZW1lbnQub25jbGljayA9IGVsZW1lbnQub25tb3VzZW91dCA9IGVsZW1lbnQub25tb3VzZW92ZXIgPSBlbGVtZW50Lm9ubW91c2Vtb3ZlID0gZWxlbWVudC5wb2ludCA9IG51bGw7XG5cdFx0XHRzdG9wKHdyYXBwZXIpOyAvLyBzdG9wIHJ1bm5pbmcgYW5pbWF0aW9uc1xuXG5cdFx0XHRpZiAod3JhcHBlci5jbGlwUGF0aCkge1xuXHRcdFx0XHR3cmFwcGVyLmNsaXBQYXRoID0gd3JhcHBlci5jbGlwUGF0aC5kZXN0cm95KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlc3Ryb3kgc3RvcHMgaW4gY2FzZSB0aGlzIGlzIGEgZ3JhZGllbnQgb2JqZWN0XG5cdFx0XHRpZiAod3JhcHBlci5zdG9wcykge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgd3JhcHBlci5zdG9wcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHdyYXBwZXIuc3RvcHNbaV0gPSB3cmFwcGVyLnN0b3BzW2ldLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3cmFwcGVyLnN0b3BzID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGVsZW1lbnRcblx0XHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBkZXN0cm95IHNoYWRvd3Ncblx0XHRcdGlmIChzaGFkb3dzKSB7XG5cdFx0XHRcdGVhY2goc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKHNoYWRvdyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBjYXNlIG9mIHVzZUhUTUwsIGNsZWFuIHVwIGVtcHR5IGNvbnRhaW5lcnMgZW11bGF0aW5nIFNWRyBncm91cHMgKCMxOTYwLCAjMjM5MywgIzI2OTcpLlxuXHRcdFx0d2hpbGUgKHBhcmVudFRvQ2xlYW4gJiYgcGFyZW50VG9DbGVhbi5kaXYgJiYgcGFyZW50VG9DbGVhbi5kaXYuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Z3JhbmRQYXJlbnQgPSBwYXJlbnRUb0NsZWFuLnBhcmVudEdyb3VwO1xuXHRcdFx0XHR3cmFwcGVyLnNhZmVSZW1vdmVDaGlsZChwYXJlbnRUb0NsZWFuLmRpdik7XG5cdFx0XHRcdGRlbGV0ZSBwYXJlbnRUb0NsZWFuLmRpdjtcblx0XHRcdFx0cGFyZW50VG9DbGVhbiA9IGdyYW5kUGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgZnJvbSBhbGlnbk9iamVjdHNcblx0XHRcdGlmICh3cmFwcGVyLmFsaWduVG8pIHtcblx0XHRcdFx0ZXJhc2Uod3JhcHBlci5yZW5kZXJlci5hbGlnbmVkT2JqZWN0cywgd3JhcHBlcik7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoa2V5IGluIHdyYXBwZXIpIHtcblx0XHRcdFx0ZGVsZXRlIHdyYXBwZXJba2V5XTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNoYWRvdyB0byB0aGUgZWxlbWVudC4gTXVzdCBiZSBkb25lIGFmdGVyIHRoZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET01cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBzaGFkb3dPcHRpb25zXG5cdFx0ICovXG5cdFx0c2hhZG93OiBmdW5jdGlvbiAoc2hhZG93T3B0aW9ucywgZ3JvdXAsIGN1dE9mZikge1xuXHRcdFx0dmFyIHNoYWRvd3MgPSBbXSxcblx0XHRcdFx0aSxcblx0XHRcdFx0c2hhZG93LFxuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRzdHJva2VXaWR0aCxcblx0XHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5LFxuXG5cdFx0XHRcdC8vIGNvbXBlbnNhdGUgZm9yIGludmVydGVkIHBsb3QgYXJlYVxuXHRcdFx0XHR0cmFuc2Zvcm07XG5cblxuXHRcdFx0aWYgKHNoYWRvd09wdGlvbnMpIHtcblx0XHRcdFx0c2hhZG93V2lkdGggPSBwaWNrKHNoYWRvd09wdGlvbnMud2lkdGgsIDMpO1xuXHRcdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSA9IChzaGFkb3dPcHRpb25zLm9wYWNpdHkgfHwgMC4xNSkgLyBzaGFkb3dXaWR0aDtcblx0XHRcdFx0dHJhbnNmb3JtID0gdGhpcy5wYXJlbnRJbnZlcnRlZCA/XG5cdFx0XHRcdFx0JygtMSwtMSknIDpcblx0XHRcdFx0XHQnKCcgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WCwgMSkgKyAnLCAnICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFksIDEpICsgJyknO1xuXHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHNoYWRvd1dpZHRoOyBpKyspIHtcblx0XHRcdFx0XHRzaGFkb3cgPSBlbGVtZW50LmNsb25lTm9kZSgwKTtcblx0XHRcdFx0XHRzdHJva2VXaWR0aCA9IChzaGFkb3dXaWR0aCAqIDIpICsgMSAtICgyICogaSk7XG5cdFx0XHRcdFx0YXR0cihzaGFkb3csIHtcblx0XHRcdFx0XHRcdCdpc1NoYWRvdyc6ICd0cnVlJyxcblx0XHRcdFx0XHRcdCdzdHJva2UnOiBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLW9wYWNpdHknOiBzaGFkb3dFbGVtZW50T3BhY2l0eSAqIGksXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0XHQndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZScgKyB0cmFuc2Zvcm0sXG5cdFx0XHRcdFx0XHQnZmlsbCc6IE5PTkVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoY3V0T2ZmKSB7XG5cdFx0XHRcdFx0XHRhdHRyKHNoYWRvdywgJ2hlaWdodCcsIG1hdGhNYXgoYXR0cihzaGFkb3csICdoZWlnaHQnKSAtIHN0cm9rZVdpZHRoLCAwKSk7XG5cdFx0XHRcdFx0XHRzaGFkb3cuY3V0SGVpZ2h0ID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGdyb3VwKSB7XG5cdFx0XHRcdFx0XHRncm91cC5lbGVtZW50LmFwcGVuZENoaWxkKHNoYWRvdyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2hhZG93LCBlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzaGFkb3dzLnB1c2goc2hhZG93KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2hhZG93cyA9IHNoYWRvd3M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR4R2V0dGVyOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAodGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRrZXkgPSB7IHg6ICdjeCcsIHk6ICdjeScgfVtrZXldIHx8IGtleTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9kZWZhdWx0R2V0dGVyKGtleSk7XG5cdFx0fSxcblxuXHRcdC8qKiBcblx0XHQgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9yIHBzZXVkbyBhdHRyaWJ1dGUsIHVzZWQgbWFpbmx5XG5cdFx0ICogZm9yIGFuaW1hdGlvbi5cblx0XHQgKi9cblx0XHRfZGVmYXVsdEdldHRlcjogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIHJldCA9IHBpY2sodGhpc1trZXldLCB0aGlzLmVsZW1lbnQgPyB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSkgOiBudWxsLCAwKTtcblxuXHRcdFx0aWYgKC9eW1xcLTAtOVxcLl0rJC8udGVzdChyZXQpKSB7IC8vIGlzIG51bWVyaWNhbFxuXHRcdFx0XHRyZXQgPSBwYXJzZUZsb2F0KHJldCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblxuXHRcdGRTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuam9pbikgeyAvLyBqb2luIHBhdGhcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5qb2luKCcgJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoLyhOYU58IHsyfXxeJCkvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gJ00gMCAwJztcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXG5cdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHR9LFxuXHRcdGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdHZhbHVlID0gdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZGFzaGRvdGRvdCcsICczLDEsMSwxLDEsMSwnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2hkb3QnLCAnMywxLDEsMScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZG90JywgJzEsMSwnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2gnLCAnMywxLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ2xvbmdkYXNoJywgJzgsMywnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9kb3QvZywgJzEsMywnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdkYXNoJywgJzQsMywnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8sJC8sICcnKVxuXHRcdFx0XHRcdC5zcGxpdCgnLCcpOyAvLyBlbmRpbmcgY29tbWFcblxuXHRcdFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0dmFsdWVbaV0gPSBwSW50KHZhbHVlW2ldKSAqIHRoaXNbJ3N0cm9rZS13aWR0aCddO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuam9pbignLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ05hTicsICdub25lJyk7IC8vICMzMjI2XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbGlnblNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsIHsgbGVmdDogJ3N0YXJ0JywgY2VudGVyOiAnbWlkZGxlJywgcmlnaHQ6ICdlbmQnIH1bdmFsdWVdKTtcblx0XHR9LFxuXHRcdG9wYWNpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0dGl0bGVTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0dmFyIHRpdGxlTm9kZSA9IHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGl0bGUnKVswXTtcblx0XHRcdGlmICghdGl0bGVOb2RlKSB7XG5cdFx0XHRcdHRpdGxlTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAndGl0bGUnKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlTm9kZSk7XG5cdFx0XHR9XG5cdFx0XHR0aXRsZU5vZGUuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdGRvYy5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0XHQoU3RyaW5nKHBpY2sodmFsdWUpLCAnJykpLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpIC8vICMzMjc2LCAjMzg5NVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0dGV4dFNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgIT09IHRoaXMudGV4dFN0cikge1xuXHRcdFx0XHQvLyBEZWxldGUgYkJveCBtZW1vIHdoZW4gdGhlIHRleHQgY2hhbmdlc1xuXHRcdFx0XHRkZWxldGUgdGhpcy5iQm94O1xuXHRcdFx0XG5cdFx0XHRcdHRoaXMudGV4dFN0ciA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy5hZGRlZCkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmaWxsU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuY29sb3JHcmFkaWVudCh2YWx1ZSwga2V5LCBlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHQvLyBJRTktMTEgZG9lc24ndCBoYW5kbGUgdmlzaWJpbHR5OmluaGVyaXQgd2VsbCwgc28gd2UgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgaW5zdGVhZCAoIzI4ODEsICMzOTA5KVxuXHRcdFx0aWYgKHZhbHVlID09PSAnaW5oZXJpdCcpIHtcblx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdH3CoGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHpJbmRleFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRcdHBhcmVudEdyb3VwID0gdGhpcy5wYXJlbnRHcm91cCxcblx0XHRcdFx0cGFyZW50V3JhcHBlciA9IHBhcmVudEdyb3VwIHx8IHJlbmRlcmVyLFxuXHRcdFx0XHRwYXJlbnROb2RlID0gcGFyZW50V3JhcHBlci5lbGVtZW50IHx8IHJlbmRlcmVyLmJveCxcblx0XHRcdFx0Y2hpbGROb2Rlcyxcblx0XHRcdFx0b3RoZXJFbGVtZW50LFxuXHRcdFx0XHRvdGhlclpJbmRleCxcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0aW5zZXJ0ZWQsXG5cdFx0XHRcdHJ1biA9IHRoaXMuYWRkZWQsXG5cdFx0XHRcdGk7XG5cdFx0XHRcblx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSkge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTsgLy8gU28gd2UgY2FuIHJlYWQgaXQgZm9yIG90aGVyIGVsZW1lbnRzIGluIHRoZSBncm91cFxuXHRcdFx0XHR2YWx1ZSA9ICt2YWx1ZTtcblx0XHRcdFx0aWYgKHRoaXNba2V5XSA9PT0gdmFsdWUpIHsgLy8gT25seSB1cGRhdGUgd2hlbiBuZWVkZWQgKCMzODY1KVxuXHRcdFx0XHRcdHJ1biA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnNlcnQgYWNjb3JkaW5nIHRvIHRoaXMgYW5kIG90aGVyIGVsZW1lbnRzJyB6SW5kZXguIEJlZm9yZSAuYWRkKCkgaXMgY2FsbGVkLFxuXHRcdFx0Ly8gbm90aGluZyBpcyBkb25lLiBUaGVuIG9uIGFkZCwgb3IgYnkgbGF0ZXIgY2FsbHMgdG8gekluZGV4U2V0dGVyLCB0aGUgbm9kZVxuXHRcdFx0Ly8gaXMgcGxhY2VkIG9uIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgRE9NLlxuXHRcdFx0aWYgKHJ1bikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuekluZGV4O1xuXG5cdFx0XHRcdGlmICh2YWx1ZSAmJiBwYXJlbnRHcm91cCkge1xuXHRcdFx0XHRcdHBhcmVudEdyb3VwLmhhbmRsZVogPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0Y2hpbGROb2RlcyA9IHBhcmVudE5vZGUuY2hpbGROb2Rlcztcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoICYmICFpbnNlcnRlZDsgaSsrKSB7XG5cdFx0XHRcdFx0b3RoZXJFbGVtZW50ID0gY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRvdGhlclpJbmRleCA9IGF0dHIob3RoZXJFbGVtZW50LCAnekluZGV4Jyk7XG5cdFx0XHRcdFx0aWYgKG90aGVyRWxlbWVudCAhPT0gZWxlbWVudCAmJiAoXG5cdFx0XHRcdFx0XHRcdC8vIEluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIGhpZ2hlciB6SW5kZXhcblx0XHRcdFx0XHRcdFx0cEludChvdGhlclpJbmRleCkgPiB2YWx1ZSB8fFxuXHRcdFx0XHRcdFx0XHQvLyBJZiBubyB6SW5kZXggZ2l2ZW4sIGluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIHpJbmRleFxuXHRcdFx0XHRcdFx0XHQoIWRlZmluZWQodmFsdWUpICYmIGRlZmluZWQob3RoZXJaSW5kZXgpKVxuXG5cdFx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG90aGVyRWxlbWVudCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaW5zZXJ0ZWQpIHtcblx0XHRcdFx0XHRwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5zZXJ0ZWQ7XG5cdFx0fSxcblx0XHRfZGVmYXVsdFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBTb21lIHNoYXJlZCBzZXR0ZXJzIGFuZCBnZXR0ZXJzXG5cdFNWR0VsZW1lbnQucHJvdG90eXBlLnlHZXR0ZXIgPSBTVkdFbGVtZW50LnByb3RvdHlwZS54R2V0dGVyO1xuXHRTVkdFbGVtZW50LnByb3RvdHlwZS50cmFuc2xhdGVYU2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUudHJhbnNsYXRlWVNldHRlciA9IFxuXHRcdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUucm90YXRpb25TZXR0ZXIgPSBTVkdFbGVtZW50LnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyID0gXG5cdFx0XHRTVkdFbGVtZW50LnByb3RvdHlwZS5zY2FsZVhTZXR0ZXIgPSBTVkdFbGVtZW50LnByb3RvdHlwZS5zY2FsZVlTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdHRoaXMuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHR9O1xuXG5cdC8vIFdlYktpdCBhbmQgQmF0aWsgaGF2ZSBwcm9ibGVtcyB3aXRoIGEgc3Ryb2tlLXdpZHRoIG9mIHplcm8sIHNvIGluIHRoaXMgY2FzZSB3ZSByZW1vdmUgdGhlIFxuXHQvLyBzdHJva2UgYXR0cmlidXRlIGFsdG9nZXRoZXIuICMxMjcwLCAjMTM2OSwgIzMwNjUsICMzMDcyLlxuXHRTVkdFbGVtZW50LnByb3RvdHlwZVsnc3Ryb2tlLXdpZHRoU2V0dGVyJ10gPSBTVkdFbGVtZW50LnByb3RvdHlwZS5zdHJva2VTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdC8vIE9ubHkgYXBwbHkgdGhlIHN0cm9rZSBhdHRyaWJ1dGUgaWYgdGhlIHN0cm9rZSB3aWR0aCBpcyBkZWZpbmVkIGFuZCBsYXJnZXIgdGhhbiAwXG5cdFx0aWYgKHRoaXMuc3Ryb2tlICYmIHRoaXNbJ3N0cm9rZS13aWR0aCddKSB7XG5cdFx0XHR0aGlzLnN0cm9rZVdpZHRoID0gdGhpc1snc3Ryb2tlLXdpZHRoJ107XG5cdFx0XHRTVkdFbGVtZW50LnByb3RvdHlwZS5maWxsU2V0dGVyLmNhbGwodGhpcywgdGhpcy5zdHJva2UsICdzdHJva2UnLCBlbGVtZW50KTsgLy8gdXNlIHByb3RvdHlwZSBhcyBpbnN0YW5jZSBtYXkgYmUgb3ZlcnJpZGRlblxuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXNbJ3N0cm9rZS13aWR0aCddKTtcblx0XHRcdHRoaXMuaGFzU3Ryb2tlID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0cm9rZS13aWR0aCcgJiYgdmFsdWUgPT09IDAgJiYgdGhpcy5oYXNTdHJva2UpIHtcblx0XHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UnKTtcblx0XHRcdHRoaXMuaGFzU3Ryb2tlID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IFNWRyByZW5kZXJlclxuXHQgKi9cblx0dmFyIFNWR1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXHRTVkdSZW5kZXJlci5wcm90b3R5cGUgPSB7XG5cdFx0RWxlbWVudDogU1ZHRWxlbWVudCxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIFNWR1JlbmRlcmVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvckV4cG9ydFxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChjb250YWluZXIsIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCBmb3JFeHBvcnQpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGxvYyA9IGxvY2F0aW9uLFxuXHRcdFx0XHRib3hXcmFwcGVyLFxuXHRcdFx0XHRlbGVtZW50LFxuXHRcdFx0XHRkZXNjO1xuXG5cdFx0XHRib3hXcmFwcGVyID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnc3ZnJylcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHZlcnNpb246ICcxLjEnXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3ModGhpcy5nZXRTdHlsZShzdHlsZSkpO1xuXHRcdFx0ZWxlbWVudCA9IGJveFdyYXBwZXIuZWxlbWVudDtcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0Ly8gRm9yIGJyb3dzZXJzIG90aGVyIHRoYW4gSUUsIGFkZCB0aGUgbmFtZXNwYWNlIGF0dHJpYnV0ZSAoIzE5NzgpXG5cdFx0XHRpZiAoY29udGFpbmVyLmlubmVySFRNTC5pbmRleE9mKCd4bWxucycpID09PSAtMSkge1xuXHRcdFx0XHRhdHRyKGVsZW1lbnQsICd4bWxucycsIFNWR19OUyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG9iamVjdCBwcm9wZXJ0aWVzXG5cdFx0XHRyZW5kZXJlci5pc1NWRyA9IHRydWU7XG5cdFx0XHRyZW5kZXJlci5ib3ggPSBlbGVtZW50O1xuXHRcdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IGJveFdyYXBwZXI7XG5cdFx0XHRyZW5kZXJlci5hbGlnbmVkT2JqZWN0cyA9IFtdO1xuXG5cdFx0XHQvLyBQYWdlIHVybCB1c2VkIGZvciBpbnRlcm5hbCByZWZlcmVuY2VzLiAjMjQsICM2NzIsICMxMDcwXG5cdFx0XHRyZW5kZXJlci51cmwgPSAoaXNGaXJlZm94IHx8IGlzV2ViS2l0KSAmJiBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKS5sZW5ndGggP1xuXHRcdFx0XHRsb2MuaHJlZlxuXHRcdFx0XHRcdC5yZXBsYWNlKC8jLio/JC8sICcnKSAvLyByZW1vdmUgdGhlIGhhc2hcblx0XHRcdFx0XHQucmVwbGFjZSgvKFtcXCgnXFwpXSkvZywgJ1xcXFwkMScpIC8vIGVzY2FwZSBwYXJhbnRoZXNlcyBhbmQgcXVvdGVzXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyAvZywgJyUyMCcpIDogLy8gcmVwbGFjZSBzcGFjZXMgKG5lZWRlZCBmb3IgU2FmYXJpIG9ubHkpXG5cdFx0XHRcdCcnO1xuXG5cdFx0XHQvLyBBZGQgZGVzY3JpcHRpb25cblx0XHRcdGRlc2MgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2Rlc2MnKS5hZGQoKTtcblx0XHRcdGRlc2MuZWxlbWVudC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoJ0NyZWF0ZWQgd2l0aCAnICsgUFJPRFVDVCArICcgJyArIFZFUlNJT04pKTtcblxuXG5cdFx0XHRyZW5kZXJlci5kZWZzID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkZWZzJykuYWRkKCk7XG5cdFx0XHRyZW5kZXJlci5mb3JFeHBvcnQgPSBmb3JFeHBvcnQ7XG5cdFx0XHRyZW5kZXJlci5ncmFkaWVudHMgPSB7fTsgLy8gT2JqZWN0IHdoZXJlIGdyYWRpZW50IFN2Z0VsZW1lbnRzIGFyZSBzdG9yZWRcblx0XHRcdHJlbmRlcmVyLmNhY2hlID0ge307IC8vIENhY2hlIGZvciBudW1lcmljYWwgYm91bmRpbmcgYm94ZXNcblxuXHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cblxuXG5cdFx0XHQvLyBJc3N1ZSAxMTAgd29ya2Fyb3VuZDpcblx0XHRcdC8vIEluIEZpcmVmb3gsIGlmIGEgZGl2IGlzIHBvc2l0aW9uZWQgYnkgcGVyY2VudGFnZSwgaXRzIHBpeGVsIHBvc2l0aW9uIG1heSBsYW5kXG5cdFx0XHQvLyBiZXR3ZWVuIHBpeGVscy4gVGhlIGNvbnRhaW5lciBpdHNlbGYgZG9lc24ndCBkaXNwbGF5IHRoaXMsIGJ1dCBhbiBTVkcgZWxlbWVudFxuXHRcdFx0Ly8gaW5zaWRlIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgZHJhd24gYXQgc3VicGl4ZWwgcHJlY2lzaW9uLiBJbiBvcmRlciB0byBkcmF3XG5cdFx0XHQvLyBzaGFycCBsaW5lcywgdGhpcyBtdXN0IGJlIGNvbXBlbnNhdGVkIGZvci4gVGhpcyBkb2Vzbid0IHNlZW0gdG8gd29yayBpbnNpZGVcblx0XHRcdC8vIGlmcmFtZXMgdGhvdWdoIChsaWtlIGluIGpzRmlkZGxlKS5cblx0XHRcdHZhciBzdWJQaXhlbEZpeCwgcmVjdDtcblx0XHRcdGlmIChpc0ZpcmVmb3ggJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuXHRcdFx0XHRyZW5kZXJlci5zdWJQaXhlbEZpeCA9IHN1YlBpeGVsRml4ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNzcyhjb250YWluZXIsIHsgbGVmdDogMCwgdG9wOiAwIH0pO1xuXHRcdFx0XHRcdHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0Y3NzKGNvbnRhaW5lciwge1xuXHRcdFx0XHRcdFx0bGVmdDogKG1hdGhDZWlsKHJlY3QubGVmdCkgLSByZWN0LmxlZnQpICsgUFgsXG5cdFx0XHRcdFx0XHR0b3A6IChtYXRoQ2VpbChyZWN0LnRvcCkgLSByZWN0LnRvcCkgKyBQWFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIHJ1biB0aGUgZml4IG5vd1xuXHRcdFx0XHRzdWJQaXhlbEZpeCgpO1xuXG5cdFx0XHRcdC8vIHJ1biBpdCBvbiByZXNpemVcblx0XHRcdFx0YWRkRXZlbnQod2luLCAncmVzaXplJywgc3ViUGl4ZWxGaXgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuc3R5bGUgPSBleHRlbmQoe1xuXHRcdFx0XHRmb250RmFtaWx5OiAnXCJMdWNpZGEgR3JhbmRlXCIsIFwiTHVjaWRhIFNhbnMgVW5pY29kZVwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJywgLy8gZGVmYXVsdCBmb250XG5cdFx0XHRcdGZvbnRTaXplOiAnMTJweCdcblx0XHRcdH0sIHN0eWxlKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERldGVjdCB3aGV0aGVyIHRoZSByZW5kZXJlciBpcyBoaWRkZW4uIFRoaXMgaGFwcGVucyB3aGVuIG9uZSBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG5cdFx0ICogaGFzIGRpc3BsYXk6IG5vbmUuICM2MDguXG5cdFx0ICovXG5cdFx0aXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAhdGhpcy5ib3hXcmFwcGVyLmdldEJCb3goKS53aWR0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveXMgdGhlIHJlbmRlcmVyIGFuZCBpdHMgYWxsb2NhdGVkIG1lbWJlcnMuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0cmVuZGVyZXJEZWZzID0gcmVuZGVyZXIuZGVmcztcblx0XHRcdHJlbmRlcmVyLmJveCA9IG51bGw7XG5cdFx0XHRyZW5kZXJlci5ib3hXcmFwcGVyID0gcmVuZGVyZXIuYm94V3JhcHBlci5kZXN0cm95KCk7XG5cblx0XHRcdC8vIENhbGwgZGVzdHJveSBvbiBhbGwgZ3JhZGllbnQgZWxlbWVudHNcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHJlbmRlcmVyLmdyYWRpZW50cyB8fCB7fSk7XG5cdFx0XHRyZW5kZXJlci5ncmFkaWVudHMgPSBudWxsO1xuXG5cdFx0XHQvLyBEZWZzIGFyZSBudWxsIGluIFZNTFJlbmRlcmVyXG5cdFx0XHQvLyBPdGhlcndpc2UsIGRlc3Ryb3kgdGhlbSBoZXJlLlxuXHRcdFx0aWYgKHJlbmRlcmVyRGVmcykge1xuXHRcdFx0XHRyZW5kZXJlci5kZWZzID0gcmVuZGVyZXJEZWZzLmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHN1YiBwaXhlbCBmaXggaGFuZGxlclxuXHRcdFx0Ly8gV2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZXJlIGlzIGEgaGFuZGxlciwgb3RoZXJ3aXNlIGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcmVnaXN0ZXJlZCBmb3IgZXZlbnQgJ3Jlc2l6ZScgYXJlIHJlbW92ZWRcblx0XHRcdC8vIFNlZSBpc3N1ZSAjOTgyXG5cdFx0XHRpZiAocmVuZGVyZXIuc3ViUGl4ZWxGaXgpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQod2luLCAncmVzaXplJywgcmVuZGVyZXIuc3ViUGl4ZWxGaXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJlci5hbGlnbmVkT2JqZWN0cyA9IG51bGw7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSB3cmFwcGVyIGZvciBhbiBTVkcgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTmFtZVxuXHRcdCAqL1xuXHRcdGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChub2RlTmFtZSkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSBuZXcgdGhpcy5FbGVtZW50KCk7XG5cdFx0XHR3cmFwcGVyLmluaXQodGhpcywgbm9kZU5hbWUpO1xuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIER1bW15IGZ1bmN0aW9uIGZvciB1c2UgaW4gY2FudmFzIHJlbmRlcmVyXG5cdFx0ICovXG5cdFx0ZHJhdzogZnVuY3Rpb24gKCkge30sXG5cblx0XHQvKipcblx0XHQgKiBQYXJzZSBhIHNpbXBsZSBIVE1MIHN0cmluZyBpbnRvIFNWRyB0c3BhbnNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0Tm9kZSBUaGUgcGFyZW50IHRleHQgU1ZHIG5vZGVcblx0XHQgKi9cblx0XHRidWlsZFRleHQ6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG5cdFx0XHR2YXIgdGV4dE5vZGUgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0Zm9yRXhwb3J0ID0gcmVuZGVyZXIuZm9yRXhwb3J0LFxuXHRcdFx0XHR0ZXh0U3RyID0gcGljayh3cmFwcGVyLnRleHRTdHIsICcnKS50b1N0cmluZygpLFxuXHRcdFx0XHRoYXNNYXJrdXAgPSB0ZXh0U3RyLmluZGV4T2YoJzwnKSAhPT0gLTEsXG5cdFx0XHRcdGxpbmVzLFxuXHRcdFx0XHRjaGlsZE5vZGVzID0gdGV4dE5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3R5bGVSZWdleCxcblx0XHRcdFx0aHJlZlJlZ2V4LFxuXHRcdFx0XHRwYXJlbnRYID0gYXR0cih0ZXh0Tm9kZSwgJ3gnKSxcblx0XHRcdFx0dGV4dFN0eWxlcyA9IHdyYXBwZXIuc3R5bGVzLFxuXHRcdFx0XHR3aWR0aCA9IHdyYXBwZXIudGV4dFdpZHRoLFxuXHRcdFx0XHR0ZXh0TGluZUhlaWdodCA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy5saW5lSGVpZ2h0LFxuXHRcdFx0XHR0ZXh0U2hhZG93ID0gdGV4dFN0eWxlcyAmJiB0ZXh0U3R5bGVzLnRleHRTaGFkb3csXG5cdFx0XHRcdGVsbGlwc2lzID0gdGV4dFN0eWxlcyAmJiB0ZXh0U3R5bGVzLnRleHRPdmVyZmxvdyA9PT0gJ2VsbGlwc2lzJyxcblx0XHRcdFx0aSA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuXHRcdFx0XHR0ZW1wUGFyZW50ID0gd2lkdGggJiYgIXdyYXBwZXIuYWRkZWQgJiYgdGhpcy5ib3gsXG5cdFx0XHRcdGdldExpbmVIZWlnaHQgPSBmdW5jdGlvbiAodHNwYW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gdGV4dExpbmVIZWlnaHQgPyBcblx0XHRcdFx0XHRcdHBJbnQodGV4dExpbmVIZWlnaHQpIDpcblx0XHRcdFx0XHRcdHJlbmRlcmVyLmZvbnRNZXRyaWNzKFxuXHRcdFx0XHRcdFx0XHQvKHB4fGVtKSQvLnRlc3QodHNwYW4gJiYgdHNwYW4uc3R5bGUuZm9udFNpemUpID9cblx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5zdHlsZS5mb250U2l6ZSA6XG5cdFx0XHRcdFx0XHRcdFx0KCh0ZXh0U3R5bGVzICYmIHRleHRTdHlsZXMuZm9udFNpemUpIHx8IHJlbmRlcmVyLnN0eWxlLmZvbnRTaXplIHx8IDEyKSxcblx0XHRcdFx0XHRcdFx0dHNwYW5cblx0XHRcdFx0XHRcdCkuaDtcblx0XHRcdFx0fSxcblx0XHRcdFx0dW5lc2NhcGVBbmdsZUJyYWNrZXRzID0gZnVuY3Rpb24gKGlucHV0U3RyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0U3RyLnJlcGxhY2UoLyZsdDsvZywgJzwnKS5yZXBsYWNlKC8mZ3Q7L2csICc+Jyk7XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vLyByZW1vdmUgb2xkIHRleHRcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dGV4dE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNraXAgdHNwYW5zLCBhZGQgdGV4dCBkaXJlY3RseSB0byB0ZXh0IG5vZGUuIFRoZSBmb3JjZVRTcGFuIGlzIGEgaG9vayBcblx0XHRcdC8vIHVzZWQgaW4gdGV4dCBvdXRsaW5lIGhhY2suXG5cdFx0XHRpZiAoIWhhc01hcmt1cCAmJiAhdGV4dFNoYWRvdyAmJiAhZWxsaXBzaXMgJiYgdGV4dFN0ci5pbmRleE9mKCcgJykgPT09IC0xKSB7XG5cdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh1bmVzY2FwZUFuZ2xlQnJhY2tldHModGV4dFN0cikpKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBDb21wbGV4IHN0cmluZ3MsIGFkZCBtb3JlIGxvZ2ljXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN0eWxlUmVnZXggPSAvPC4qc3R5bGU9XCIoW15cIl0rKVwiLio+Lztcblx0XHRcdFx0aHJlZlJlZ2V4ID0gLzwuKmhyZWY9XCIoaHR0cFteXCJdKylcIi4qPi87XG5cblx0XHRcdFx0aWYgKHRlbXBQYXJlbnQpIHtcblx0XHRcdFx0XHR0ZW1wUGFyZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgLy8gYXR0YWNoIGl0IHRvIHRoZSBET00gdG8gcmVhZCBvZmZzZXQgd2lkdGhcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYXNNYXJrdXApIHtcblx0XHRcdFx0XHRsaW5lcyA9IHRleHRTdHJcblx0XHRcdFx0XHRcdC5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPicpXG5cdFx0XHRcdFx0XHQucmVwbGFjZSgvPChpfGVtKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC1zdHlsZTppdGFsaWNcIj4nKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLzxhL2csICc8c3BhbicpXG5cdFx0XHRcdFx0XHQucmVwbGFjZSgvPFxcLyhifHN0cm9uZ3xpfGVtfGEpPi9nLCAnPC9zcGFuPicpXG5cdFx0XHRcdFx0XHQuc3BsaXQoLzxici4qPz4vZyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaW5lcyA9IFt0ZXh0U3RyXTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly8gcmVtb3ZlIGVtcHR5IGxpbmUgYXQgZW5kXG5cdFx0XHRcdGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJycpIHtcblx0XHRcdFx0XHRsaW5lcy5wb3AoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBidWlsZCB0aGUgbGluZXNcblx0XHRcdFx0ZWFjaChsaW5lcywgZnVuY3Rpb24gKGxpbmUsIGxpbmVObykge1xuXHRcdFx0XHRcdHZhciBzcGFucywgc3Bhbk5vID0gMDtcblxuXHRcdFx0XHRcdGxpbmUgPSBsaW5lLnJlcGxhY2UoLzxzcGFuL2csICd8fHw8c3BhbicpLnJlcGxhY2UoLzxcXC9zcGFuPi9nLCAnPC9zcGFuPnx8fCcpO1xuXHRcdFx0XHRcdHNwYW5zID0gbGluZS5zcGxpdCgnfHx8Jyk7XG5cblx0XHRcdFx0XHRlYWNoKHNwYW5zLCBmdW5jdGlvbiAoc3Bhbikge1xuXHRcdFx0XHRcdFx0aWYgKHNwYW4gIT09ICcnIHx8IHNwYW5zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IHt9LFxuXHRcdFx0XHRcdFx0XHRcdHRzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0c3BhbicpLFxuXHRcdFx0XHRcdFx0XHRcdHNwYW5TdHlsZTsgLy8gIzM5MFxuXHRcdFx0XHRcdFx0XHRpZiAoc3R5bGVSZWdleC50ZXN0KHNwYW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3BhblN0eWxlID0gc3Bhbi5tYXRjaChzdHlsZVJlZ2V4KVsxXS5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLCAnJDFmaWxsJDInKTtcblx0XHRcdFx0XHRcdFx0XHRhdHRyKHRzcGFuLCAnc3R5bGUnLCBzcGFuU3R5bGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChocmVmUmVnZXgudGVzdChzcGFuKSAmJiAhZm9yRXhwb3J0KSB7IC8vIE5vdCBmb3IgZXhwb3J0IC0gIzE1Mjlcblx0XHRcdFx0XHRcdFx0XHRhdHRyKHRzcGFuLCAnb25jbGljaycsICdsb2NhdGlvbi5ocmVmPVxcXCInICsgc3Bhbi5tYXRjaChocmVmUmVnZXgpWzFdICsgJ1xcXCInKTtcblx0XHRcdFx0XHRcdFx0XHRjc3ModHNwYW4sIHsgY3Vyc29yOiAncG9pbnRlcicgfSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRzcGFuID0gdW5lc2NhcGVBbmdsZUJyYWNrZXRzKHNwYW4ucmVwbGFjZSgvPCgufFxcbikqPz4vZywgJycpIHx8ICcgJyk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTmVzdGVkIHRhZ3MgYXJlbid0IHN1cHBvcnRlZCwgYW5kIGNhdXNlIGNyYXNoIGluIFNhZmFyaSAoIzE1OTYpXG5cdFx0XHRcdFx0XHRcdGlmIChzcGFuICE9PSAnICcpIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGFkZCB0aGUgdGV4dCBub2RlXG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4uYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHNwYW4pKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICghc3Bhbk5vKSB7IC8vIGZpcnN0IHNwYW4gaW4gYSBsaW5lLCBhbGlnbiBpdCB0byB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmVObyAmJiBwYXJlbnRYICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZXMueCA9IHBhcmVudFg7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZXMuZHggPSAwOyAvLyAjMTZcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhZGQgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sIGF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGl0XG5cdFx0XHRcdFx0XHRcdFx0dGV4dE5vZGUuYXBwZW5kQ2hpbGQodHNwYW4pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZmlyc3Qgc3BhbiBvbiBzdWJzZXF1ZW50IGxpbmUsIGFkZCB0aGUgbGluZSBoZWlnaHRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXNwYW5ObyAmJiBsaW5lTm8pIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYWxsb3cgZ2V0dGluZyB0aGUgcmlnaHQgb2Zmc2V0IGhlaWdodCBpbiBleHBvcnRpbmcgaW4gSUVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghaGFzU1ZHICYmIGZvckV4cG9ydCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjc3ModHNwYW4sIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU2V0IHRoZSBsaW5lIGhlaWdodCBiYXNlZCBvbiB0aGUgZm9udCBzaXplIG9mIGVpdGhlclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIHRleHQgZWxlbWVudCBvciB0aGUgdHNwYW4gZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cihcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdkeScsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGdldExpbmVIZWlnaHQodHNwYW4pXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8qaWYgKHdpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZW5kZXJlci5icmVha1RleHQod3JhcHBlciwgd2lkdGgpO1xuXHRcdFx0XHRcdFx0XHRcdH0qL1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2hlY2sgd2lkdGggYW5kIGFwcGx5IHNvZnQgYnJlYWtzIG9yIGVsbGlwc2lzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgd29yZHMgPSBzcGFuLnJlcGxhY2UoLyhbXlxcXl0pLS9nLCAnJDEtICcpLnNwbGl0KCcgJyksIC8vICMxMjczXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGhhc1doaXRlU3BhY2UgPSBzcGFucy5sZW5ndGggPiAxIHx8IGxpbmVObyB8fCAod29yZHMubGVuZ3RoID4gMSAmJiB0ZXh0U3R5bGVzLndoaXRlU3BhY2UgIT09ICdub3dyYXAnKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG9vTG9uZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0d2FzVG9vTG9uZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0dWFsV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3QgPSBbXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZHkgPSBnZXRMaW5lSGVpZ2h0KHRzcGFuKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c29mdExpbmVObyA9IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZFN0ciA9IHNwYW4sIC8vIGZvciBlbGxpcHNpc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJzb3IgPSB3b3JkU3RyLmxlbmd0aCwgLy8gYmluYXJ5IHNlYXJjaCBjdXJzb3Jcblx0XHRcdFx0XHRcdFx0XHRcdFx0YkJveDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKChoYXNXaGl0ZVNwYWNlIHx8IGVsbGlwc2lzKSAmJiAod29yZHMubGVuZ3RoIHx8IHJlc3QubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLnJvdGF0aW9uID0gMDsgLy8gZGlzY2FyZCByb3RhdGlvbiB3aGVuIGNvbXB1dGluZyBib3hcblx0XHRcdFx0XHRcdFx0XHRcdFx0YkJveCA9IHdyYXBwZXIuZ2V0QkJveCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0dWFsV2lkdGggPSBiQm94LndpZHRoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9sZCBJRSBjYW5ub3QgbWVhc3VyZSB0aGUgYWN0dWFsV2lkdGggZm9yIFNWRyBlbGVtZW50cyAoIzIzMTQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghaGFzU1ZHICYmIHJlbmRlcmVyLmZvckV4cG9ydCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjdHVhbFdpZHRoID0gcmVuZGVyZXIubWVhc3VyZVNwYW5XaWR0aCh0c3Bhbi5maXJzdENoaWxkLmRhdGEsIHdyYXBwZXIuc3R5bGVzKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRvb0xvbmcgPSBhY3R1YWxXaWR0aCA+IHdpZHRoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBlbGxpcHNpcywgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgY29ycmVjdCBzdHJpbmcgbGVuZ3RoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh3YXNUb29Mb25nID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3YXNUb29Mb25nID0gdG9vTG9uZzsgLy8gRmlyc3QgdGltZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbGxpcHNpcyAmJiB3YXNUb29Mb25nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y3Vyc29yIC89IDI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAod29yZFN0ciA9PT0gJycgfHwgKCF0b29Mb25nICYmIGN1cnNvciA8IDAuNSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRzID0gW107IC8vIEFsbCBvaywgYnJlYWsgb3V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0b29Mb25nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdhc1Rvb0xvbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZFN0ciA9IHNwYW4uc3Vic3RyaW5nKDAsIHdvcmRTdHIubGVuZ3RoICsgKHRvb0xvbmcgPyAtMSA6IDEpICogbWF0aENlaWwoY3Vyc29yKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IFt3b3JkU3RyICsgKHdpZHRoID4gMyA/ICdcXHUyMDI2JyA6ICcnKV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5yZW1vdmVDaGlsZCh0c3Bhbi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTG9vcGluZyBkb3duLCB0aGlzIGlzIHRoZSBmaXJzdCB3b3JkIHNlcXVlbmNlIHRoYXQgaXMgbm90IHRvbyBsb25nLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBzbyB3ZSBjYW4gbW92ZSBvbiB0byBidWlsZCB0aGUgbmV4dCBsaW5lLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF0b29Mb25nIHx8IHdvcmRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRzID0gcmVzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN0ID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNvZnRMaW5lTm8rKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3RzcGFuJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdHRyKHRzcGFuLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGR5OiBkeSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eDogcGFyZW50WFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3BhblN0eWxlKSB7IC8vICMzOTBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ3N0eWxlJywgc3BhblN0eWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFjdHVhbFdpZHRoID4gd2lkdGgpIHsgLy8gYSBzaW5nbGUgd29yZCBpcyBwcmVzc2luZyBpdCBvdXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoID0gYWN0dWFsV2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBhcHBlbmQgdG8gZXhpc3RpbmcgbGluZSB0c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnJlbW92ZUNoaWxkKHRzcGFuLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3QudW5zaGlmdCh3b3Jkcy5wb3AoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh3b3Jkcy5qb2luKCcgJykucmVwbGFjZSgvLSAvZywgJy0nKSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod2FzVG9vTG9uZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLmF0dHIoJ3RpdGxlJywgd3JhcHBlci50ZXh0U3RyKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRzcGFuTm8rKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRlbXBQYXJlbnQpIHtcblx0XHRcdFx0XHR0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTsgLy8gYXR0YWNoIGl0IHRvIHRoZSBET00gdG8gcmVhZCBvZmZzZXQgd2lkdGhcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSB0ZXh0IHNoYWRvd1xuXHRcdFx0XHRpZiAodGV4dFNoYWRvdyAmJiB3cmFwcGVyLmFwcGx5VGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdHdyYXBwZXIuYXBwbHlUZXh0U2hhZG93KHRleHRTaGFkb3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFxuXG5cdFx0Lypcblx0XHRicmVha1RleHQ6IGZ1bmN0aW9uICh3cmFwcGVyLCB3aWR0aCkge1xuXHRcdFx0dmFyIGJCb3ggPSB3cmFwcGVyLmdldEJCb3goKSxcblx0XHRcdFx0bm9kZSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dGV4dExlbmd0aCA9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRwb3MgPSBtYXRoUm91bmQod2lkdGggKiB0ZXh0TGVuZ3RoIC8gYkJveC53aWR0aCksIC8vIHRyeSB0aGlzIHBvc2l0aW9uIGZpcnN0LCBiYXNlZCBvbiBhdmVyYWdlIGNoYXJhY3RlciB3aWR0aFxuXHRcdFx0XHRpbmNyZW1lbnQgPSAwLFxuXHRcdFx0XHRmaW5hbFBvcztcblxuXHRcdFx0aWYgKGJCb3gud2lkdGggPiB3aWR0aCkge1xuXHRcdFx0XHR3aGlsZSAoZmluYWxQb3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHRMZW5ndGggPSBub2RlLmdldFN1YlN0cmluZ0xlbmd0aCgwLCBwb3MpO1xuXG5cdFx0XHRcdFx0aWYgKHRleHRMZW5ndGggPD0gd2lkdGgpIHtcblx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGZpbmFsUG9zID0gcG9zO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50ID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRmaW5hbFBvcyA9IHBvcyAtIDE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQgPSAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zICs9IGluY3JlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coZmluYWxQb3MsIG5vZGUuZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIGZpbmFsUG9zKSlcblx0XHR9LFxuXHRcdCovXG5cblx0XHQvKiogXG5cdFx0ICogUmV0dXJucyB3aGl0ZSBmb3IgZGFyayBjb2xvcnMgYW5kIGJsYWNrIGZvciBicmlnaHQgY29sb3JzXG5cdFx0ICovXG5cdFx0Z2V0Q29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvcihjb2xvcikucmdiYTtcblx0XHRcdHJldHVybiBjb2xvclswXSArIGNvbG9yWzFdICsgY29sb3JbMl0gPiAzODQgPyAnIzAwMDAwMCcgOiAnI0ZGRkZGRic7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIGJ1dHRvbiB3aXRoIHByZXNldCBzdGF0ZXNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub3JtYWxTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBob3ZlclN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHByZXNzZWRTdGF0ZVxuXHRcdCAqL1xuXHRcdGJ1dHRvbjogZnVuY3Rpb24gKHRleHQsIHgsIHksIGNhbGxiYWNrLCBub3JtYWxTdGF0ZSwgaG92ZXJTdGF0ZSwgcHJlc3NlZFN0YXRlLCBkaXNhYmxlZFN0YXRlLCBzaGFwZSkge1xuXHRcdFx0dmFyIGxhYmVsID0gdGhpcy5sYWJlbCh0ZXh0LCB4LCB5LCBzaGFwZSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgJ2J1dHRvbicpLFxuXHRcdFx0XHRjdXJTdGF0ZSA9IDAsXG5cdFx0XHRcdHN0YXRlT3B0aW9ucyxcblx0XHRcdFx0c3RhdGVTdHlsZSxcblx0XHRcdFx0bm9ybWFsU3R5bGUsXG5cdFx0XHRcdGhvdmVyU3R5bGUsXG5cdFx0XHRcdHByZXNzZWRTdHlsZSxcblx0XHRcdFx0ZGlzYWJsZWRTdHlsZSxcblx0XHRcdFx0dmVydGljYWxHcmFkaWVudCA9IHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDEgfTtcblxuXHRcdFx0Ly8gTm9ybWFsIHN0YXRlIC0gcHJlcGFyZSB0aGUgYXR0cmlidXRlc1xuXHRcdFx0bm9ybWFsU3RhdGUgPSBtZXJnZSh7XG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRzdHJva2U6ICcjQ0NDQ0NDJyxcblx0XHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0XHRbMCwgJyNGRUZFRkUnXSxcblx0XHRcdFx0XHRcdFsxLCAnI0Y2RjZGNiddXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyOiAyLFxuXHRcdFx0XHRwYWRkaW5nOiA1LFxuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGNvbG9yOiAnYmxhY2snXG5cdFx0XHRcdH1cblx0XHRcdH0sIG5vcm1hbFN0YXRlKTtcblx0XHRcdG5vcm1hbFN0eWxlID0gbm9ybWFsU3RhdGUuc3R5bGU7XG5cdFx0XHRkZWxldGUgbm9ybWFsU3RhdGUuc3R5bGU7XG5cblx0XHRcdC8vIEhvdmVyIHN0YXRlXG5cdFx0XHRob3ZlclN0YXRlID0gbWVyZ2Uobm9ybWFsU3RhdGUsIHtcblx0XHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRcdGZpbGw6IHtcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudDogdmVydGljYWxHcmFkaWVudCxcblx0XHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFx0WzAsICcjRkZGJ10sXG5cdFx0XHRcdFx0XHRbMSwgJyNBQ0YnXVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fVxuXHRcdFx0fSwgaG92ZXJTdGF0ZSk7XG5cdFx0XHRob3ZlclN0eWxlID0gaG92ZXJTdGF0ZS5zdHlsZTtcblx0XHRcdGRlbGV0ZSBob3ZlclN0YXRlLnN0eWxlO1xuXG5cdFx0XHQvLyBQcmVzc2VkIHN0YXRlXG5cdFx0XHRwcmVzc2VkU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0XHRzdHJva2U6ICcjNjhBJyxcblx0XHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0XHRbMCwgJyM5QkQnXSxcblx0XHRcdFx0XHRcdFsxLCAnI0NERiddXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9XG5cdFx0XHR9LCBwcmVzc2VkU3RhdGUpO1xuXHRcdFx0cHJlc3NlZFN0eWxlID0gcHJlc3NlZFN0YXRlLnN0eWxlO1xuXHRcdFx0ZGVsZXRlIHByZXNzZWRTdGF0ZS5zdHlsZTtcblxuXHRcdFx0Ly8gRGlzYWJsZWQgc3RhdGVcblx0XHRcdGRpc2FibGVkU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGNvbG9yOiAnI0NDQydcblx0XHRcdFx0fVxuXHRcdFx0fSwgZGlzYWJsZWRTdGF0ZSk7XG5cdFx0XHRkaXNhYmxlZFN0eWxlID0gZGlzYWJsZWRTdGF0ZS5zdHlsZTtcblx0XHRcdGRlbGV0ZSBkaXNhYmxlZFN0YXRlLnN0eWxlO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50cy4gSUU5IGFuZCBJRTEwIG5lZWQgbW91c2VvdmVyIGFuZCBtb3VzZW91dCB0byBmdW5jaXRvbiAoIzY2NykuXG5cdFx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3ZlcicgOiAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cihob3ZlclN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhob3ZlclN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3V0JyA6ICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY3VyU3RhdGUgIT09IDMpIHtcblx0XHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBbbm9ybWFsU3RhdGUsIGhvdmVyU3RhdGUsIHByZXNzZWRTdGF0ZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRcdHN0YXRlU3R5bGUgPSBbbm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIHByZXNzZWRTdHlsZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoc3RhdGVPcHRpb25zKVxuXHRcdFx0XHRcdFx0LmNzcyhzdGF0ZVN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGxhYmVsLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHRcdGxhYmVsLnN0YXRlID0gY3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdFx0aWYgKCFzdGF0ZSkge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIobm9ybWFsU3RhdGUpXG5cdFx0XHRcdFx0XHQuY3NzKG5vcm1hbFN0eWxlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gMikge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIocHJlc3NlZFN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhwcmVzc2VkU3R5bGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSAzKSB7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cihkaXNhYmxlZFN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhkaXNhYmxlZFN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGxhYmVsXG5cdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGxhYmVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hdHRyKG5vcm1hbFN0YXRlKVxuXHRcdFx0XHQuY3NzKGV4dGVuZCh7IGN1cnNvcjogJ2RlZmF1bHQnIH0sIG5vcm1hbFN0eWxlKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgYSBzdHJhaWdodCBsaW5lIGNyaXNwZXIgYnkgbm90IHNwaWxsaW5nIG91dCB0byBuZWlnaGJvdXIgcGl4ZWxzXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICovXG5cdFx0Y3Jpc3BMaW5lOiBmdW5jdGlvbiAocG9pbnRzLCB3aWR0aCkge1xuXHRcdFx0Ly8gcG9pbnRzIGZvcm1hdDogW00sIDAsIDAsIEwsIDEwMCwgMF1cblx0XHRcdC8vIG5vcm1hbGl6ZSB0byBhIGNyaXNwIGxpbmVcblx0XHRcdGlmIChwb2ludHNbMV0gPT09IHBvaW50c1s0XSkge1xuXHRcdFx0XHQvLyBTdWJzdHJhY3QgZHVlIHRvICMxMTI5LiBOb3cgYm90dG9tIGFuZCBsZWZ0IGF4aXMgZ3JpZGxpbmVzIGJlaGF2ZSB0aGUgc2FtZS5cblx0XHRcdFx0cG9pbnRzWzFdID0gcG9pbnRzWzRdID0gbWF0aFJvdW5kKHBvaW50c1sxXSkgLSAod2lkdGggJSAyIC8gMik7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnRzWzJdID09PSBwb2ludHNbNV0pIHtcblx0XHRcdFx0cG9pbnRzWzJdID0gcG9pbnRzWzVdID0gbWF0aFJvdW5kKHBvaW50c1syXSkgKyAod2lkdGggJSAyIC8gMik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYSBwYXRoXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBTVkcgcGF0aCBpbiBhcnJheSBmb3JtXG5cdFx0ICovXG5cdFx0cGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdHZhciBhdHRyID0ge1xuXHRcdFx0XHRmaWxsOiBOT05FXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzQXJyYXkocGF0aCkpIHtcblx0XHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0XHRleHRlbmQoYXR0ciwgcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdwYXRoJykuYXR0cihhdHRyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyBhbmQgcmV0dXJuIGFuIFNWRyBjaXJjbGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJhZGl1c1xuXHRcdCAqL1xuXHRcdGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHIpIHtcblx0XHRcdHZhciBhdHRyID0gaXNPYmplY3QoeCkgP1xuXHRcdFx0XHR4IDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHRyOiByXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpO1xuXG5cdFx0XHR3cmFwcGVyLnhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnY3gnLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci55U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2N5JywgdmFsdWUpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB3cmFwcGVyLmF0dHIoYXR0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYW5kIHJldHVybiBhbiBhcmNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSByIFJhZGl1c1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclIgSW5uZXIgcmFkaXVzIGxpa2UgdXNlZCBpbiBkb251dCBjaGFydHNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnRpbmcgYW5nbGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZGluZyBhbmdsZVxuXHRcdCAqL1xuXHRcdGFyYzogZnVuY3Rpb24gKHgsIHksIHIsIGlubmVyUiwgc3RhcnQsIGVuZCkge1xuXHRcdFx0dmFyIGFyYztcblxuXHRcdFx0aWYgKGlzT2JqZWN0KHgpKSB7XG5cdFx0XHRcdHkgPSB4Lnk7XG5cdFx0XHRcdHIgPSB4LnI7XG5cdFx0XHRcdGlubmVyUiA9IHguaW5uZXJSO1xuXHRcdFx0XHRzdGFydCA9IHguc3RhcnQ7XG5cdFx0XHRcdGVuZCA9IHguZW5kO1xuXHRcdFx0XHR4ID0geC54O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcmNzIGFyZSBkZWZpbmVkIGFzIHN5bWJvbHMgZm9yIHRoZSBhYmlsaXR5IHRvIHNldFxuXHRcdFx0Ly8gYXR0cmlidXRlcyBpbiBhdHRyIGFuZCBhbmltYXRlXG5cdFx0XHRhcmMgPSB0aGlzLnN5bWJvbCgnYXJjJywgeCB8fCAwLCB5IHx8IDAsIHIgfHwgMCwgciB8fCAwLCB7XG5cdFx0XHRcdGlubmVyUjogaW5uZXJSIHx8IDAsXG5cdFx0XHRcdHN0YXJ0OiBzdGFydCB8fCAwLFxuXHRcdFx0XHRlbmQ6IGVuZCB8fCAwXG5cdFx0XHR9KTtcblx0XHRcdGFyYy5yID0gcjsgLy8gIzk1OVxuXHRcdFx0cmV0dXJuIGFyYztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyBhbmQgcmV0dXJuIGEgcmVjdGFuZ2xlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRvcCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gciBCb3JkZXIgY29ybmVyIHJhZGl1c1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aCBBIHN0cm9rZSB3aWR0aCBjYW4gYmUgc3VwcGxpZWQgdG8gYWxsb3cgY3Jpc3AgZHJhd2luZ1xuXHRcdCAqL1xuXHRcdHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByLCBzdHJva2VXaWR0aCkge1xuXG5cdFx0XHRyID0gaXNPYmplY3QoeCkgPyB4LnIgOiByO1xuXG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgncmVjdCcpLFxuXHRcdFx0XHRhdHRyaWJzID0gaXNPYmplY3QoeCkgPyB4IDogeCA9PT0gVU5ERUZJTkVEID8ge30gOiB7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiBtYXRoTWF4KHdpZHRoLCAwKSxcblx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhNYXgoaGVpZ2h0LCAwKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRhdHRyaWJzLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdGF0dHJpYnMgPSB3cmFwcGVyLmNyaXNwKGF0dHJpYnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocikge1xuXHRcdFx0XHRhdHRyaWJzLnIgPSByO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwcGVyLnJTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0YXR0cih0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHRyeDogdmFsdWUsXG5cdFx0XHRcdFx0cnk6IHZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHdyYXBwZXIuYXR0cihhdHRyaWJzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBib3ggYW5kIHJlLWFsaWduIGFsbCBhbGlnbmVkIGVsZW1lbnRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGhlaWdodFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZVxuXHRcdCAqXG5cdFx0ICovXG5cdFx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGUpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGFsaWduZWRPYmplY3RzID0gcmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsXG5cdFx0XHRcdGkgPSBhbGlnbmVkT2JqZWN0cy5sZW5ndGg7XG5cblx0XHRcdHJlbmRlcmVyLndpZHRoID0gd2lkdGg7XG5cdFx0XHRyZW5kZXJlci5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdHJlbmRlcmVyLmJveFdyYXBwZXJbcGljayhhbmltYXRlLCB0cnVlKSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oe1xuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9KTtcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRhbGlnbmVkT2JqZWN0c1tpXS5hbGlnbigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBncm91cFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBncm91cCB3aWxsIGJlIGdpdmVuIGEgY2xhc3MgbmFtZSBvZiAnaGlnaGNoYXJ0cy17bmFtZX0nLlxuXHRcdCAqXHQgVGhpcyBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyBhbmQgc2NyaXB0aW5nLlxuXHRcdCAqL1xuXHRcdGc6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZycpO1xuXHRcdFx0cmV0dXJuIGRlZmluZWQobmFtZSkgPyBlbGVtLmF0dHIoeyAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH0pIDogZWxlbTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGlzcGxheSBhbiBpbWFnZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGltYWdlOiBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHR2YXIgYXR0cmlicyA9IHtcblx0XHRcdFx0XHRwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBOT05FXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVsZW1XcmFwcGVyO1xuXG5cdFx0XHQvLyBvcHRpb25hbCBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0ZXh0ZW5kKGF0dHJpYnMsIHtcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtV3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnaW1hZ2UnKS5hdHRyKGF0dHJpYnMpO1xuXG5cdFx0XHQvLyBzZXQgdGhlIGhyZWYgaW4gdGhlIHhsaW5rIG5hbWVzcGFjZVxuXHRcdFx0aWYgKGVsZW1XcmFwcGVyLmVsZW1lbnQuc2V0QXR0cmlidXRlTlMpIHtcblx0XHRcdFx0ZWxlbVdyYXBwZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdFx0XHRcdFx0J2hyZWYnLCBzcmMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY291bGQgYmUgZXhwb3J0aW5nIGluIElFXG5cdFx0XHRcdC8vIHVzaW5nIGhyZWYgdGhyb3dzIFwibm90IHN1cHBvcnRlZFwiIGluIGllNyBhbmQgdW5kZXIsIHJlcXVyaWVzIHJlZ2V4IHNoaW0gdG8gZml4IGxhdGVyXG5cdFx0XHRcdGVsZW1XcmFwcGVyLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoYy1zdmctaHJlZicsIHNyYyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWxlbVdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYSBzeW1ib2wgb3V0IG9mIHByZS1kZWZpbmVkIHNoYXBlIHBhdGhzIGZyb20gdGhlIG5hbWVzcGFjZSAnc3ltYm9sJyBvYmplY3QuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHhcblx0XHQgKiBAcGFyYW0ge09iamVjdH0geVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSByYWRpdXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXG5cdFx0XHR2YXIgb2JqLFxuXG5cdFx0XHRcdC8vIGdldCB0aGUgc3ltYm9sIGRlZmluaXRpb24gZnVuY3Rpb25cblx0XHRcdFx0c3ltYm9sRm4gPSB0aGlzLnN5bWJvbHNbc3ltYm9sXSxcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGVyZSdzIGEgcGF0aCBkZWZpbmVkIGZvciB0aGlzIHN5bWJvbFxuXHRcdFx0XHRwYXRoID0gc3ltYm9sRm4gJiYgc3ltYm9sRm4oXG5cdFx0XHRcdFx0bWF0aFJvdW5kKHgpLFxuXHRcdFx0XHRcdG1hdGhSb3VuZCh5KSxcblx0XHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdFx0b3B0aW9uc1xuXHRcdFx0XHQpLFxuXG5cdFx0XHRcdGltYWdlRWxlbWVudCxcblx0XHRcdFx0aW1hZ2VSZWdleCA9IC9edXJsXFwoKC4qPylcXCkkLyxcblx0XHRcdFx0aW1hZ2VTcmMsXG5cdFx0XHRcdGltYWdlU2l6ZSxcblx0XHRcdFx0Y2VudGVySW1hZ2U7XG5cblx0XHRcdGlmIChwYXRoKSB7XG5cblx0XHRcdFx0b2JqID0gdGhpcy5wYXRoKHBhdGgpO1xuXHRcdFx0XHQvLyBleHBhbmRvIHByb3BlcnRpZXMgZm9yIHVzZSBpbiBhbmltYXRlIGFuZCBhdHRyXG5cdFx0XHRcdGV4dGVuZChvYmosIHtcblx0XHRcdFx0XHRzeW1ib2xOYW1lOiBzeW1ib2wsXG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdFx0XHRleHRlbmQob2JqLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdC8vIGltYWdlIHN5bWJvbHNcblx0XHRcdH0gZWxzZSBpZiAoaW1hZ2VSZWdleC50ZXN0KHN5bWJvbCkpIHtcblxuXHRcdFx0XHQvLyBPbiBpbWFnZSBsb2FkLCBzZXQgdGhlIHNpemUgYW5kIHBvc2l0aW9uXG5cdFx0XHRcdGNlbnRlckltYWdlID0gZnVuY3Rpb24gKGltZywgc2l6ZSkge1xuXHRcdFx0XHRcdGlmIChpbWcuZWxlbWVudCkgeyAvLyBpdCBtYXkgYmUgZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEzOTApXG5cdFx0XHRcdFx0XHRpbWcuYXR0cih7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzaXplWzBdLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHNpemVbMV1cblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWltZy5hbGlnbkJ5VHJhbnNsYXRlKSB7IC8vICMxODVcblx0XHRcdFx0XHRcdFx0aW1nLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoKHdpZHRoIC0gc2l6ZVswXSkgLyAyKSwgLy8gIzEzNzhcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoKGhlaWdodCAtIHNpemVbMV0pIC8gMilcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aW1hZ2VTcmMgPSBzeW1ib2wubWF0Y2goaW1hZ2VSZWdleClbMV07XG5cdFx0XHRcdGltYWdlU2l6ZSA9IHN5bWJvbFNpemVzW2ltYWdlU3JjXSB8fCAob3B0aW9ucyAmJiBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICYmIFtvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodF0pO1xuXG5cdFx0XHRcdC8vIElyZWF0ZSB0aGUgaW1hZ2Ugc3luY2hyb25vdXNseSwgYWRkIGF0dHJpYnMgYXN5bmNcblx0XHRcdFx0b2JqID0gdGhpcy5pbWFnZShpbWFnZVNyYylcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdFx0eTogeVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRvYmouaXNJbWcgPSB0cnVlO1xuXG5cdFx0XHRcdGlmIChpbWFnZVNpemUpIHtcblx0XHRcdFx0XHRjZW50ZXJJbWFnZShvYmosIGltYWdlU2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBpbWFnZSB0byBiZSAwIHNpemUgc28gZXhwb3J0IHdpbGwgc3RpbGwgZnVuY3Rpb24gaWYgdGhlcmUncyBubyBjYWNoZWQgc2l6ZXMuXG5cdFx0XHRcdFx0b2JqLmF0dHIoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgSmF2YVNjcmlwdCBpbWFnZSB0byBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQuIER1ZSB0byBhIGJ1ZyBpbiBJRSA8IDgsXG5cdFx0XHRcdFx0Ly8gdGhlIGNyZWF0ZWQgZWxlbWVudCBtdXN0IGJlIGFzc2lnbmVkIHRvIGEgdmFyaWFibGUgaW4gb3JkZXIgdG8gbG9hZCAoIzI5MikuXG5cdFx0XHRcdFx0aW1hZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgnaW1nJywge1xuXHRcdFx0XHRcdFx0b25sb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGNlbnRlckltYWdlKG9iaiwgc3ltYm9sU2l6ZXNbaW1hZ2VTcmNdID0gW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c3JjOiBpbWFnZVNyY1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGV4dGVuZGFibGUgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgZm9yIGRlZmluaW5nIHN5bWJvbCBwYXRocy5cblx0XHQgKi9cblx0XHRzeW1ib2xzOiB7XG5cdFx0XHQnY2lyY2xlJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0dmFyIGNwdyA9IDAuMTY2ICogdztcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdFx0J0MnLCB4ICsgdyArIGNwdywgeSwgeCArIHcgKyBjcHcsIHkgKyBoLCB4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHRcdCdDJywgeCAtIGNwdywgeSArIGgsIHggLSBjcHcsIHksIHggKyB3IC8gMiwgeSxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cblx0XHRcdCdzcXVhcmUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHksXG5cdFx0XHRcdFx0eCArIHcsIHkgKyBoLFxuXHRcdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHRcdCdaJ1xuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblxuXHRcdFx0J3RyaWFuZ2xlJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHkgKyBoLFxuXHRcdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHRcdCdaJ1xuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblxuXHRcdFx0J3RyaWFuZ2xlLWRvd24nOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHksXG5cdFx0XHRcdFx0eCArIHcgLyAyLCB5ICsgaCxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cdFx0XHQnZGlhbW9uZCc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRcdEwsIHggKyB3LCB5ICsgaCAvIDIsXG5cdFx0XHRcdFx0eCArIHcgLyAyLCB5ICsgaCxcblx0XHRcdFx0XHR4LCB5ICsgaCAvIDIsXG5cdFx0XHRcdFx0J1onXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0J2FyYyc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRcdFx0cmFkaXVzID0gb3B0aW9ucy5yIHx8IHcgfHwgaCxcblx0XHRcdFx0XHRlbmQgPSBvcHRpb25zLmVuZCAtIDAuMDAxLCAvLyB0byBwcmV2ZW50IGNvcyBhbmQgc2luIG9mIHN0YXJ0IGFuZCBlbmQgZnJvbSBiZWNvbWluZyBlcXVhbCBvbiAzNjAgYXJjcyAocmVsYXRlZDogIzE1NjEpXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMgPSBvcHRpb25zLmlubmVyUixcblx0XHRcdFx0XHRvcGVuID0gb3B0aW9ucy5vcGVuLFxuXHRcdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdFx0c2luU3RhcnQgPSBtYXRoU2luKHN0YXJ0KSxcblx0XHRcdFx0XHRjb3NFbmQgPSBtYXRoQ29zKGVuZCksXG5cdFx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRcdGxvbmdBcmMgPSBvcHRpb25zLmVuZCAtIHN0YXJ0IDwgbWF0aFBJID8gMCA6IDE7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdHggKyByYWRpdXMgKiBjb3NTdGFydCxcblx0XHRcdFx0XHR5ICsgcmFkaXVzICogc2luU3RhcnQsXG5cdFx0XHRcdFx0J0EnLCAvLyBhcmNUb1xuXHRcdFx0XHRcdHJhZGl1cywgLy8geCByYWRpdXNcblx0XHRcdFx0XHRyYWRpdXMsIC8vIHkgcmFkaXVzXG5cdFx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHRcdDEsIC8vIGNsb2Nrd2lzZVxuXHRcdFx0XHRcdHggKyByYWRpdXMgKiBjb3NFbmQsXG5cdFx0XHRcdFx0eSArIHJhZGl1cyAqIHNpbkVuZCxcblx0XHRcdFx0XHRvcGVuID8gTSA6IEwsXG5cdFx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zRW5kLFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpbkVuZCxcblx0XHRcdFx0XHQnQScsIC8vIGFyY1RvXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHkgcmFkaXVzXG5cdFx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHRcdDAsIC8vIGNsb2Nrd2lzZVxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc1N0YXJ0LFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LFxuXG5cdFx0XHRcdFx0b3BlbiA/ICcnIDogJ1onIC8vIGNsb3NlXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENhbGxvdXQgc2hhcGUgdXNlZCBmb3IgZGVmYXVsdCB0b29sdGlwcywgYWxzbyB1c2VkIGZvciByb3VuZGVkIHJlY3RhbmdsZXMgaW4gVk1MXG5cdFx0XHQgKi9cblx0XHRcdGNhbGxvdXQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBhcnJvd0xlbmd0aCA9IDYsXG5cdFx0XHRcdFx0aGFsZkRpc3RhbmNlID0gNixcblx0XHRcdFx0XHRyID0gbWF0aE1pbigob3B0aW9ucyAmJiBvcHRpb25zLnIpIHx8IDAsIHcsIGgpLFxuXHRcdFx0XHRcdHNhZmVEaXN0YW5jZSA9IHIgKyBoYWxmRGlzdGFuY2UsXG5cdFx0XHRcdFx0YW5jaG9yWCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmNob3JYLFxuXHRcdFx0XHRcdGFuY2hvclkgPSBvcHRpb25zICYmIG9wdGlvbnMuYW5jaG9yWSxcblx0XHRcdFx0XHRwYXRoO1xuXG5cdFx0XHRcdHBhdGggPSBbXG5cdFx0XHRcdFx0J00nLCB4ICsgciwgeSwgXG5cdFx0XHRcdFx0J0wnLCB4ICsgdyAtIHIsIHksIC8vIHRvcCBzaWRlXG5cdFx0XHRcdFx0J0MnLCB4ICsgdywgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgciwgLy8gdG9wLXJpZ2h0IGNvcm5lclxuXHRcdFx0XHRcdCdMJywgeCArIHcsIHkgKyBoIC0gciwgLy8gcmlnaHQgc2lkZVxuXHRcdFx0XHRcdCdDJywgeCArIHcsIHkgKyBoLCB4ICsgdywgeSArIGgsIHggKyB3IC0gciwgeSArIGgsIC8vIGJvdHRvbS1yaWdodCBjb3JuZXJcblx0XHRcdFx0XHQnTCcsIHggKyByLCB5ICsgaCwgLy8gYm90dG9tIHNpZGVcblx0XHRcdFx0XHQnQycsIHgsIHkgKyBoLCB4LCB5ICsgaCwgeCwgeSArIGggLSByLCAvLyBib3R0b20tbGVmdCBjb3JuZXJcblx0XHRcdFx0XHQnTCcsIHgsIHkgKyByLCAvLyBsZWZ0IHNpZGVcblx0XHRcdFx0XHQnQycsIHgsIHksIHgsIHksIHggKyByLCB5IC8vIHRvcC1yaWdodCBjb3JuZXJcblx0XHRcdFx0XTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhbmNob3JYICYmIGFuY2hvclggPiB3ICYmIGFuY2hvclkgPiB5ICsgc2FmZURpc3RhbmNlICYmIGFuY2hvclkgPCB5ICsgaCAtIHNhZmVEaXN0YW5jZSkgeyAvLyByZXBsYWNlIHJpZ2h0IHNpZGVcblx0XHRcdFx0XHRwYXRoLnNwbGljZSgxMywgMyxcblx0XHRcdFx0XHRcdCdMJywgeCArIHcsIGFuY2hvclkgLSBoYWxmRGlzdGFuY2UsIFxuXHRcdFx0XHRcdFx0eCArIHcgKyBhcnJvd0xlbmd0aCwgYW5jaG9yWSxcblx0XHRcdFx0XHRcdHggKyB3LCBhbmNob3JZICsgaGFsZkRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0eCArIHcsIHkgKyBoIC0gclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYW5jaG9yWCAmJiBhbmNob3JYIDwgMCAmJiBhbmNob3JZID4geSArIHNhZmVEaXN0YW5jZSAmJiBhbmNob3JZIDwgeSArIGggLSBzYWZlRGlzdGFuY2UpIHsgLy8gcmVwbGFjZSBsZWZ0IHNpZGVcblx0XHRcdFx0XHRwYXRoLnNwbGljZSgzMywgMywgXG5cdFx0XHRcdFx0XHQnTCcsIHgsIGFuY2hvclkgKyBoYWxmRGlzdGFuY2UsIFxuXHRcdFx0XHRcdFx0eCAtIGFycm93TGVuZ3RoLCBhbmNob3JZLFxuXHRcdFx0XHRcdFx0eCwgYW5jaG9yWSAtIGhhbGZEaXN0YW5jZSxcblx0XHRcdFx0XHRcdHgsIHkgKyByXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhbmNob3JZICYmIGFuY2hvclkgPiBoICYmIGFuY2hvclggPiB4ICsgc2FmZURpc3RhbmNlICYmIGFuY2hvclggPCB4ICsgdyAtIHNhZmVEaXN0YW5jZSkgeyAvLyByZXBsYWNlIGJvdHRvbVxuXHRcdFx0XHRcdHBhdGguc3BsaWNlKDIzLCAzLFxuXHRcdFx0XHRcdFx0J0wnLCBhbmNob3JYICsgaGFsZkRpc3RhbmNlLCB5ICsgaCxcblx0XHRcdFx0XHRcdGFuY2hvclgsIHkgKyBoICsgYXJyb3dMZW5ndGgsXG5cdFx0XHRcdFx0XHRhbmNob3JYIC0gaGFsZkRpc3RhbmNlLCB5ICsgaCxcblx0XHRcdFx0XHRcdHggKyByLCB5ICsgaFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYW5jaG9yWSAmJiBhbmNob3JZIDwgMCAmJiBhbmNob3JYID4geCArIHNhZmVEaXN0YW5jZSAmJiBhbmNob3JYIDwgeCArIHcgLSBzYWZlRGlzdGFuY2UpIHsgLy8gcmVwbGFjZSB0b3Bcblx0XHRcdFx0XHRwYXRoLnNwbGljZSgzLCAzLFxuXHRcdFx0XHRcdFx0J0wnLCBhbmNob3JYIC0gaGFsZkRpc3RhbmNlLCB5LFxuXHRcdFx0XHRcdFx0YW5jaG9yWCwgeSAtIGFycm93TGVuZ3RoLFxuXHRcdFx0XHRcdFx0YW5jaG9yWCArIGhhbGZEaXN0YW5jZSwgeSxcblx0XHRcdFx0XHRcdHcgLSByLCB5XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGF0aDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIGEgY2xpcHBpbmcgcmVjdGFuZ2xlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKi9cblx0XHRjbGlwUmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdHZhciB3cmFwcGVyLFxuXHRcdFx0XHRpZCA9IFBSRUZJWCArIGlkQ291bnRlcisrLFxuXG5cdFx0XHRcdGNsaXBQYXRoID0gdGhpcy5jcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpLmF0dHIoe1xuXHRcdFx0XHRcdGlkOiBpZFxuXHRcdFx0XHR9KS5hZGQodGhpcy5kZWZzKTtcblxuXHRcdFx0d3JhcHBlciA9IHRoaXMucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKS5hZGQoY2xpcFBhdGgpO1xuXHRcdFx0d3JhcHBlci5pZCA9IGlkO1xuXHRcdFx0d3JhcHBlci5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuXHRcdFx0d3JhcHBlci5jb3VudCA9IDA7XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblxuXHRcdFxuXG5cblx0XHQvKipcblx0XHQgKiBBZGQgdGV4dCB0byB0aGUgU1ZHIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBMZWZ0IHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSB1c2VIVE1MIFVzZSBIVE1MIHRvIHJlbmRlciB0aGUgdGV4dFxuXHRcdCAqL1xuXHRcdHRleHQ6IGZ1bmN0aW9uIChzdHIsIHgsIHksIHVzZUhUTUwpIHtcblxuXHRcdFx0Ly8gZGVjbGFyZSB2YXJpYWJsZXNcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGZha2VTVkcgPSB1c2VDYW5WRyB8fCAoIWhhc1NWRyAmJiByZW5kZXJlci5mb3JFeHBvcnQpLFxuXHRcdFx0XHR3cmFwcGVyLFxuXHRcdFx0XHRhdHRyID0ge307XG5cblx0XHRcdGlmICh1c2VIVE1MICYmICFyZW5kZXJlci5mb3JFeHBvcnQpIHtcblx0XHRcdFx0cmV0dXJuIHJlbmRlcmVyLmh0bWwoc3RyLCB4LCB5KTtcblx0XHRcdH1cblxuXHRcdFx0YXR0ci54ID0gTWF0aC5yb3VuZCh4IHx8IDApOyAvLyBYIGlzIGFsd2F5cyBuZWVkZWQgZm9yIGxpbmUtd3JhcCBsb2dpY1xuXHRcdFx0aWYgKHkpIHtcblx0XHRcdFx0YXR0ci55ID0gTWF0aC5yb3VuZCh5KTtcblx0XHRcdH1cblx0XHRcdGlmIChzdHIgfHwgc3RyID09PSAwKSB7XG5cdFx0XHRcdGF0dHIudGV4dCA9IHN0cjtcblx0XHRcdH1cblxuXHRcdFx0d3JhcHBlciA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3RleHQnKVxuXHRcdFx0XHQuYXR0cihhdHRyKTtcblxuXHRcdFx0Ly8gUHJldmVudCB3cmFwcGluZyBmcm9tIGNyZWF0aW5nIGZhbHNlIG9mZnNldFdpZHRocyBpbiBleHBvcnQgaW4gbGVnYWN5IElFICgjMTA3OSwgIzEwNjMpXG5cdFx0XHRpZiAoZmFrZVNWRykge1xuXHRcdFx0XHR3cmFwcGVyLmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXVzZUhUTUwpIHtcblx0XHRcdFx0d3JhcHBlci54U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgdHNwYW5zID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHNwYW4nKSxcblx0XHRcdFx0XHRcdHRzcGFuLFxuXHRcdFx0XHRcdFx0cGFyZW50VmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoa2V5KSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRzcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dHNwYW4gPSB0c3BhbnNbaV07XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgeCB2YWx1ZXMgYXJlIGVxdWFsLCB0aGUgdHNwYW4gcmVwcmVzZW50cyBhIGxpbmVicmVha1xuXHRcdFx0XHRcdFx0aWYgKHRzcGFuLmdldEF0dHJpYnV0ZShrZXkpID09PSBwYXJlbnRWYWwpIHtcblx0XHRcdFx0XHRcdFx0dHNwYW4uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgdG8gcmV0dXJuIHRoZSBiYXNlbGluZSBvZmZzZXQgYW5kIHRvdGFsIGxpbmUgaGVpZ2h0IGZyb20gdGhlIGZvbnQgc2l6ZVxuXHRcdCAqL1xuXHRcdGZvbnRNZXRyaWNzOiBmdW5jdGlvbiAoZm9udFNpemUsIGVsZW0pIHtcblx0XHRcdHZhciBsaW5lSGVpZ2h0LFxuXHRcdFx0XHRiYXNlbGluZSxcblx0XHRcdFx0c3R5bGU7XG5cblx0XHRcdGZvbnRTaXplID0gZm9udFNpemUgfHwgdGhpcy5zdHlsZS5mb250U2l6ZTtcblx0XHRcdGlmIChlbGVtICYmIHdpbi5nZXRDb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRcdGVsZW0gPSBlbGVtLmVsZW1lbnQgfHwgZWxlbTsgLy8gU1ZHRWxlbWVudFxuXHRcdFx0XHRzdHlsZSA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIFwiXCIpO1xuXHRcdFx0XHRmb250U2l6ZSA9IHN0eWxlICYmIHN0eWxlLmZvbnRTaXplOyAvLyAjNDMwOSwgdGhlIHN0eWxlIGRvZXNuJ3QgZXhpc3QgaW5zaWRlIGEgaGlkZGVuIGlmcmFtZSBpbiBGaXJlZm94XG5cdFx0XHR9XG5cdFx0XHRmb250U2l6ZSA9IC9weC8udGVzdChmb250U2l6ZSkgPyBwSW50KGZvbnRTaXplKSA6IC9lbS8udGVzdChmb250U2l6ZSkgPyBwYXJzZUZsb2F0KGZvbnRTaXplKSAqIDEyIDogMTI7XG5cblx0XHRcdC8vIEVtcGlyaWNhbCB2YWx1ZXMgZm91bmQgYnkgY29tcGFyaW5nIGZvbnQgc2l6ZSBhbmQgYm91bmRpbmcgYm94IGhlaWdodC5cblx0XHRcdC8vIEFwcGxpZXMgdG8gdGhlIGRlZmF1bHQgZm9udCBmYW1pbHkuIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaGlnaGNoYXJ0cy83eHZuNy9cblx0XHRcdGxpbmVIZWlnaHQgPSBmb250U2l6ZSA8IDI0ID8gZm9udFNpemUgKyAzIDogbWF0aFJvdW5kKGZvbnRTaXplICogMS4yKTtcblx0XHRcdGJhc2VsaW5lID0gbWF0aFJvdW5kKGxpbmVIZWlnaHQgKiAwLjgpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRoOiBsaW5lSGVpZ2h0LFxuXHRcdFx0XHRiOiBiYXNlbGluZSxcblx0XHRcdFx0ZjogZm9udFNpemVcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvcnJlY3QgWCBhbmQgWSBwb3NpdGlvbmluZyBvZiBhIGxhYmVsIGZvciByb3RhdGlvbiAoIzE3NjQpXG5cdFx0ICovXG5cdFx0cm90Q29ycjogZnVuY3Rpb24gKGJhc2VsaW5lLCByb3RhdGlvbiwgYWx0ZXJZKSB7XG5cdFx0XHR2YXIgeSA9IGJhc2VsaW5lO1xuXHRcdFx0aWYgKHJvdGF0aW9uICYmIGFsdGVyWSkge1xuXHRcdFx0XHR5ID0gbWF0aE1heCh5ICogbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpLCA0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6ICgtYmFzZWxpbmUgLyAzKSAqIG1hdGhTaW4ocm90YXRpb24gKiBkZWcycmFkKSxcblx0XHRcdFx0eTogeVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgbGFiZWwsIGEgdGV4dCBpdGVtIHRoYXQgY2FuIGhvbGQgYSBjb2xvcmVkIG9yIGdyYWRpZW50IGJhY2tncm91bmRcblx0XHQgKiBhcyB3ZWxsIGFzIGEgYm9yZGVyIGFuZCBzaGFkb3cuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc2hhcGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5jaG9yWCBJbiBjYXNlIHRoZSBzaGFwZSBoYXMgYSBwb2ludGVyLCBsaWtlIGEgZmxhZywgdGhpcyBpcyB0aGVcblx0XHQgKlx0Y29vcmRpbmF0ZXMgaXQgc2hvdWxkIGJlIHBpbm5lZCB0b1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JZXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBiYXNlbGluZSBXaGV0aGVyIHRvIHBvc2l0aW9uIHRoZSBsYWJlbCByZWxhdGl2ZSB0byB0aGUgdGV4dCBiYXNlbGluZSxcblx0XHQgKlx0bGlrZSByZW5kZXJlci50ZXh0LCBvciB0byB0aGUgdXBwZXIgYm9yZGVyIG9mIHRoZSByZWN0YW5nbGUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyBuYW1lIGZvciB0aGUgZ3JvdXBcblx0XHQgKi9cblx0XHRsYWJlbDogZnVuY3Rpb24gKHN0ciwgeCwgeSwgc2hhcGUsIGFuY2hvclgsIGFuY2hvclksIHVzZUhUTUwsIGJhc2VsaW5lLCBjbGFzc05hbWUpIHtcblxuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0d3JhcHBlciA9IHJlbmRlcmVyLmcoY2xhc3NOYW1lKSxcblx0XHRcdFx0dGV4dCA9IHJlbmRlcmVyLnRleHQoJycsIDAsIDAsIHVzZUhUTUwpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ekluZGV4OiAxXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0Ly8uYWRkKHdyYXBwZXIpLFxuXHRcdFx0XHRib3gsXG5cdFx0XHRcdGJCb3gsXG5cdFx0XHRcdGFsaWduRmFjdG9yID0gMCxcblx0XHRcdFx0cGFkZGluZyA9IDMsXG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gMCxcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0d3JhcHBlclgsXG5cdFx0XHRcdHdyYXBwZXJZLFxuXHRcdFx0XHRjcmlzcEFkanVzdCA9IDAsXG5cdFx0XHRcdGRlZmVycmVkQXR0ciA9IHt9LFxuXHRcdFx0XHRiYXNlbGluZU9mZnNldCxcblx0XHRcdFx0bmVlZHNCb3g7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgRE9NICh3aGVuIHRoZSBib3VuZGluZyBib3ggaXNcblx0XHRcdCAqIGF2YWlsYWJsZSksIGFuZCBhZnRlciB0aGUgdGV4dCBvZiB0aGUgbGFiZWwgaXMgdXBkYXRlZCB0byBkZXRlY3QgdGhlIG5ldyBib3VuZGluZ1xuXHRcdFx0ICogYm94IGFuZCByZWZsZWN0IGl0IGluIHRoZSBib3JkZXIgYm94LlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVCb3hTaXplKCkge1xuXHRcdFx0XHR2YXIgYm94WCxcblx0XHRcdFx0XHRib3hZLFxuXHRcdFx0XHRcdHN0eWxlID0gdGV4dC5lbGVtZW50LnN0eWxlO1xuXG5cdFx0XHRcdGJCb3ggPSAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCB8fCB3cmFwcGVyLnN0eWxlcy50ZXh0QWxpZ24pICYmIGRlZmluZWQodGV4dC50ZXh0U3RyKSAmJiBcblx0XHRcdFx0XHR0ZXh0LmdldEJCb3goKTsgLy8jMzI5NSAmJiAzNTE0IGJveCBmYWlsdXJlIHdoZW4gc3RyaW5nIGVxdWFscyAwXG5cdFx0XHRcdHdyYXBwZXIud2lkdGggPSAod2lkdGggfHwgYkJveC53aWR0aCB8fCAwKSArIDIgKiBwYWRkaW5nICsgcGFkZGluZ0xlZnQ7XG5cdFx0XHRcdHdyYXBwZXIuaGVpZ2h0ID0gKGhlaWdodCB8fCBiQm94LmhlaWdodCB8fCAwKSArIDIgKiBwYWRkaW5nO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgbGFiZWwtc2NvcGVkIHkgb2Zmc2V0XG5cdFx0XHRcdGJhc2VsaW5lT2Zmc2V0ID0gcGFkZGluZyArIHJlbmRlcmVyLmZvbnRNZXRyaWNzKHN0eWxlICYmIHN0eWxlLmZvbnRTaXplLCB0ZXh0KS5iO1xuXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVlZHNCb3gpIHtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSB0aGUgYm9yZGVyIGJveCBpZiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRcdFx0aWYgKCFib3gpIHtcblx0XHRcdFx0XHRcdGJveFggPSBtYXRoUm91bmQoLWFsaWduRmFjdG9yICogcGFkZGluZykgKyBjcmlzcEFkanVzdDtcblx0XHRcdFx0XHRcdGJveFkgPSAoYmFzZWxpbmUgPyAtYmFzZWxpbmVPZmZzZXQgOiAwKSArIGNyaXNwQWRqdXN0O1xuXG5cdFx0XHRcdFx0XHR3cmFwcGVyLmJveCA9IGJveCA9IHNoYXBlID9cblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc3ltYm9sKHNoYXBlLCBib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCwgZGVmZXJyZWRBdHRyKSA6XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnJlY3QoYm94WCwgYm94WSwgd3JhcHBlci53aWR0aCwgd3JhcHBlci5oZWlnaHQsIDAsIGRlZmVycmVkQXR0cltTVFJPS0VfV0lEVEhdKTtcblx0XHRcdFx0XHRcdGJveC5hdHRyKCdmaWxsJywgTk9ORSkuYWRkKHdyYXBwZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGFwcGx5IHRoZSBib3ggYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICghYm94LmlzSW1nKSB7IC8vICMxNjMwXG5cdFx0XHRcdFx0XHRib3guYXR0cihleHRlbmQoe1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogbWF0aFJvdW5kKHdyYXBwZXIud2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhSb3VuZCh3cmFwcGVyLmhlaWdodClcblx0XHRcdFx0XHRcdH0sIGRlZmVycmVkQXR0cikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZlcnJlZEF0dHIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHNldHRpbmcgdGV4dCBvciBwYWRkaW5nLCBidXQgb25seSBpZiBwYWRkaW5nIGlzIGNoYW5nZWRcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlVGV4dFBhZGRpbmcoKSB7XG5cdFx0XHRcdHZhciBzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBzdHlsZXMgJiYgc3R5bGVzLnRleHRBbGlnbixcblx0XHRcdFx0XHR4ID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nICogKDEgLSBhbGlnbkZhY3RvciksXG5cdFx0XHRcdFx0eTtcblxuXHRcdFx0XHQvLyBkZXRlcm1pbiB5IGJhc2VkIG9uIHRoZSBiYXNlbGluZVxuXHRcdFx0XHR5ID0gYmFzZWxpbmUgPyAwIDogYmFzZWxpbmVPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgYWxpZ25tZW50XG5cdFx0XHRcdGlmIChkZWZpbmVkKHdpZHRoKSAmJiBiQm94ICYmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInIHx8IHRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcblx0XHRcdFx0XHR4ICs9IHsgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bdGV4dEFsaWduXSAqICh3aWR0aCAtIGJCb3gud2lkdGgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIGlmIGFueXRoaW5nIGNoYW5nZWRcblx0XHRcdFx0aWYgKHggIT09IHRleHQueCB8fCB5ICE9PSB0ZXh0LnkpIHtcblx0XHRcdFx0XHR0ZXh0LmF0dHIoJ3gnLCB4KTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHR0ZXh0LmF0dHIoJ3knLCB5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY3VycmVudCB2YWx1ZXNcblx0XHRcdFx0dGV4dC54ID0geDtcblx0XHRcdFx0dGV4dC55ID0geTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBib3ggYXR0cmlidXRlLCBvciBkZWZlciBpdCBpZiB0aGUgYm94IGlzIG5vdCB5ZXQgY3JlYXRlZFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGtleVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGJveEF0dHIoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdFx0Ym94LmF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRBdHRyW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFmdGVyIHRoZSB0ZXh0IGVsZW1lbnQgaXMgYWRkZWQsIGdldCB0aGUgZGVzaXJlZCBzaXplIG9mIHRoZSBib3JkZXIgYm94XG5cdFx0XHQgKiBhbmQgYWRkIGl0IGJlZm9yZSB0aGUgdGV4dCBpbiB0aGUgRE9NLlxuXHRcdFx0ICovXG5cdFx0XHR3cmFwcGVyLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0ZXh0LmFkZCh3cmFwcGVyKTtcblx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHR0ZXh0OiAoc3RyIHx8IHN0ciA9PT0gMCkgPyBzdHIgOiAnJywgLy8gYWxpZ25tZW50IGlzIGF2YWlsYWJsZSBub3cgLy8gIzMyOTU6IDAgbm90IHJlbmRlcmVkIGlmIGdpdmVuIGFzIGEgdmFsdWVcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHlcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGJveCAmJiBkZWZpbmVkKGFuY2hvclgpKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHRcdGFuY2hvclg6IGFuY2hvclgsXG5cdFx0XHRcdFx0XHRhbmNob3JZOiBhbmNob3JZXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBBZGQgc3BlY2lmaWMgYXR0cmlidXRlIHNldHRlcnMuXG5cdFx0XHQgKi9cblxuXHRcdFx0Ly8gb25seSBjaGFuZ2UgbG9jYWwgdmFyaWFibGVzXG5cdFx0XHR3cmFwcGVyLndpZHRoU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHdpZHRoID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5oZWlnaHRTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aGVpZ2h0ID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5wYWRkaW5nU2V0dGVyID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAoZGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHBhZGRpbmcpIHtcblx0XHRcdFx0XHRwYWRkaW5nID0gd3JhcHBlci5wYWRkaW5nID0gdmFsdWU7XG5cdFx0XHRcdFx0dXBkYXRlVGV4dFBhZGRpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIucGFkZGluZ0xlZnRTZXR0ZXIgPSAgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gcGFkZGluZ0xlZnQpIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IHZhbHVlO1xuXHRcdFx0XHRcdHVwZGF0ZVRleHRQYWRkaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblxuXHRcdFx0Ly8gY2hhbmdlIGxvY2FsIHZhcmlhYmxlIGFuZCBwcmV2ZW50IHNldHRpbmcgYXR0cmlidXRlIG9uIHRoZSBncm91cFxuXHRcdFx0d3JhcHBlci5hbGlnblNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRhbGlnbkZhY3RvciA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bdmFsdWVdO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYXBwbHkgdGhlc2UgdG8gdGhlIGJveCBhbmQgdGhlIHRleHQgYWxpa2Vcblx0XHRcdHdyYXBwZXIudGV4dFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdHRleHQudGV4dFNldHRlcih2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dXBkYXRlQm94U2l6ZSgpO1xuXHRcdFx0XHR1cGRhdGVUZXh0UGFkZGluZygpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYXBwbHkgdGhlc2UgdG8gdGhlIGJveCBidXQgbm90IHRvIHRoZSB0ZXh0XG5cdFx0XHR3cmFwcGVyWydzdHJva2Utd2lkdGhTZXR0ZXInXSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdG5lZWRzQm94ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjcmlzcEFkanVzdCA9IHZhbHVlICUgMiAvIDI7XG5cdFx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5zdHJva2VTZXR0ZXIgPSB3cmFwcGVyLmZpbGxTZXR0ZXIgPSB3cmFwcGVyLnJTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAnZmlsbCcgJiYgdmFsdWUpIHtcblx0XHRcdFx0XHRuZWVkc0JveCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ym94QXR0cihrZXksIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLmFuY2hvclhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRhbmNob3JYID0gdmFsdWU7XG5cdFx0XHRcdGJveEF0dHIoa2V5LCBtYXRoUm91bmQodmFsdWUpIC0gY3Jpc3BBZGp1c3QgLSB3cmFwcGVyWCk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5hbmNob3JZU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0YW5jaG9yWSA9IHZhbHVlO1xuXHRcdFx0XHRib3hBdHRyKGtleSwgdmFsdWUgLSB3cmFwcGVyWSk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyByZW5hbWUgYXR0cmlidXRlc1xuXHRcdFx0d3JhcHBlci54U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHdyYXBwZXIueCA9IHZhbHVlOyAvLyBmb3IgYW5pbWF0aW9uIGdldHRlclxuXHRcdFx0XHRpZiAoYWxpZ25GYWN0b3IpIHtcblx0XHRcdFx0XHR2YWx1ZSAtPSBhbGlnbkZhY3RvciAqICgod2lkdGggfHwgYkJveC53aWR0aCkgKyBwYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3cmFwcGVyWCA9IG1hdGhSb3VuZCh2YWx1ZSk7XG5cdFx0XHRcdHdyYXBwZXIuYXR0cigndHJhbnNsYXRlWCcsIHdyYXBwZXJYKTtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLnlTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0d3JhcHBlclkgPSB3cmFwcGVyLnkgPSBtYXRoUm91bmQodmFsdWUpO1xuXHRcdFx0XHR3cmFwcGVyLmF0dHIoJ3RyYW5zbGF0ZVknLCB3cmFwcGVyWSk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBSZWRpcmVjdCBjZXJ0YWluIG1ldGhvZHMgdG8gZWl0aGVyIHRoZSBib3ggb3IgdGhlIHRleHRcblx0XHRcdHZhciBiYXNlQ3NzID0gd3JhcHBlci5jc3M7XG5cdFx0XHRyZXR1cm4gZXh0ZW5kKHdyYXBwZXIsIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFBpY2sgdXAgc29tZSBwcm9wZXJ0aWVzIGFuZCBhcHBseSB0aGVtIHRvIHRoZSB0ZXh0IGluc3RlYWQgb2YgdGhlIHdyYXBwZXJcblx0XHRcdFx0ICovXG5cdFx0XHRcdGNzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdFx0XHRcdGlmIChzdHlsZXMpIHtcblx0XHRcdFx0XHRcdHZhciB0ZXh0U3R5bGVzID0ge307XG5cdFx0XHRcdFx0XHRzdHlsZXMgPSBtZXJnZShzdHlsZXMpOyAvLyBjcmVhdGUgYSBjb3B5IHRvIGF2b2lkIGFsdGVyaW5nIHRoZSBvcmlnaW5hbCBvYmplY3QgKCM1MzcpXG5cdFx0XHRcdFx0XHRlYWNoKHdyYXBwZXIudGV4dFByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3R5bGVzW3Byb3BdICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZXh0U3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBzdHlsZXNbcHJvcF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0dGV4dC5jc3ModGV4dFN0eWxlcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBiYXNlQ3NzLmNhbGwod3JhcHBlciwgc3R5bGVzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBib3gsIG5vdCB0aGUgZ3JvdXBcblx0XHRcdFx0ICovXG5cdFx0XHRcdGdldEJCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGJCb3gud2lkdGggKyAyICogcGFkZGluZyxcblx0XHRcdFx0XHRcdGhlaWdodDogYkJveC5oZWlnaHQgKyAyICogcGFkZGluZyxcblx0XHRcdFx0XHRcdHg6IGJCb3gueCAtIHBhZGRpbmcsXG5cdFx0XHRcdFx0XHR5OiBiQm94LnkgLSBwYWRkaW5nXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFwcGx5IHRoZSBzaGFkb3cgdG8gdGhlIGJveFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0c2hhZG93OiBmdW5jdGlvbiAoYikge1xuXHRcdFx0XHRcdGlmIChib3gpIHtcblx0XHRcdFx0XHRcdGJveC5zaGFkb3coYik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogRGVzdHJveSBhbmQgcmVsZWFzZSBtZW1vcnkuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQvLyBBZGRlZCBieSBidXR0b24gaW1wbGVtZW50YXRpb25cblx0XHRcdFx0XHRyZW1vdmVFdmVudCh3cmFwcGVyLmVsZW1lbnQsICdtb3VzZWVudGVyJyk7XG5cdFx0XHRcdFx0cmVtb3ZlRXZlbnQod3JhcHBlci5lbGVtZW50LCAnbW91c2VsZWF2ZScpO1xuXG5cdFx0XHRcdFx0aWYgKHRleHQpIHtcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdFx0Ym94ID0gYm94LmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2FsbCBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGRlc3Ryb3kgdGhlIHJlc3Rcblx0XHRcdFx0XHRTVkdFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95LmNhbGwod3JhcHBlcik7XG5cblx0XHRcdFx0XHQvLyBSZWxlYXNlIGxvY2FsIHBvaW50ZXJzICgjMTI5OClcblx0XHRcdFx0XHR3cmFwcGVyID0gcmVuZGVyZXIgPSB1cGRhdGVCb3hTaXplID0gdXBkYXRlVGV4dFBhZGRpbmcgPSBib3hBdHRyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9OyAvLyBlbmQgU1ZHUmVuZGVyZXJcblxuXG5cdC8vIGdlbmVyYWwgcmVuZGVyZXJcblx0UmVuZGVyZXIgPSBTVkdSZW5kZXJlcjtcblx0Ly8gZXh0ZW5kIFN2Z0VsZW1lbnQgZm9yIHVzZUhUTUwgb3B0aW9uXG5cdGV4dGVuZChTVkdFbGVtZW50LnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IENTUyB0byBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWQgaW4gdGV4dCB3aXRoaW4gU1ZHIHJlbmRlcmluZyBhbmRcblx0XHQgKiBieSB0aGUgVk1MIHJlbmRlcmVyXG5cdFx0ICovXG5cdFx0aHRtbENzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHR0ZXh0V2lkdGggPSBzdHlsZXMgJiYgZWxlbWVudC50YWdOYW1lID09PSAnU1BBTicgJiYgc3R5bGVzLndpZHRoO1xuXG5cdFx0XHRpZiAodGV4dFdpZHRoKSB7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXMud2lkdGg7XG5cdFx0XHRcdHdyYXBwZXIudGV4dFdpZHRoID0gdGV4dFdpZHRoO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMudGV4dE92ZXJmbG93ID09PSAnZWxsaXBzaXMnKSB7XG5cdFx0XHRcdHN0eWxlcy53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG5cdFx0XHRcdHN0eWxlcy5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXHRcdFx0fVxuXHRcdFx0d3JhcHBlci5zdHlsZXMgPSBleHRlbmQod3JhcHBlci5zdHlsZXMsIHN0eWxlcyk7XG5cdFx0XHRjc3Mod3JhcHBlci5lbGVtZW50LCBzdHlsZXMpO1xuXG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVk1MIGFuZCB1c2VIVE1MIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGhlIGJvdW5kaW5nIGJveCBiYXNlZCBvbiBvZmZzZXRzXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFdoZXRoZXIgdG8gZm9yY2UgYSBmcmVzaCB2YWx1ZSBmcm9tIHRoZSBET00gb3IgdG9cblx0XHQgKiB1c2UgdGhlIGNhY2hlZCB2YWx1ZVxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBIGhhc2ggY29udGFpbmluZyB2YWx1ZXMgZm9yIHgsIHksIHdpZHRoIGFuZCBoZWlnaHRcblx0XHQgKi9cblxuXHRcdGh0bWxHZXRCQm94OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQ7XG5cblx0XHRcdC8vIGZha2luZyBnZXRCQm94IGluIGV4cG9ydGVkIFNWRyBpbiBsZWdhY3kgSUVcblx0XHRcdC8vIGZha2luZyBnZXRCQm94IGluIGV4cG9ydGVkIFNWRyBpbiBsZWdhY3kgSUUgKGlzIHRoaXMgYSBkdXBsaWNhdGUgb2YgdGhlIGZpeCBmb3IgIzEwNzk/KVxuXHRcdFx0aWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICd0ZXh0Jykge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gQUJTT0xVVEU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcblx0XHRcdFx0eTogZWxlbWVudC5vZmZzZXRUb3AsXG5cdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgb3ZlcnJpZGUgcHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIGVsZW1lbnRzIGJhc2VkIG9uIGludGVybmFsXG5cdFx0ICogcHJvcGVydGllcyBiYXNlZCBvbiBTVkcgdHJhbnNmb3JtXG5cdFx0ICovXG5cdFx0aHRtbFVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gYWxpZ25pbmcgbm9uIGFkZGVkIGVsZW1lbnRzIGlzIGV4cGVuc2l2ZVxuXHRcdFx0aWYgKCF0aGlzLmFkZGVkKSB7XG5cdFx0XHRcdHRoaXMuYWxpZ25PbkFkZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRyZW5kZXJlciA9IHdyYXBwZXIucmVuZGVyZXIsXG5cdFx0XHRcdGVsZW0gPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHRyYW5zbGF0ZVggPSB3cmFwcGVyLnRyYW5zbGF0ZVggfHwgMCxcblx0XHRcdFx0dHJhbnNsYXRlWSA9IHdyYXBwZXIudHJhbnNsYXRlWSB8fCAwLFxuXHRcdFx0XHR4ID0gd3JhcHBlci54IHx8IDAsXG5cdFx0XHRcdHkgPSB3cmFwcGVyLnkgfHwgMCxcblx0XHRcdFx0YWxpZ24gPSB3cmFwcGVyLnRleHRBbGlnbiB8fCAnbGVmdCcsXG5cdFx0XHRcdGFsaWduQ29ycmVjdGlvbiA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bYWxpZ25dLFxuXHRcdFx0XHRzaGFkb3dzID0gd3JhcHBlci5zaGFkb3dzLFxuXHRcdFx0XHRzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcztcblxuXHRcdFx0Ly8gYXBwbHkgdHJhbnNsYXRlXG5cdFx0XHRjc3MoZWxlbSwge1xuXHRcdFx0XHRtYXJnaW5MZWZ0OiB0cmFuc2xhdGVYLFxuXHRcdFx0XHRtYXJnaW5Ub3A6IHRyYW5zbGF0ZVlcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHNoYWRvd3MpIHsgLy8gdXNlZCBpbiBsYWJlbHMvdG9vbHRpcFxuXHRcdFx0XHRlYWNoKHNoYWRvd3MsIGZ1bmN0aW9uIChzaGFkb3cpIHtcblx0XHRcdFx0XHRjc3Moc2hhZG93LCB7XG5cdFx0XHRcdFx0XHRtYXJnaW5MZWZ0OiB0cmFuc2xhdGVYICsgMSxcblx0XHRcdFx0XHRcdG1hcmdpblRvcDogdHJhbnNsYXRlWSArIDFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGx5IGludmVyc2lvblxuXHRcdFx0aWYgKHdyYXBwZXIuaW52ZXJ0ZWQpIHsgLy8gd3JhcHBlciBpcyBhIGdyb3VwXG5cdFx0XHRcdGVhY2goZWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRcdFx0XHRyZW5kZXJlci5pbnZlcnRDaGlsZChjaGlsZCwgZWxlbSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZWxlbS50YWdOYW1lID09PSAnU1BBTicpIHtcblxuXHRcdFx0XHR2YXIgd2lkdGgsXG5cdFx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRcdGJhc2VsaW5lLFxuXHRcdFx0XHRcdHRleHRXaWR0aCA9IHBJbnQod3JhcHBlci50ZXh0V2lkdGgpLFxuXHRcdFx0XHRcdGN1cnJlbnRUZXh0VHJhbnNmb3JtID0gW3JvdGF0aW9uLCBhbGlnbiwgZWxlbS5pbm5lckhUTUwsIHdyYXBwZXIudGV4dFdpZHRoXS5qb2luKCcsJyk7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRUZXh0VHJhbnNmb3JtICE9PSB3cmFwcGVyLmNUVCkgeyAvLyBkbyB0aGUgY2FsY3VsYXRpb25zIGFuZCBET00gYWNjZXNzIG9ubHkgaWYgcHJvcGVydGllcyBjaGFuZ2VkXG5cblxuXHRcdFx0XHRcdGJhc2VsaW5lID0gcmVuZGVyZXIuZm9udE1ldHJpY3MoZWxlbS5zdHlsZS5mb250U2l6ZSkuYjtcblxuXHRcdFx0XHRcdC8vIFJlbmRlcmVyIHNwZWNpZmljIGhhbmRsaW5nIG9mIHNwYW4gcm90YXRpb25cblx0XHRcdFx0XHRpZiAoZGVmaW5lZChyb3RhdGlvbikpIHtcblx0XHRcdFx0XHRcdHdyYXBwZXIuc2V0U3BhblJvdGF0aW9uKHJvdGF0aW9uLCBhbGlnbkNvcnJlY3Rpb24sIGJhc2VsaW5lKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aWR0aCA9IHBpY2sod3JhcHBlci5lbGVtV2lkdGgsIGVsZW0ub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHRleHRXaWR0aFxuXHRcdFx0XHRcdGlmICh3aWR0aCA+IHRleHRXaWR0aCAmJiAvWyBcXC1dLy50ZXN0KGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQpKSB7IC8vICM5ODMsICMxMjU0XG5cdFx0XHRcdFx0XHRjc3MoZWxlbSwge1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGV4dFdpZHRoICsgUFgsXG5cdFx0XHRcdFx0XHRcdGRpc3BsYXk6ICdibG9jaycsXG5cdFx0XHRcdFx0XHRcdHdoaXRlU3BhY2U6IChzdHlsZXMgJiYgc3R5bGVzLndoaXRlU3BhY2UpIHx8ICdub3JtYWwnIC8vICMzMzMxXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHdpZHRoID0gdGV4dFdpZHRoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdyYXBwZXIuZ2V0U3BhbkNvcnJlY3Rpb24od2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24sIHJvdGF0aW9uLCBhbGlnbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBseSBwb3NpdGlvbiB3aXRoIGNvcnJlY3Rpb25cblx0XHRcdFx0Y3NzKGVsZW0sIHtcblx0XHRcdFx0XHRsZWZ0OiAoeCArICh3cmFwcGVyLnhDb3JyIHx8IDApKSArIFBYLFxuXHRcdFx0XHRcdHRvcDogKHkgKyAod3JhcHBlci55Q29yciB8fCAwKSkgKyBQWFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBmb3JjZSByZWZsb3cgaW4gd2Via2l0IHRvIGFwcGx5IHRoZSBsZWZ0IGFuZCB0b3Agb24gdXNlSFRNTCBlbGVtZW50ICgjMTI0OSlcblx0XHRcdFx0aWYgKGlzV2ViS2l0KSB7XG5cdFx0XHRcdFx0YmFzZWxpbmUgPSBlbGVtLm9mZnNldEhlaWdodDsgLy8gYXNzaWduZWQgdG8gYmFzZWxpbmUgZm9yIEpTTGludCBwdXJwb3NlXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY3VycmVudCB0ZXh0IHRyYW5zZm9ybVxuXHRcdFx0XHR3cmFwcGVyLmNUVCA9IGN1cnJlbnRUZXh0VHJhbnNmb3JtO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHJvdGF0aW9uIG9mIGFuIGluZGl2aWR1YWwgSFRNTCBzcGFuXG5cdFx0ICovXG5cdFx0c2V0U3BhblJvdGF0aW9uOiBmdW5jdGlvbiAocm90YXRpb24sIGFsaWduQ29ycmVjdGlvbiwgYmFzZWxpbmUpIHtcblx0XHRcdHZhciByb3RhdGlvblN0eWxlID0ge30sXG5cdFx0XHRcdGNzc1RyYW5zZm9ybUtleSA9IGlzSUUgPyAnLW1zLXRyYW5zZm9ybScgOiBpc1dlYktpdCA/ICctd2Via2l0LXRyYW5zZm9ybScgOiBpc0ZpcmVmb3ggPyAnTW96VHJhbnNmb3JtJyA6IGlzT3BlcmEgPyAnLW8tdHJhbnNmb3JtJyA6ICcnO1xuXG5cdFx0XHRyb3RhdGlvblN0eWxlW2Nzc1RyYW5zZm9ybUtleV0gPSByb3RhdGlvblN0eWxlLnRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ2RlZyknO1xuXHRcdFx0cm90YXRpb25TdHlsZVtjc3NUcmFuc2Zvcm1LZXkgKyAoaXNGaXJlZm94ID8gJ09yaWdpbicgOiAnLW9yaWdpbicpXSA9IHJvdGF0aW9uU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKGFsaWduQ29ycmVjdGlvbiAqIDEwMCkgKyAnJSAnICsgYmFzZWxpbmUgKyAncHgnO1xuXHRcdFx0Y3NzKHRoaXMuZWxlbWVudCwgcm90YXRpb25TdHlsZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY29ycmVjdGlvbiBpbiBYIGFuZCBZIHBvc2l0aW9uaW5nIGFzIHRoZSBlbGVtZW50IGlzIHJvdGF0ZWQuXG5cdFx0ICovXG5cdFx0Z2V0U3BhbkNvcnJlY3Rpb246IGZ1bmN0aW9uICh3aWR0aCwgYmFzZWxpbmUsIGFsaWduQ29ycmVjdGlvbikge1xuXHRcdFx0dGhpcy54Q29yciA9IC13aWR0aCAqIGFsaWduQ29ycmVjdGlvbjtcblx0XHRcdHRoaXMueUNvcnIgPSAtYmFzZWxpbmU7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBFeHRlbmQgU3ZnUmVuZGVyZXIgZm9yIHVzZUhUTUwgb3B0aW9uLlxuXHRleHRlbmQoU1ZHUmVuZGVyZXIucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIEhUTUwgdGV4dCBub2RlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIFZNTCByZW5kZXJlciBhcyB3ZWxsIGFzIHRoZSBTVkdcblx0XHQgKiByZW5kZXJlciB0aHJvdWdoIHRoZSB1c2VIVE1MIG9wdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICovXG5cdFx0aHRtbDogZnVuY3Rpb24gKHN0ciwgeCwgeSkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyO1xuXG5cdFx0XHQvLyBUZXh0IHNldHRlclxuXHRcdFx0d3JhcHBlci50ZXh0U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPT0gZWxlbWVudC5pbm5lckhUTUwpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5iQm94O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy50ZXh0U3RyID0gdmFsdWU7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBWYXJpb3VzIHNldHRlcnMgd2hpY2ggcmVseSBvbiB1cGRhdGUgdHJhbnNmb3JtXG5cdFx0XHR3cmFwcGVyLnhTZXR0ZXIgPSB3cmFwcGVyLnlTZXR0ZXIgPSB3cmFwcGVyLmFsaWduU2V0dGVyID0gd3JhcHBlci5yb3RhdGlvblNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdhbGlnbicpIHtcblx0XHRcdFx0XHRrZXkgPSAndGV4dEFsaWduJzsgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgU1ZHRWxlbWVudC5hbGlnbiBtZXRob2QuIFNhbWUgYXMgVk1MLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR3cmFwcGVyLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFNldCB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzXG5cdFx0XHR3cmFwcGVyLmF0dHIoe1xuXHRcdFx0XHRcdHRleHQ6IHN0cixcblx0XHRcdFx0XHR4OiBtYXRoUm91bmQoeCksXG5cdFx0XHRcdFx0eTogbWF0aFJvdW5kKHkpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHRmb250RmFtaWx5OiB0aGlzLnN0eWxlLmZvbnRGYW1pbHksXG5cdFx0XHRcdFx0Zm9udFNpemU6IHRoaXMuc3R5bGUuZm9udFNpemVcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIEtlZXAgdGhlIHdoaXRlU3BhY2Ugc3R5bGUgb3V0c2lkZSB0aGUgd3JhcHBlci5zdHlsZXMgY29sbGVjdGlvblxuXHRcdFx0ZWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG5cblx0XHRcdC8vIFVzZSB0aGUgSFRNTCBzcGVjaWZpYyAuY3NzIG1ldGhvZFxuXHRcdFx0d3JhcHBlci5jc3MgPSB3cmFwcGVyLmh0bWxDc3M7XG5cblx0XHRcdC8vIFRoaXMgaXMgc3BlY2lmaWMgZm9yIEhUTUwgd2l0aGluIFNWR1xuXHRcdFx0aWYgKHJlbmRlcmVyLmlzU1ZHKSB7XG5cdFx0XHRcdHdyYXBwZXIuYWRkID0gZnVuY3Rpb24gKHN2Z0dyb3VwV3JhcHBlcikge1xuXG5cdFx0XHRcdFx0dmFyIGh0bWxHcm91cCxcblx0XHRcdFx0XHRcdGNvbnRhaW5lciA9IHJlbmRlcmVyLmJveC5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0cGFyZW50R3JvdXAsXG5cdFx0XHRcdFx0XHRwYXJlbnRzID0gW107XG5cblx0XHRcdFx0XHR0aGlzLnBhcmVudEdyb3VwID0gc3ZnR3JvdXBXcmFwcGVyO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbW9jayBncm91cCB0byBob2xkIHRoZSBIVE1MIGVsZW1lbnRzXG5cdFx0XHRcdFx0aWYgKHN2Z0dyb3VwV3JhcHBlcikge1xuXHRcdFx0XHRcdFx0aHRtbEdyb3VwID0gc3ZnR3JvdXBXcmFwcGVyLmRpdjtcblx0XHRcdFx0XHRcdGlmICghaHRtbEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVhZCB0aGUgcGFyZW50IGNoYWluIGludG8gYW4gYXJyYXkgYW5kIHJlYWQgZnJvbSB0b3AgZG93blxuXHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cCA9IHN2Z0dyb3VwV3JhcHBlcjtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhcmVudEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRzLnB1c2gocGFyZW50R3JvdXApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTW92ZSB1cCB0byB0aGUgbmV4dCBwYXJlbnQgZ3JvdXBcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwLnBhcmVudEdyb3VwO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gRW5zdXJlIGR5bmFtaWNhbGx5IHVwZGF0aW5nIHBvc2l0aW9uIHdoZW4gYW55IHBhcmVudCBpcyB0cmFuc2xhdGVkXG5cdFx0XHRcdFx0XHRcdGVhY2gocGFyZW50cy5yZXZlcnNlKCksIGZ1bmN0aW9uIChwYXJlbnRHcm91cCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBodG1sR3JvdXBTdHlsZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNscyA9IGF0dHIocGFyZW50R3JvdXAuZWxlbWVudCwgJ2NsYXNzJyk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoY2xzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbHMgPSB7IGNsYXNzTmFtZTogY2xzIH07XG5cdFx0XHRcdFx0XHRcdFx0fSAvLyBlbHNlIG51bGxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIEhUTUwgZGl2IGFuZCBhcHBlbmQgaXQgdG8gdGhlIHBhcmVudCBkaXYgdG8gZW11bGF0ZVxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBTVkcgZ3JvdXAgc3RydWN0dXJlXG5cdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwID0gcGFyZW50R3JvdXAuZGl2ID0gcGFyZW50R3JvdXAuZGl2IHx8IGNyZWF0ZUVsZW1lbnQoRElWLCBjbHMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHRcdFx0XHRcdGxlZnQ6IChwYXJlbnRHcm91cC50cmFuc2xhdGVYIHx8IDApICsgUFgsXG5cdFx0XHRcdFx0XHRcdFx0XHR0b3A6IChwYXJlbnRHcm91cC50cmFuc2xhdGVZIHx8IDApICsgUFhcblx0XHRcdFx0XHRcdFx0XHR9LCBodG1sR3JvdXAgfHwgY29udGFpbmVyKTsgLy8gdGhlIHRvcCBncm91cCBpcyBhcHBlbmRlZCB0byBjb250YWluZXJcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFNob3J0Y3V0XG5cdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGUgPSBodG1sR3JvdXAuc3R5bGU7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTZXQgbGlzdGVuZXJzIHRvIHVwZGF0ZSB0aGUgSFRNTCBkaXYncyBwb3NpdGlvbiB3aGVuZXZlciB0aGUgU1ZHIGdyb3VwXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcG9zaXRpb24gaXMgY2hhbmdlZFxuXHRcdFx0XHRcdFx0XHRcdGV4dGVuZChwYXJlbnRHcm91cCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGUubGVmdCA9IHZhbHVlICsgUFg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zbGF0ZVlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlLnRvcCA9IHZhbHVlICsgUFg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHdyYXAocGFyZW50R3JvdXAsICd2aXNpYmlsaXR5U2V0dGVyJywgZnVuY3Rpb24gKHByb2NlZWQsIHZhbHVlLCBrZXksIGVsZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2NlZWQuY2FsbCh0aGlzLCB2YWx1ZSwga2V5LCBlbGVtKTtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aHRtbEdyb3VwID0gY29udGFpbmVyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGh0bWxHcm91cC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0XHRcdC8vIFNoYXJlZCB3aXRoIFZNTDpcblx0XHRcdFx0XHR3cmFwcGVyLmFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAod3JhcHBlci5hbGlnbk9uQWRkKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVyLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH1cblx0fSk7XG5cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqIFNUQVJUIE9GIElOVEVSTkVUIEVYUExPUkVSIDw9IDggU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiBGb3IgYXBwbGljYXRpb25zIGFuZCB3ZWJzaXRlcyB0aGF0IGRvbid0IG5lZWQgSUUgc3VwcG9ydCwgbGlrZSBwbGF0Zm9ybSAgICAqXG5cdCAqIHRhcmdldGVkIG1vYmlsZSBhcHBzIGFuZCB3ZWIgYXBwcywgdGhpcyBjb2RlIGNhbiBiZSByZW1vdmVkLiAgICAgICAgICAgICAgICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIFZNTFJlbmRlcmVyLCBWTUxFbGVtZW50O1xuXHRpZiAoIWhhc1NWRyAmJiAhdXNlQ2FuVkcpIHtcblxuXHQvKipcblx0ICogVGhlIFZNTCBlbGVtZW50IHdyYXBwZXIuXG5cdCAqL1xuXHRWTUxFbGVtZW50ID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSBhIG5ldyBWTUwgZWxlbWVudCB3cmFwcGVyLiBJdCBidWlsZHMgdGhlIG1hcmt1cCBhcyBhIHN0cmluZ1xuXHRcdCAqIHRvIG1pbmltaXplIERPTSB0cmFmZmljLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTmFtZVxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChyZW5kZXJlciwgbm9kZU5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0bWFya3VwID0gIFsnPCcsIG5vZGVOYW1lLCAnIGZpbGxlZD1cImZcIiBzdHJva2VkPVwiZlwiJ10sXG5cdFx0XHRcdHN0eWxlID0gWydwb3NpdGlvbjogJywgQUJTT0xVVEUsICc7J10sXG5cdFx0XHRcdGlzRGl2ID0gbm9kZU5hbWUgPT09IERJVjtcblxuXHRcdFx0Ly8gZGl2cyBhbmQgc2hhcGVzIG5lZWQgc2l6ZVxuXHRcdFx0aWYgKG5vZGVOYW1lID09PSAnc2hhcGUnIHx8IGlzRGl2KSB7XG5cdFx0XHRcdHN0eWxlLnB1c2goJ2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlLnB1c2goJ3Zpc2liaWxpdHk6ICcsIGlzRGl2ID8gSElEREVOIDogVklTSUJMRSk7XG5cblx0XHRcdG1hcmt1cC5wdXNoKCcgc3R5bGU9XCInLCBzdHlsZS5qb2luKCcnKSwgJ1wiLz4nKTtcblxuXHRcdFx0Ly8gY3JlYXRlIGVsZW1lbnQgd2l0aCBkZWZhdWx0IGF0dHJpYnV0ZXMgYW5kIHN0eWxlXG5cdFx0XHRpZiAobm9kZU5hbWUpIHtcblx0XHRcdFx0bWFya3VwID0gaXNEaXYgfHwgbm9kZU5hbWUgPT09ICdzcGFuJyB8fCBub2RlTmFtZSA9PT0gJ2ltZycgP1xuXHRcdFx0XHRcdG1hcmt1cC5qb2luKCcnKVxuXHRcdFx0XHRcdDogcmVuZGVyZXIucHJlcFZNTChtYXJrdXApO1xuXHRcdFx0XHR3cmFwcGVyLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KG1hcmt1cCk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXBwZXIucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBub2RlIHRvIHRoZSBnaXZlbiBwYXJlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbiAocGFyZW50KSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0Ym94ID0gcmVuZGVyZXIuYm94LFxuXHRcdFx0XHRpbnZlcnRlZCA9IHBhcmVudCAmJiBwYXJlbnQuaW52ZXJ0ZWQsXG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBwYXJlbnQgbm9kZVxuXHRcdFx0XHRwYXJlbnROb2RlID0gcGFyZW50ID9cblx0XHRcdFx0XHRwYXJlbnQuZWxlbWVudCB8fCBwYXJlbnQgOlxuXHRcdFx0XHRcdGJveDtcblxuXG5cdFx0XHQvLyBpZiB0aGUgcGFyZW50IGdyb3VwIGlzIGludmVydGVkLCBhcHBseSBpbnZlcnNpb24gb24gYWxsIGNoaWxkcmVuXG5cdFx0XHRpZiAoaW52ZXJ0ZWQpIHsgLy8gb25seSBvbiBncm91cHNcblx0XHRcdFx0cmVuZGVyZXIuaW52ZXJ0Q2hpbGQoZWxlbWVudCwgcGFyZW50Tm9kZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGVuZCBpdFxuXHRcdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0Ly8gYWxpZ24gdGV4dCBhZnRlciBhZGRpbmcgdG8gYmUgYWJsZSB0byByZWFkIG9mZnNldFxuXHRcdFx0d3JhcHBlci5hZGRlZCA9IHRydWU7XG5cdFx0XHRpZiAod3JhcHBlci5hbGlnbk9uQWRkICYmICF3cmFwcGVyLmRlZmVyVXBkYXRlVHJhbnNmb3JtKSB7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpcmUgYW4gZXZlbnQgZm9yIGludGVybmFsIGhvb2tzXG5cdFx0XHRpZiAod3JhcHBlci5vbkFkZCkge1xuXHRcdFx0XHR3cmFwcGVyLm9uQWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgYWx3YXlzIHVzZXMgaHRtbFVwZGF0ZVRyYW5zZm9ybVxuXHRcdCAqL1xuXHRcdHVwZGF0ZVRyYW5zZm9ybTogU1ZHRWxlbWVudC5wcm90b3R5cGUuaHRtbFVwZGF0ZVRyYW5zZm9ybSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcm90YXRpb24gb2YgYSBzcGFuIHdpdGggb2xkSUUncyBmaWx0ZXJcblx0XHQgKi9cblx0XHRzZXRTcGFuUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIEFkanVzdCBmb3IgYWxpZ25tZW50IGFuZCByb3RhdGlvbi4gUm90YXRpb24gb2YgdXNlSFRNTCBjb250ZW50IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcblx0XHRcdC8vIGJ1dCBpdCBjYW4gcHJvYmFibHkgYmUgaW1wbGVtZW50ZWQgZm9yIEZpcmVmb3ggMy41KyBvbiB1c2VyIHJlcXVlc3QuIEZGMy41K1xuXHRcdFx0Ly8gaGFzIHN1cHBvcnQgZm9yIENTUzMgdHJhbnNmb3JtLiBUaGUgZ2V0QkJveCBtZXRob2QgYWxzbyBuZWVkcyB0byBiZSB1cGRhdGVkXG5cdFx0XHQvLyB0byBjb21wZW5zYXRlIGZvciB0aGUgcm90YXRpb24sIGxpa2UgaXQgY3VycmVudGx5IGRvZXMgZm9yIFNWRy5cblx0XHRcdC8vIFRlc3QgY2FzZTogaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzL1lidDQ0L1xuXG5cdFx0XHR2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuXHRcdFx0XHRjb3N0aGV0YSA9IG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSxcblx0XHRcdFx0c2ludGhldGEgPSBtYXRoU2luKHJvdGF0aW9uICogZGVnMnJhZCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0ZmlsdGVyOiByb3RhdGlvbiA/IFsncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9JywgY29zdGhldGEsXG5cdFx0XHRcdFx0JywgTTEyPScsIC1zaW50aGV0YSwgJywgTTIxPScsIHNpbnRoZXRhLCAnLCBNMjI9JywgY29zdGhldGEsXG5cdFx0XHRcdFx0Jywgc2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnKSddLmpvaW4oJycpIDogTk9ORVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgcG9zaXRpb25pbmcgY29ycmVjdGlvbiBmb3IgdGhlIHNwYW4gYWZ0ZXIgcm90YXRpbmcuIFxuXHRcdCAqL1xuXHRcdGdldFNwYW5Db3JyZWN0aW9uOiBmdW5jdGlvbiAod2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24sIHJvdGF0aW9uLCBhbGlnbikge1xuXG5cdFx0XHR2YXIgY29zdGhldGEgPSByb3RhdGlvbiA/IG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSA6IDEsXG5cdFx0XHRcdHNpbnRoZXRhID0gcm90YXRpb24gPyBtYXRoU2luKHJvdGF0aW9uICogZGVnMnJhZCkgOiAwLFxuXHRcdFx0XHRoZWlnaHQgPSBwaWNrKHRoaXMuZWxlbUhlaWdodCwgdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdHF1YWQsXG5cdFx0XHRcdG5vbkxlZnQgPSBhbGlnbiAmJiBhbGlnbiAhPT0gJ2xlZnQnO1xuXG5cdFx0XHQvLyBjb3JyZWN0IHggYW5kIHlcblx0XHRcdHRoaXMueENvcnIgPSBjb3N0aGV0YSA8IDAgJiYgLXdpZHRoO1xuXHRcdFx0dGhpcy55Q29yciA9IHNpbnRoZXRhIDwgMCAmJiAtaGVpZ2h0O1xuXG5cdFx0XHQvLyBjb3JyZWN0IGZvciBiYXNlbGluZSBhbmQgY29ybmVycyBzcGlsbGluZyBvdXQgYWZ0ZXIgcm90YXRpb25cblx0XHRcdHF1YWQgPSBjb3N0aGV0YSAqIHNpbnRoZXRhIDwgMDtcblx0XHRcdHRoaXMueENvcnIgKz0gc2ludGhldGEgKiBiYXNlbGluZSAqIChxdWFkID8gMSAtIGFsaWduQ29ycmVjdGlvbiA6IGFsaWduQ29ycmVjdGlvbik7XG5cdFx0XHR0aGlzLnlDb3JyIC09IGNvc3RoZXRhICogYmFzZWxpbmUgKiAocm90YXRpb24gPyAocXVhZCA/IGFsaWduQ29ycmVjdGlvbiA6IDEgLSBhbGlnbkNvcnJlY3Rpb24pIDogMSk7XG5cdFx0XHQvLyBjb3JyZWN0IGZvciB0aGUgbGVuZ3RoL2hlaWdodCBvZiB0aGUgdGV4dFxuXHRcdFx0aWYgKG5vbkxlZnQpIHtcblx0XHRcdFx0dGhpcy54Q29yciAtPSB3aWR0aCAqIGFsaWduQ29ycmVjdGlvbiAqIChjb3N0aGV0YSA8IDAgPyAtMSA6IDEpO1xuXHRcdFx0XHRpZiAocm90YXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLnlDb3JyIC09IGhlaWdodCAqIGFsaWduQ29ycmVjdGlvbiAqIChzaW50aGV0YSA8IDAgPyAtMSA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHR0ZXh0QWxpZ246IGFsaWduXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyBhIHN1YnNldCBvZiBhbiBTVkcgcGF0aCBkZWZpbml0aW9uIHRvIGl0cyBWTUwgY291bnRlcnBhcnQuIFRha2VzIGFuIGFycmF5XG5cdFx0ICogYXMgdGhlIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIHN0cmluZy5cblx0XHQgKi9cblx0XHRwYXRoVG9WTUw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gY29udmVydCBwYXRoc1xuXHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG5cdFx0XHRcdHBhdGggPSBbXTtcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHRcdC8vIE11bHRpcGx5IGJ5IDEwIHRvIGFsbG93IHN1YnBpeGVsIHByZWNpc2lvbi5cblx0XHRcdFx0Ly8gU3Vic3RyYWN0aW5nIGhhbGYgYSBwaXhlbCBzZWVtcyB0byBtYWtlIHRoZSBjb29yZGluYXRlc1xuXHRcdFx0XHQvLyBhbGlnbiB3aXRoIFNWRywgYnV0IHRoaXMgaGFzbid0IGJlZW4gdGVzdGVkIHRob3JvdWdobHlcblx0XHRcdFx0aWYgKGlzTnVtYmVyKHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdHBhdGhbaV0gPSBtYXRoUm91bmQodmFsdWVbaV0gKiAxMCkgLSA1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlW2ldID09PSAnWicpIHsgLy8gY2xvc2UgdGhlIHBhdGhcblx0XHRcdFx0XHRwYXRoW2ldID0gJ3gnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhdGhbaV0gPSB2YWx1ZVtpXTtcblxuXHRcdFx0XHRcdC8vIFdoZW4gdGhlIHN0YXJ0IFggYW5kIGVuZCBYIGNvb3JkaW5hdGVzIG9mIGFuIGFyYyBhcmUgdG9vIGNsb3NlLFxuXHRcdFx0XHRcdC8vIHRoZXkgYXJlIHJvdW5kZWQgdG8gdGhlIHNhbWUgdmFsdWUgYWJvdmUuIEluIHRoaXMgY2FzZSwgc3Vic3RyYWN0IG9yIFxuXHRcdFx0XHRcdC8vIGFkZCAxIGZyb20gdGhlIGVuZCBYIGFuZCBZIHBvc2l0aW9ucy4gIzE4NiwgIzc2MCwgIzEzNzEsICMxNDEwLlxuXHRcdFx0XHRcdGlmICh2YWx1ZS5pc0FyYyAmJiAodmFsdWVbaV0gPT09ICd3YScgfHwgdmFsdWVbaV0gPT09ICdhdCcpKSB7XG5cdFx0XHRcdFx0XHQvLyBTdGFydCBhbmQgZW5kIFhcblx0XHRcdFx0XHRcdGlmIChwYXRoW2kgKyA1XSA9PT0gcGF0aFtpICsgN10pIHtcblx0XHRcdFx0XHRcdFx0cGF0aFtpICsgN10gKz0gdmFsdWVbaSArIDddID4gdmFsdWVbaSArIDVdID8gMSA6IC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gU3RhcnQgYW5kIGVuZCBZXG5cdFx0XHRcdFx0XHRpZiAocGF0aFtpICsgNl0gPT09IHBhdGhbaSArIDhdKSB7XG5cdFx0XHRcdFx0XHRcdHBhdGhbaSArIDhdICs9IHZhbHVlW2kgKyA4XSA+IHZhbHVlW2kgKyA2XSA/IDEgOiAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0XG5cdFx0XHQvLyBMb29wIHVwIGFnYWluIHRvIGhhbmRsZSBwYXRoIHNob3J0Y3V0cyAoIzIxMzIpXG5cdFx0XHQvKndoaWxlIChpKysgPCBwYXRoLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAocGF0aFtpXSA9PT0gJ0gnKSB7IC8vIGhvcml6b250YWwgbGluZSB0b1xuXHRcdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDIsIDAsIHBhdGhbaSAtIDFdKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwYXRoW2ldID09PSAnVicpIHsgLy8gdmVydGljYWwgbGluZSB0b1xuXHRcdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDEsIDAsIHBhdGhbaSAtIDJdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSovXG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKCcgJykgfHwgJ3gnO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGVsZW1lbnQncyBjbGlwcGluZyB0byBhIHByZWRlZmluZWQgcmVjdGFuZ2xlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBjbGlwIHJlY3RhbmdsZVxuXHRcdCAqL1xuXHRcdGNsaXA6IGZ1bmN0aW9uIChjbGlwUmVjdCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRjbGlwTWVtYmVycyxcblx0XHRcdFx0Y3NzUmV0O1xuXG5cdFx0XHRpZiAoY2xpcFJlY3QpIHtcblx0XHRcdFx0Y2xpcE1lbWJlcnMgPSBjbGlwUmVjdC5tZW1iZXJzO1xuXHRcdFx0XHRlcmFzZShjbGlwTWVtYmVycywgd3JhcHBlcik7IC8vIEVuc3VyZSB1bmlxdWUgbGlzdCBvZiBlbGVtZW50cyAoIzEyNTgpXG5cdFx0XHRcdGNsaXBNZW1iZXJzLnB1c2god3JhcHBlcik7XG5cdFx0XHRcdHdyYXBwZXIuZGVzdHJveUNsaXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZXJhc2UoY2xpcE1lbWJlcnMsIHdyYXBwZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjc3NSZXQgPSBjbGlwUmVjdC5nZXRDU1Mod3JhcHBlcik7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh3cmFwcGVyLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5kZXN0cm95Q2xpcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNzc1JldCA9IHsgY2xpcDogZG9jTW9kZTggPyAnaW5oZXJpdCcgOiAncmVjdChhdXRvKScgfTsgLy8gIzEyMTRcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdyYXBwZXIuY3NzKGNzc1JldCk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHN0eWxlcyBmb3IgdGhlIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdFx0ICovXG5cdFx0Y3NzOiBTVkdFbGVtZW50LnByb3RvdHlwZS5odG1sQ3NzLFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdFx0ICogSXNzdWUgNDkwOyBpbiBWTUwgcmVtb3ZlQ2hpbGQgcmVzdWx0cyBpbiBPcnBoYW5lZCBub2RlcyBhY2NvcmRpbmcgdG8gc0lFdmUsIGRpc2NhcmRFbGVtZW50IGRvZXMgbm90LlxuXHRcdCAqL1xuXHRcdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdC8vIGRpc2NhcmRFbGVtZW50IHdpbGwgZGV0YWNoIHRoZSBub2RlIGZyb20gaXRzIHBhcmVudCBiZWZvcmUgYXR0YWNoaW5nIGl0XG5cdFx0XHQvLyB0byB0aGUgZ2FyYmFnZSBiaW4uIFRoZXJlZm9yZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGUgbm9kZSBpcyBhdHRhY2hlZCBhbmQgaGF2ZSBwYXJlbnQuXG5cdFx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGRpc2NhcmRFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmQgZWxlbWVudC5kZXN0cm95IGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGNsaXAgbWVtYmVycyBhcnJheVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveUNsaXAoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFNWR0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gVk1MIG92ZXJyaWRlIGZvciBub3JtYWxpemluZyBldmVudCBwYXJhbWV0ZXJzLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0b246IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdC8vIHNpbXBsZXN0IHBvc3NpYmxlIGV2ZW50IG1vZGVsIGZvciBpbnRlcm5hbCB1c2Vcblx0XHRcdHRoaXMuZWxlbWVudFsnb24nICsgZXZlbnRUeXBlXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGV2dCA9IHdpbi5ldmVudDtcblx0XHRcdFx0ZXZ0LnRhcmdldCA9IGV2dC5zcmNFbGVtZW50O1xuXHRcdFx0XHRoYW5kbGVyKGV2dCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluIHN0YWNrZWQgY29sdW1ucywgY3V0IG9mZiB0aGUgc2hhZG93cyBzbyB0aGF0IHRoZXkgZG9uJ3Qgb3ZlcmxhcFxuXHRcdCAqL1xuXHRcdGN1dE9mZlBhdGg6IGZ1bmN0aW9uIChwYXRoLCBsZW5ndGgpIHtcblxuXHRcdFx0dmFyIGxlbjtcblxuXHRcdFx0cGF0aCA9IHBhdGguc3BsaXQoL1sgLF0vKTtcblx0XHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0XHRpZiAobGVuID09PSA5IHx8IGxlbiA9PT0gMTEpIHtcblx0XHRcdFx0cGF0aFtsZW4gLSA0XSA9IHBhdGhbbGVuIC0gMl0gPSBwSW50KHBhdGhbbGVuIC0gMl0pIC0gMTAgKiBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKCcgJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IGEgZHJvcCBzaGFkb3cgYnkgY29weWluZyBlbGVtZW50cyBhbmQgZ2l2aW5nIHRoZW0gZGlmZmVyZW50IHN0cm9rZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBzaGFkb3dPcHRpb25zXG5cdFx0ICovXG5cdFx0c2hhZG93OiBmdW5jdGlvbiAoc2hhZG93T3B0aW9ucywgZ3JvdXAsIGN1dE9mZikge1xuXHRcdFx0dmFyIHNoYWRvd3MgPSBbXSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRzaGFkb3csXG5cdFx0XHRcdGVsZW1TdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRcdG1hcmt1cCxcblx0XHRcdFx0cGF0aCA9IGVsZW1lbnQucGF0aCxcblx0XHRcdFx0c3Ryb2tlV2lkdGgsXG5cdFx0XHRcdG1vZGlmaWVkUGF0aCxcblx0XHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5O1xuXG5cdFx0XHQvLyBzb21lIHRpbWVzIGVtcHR5IHBhdGhzIGFyZSBub3Qgc3RyaW5nc1xuXHRcdFx0aWYgKHBhdGggJiYgdHlwZW9mIHBhdGgudmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhdGggPSAneCc7XG5cdFx0XHR9XG5cdFx0XHRtb2RpZmllZFBhdGggPSBwYXRoO1xuXG5cdFx0XHRpZiAoc2hhZG93T3B0aW9ucykge1xuXHRcdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5ID0gKHNoYWRvd09wdGlvbnMub3BhY2l0eSB8fCAwLjE1KSAvIHNoYWRvd1dpZHRoO1xuXHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IDM7IGkrKykge1xuXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSAoc2hhZG93V2lkdGggKiAyKSArIDEgLSAoMiAqIGkpO1xuXG5cdFx0XHRcdFx0Ly8gQ3V0IG9mZiBzaGFkb3dzIGZvciBzdGFja2VkIGNvbHVtbiBpdGVtc1xuXHRcdFx0XHRcdGlmIChjdXRPZmYpIHtcblx0XHRcdFx0XHRcdG1vZGlmaWVkUGF0aCA9IHRoaXMuY3V0T2ZmUGF0aChwYXRoLnZhbHVlLCBzdHJva2VXaWR0aCArIDAuNSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFya3VwID0gWyc8c2hhcGUgaXNTaGFkb3c9XCJ0cnVlXCIgc3Ryb2tld2VpZ2h0PVwiJywgc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0XHQnXCIgZmlsbGVkPVwiZmFsc2VcIiBwYXRoPVwiJywgbW9kaWZpZWRQYXRoLFxuXHRcdFx0XHRcdFx0J1wiIGNvb3Jkc2l6ZT1cIjEwIDEwXCIgc3R5bGU9XCInLCBlbGVtZW50LnN0eWxlLmNzc1RleHQsICdcIiAvPiddO1xuXG5cdFx0XHRcdFx0c2hhZG93ID0gY3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksXG5cdFx0XHRcdFx0XHRudWxsLCB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHBJbnQoZWxlbVN0eWxlLmxlZnQpICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFgsIDEpLFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBJbnQoZWxlbVN0eWxlLnRvcCkgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WSwgMSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGlmIChjdXRPZmYpIHtcblx0XHRcdFx0XHRcdHNoYWRvdy5jdXRPZmYgPSBzdHJva2VXaWR0aCArIDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYXBwbHkgdGhlIG9wYWNpdHlcblx0XHRcdFx0XHRtYXJrdXAgPSBbJzxzdHJva2UgY29sb3I9XCInLCBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsICdcIiBvcGFjaXR5PVwiJywgc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLCAnXCIvPiddO1xuXHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQocmVuZGVyZXIucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBzaGFkb3cpO1xuXG5cblx0XHRcdFx0XHQvLyBpbnNlcnQgaXRcblx0XHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzaGFkb3csIGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHJlY29yZCBpdFxuXHRcdFx0XHRcdHNoYWRvd3MucHVzaChzaGFkb3cpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNoYWRvd3MgPSBzaGFkb3dzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHR1cGRhdGVTaGFkb3dzOiBub29wLCAvLyBVc2VkIGluIFNWRyBvbmx5XG5cblx0XHRzZXRBdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKGRvY01vZGU4KSB7IC8vIElFOCBzZXRBdHRyaWJ1dGUgYnVnXG5cdFx0XHRcdHRoaXMuZWxlbWVudFtrZXldID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2xhc3NTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gSUU4IFN0YW5kYXJkcyBtb2RlIGhhcyBwcm9ibGVtcyByZXRyaWV2aW5nIHRoZSBjbGFzc05hbWUgdW5sZXNzIHNldCBsaWtlIHRoaXNcblx0XHRcdHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcblx0XHR9LFxuXHRcdGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHZhciBzdHJva2VFbGVtID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF0gfHxcblx0XHRcdFx0Y3JlYXRlRWxlbWVudCh0aGlzLnJlbmRlcmVyLnByZXBWTUwoWyc8c3Ryb2tlLz4nXSksIG51bGwsIG51bGwsIGVsZW1lbnQpO1xuXHRcdFx0c3Ryb2tlRWxlbVtrZXldID0gdmFsdWUgfHwgJ3NvbGlkJztcblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlOyAvKiBiZWNhdXNlIGNoYW5naW5nIHN0cm9rZS13aWR0aCB3aWxsIGNoYW5nZSB0aGUgZGFzaCBsZW5ndGhcblx0XHRcdFx0YW5kIGNhdXNlIGFuIGVwaWxlcHRpYyBlZmZlY3QgKi9cblx0XHR9LFxuXHRcdGRTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2hhZG93cyA9IHRoaXMuc2hhZG93cztcblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgW107XG5cdFx0XHR0aGlzLmQgPSB2YWx1ZS5qb2luICYmIHZhbHVlLmpvaW4oJyAnKTsgLy8gdXNlZCBpbiBnZXR0ZXIgZm9yIGFuaW1hdGlvblxuXG5cdFx0XHRlbGVtZW50LnBhdGggPSB2YWx1ZSA9IHRoaXMucGF0aFRvVk1MKHZhbHVlKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHNoYWRvd3Ncblx0XHRcdGlmIChzaGFkb3dzKSB7XG5cdFx0XHRcdGkgPSBzaGFkb3dzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHNoYWRvd3NbaV0ucGF0aCA9IHNoYWRvd3NbaV0uY3V0T2ZmID8gdGhpcy5jdXRPZmZQYXRoKHZhbHVlLCBzaGFkb3dzW2ldLmN1dE9mZikgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRBdHRyKGtleSwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0ZmlsbFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cdFx0XHRpZiAobm9kZU5hbWUgPT09ICdTUEFOJykgeyAvLyB0ZXh0IGNvbG9yXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuY29sb3IgPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgIT09ICdJTUcnKSB7IC8vICMxMzM2XG5cdFx0XHRcdGVsZW1lbnQuZmlsbGVkID0gdmFsdWUgIT09IE5PTkU7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cignZmlsbGNvbG9yJywgdGhpcy5yZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvcGFjaXR5U2V0dGVyOiBub29wLCAvLyBEb24ndCBib3RoZXIgLSBhbmltYXRpb24gaXMgdG9vIHNsb3cgYW5kIGZpbHRlcnMgaW50cm9kdWNlIGFydGlmYWN0c1xuXHRcdHJvdGF0aW9uU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRcdHRoaXNba2V5XSA9IHN0eWxlW2tleV0gPSB2YWx1ZTsgLy8gc3R5bGUgaXMgZm9yICMxODczXG5cblx0XHRcdC8vIENvcnJlY3Rpb24gZm9yIHRoZSAxeDEgc2l6ZSBvZiB0aGUgc2hhcGUgY29udGFpbmVyLiBVc2VkIGluIGdhdWdlIG5lZWRsZXMuXG5cdFx0XHRzdHlsZS5sZWZ0ID0gLW1hdGhSb3VuZChtYXRoU2luKHZhbHVlICogZGVnMnJhZCkgKyAxKSArIFBYO1xuXHRcdFx0c3R5bGUudG9wID0gbWF0aFJvdW5kKG1hdGhDb3ModmFsdWUgKiBkZWcycmFkKSkgKyBQWDtcblx0XHR9LFxuXHRcdHN0cm9rZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuc2V0QXR0cignc3Ryb2tlY29sb3InLCB0aGlzLnJlbmRlcmVyLmNvbG9yKHZhbHVlLCBlbGVtZW50LCBrZXkpKTtcblx0XHR9LFxuXHRcdCdzdHJva2Utd2lkdGhTZXR0ZXInOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zdHJva2VkID0gISF2YWx1ZTsgLy8gVk1MIFwic3Ryb2tlZFwiIGF0dHJpYnV0ZVxuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8vIHVzZWQgaW4gZ2V0dGVyLCBpc3N1ZSAjMTEzXG5cdFx0XHRpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlICs9IFBYO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRBdHRyKCdzdHJva2V3ZWlnaHQnLCB2YWx1ZSk7XG5cdFx0fSxcblx0XHR0aXRsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRoaXMuc2V0QXR0cihrZXksIHZhbHVlKTtcblx0XHR9LFxuXHRcdHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cblx0XHRcdC8vIEhhbmRsZSBpbmhlcml0ZWQgdmlzaWJpbGl0eVxuXHRcdFx0aWYgKHZhbHVlID09PSAnaW5oZXJpdCcpIHtcblx0XHRcdFx0dmFsdWUgPSBWSVNJQkxFO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBMZXQgdGhlIHNoYWRvdyBmb2xsb3cgdGhlIG1haW4gZWxlbWVudFxuXHRcdFx0aWYgKHRoaXMuc2hhZG93cykge1xuXHRcdFx0XHRlYWNoKHRoaXMuc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHRcdHNoYWRvdy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnN0ZWFkIG9mIHRvZ2dsaW5nIHRoZSB2aXNpYmlsaXR5IENTUyBwcm9wZXJ0eSwgbW92ZSB0aGUgZGl2IG91dCBvZiB0aGUgdmlld3BvcnQuXG5cdFx0XHQvLyBUaGlzIHdvcmtzIGFyb3VuZCAjNjEgYW5kICM1ODZcblx0XHRcdGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnRElWJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlID09PSBISURERU4gPyAnLTk5OWVtJyA6IDA7XG5cblx0XHRcdFx0Ly8gSW4gb3JkZXIgdG8gcmVkcmF3LCBJRTcgbmVlZHMgdGhlIGRpdiB0byBiZSB2aXNpYmxlIHdoZW4gdHVja2VkIGF3YXlcblx0XHRcdFx0Ly8gb3V0c2lkZSB0aGUgdmlld3BvcnQuIFNvIHRoZSB2aXNpYmlsaXR5IGlzIGFjdHVhbGx5IG9wcG9zaXRlIG9mXG5cdFx0XHRcdC8vIHRoZSBleHBlY3RlZCB2YWx1ZS4gVGhpcyBhcHBsaWVzIHRvIHRoZSB0b29sdGlwIG9ubHkuXG5cdFx0XHRcdGlmICghZG9jTW9kZTgpIHtcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZSA/IFZJU0lCTEUgOiBISURERU47XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9LFxuXHRcdHhTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLy8gdXNlZCBpbiBnZXR0ZXJcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3gnKSB7XG5cdFx0XHRcdGtleSA9ICdsZWZ0Jztcblx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAneScpIHtcblx0XHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0XHR9LyogZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gbWF0aE1heCgwLCB2YWx1ZSk7IC8vIGRvbid0IHNldCB3aWR0aCBvciBoZWlnaHQgYmVsb3cgemVybyAoIzMxMSlcblx0XHRcdH0qL1xuXG5cdFx0XHQvLyBjbGlwcGluZyByZWN0YW5nbGUgc3BlY2lhbFxuXHRcdFx0aWYgKHRoaXMudXBkYXRlQ2xpcHBpbmcpIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8vIHRoZSBrZXkgaXMgbm93ICdsZWZ0JyBvciAndG9wJyBmb3IgJ3gnIGFuZCAneSdcblx0XHRcdFx0dGhpcy51cGRhdGVDbGlwcGluZygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbm9ybWFsXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ekluZGV4U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXHRIaWdoY2hhcnRzLlZNTEVsZW1lbnQgPSBWTUxFbGVtZW50ID0gZXh0ZW5kQ2xhc3MoU1ZHRWxlbWVudCwgVk1MRWxlbWVudCk7XG5cblx0Ly8gU29tZSBzaGFyZWQgc2V0dGVyc1xuXHRWTUxFbGVtZW50LnByb3RvdHlwZS55U2V0dGVyID1cblx0XHRWTUxFbGVtZW50LnByb3RvdHlwZS53aWR0aFNldHRlciA9IFxuXHRcdFZNTEVsZW1lbnQucHJvdG90eXBlLmhlaWdodFNldHRlciA9IFxuXHRcdFZNTEVsZW1lbnQucHJvdG90eXBlLnhTZXR0ZXI7XG5cblxuXHQvKipcblx0ICogVGhlIFZNTCByZW5kZXJlclxuXHQgKi9cblx0dmFyIFZNTFJlbmRlcmVyRXh0ZW5zaW9uID0geyAvLyBpbmhlcml0IFNWR1JlbmRlcmVyXG5cblx0XHRFbGVtZW50OiBWTUxFbGVtZW50LFxuXHRcdGlzSUU4OiB1c2VyQWdlbnQuaW5kZXhPZignTVNJRSA4LjAnKSA+IC0xLFxuXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBWTUxSZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCwgc3R5bGUpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGJveFdyYXBwZXIsXG5cdFx0XHRcdGJveCxcblx0XHRcdFx0Y3NzO1xuXG5cdFx0XHRyZW5kZXJlci5hbGlnbmVkT2JqZWN0cyA9IFtdO1xuXG5cdFx0XHRib3hXcmFwcGVyID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChESVYpXG5cdFx0XHRcdC5jc3MoZXh0ZW5kKHRoaXMuZ2V0U3R5bGUoc3R5bGUpLCB7IHBvc2l0aW9uOiBSRUxBVElWRX0pKTtcblx0XHRcdGJveCA9IGJveFdyYXBwZXIuZWxlbWVudDtcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3hXcmFwcGVyLmVsZW1lbnQpO1xuXG5cblx0XHRcdC8vIGdlbmVyYXRlIHRoZSBjb250YWluaW5nIGJveFxuXHRcdFx0cmVuZGVyZXIuaXNWTUwgPSB0cnVlO1xuXHRcdFx0cmVuZGVyZXIuYm94ID0gYm94O1xuXHRcdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IGJveFdyYXBwZXI7XG5cdFx0XHRyZW5kZXJlci5jYWNoZSA9IHt9O1xuXG5cblx0XHRcdHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXG5cdFx0XHQvLyBUaGUgb25seSB3YXkgdG8gbWFrZSBJRTYgYW5kIElFNyBwcmludCBpcyB0byB1c2UgYSBnbG9iYWwgbmFtZXNwYWNlLiBIb3dldmVyLFxuXHRcdFx0Ly8gd2l0aCBJRTggdGhlIG9ubHkgd2F5IHRvIG1ha2UgdGhlIGR5bmFtaWMgc2hhcGVzIHZpc2libGUgaW4gc2NyZWVuIGFuZCBwcmludCBtb2RlXG5cdFx0XHQvLyBzZWVtcyB0byBiZSB0byBhZGQgdGhlIHhtbG5zIGF0dHJpYnV0ZSBhbmQgdGhlIGJlaGF2aW91ciBzdHlsZSBpbmxpbmUuXG5cdFx0XHRpZiAoIWRvYy5uYW1lc3BhY2VzLmhjdikge1xuXG5cdFx0XHRcdGRvYy5uYW1lc3BhY2VzLmFkZCgnaGN2JywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cblx0XHRcdFx0Ly8gU2V0dXAgZGVmYXVsdCBDU1MgKCMyMTUzLCAjMjM2OCwgIzIzODQpXG5cdFx0XHRcdGNzcyA9ICdoY3ZcXFxcOmZpbGwsIGhjdlxcXFw6cGF0aCwgaGN2XFxcXDpzaGFwZSwgaGN2XFxcXDpzdHJva2UnICtcblx0XHRcdFx0XHQneyBiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9ICc7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5jc3NUZXh0ID0gY3NzO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0ZG9jLnN0eWxlU2hlZXRzWzBdLmNzc1RleHQgKz0gY3NzO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBEZXRlY3Qgd2hldGhlciB0aGUgcmVuZGVyZXIgaXMgaGlkZGVuLiBUaGlzIGhhcHBlbnMgd2hlbiBvbmUgb2YgdGhlIHBhcmVudCBlbGVtZW50c1xuXHRcdCAqIGhhcyBkaXNwbGF5OiBub25lXG5cdFx0ICovXG5cdFx0aXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAhdGhpcy5ib3gub2Zmc2V0V2lkdGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSBhIGNsaXBwaW5nIHJlY3RhbmdsZS4gSW4gVk1MIGl0IGlzIGFjY29tcGxpc2hlZCBieSBzdG9yaW5nIHRoZSB2YWx1ZXNcblx0XHQgKiBmb3Igc2V0dGluZyB0aGUgQ1NTIHN0eWxlIHRvIGFsbCBhc3NvY2lhdGVkIG1lbWJlcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGNsaXBSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBkdW1teSBlbGVtZW50XG5cdFx0XHR2YXIgY2xpcFJlY3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKSxcblx0XHRcdFx0aXNPYmogPSBpc09iamVjdCh4KTtcblxuXHRcdFx0Ly8gbWltaWMgYSByZWN0YW5nbGUgd2l0aCBpdHMgc3R5bGUgb2JqZWN0IGZvciBhdXRvbWF0aWMgdXBkYXRpbmcgaW4gYXR0clxuXHRcdFx0cmV0dXJuIGV4dGVuZChjbGlwUmVjdCwge1xuXHRcdFx0XHRtZW1iZXJzOiBbXSxcblx0XHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRcdGxlZnQ6IChpc09iaiA/IHgueCA6IHgpICsgMSxcblx0XHRcdFx0dG9wOiAoaXNPYmogPyB4LnkgOiB5KSArIDEsXG5cdFx0XHRcdHdpZHRoOiAoaXNPYmogPyB4LndpZHRoIDogd2lkdGgpIC0gMSxcblx0XHRcdFx0aGVpZ2h0OiAoaXNPYmogPyB4LmhlaWdodCA6IGhlaWdodCkgLSAxLFxuXHRcdFx0XHRnZXRDU1M6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRpc1NoYXBlID0gbm9kZU5hbWUgPT09ICdzaGFwZScsXG5cdFx0XHRcdFx0XHRpbnZlcnRlZCA9IHdyYXBwZXIuaW52ZXJ0ZWQsXG5cdFx0XHRcdFx0XHRyZWN0ID0gdGhpcyxcblx0XHRcdFx0XHRcdHRvcCA9IHJlY3QudG9wIC0gKGlzU2hhcGUgPyBlbGVtZW50Lm9mZnNldFRvcCA6IDApLFxuXHRcdFx0XHRcdFx0bGVmdCA9IHJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gbGVmdCArIHJlY3Qud2lkdGgsXG5cdFx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyByZWN0LmhlaWdodCxcblx0XHRcdFx0XHRcdHJldCA9IHtcblx0XHRcdFx0XHRcdFx0Y2xpcDogJ3JlY3QoJyArXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gbGVmdCA6IHRvcCkgKyAncHgsJyArXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gYm90dG9tIDogcmlnaHQpICsgJ3B4LCcgK1xuXHRcdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IHJpZ2h0IDogYm90dG9tKSArICdweCwnICtcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyB0b3AgOiBsZWZ0KSArICdweCknXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gaXNzdWUgNzQgd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGlmICghaW52ZXJ0ZWQgJiYgZG9jTW9kZTggJiYgbm9kZU5hbWUgPT09ICdESVYnKSB7XG5cdFx0XHRcdFx0XHRleHRlbmQocmV0LCB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiByaWdodCArIFBYLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGJvdHRvbSArIFBYXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyB1c2VkIGluIGF0dHIgYW5kIGFuaW1hdGlvbiB0byB1cGRhdGUgdGhlIGNsaXBwaW5nIG9mIGFsbCBtZW1iZXJzXG5cdFx0XHRcdHVwZGF0ZUNsaXBwaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZWFjaChjbGlwUmVjdC5tZW1iZXJzLCBmdW5jdGlvbiAobWVtYmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobWVtYmVyLmVsZW1lbnQpIHsgLy8gRGVsZXRlZCBzZXJpZXMsIGxpa2UgaW4gc3RvY2svbWVtYmVycy9zZXJpZXMtcmVtb3ZlIGRlbW8uIFNob3VsZCBiZSByZW1vdmVkIGZyb20gbWVtYmVycywgYnV0IHRoaXMgd2lsbCBkby5cblx0XHRcdFx0XHRcdFx0bWVtYmVyLmNzcyhjbGlwUmVjdC5nZXRDU1MobWVtYmVyKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVGFrZSBhIGNvbG9yIGFuZCByZXR1cm4gaXQgaWYgaXQncyBhIHN0cmluZywgbWFrZSBpdCBhIGdyYWRpZW50IGlmIGl0J3MgYVxuXHRcdCAqIGdyYWRpZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgYXBwbHkgb3BhY2l0eS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvciBUaGUgY29sb3Igb3IgY29uZmlnIG9iamVjdFxuXHRcdCAqL1xuXHRcdGNvbG9yOiBmdW5jdGlvbiAoY29sb3IsIGVsZW0sIHByb3AsIHdyYXBwZXIpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGNvbG9yT2JqZWN0LFxuXHRcdFx0XHRyZWdleFJnYmEgPSAvXnJnYmEvLFxuXHRcdFx0XHRtYXJrdXAsXG5cdFx0XHRcdGZpbGxUeXBlLFxuXHRcdFx0XHRyZXQgPSBOT05FO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgbGluZWFyIG9yIHJhZGlhbCBncmFkaWVudFxuXHRcdFx0aWYgKGNvbG9yICYmIGNvbG9yLmxpbmVhckdyYWRpZW50KSB7XG5cdFx0XHRcdGZpbGxUeXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdH0gZWxzZSBpZiAoY29sb3IgJiYgY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdFx0ZmlsbFR5cGUgPSAncGF0dGVybic7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKGZpbGxUeXBlKSB7XG5cblx0XHRcdFx0dmFyIHN0b3BDb2xvcixcblx0XHRcdFx0XHRzdG9wT3BhY2l0eSxcblx0XHRcdFx0XHRncmFkaWVudCA9IGNvbG9yLmxpbmVhckdyYWRpZW50IHx8IGNvbG9yLnJhZGlhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHgxLFxuXHRcdFx0XHRcdHkxLFxuXHRcdFx0XHRcdHgyLFxuXHRcdFx0XHRcdHkyLFxuXHRcdFx0XHRcdG9wYWNpdHkxLFxuXHRcdFx0XHRcdG9wYWNpdHkyLFxuXHRcdFx0XHRcdGNvbG9yMSxcblx0XHRcdFx0XHRjb2xvcjIsXG5cdFx0XHRcdFx0ZmlsbEF0dHIgPSAnJyxcblx0XHRcdFx0XHRzdG9wcyA9IGNvbG9yLnN0b3BzLFxuXHRcdFx0XHRcdGZpcnN0U3RvcCxcblx0XHRcdFx0XHRsYXN0U3RvcCxcblx0XHRcdFx0XHRjb2xvcnMgPSBbXSxcblx0XHRcdFx0XHRhZGRGaWxsTm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIEFkZCB0aGUgZmlsbCBzdWJub2RlLiBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcblx0XHRcdFx0XHRcdC8vIGFyZSByZXZlcnNlZC5cblx0XHRcdFx0XHRcdG1hcmt1cCA9IFsnPGZpbGwgY29sb3JzPVwiJyArIGNvbG9ycy5qb2luKCcsJykgKyAnXCIgb3BhY2l0eT1cIicsIG9wYWNpdHkyLCAnXCIgbzpvcGFjaXR5Mj1cIicsIG9wYWNpdHkxLFxuXHRcdFx0XHRcdFx0XHQnXCIgdHlwZT1cIicsIGZpbGxUeXBlLCAnXCIgJywgZmlsbEF0dHIsICdmb2N1cz1cIjEwMCVcIiBtZXRob2Q9XCJhbnlcIiAvPiddO1xuXHRcdFx0XHRcdFx0Y3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksIG51bGwsIG51bGwsIGVsZW0pO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gRXh0ZW5kIGZyb20gMCB0byAxXG5cdFx0XHRcdGZpcnN0U3RvcCA9IHN0b3BzWzBdO1xuXHRcdFx0XHRsYXN0U3RvcCA9IHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAoZmlyc3RTdG9wWzBdID4gMCkge1xuXHRcdFx0XHRcdHN0b3BzLnVuc2hpZnQoW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdGZpcnN0U3RvcFsxXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsYXN0U3RvcFswXSA8IDEpIHtcblx0XHRcdFx0XHRzdG9wcy5wdXNoKFtcblx0XHRcdFx0XHRcdDEsXG5cdFx0XHRcdFx0XHRsYXN0U3RvcFsxXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29tcHV0ZSB0aGUgc3RvcHNcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3AsIGkpIHtcblx0XHRcdFx0XHRpZiAocmVnZXhSZ2JhLnRlc3Qoc3RvcFsxXSkpIHtcblx0XHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcFsxXTtcblx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBCdWlsZCB0aGUgY29sb3IgYXR0cmlidXRlXG5cdFx0XHRcdFx0Y29sb3JzLnB1c2goKHN0b3BbMF0gKiAxMDApICsgJyUgJyArIHN0b3BDb2xvcik7XG5cblx0XHRcdFx0XHQvLyBPbmx5IHN0YXJ0IGFuZCBlbmQgb3BhY2l0aWVzIGFyZSBhbGxvd2VkLCBzbyB3ZSB1c2UgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdFxuXHRcdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTEgPSBzdG9wT3BhY2l0eTtcblx0XHRcdFx0XHRcdGNvbG9yMiA9IHN0b3BDb2xvcjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTIgPSBzdG9wT3BhY2l0eTtcblx0XHRcdFx0XHRcdGNvbG9yMSA9IHN0b3BDb2xvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSBncmFkaWVudCB0byBmaWxscyBvbmx5LlxuXHRcdFx0XHRpZiAocHJvcCA9PT0gJ2ZpbGwnKSB7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbGluZWFyIGdyYWRpZW50IGFuZ2xlXG5cdFx0XHRcdFx0aWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHR4MSA9IGdyYWRpZW50LngxIHx8IGdyYWRpZW50WzBdIHx8IDA7XG5cdFx0XHRcdFx0XHR5MSA9IGdyYWRpZW50LnkxIHx8IGdyYWRpZW50WzFdIHx8IDA7XG5cdFx0XHRcdFx0XHR4MiA9IGdyYWRpZW50LngyIHx8IGdyYWRpZW50WzJdIHx8IDA7XG5cdFx0XHRcdFx0XHR5MiA9IGdyYWRpZW50LnkyIHx8IGdyYWRpZW50WzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRmaWxsQXR0ciA9ICdhbmdsZT1cIicgKyAoOTAgIC0gbWF0aC5hdGFuKFxuXHRcdFx0XHRcdFx0XHQoeTIgLSB5MSkgLyAvLyB5IHZlY3RvclxuXHRcdFx0XHRcdFx0XHQoeDIgLSB4MSkgLy8geCB2ZWN0b3Jcblx0XHRcdFx0XHRcdFx0KSAqIDE4MCAvIG1hdGhQSSkgKyAnXCInO1xuXG5cdFx0XHRcdFx0XHRhZGRGaWxsTm9kZSgpO1xuXG5cdFx0XHRcdFx0Ly8gUmFkaWFsIChjaXJjdWxhcikgZ3JhZGllbnRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgciA9IGdyYWRpZW50LnIsXG5cdFx0XHRcdFx0XHRcdHNpemV4ID0gciAqIDIsXG5cdFx0XHRcdFx0XHRcdHNpemV5ID0gciAqIDIsXG5cdFx0XHRcdFx0XHRcdGN4ID0gZ3JhZGllbnQuY3gsXG5cdFx0XHRcdFx0XHRcdGN5ID0gZ3JhZGllbnQuY3ksXG5cdFx0XHRcdFx0XHRcdHJhZGlhbFJlZmVyZW5jZSA9IGVsZW0ucmFkaWFsUmVmZXJlbmNlLFxuXHRcdFx0XHRcdFx0XHRiQm94LFxuXHRcdFx0XHRcdFx0XHRhcHBseVJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyYWRpYWxSZWZlcmVuY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJCb3ggPSB3cmFwcGVyLmdldEJCb3goKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN4ICs9IChyYWRpYWxSZWZlcmVuY2VbMF0gLSBiQm94LngpIC8gYkJveC53aWR0aCAtIDAuNTtcblx0XHRcdFx0XHRcdFx0XHRcdGN5ICs9IChyYWRpYWxSZWZlcmVuY2VbMV0gLSBiQm94LnkpIC8gYkJveC5oZWlnaHQgLSAwLjU7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaXpleCAqPSByYWRpYWxSZWZlcmVuY2VbMl0gLyBiQm94LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdFx0c2l6ZXkgKj0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gYkJveC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGZpbGxBdHRyID0gJ3NyYz1cIicgKyBkZWZhdWx0T3B0aW9ucy5nbG9iYWwuVk1MUmFkaWFsR3JhZGllbnRVUkwgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnc2l6ZT1cIicgKyBzaXpleCArICcsJyArIHNpemV5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J29yaWdpbj1cIjAuNSwwLjVcIiAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCdwb3NpdGlvbj1cIicgKyBjeCArICcsJyArIGN5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J2NvbG9yMj1cIicgKyBjb2xvcjIgKyAnXCIgJztcblxuXHRcdFx0XHRcdFx0XHRcdGFkZEZpbGxOb2RlKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIEFwcGx5IHJhZGlhbCBncmFkaWVudFxuXHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIuYWRkZWQpIHtcblx0XHRcdFx0XHRcdFx0YXBwbHlSYWRpYWxHcmFkaWVudCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBrbm93IHRoZSBib3VuZGluZyBib3ggdG8gZ2V0IHRoZSBzaXplIGFuZCBwb3NpdGlvbiByaWdodFxuXHRcdFx0XHRcdFx0XHR3cmFwcGVyLm9uQWRkID0gYXBwbHlSYWRpYWxHcmFkaWVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVGhlIGZpbGwgZWxlbWVudCdzIGNvbG9yIGF0dHJpYnV0ZSBpcyBicm9rZW4gaW4gSUU4IHN0YW5kYXJkcyBtb2RlLCBzbyB3ZVxuXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBzZXQgdGhlIHBhcmVudCBzaGFwZSdzIGZpbGxjb2xvciBhdHRyaWJ1dGUgaW5zdGVhZC5cblx0XHRcdFx0XHRcdHJldCA9IGNvbG9yMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR3JhZGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBWTUwgc3Ryb2tlLCByZXR1cm4gdGhlIGZpcnN0IGNvbG9yLiAjNzIyLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IHN0b3BDb2xvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgY29sb3IgaXMgYW4gcmdiYSBjb2xvciwgc3BsaXQgaXQgYW5kIGFkZCBhIGZpbGwgbm9kZVxuXHRcdFx0Ly8gdG8gaG9sZCB0aGUgb3BhY2l0eSBjb21wb25lbnRcblx0XHRcdH0gZWxzZSBpZiAocmVnZXhSZ2JhLnRlc3QoY29sb3IpICYmIGVsZW0udGFnTmFtZSAhPT0gJ0lNRycpIHtcblxuXHRcdFx0XHRjb2xvck9iamVjdCA9IENvbG9yKGNvbG9yKTtcblxuXHRcdFx0XHRtYXJrdXAgPSBbJzwnLCBwcm9wLCAnIG9wYWNpdHk9XCInLCBjb2xvck9iamVjdC5nZXQoJ2EnKSwgJ1wiLz4nXTtcblx0XHRcdFx0Y3JlYXRlRWxlbWVudCh0aGlzLnByZXBWTUwobWFya3VwKSwgbnVsbCwgbnVsbCwgZWxlbSk7XG5cblx0XHRcdFx0cmV0ID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcHJvcE5vZGVzID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShwcm9wKTsgLy8gJ3N0cm9rZScgb3IgJ2ZpbGwnIG5vZGVcblx0XHRcdFx0aWYgKHByb3BOb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRwcm9wTm9kZXNbMF0ub3BhY2l0eSA9IDE7XG5cdFx0XHRcdFx0cHJvcE5vZGVzWzBdLnR5cGUgPSAnc29saWQnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldCA9IGNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUYWtlIGEgVk1MIHN0cmluZyBhbmQgcHJlcGFyZSBpdCBmb3IgZWl0aGVyIElFOCBvciBJRTYvSUU3LlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IG1hcmt1cCBBIHN0cmluZyBhcnJheSBvZiB0aGUgVk1MIG1hcmt1cCB0byBwcmVwYXJlXG5cdFx0ICovXG5cdFx0cHJlcFZNTDogZnVuY3Rpb24gKG1hcmt1cCkge1xuXHRcdFx0dmFyIHZtbFN0eWxlID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOycsXG5cdFx0XHRcdGlzSUU4ID0gdGhpcy5pc0lFODtcblxuXHRcdFx0bWFya3VwID0gbWFya3VwLmpvaW4oJycpO1xuXG5cdFx0XHRpZiAoaXNJRTgpIHsgLy8gYWRkIHhtbG5zIGFuZCBzdHlsZSBpbmxpbmVcblx0XHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJy8+JywgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIgLz4nKTtcblx0XHRcdFx0aWYgKG1hcmt1cC5pbmRleE9mKCdzdHlsZT1cIicpID09PSAtMSkge1xuXHRcdFx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCcvPicsICcgc3R5bGU9XCInICsgdm1sU3R5bGUgKyAnXCIgLz4nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnc3R5bGU9XCInLCAnc3R5bGU9XCInICsgdm1sU3R5bGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7IC8vIGFkZCBuYW1lc3BhY2Vcblx0XHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJzwnLCAnPGhjdjonKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hcmt1cDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHJvdGF0ZWQgYW5kIGFsaWduZWQgdGV4dFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICovXG5cdFx0dGV4dDogU1ZHUmVuZGVyZXIucHJvdG90eXBlLmh0bWwsXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYW5kIHJldHVybiBhIHBhdGggZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcblx0XHQgKi9cblx0XHRwYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0dmFyIGF0dHIgPSB7XG5cdFx0XHRcdC8vIHN1YnBpeGVsIHByZWNpc2lvbiBkb3duIHRvIDAuMSAod2lkdGggYW5kIGhlaWdodCA9IDFweClcblx0XHRcdFx0Y29vcmRzaXplOiAnMTAgMTAnXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzQXJyYXkocGF0aCkpIHtcblx0XHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0XHRleHRlbmQoYXR0ciwgcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdGhlIHNoYXBlXG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdzaGFwZScpLmF0dHIoYXR0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgY2lyY2xlIGVsZW1lbnQuIEluIFZNTCBjaXJjbGVzIGFyZSBpbXBsZW1lbnRlZCBhc1xuXHRcdCAqIHNoYXBlcywgd2hpY2ggaXMgZmFzdGVyIHRoYW4gdjpvdmFsXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSByXG5cdFx0ICovXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcikge1xuXHRcdFx0dmFyIGNpcmNsZSA9IHRoaXMuc3ltYm9sKCdjaXJjbGUnKTtcblx0XHRcdGlmIChpc09iamVjdCh4KSkge1xuXHRcdFx0XHRyID0geC5yO1xuXHRcdFx0XHR5ID0geC55O1xuXHRcdFx0XHR4ID0geC54O1xuXHRcdFx0fVxuXHRcdFx0Y2lyY2xlLmlzQ2lyY2xlID0gdHJ1ZTsgLy8gQ2F1c2VzIHggYW5kIHkgdG8gbWVhbiBjZW50ZXIgKCMxNjgyKVxuXHRcdFx0Y2lyY2xlLnIgPSByO1xuXHRcdFx0cmV0dXJuIGNpcmNsZS5hdHRyKHsgeDogeCwgeTogeSB9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgZ3JvdXAgdXNpbmcgYW4gb3V0ZXIgZGl2IGFuZCBhbiBpbm5lciB2Omdyb3VwIHRvIGFsbG93IHJvdGF0aW5nXG5cdFx0ICogYW5kIGZsaXBwaW5nLiBBIHNpbXBsZSB2Omdyb3VwIHdvdWxkIGhhdmUgcHJvYmxlbXMgd2l0aCBwb3NpdGlvbmluZ1xuXHRcdCAqIGNoaWxkIEhUTUwgZWxlbWVudHMgYW5kIENTUyBjbGlwLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGdyb3VwXG5cdFx0ICovXG5cdFx0ZzogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyLFxuXHRcdFx0XHRhdHRyaWJzO1xuXG5cdFx0XHQvLyBzZXQgdGhlIGNsYXNzIG5hbWVcblx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdGF0dHJpYnMgPSB7ICdjbGFzc05hbWUnOiBQUkVGSVggKyBuYW1lLCAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZSBkaXYgdG8gaG9sZCBIVE1MIGFuZCBjbGlwcGluZ1xuXHRcdFx0d3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudChESVYpLmF0dHIoYXR0cmlicyk7XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgb3ZlcnJpZGUgdG8gY3JlYXRlIGEgcmVndWxhciBIVE1MIGltYWdlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0aW1hZ2U6IGZ1bmN0aW9uIChzcmMsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdHZhciBvYmogPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG5cdFx0XHRcdC5hdHRyKHsgc3JjOiBzcmMgfSk7XG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRvYmouYXR0cih7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvciByZWN0YW5nbGVzLCBWTUwgdXNlcyBhIHNoYXBlIGZvciByZWN0IHRvIG92ZXJjb21lIGJ1Z3MgYW5kIHJvdGF0aW9uIHByb2JsZW1zXG5cdFx0ICovXG5cdFx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUgPT09ICdyZWN0JyA/IHRoaXMuc3ltYm9sKG5vZGVOYW1lKSA6IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbm9kZU5hbWUpO1x0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluIHRoZSBWTUwgcmVuZGVyZXIsIGVhY2ggY2hpbGQgb2YgYW4gaW52ZXJ0ZWQgZGl2IChncm91cCkgaXMgaW52ZXJ0ZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnROb2RlXG5cdFx0ICovXG5cdFx0aW52ZXJ0Q2hpbGQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnROb2RlKSB7XG5cdFx0XHR2YXIgcmVuID0gdGhpcyxcblx0XHRcdFx0cGFyZW50U3R5bGUgPSBwYXJlbnROb2RlLnN0eWxlLFxuXHRcdFx0XHRpbWdTdHlsZSA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lNRycgJiYgZWxlbWVudC5zdHlsZTsgLy8gIzExMTFcblxuXHRcdFx0Y3NzKGVsZW1lbnQsIHtcblx0XHRcdFx0ZmxpcDogJ3gnLFxuXHRcdFx0XHRsZWZ0OiBwSW50KHBhcmVudFN0eWxlLndpZHRoKSAtIChpbWdTdHlsZSA/IHBJbnQoaW1nU3R5bGUudG9wKSA6IDEpLFxuXHRcdFx0XHR0b3A6IHBJbnQocGFyZW50U3R5bGUuaGVpZ2h0KSAtIChpbWdTdHlsZSA/IHBJbnQoaW1nU3R5bGUubGVmdCkgOiAxKSxcblx0XHRcdFx0cm90YXRpb246IC05MFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFJlY3Vyc2l2ZWx5IGludmVydCBjaGlsZCBlbGVtZW50cywgbmVlZGVkIGZvciBuZXN0ZWQgY29tcG9zaXRlIHNoYXBlcyBsaWtlIGJveCBwbG90cyBhbmQgZXJyb3IgYmFycy4gIzE2ODAsICMxODA2LlxuXHRcdFx0ZWFjaChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRyZW4uaW52ZXJ0Q2hpbGQoY2hpbGQsIGVsZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFN5bWJvbCBkZWZpbml0aW9ucyB0aGF0IG92ZXJyaWRlIHRoZSBwYXJlbnQgU1ZHIHJlbmRlcmVyJ3Mgc3ltYm9sc1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0c3ltYm9sczoge1xuXHRcdFx0Ly8gVk1MIHNwZWNpZmljIGFyYyBmdW5jdGlvblxuXHRcdFx0YXJjOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRcdGVuZCA9IG9wdGlvbnMuZW5kLFxuXHRcdFx0XHRcdHJhZGl1cyA9IG9wdGlvbnMuciB8fCB3IHx8IGgsXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMgPSBvcHRpb25zLmlubmVyUixcblx0XHRcdFx0XHRjb3NTdGFydCA9IG1hdGhDb3Moc3RhcnQpLFxuXHRcdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdFx0Y29zRW5kID0gbWF0aENvcyhlbmQpLFxuXHRcdFx0XHRcdHNpbkVuZCA9IG1hdGhTaW4oZW5kKSxcblx0XHRcdFx0XHRyZXQ7XG5cblx0XHRcdFx0aWYgKGVuZCAtIHN0YXJ0ID09PSAwKSB7IC8vIG5vIGFuZ2xlLCBkb24ndCBzaG93IGl0LlxuXHRcdFx0XHRcdHJldHVybiBbJ3gnXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IFtcblx0XHRcdFx0XHQnd2EnLCAvLyBjbG9ja3dpc2UgYXJjIHRvXG5cdFx0XHRcdFx0eCAtIHJhZGl1cywgLy8gbGVmdFxuXHRcdFx0XHRcdHkgLSByYWRpdXMsIC8vIHRvcFxuXHRcdFx0XHRcdHggKyByYWRpdXMsIC8vIHJpZ2h0XG5cdFx0XHRcdFx0eSArIHJhZGl1cywgLy8gYm90dG9tXG5cdFx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc1N0YXJ0LCAvLyBzdGFydCB4XG5cdFx0XHRcdFx0eSArIHJhZGl1cyAqIHNpblN0YXJ0LCAvLyBzdGFydCB5XG5cdFx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc0VuZCwgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgcmFkaXVzICogc2luRW5kICAvLyBlbmQgeVxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLm9wZW4gJiYgIWlubmVyUmFkaXVzKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goXG5cdFx0XHRcdFx0XHQnZScsXG5cdFx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdFx0eCwvLyAtIGlubmVyUmFkaXVzLFxuXHRcdFx0XHRcdFx0eS8vIC0gaW5uZXJSYWRpdXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0LnB1c2goXG5cdFx0XHRcdFx0J2F0JywgLy8gYW50aSBjbG9ja3dpc2UgYXJjIHRvXG5cdFx0XHRcdFx0eCAtIGlubmVyUmFkaXVzLCAvLyBsZWZ0XG5cdFx0XHRcdFx0eSAtIGlubmVyUmFkaXVzLCAvLyB0b3Bcblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMsIC8vIHJpZ2h0XG5cdFx0XHRcdFx0eSArIGlubmVyUmFkaXVzLCAvLyBib3R0b21cblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NFbmQsIC8vIHN0YXJ0IHhcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsIC8vIHN0YXJ0IHlcblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NTdGFydCwgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5TdGFydCwgLy8gZW5kIHlcblx0XHRcdFx0XHQneCcsIC8vIGZpbmlzaCBwYXRoXG5cdFx0XHRcdFx0J2UnIC8vIGNsb3NlXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0LmlzQXJjID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSxcblx0XHRcdC8vIEFkZCBjaXJjbGUgc3ltYm9sIHBhdGguIFRoaXMgcGVyZm9ybXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB2Om92YWwuXG5cdFx0XHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCB3cmFwcGVyKSB7XG5cblx0XHRcdFx0aWYgKHdyYXBwZXIpIHtcblx0XHRcdFx0XHR3ID0gaCA9IDIgKiB3cmFwcGVyLnI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDZW50ZXIgY29ycmVjdGlvbiwgIzE2ODJcblx0XHRcdFx0aWYgKHdyYXBwZXIgJiYgd3JhcHBlci5pc0NpcmNsZSkge1xuXHRcdFx0XHRcdHggLT0gdyAvIDI7XG5cdFx0XHRcdFx0eSAtPSBoIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiB0aGUgcGF0aFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdCd3YScsIC8vIGNsb2Nrd2lzZWFyY3RvXG5cdFx0XHRcdFx0eCwgLy8gbGVmdFxuXHRcdFx0XHRcdHksIC8vIHRvcFxuXHRcdFx0XHRcdHggKyB3LCAvLyByaWdodFxuXHRcdFx0XHRcdHkgKyBoLCAvLyBib3R0b21cblx0XHRcdFx0XHR4ICsgdywgLy8gc3RhcnQgeFxuXHRcdFx0XHRcdHkgKyBoIC8gMiwgICAgIC8vIHN0YXJ0IHlcblx0XHRcdFx0XHR4ICsgdywgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgaCAvIDIsICAgICAvLyBlbmQgeVxuXHRcdFx0XHRcdC8vJ3gnLCAvLyBmaW5pc2ggcGF0aFxuXHRcdFx0XHRcdCdlJyAvLyBjbG9zZVxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIHJlY3RhbmdsZSBzeW1ib2wgcGF0aCB3aGljaCBlYXNlcyByb3RhdGlvbiBhbmQgb21pdHMgYXJjc2l6ZSBwcm9ibGVtc1xuXHRcdFx0ICogY29tcGFyZWQgdG8gdGhlIGJ1aWx0LWluIFZNTCByb3VuZHJlY3Qgc2hhcGUuIFdoZW4gYm9yZGVycyBhcmUgbm90IHJvdW5kZWQsXG5cdFx0XHQgKiB1c2UgdGhlIHNpbXBsZXIgc3F1YXJlIHBhdGgsIGVsc2UgdXNlIHRoZSBjYWxsb3V0IHBhdGggd2l0aG91dCB0aGUgYXJyb3cuXG5cdFx0XHQgKi9cblx0XHRcdHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHJldHVybiBTVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9sc1tcblx0XHRcdFx0XHQhZGVmaW5lZChvcHRpb25zKSB8fCAhb3B0aW9ucy5yID8gJ3NxdWFyZScgOiAnY2FsbG91dCdcblx0XHRcdFx0XS5jYWxsKDAsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0SGlnaGNoYXJ0cy5WTUxSZW5kZXJlciA9IFZNTFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXHRWTUxSZW5kZXJlci5wcm90b3R5cGUgPSBtZXJnZShTVkdSZW5kZXJlci5wcm90b3R5cGUsIFZNTFJlbmRlcmVyRXh0ZW5zaW9uKTtcblxuXHRcdC8vIGdlbmVyYWwgcmVuZGVyZXJcblx0XHRSZW5kZXJlciA9IFZNTFJlbmRlcmVyO1xuXHR9XG5cblx0Ly8gVGhpcyBtZXRob2QgaXMgdXNlZCB3aXRoIGV4cG9ydGluZyBpbiBvbGQgSUUsIHdoZW4gZW11bGF0aW5nIFNWRyAoc2VlICMyMzE0KVxuXHRTVkdSZW5kZXJlci5wcm90b3R5cGUubWVhc3VyZVNwYW5XaWR0aCA9IGZ1bmN0aW9uICh0ZXh0LCBzdHlsZXMpIHtcblx0XHR2YXIgbWVhc3VyaW5nU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG5cdFx0XHRvZmZzZXRXaWR0aCxcblx0XHR0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblxuXHRcdG1lYXN1cmluZ1NwYW4uYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuXHRcdGNzcyhtZWFzdXJpbmdTcGFuLCBzdHlsZXMpO1xuXHRcdHRoaXMuYm94LmFwcGVuZENoaWxkKG1lYXN1cmluZ1NwYW4pO1xuXHRcdG9mZnNldFdpZHRoID0gbWVhc3VyaW5nU3Bhbi5vZmZzZXRXaWR0aDtcblx0XHRkaXNjYXJkRWxlbWVudChtZWFzdXJpbmdTcGFuKTsgLy8gIzI0NjNcblx0XHRyZXR1cm4gb2Zmc2V0V2lkdGg7XG5cdH07XG5cblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogRU5EIE9GIElOVEVSTkVUIEVYUExPUkVSIDw9IDggU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqIFNUQVJUIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUuIFRISVMgQ0FOIEJFIFJFTU9WRUQgSUYgWU9VJ1JFIE5PVCAgICAgICpcblx0ICogVEFSR0VUSU5HIFRIQVQgU1lTVEVNLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0dmFyIENhblZHUmVuZGVyZXIsXG5cdFx0Q2FuVkdDb250cm9sbGVyO1xuXG5cdGlmICh1c2VDYW5WRykge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBDYW5WR1JlbmRlcmVyIGlzIGVtcHR5IGZyb20gc3RhcnQgdG8ga2VlcCB0aGUgc291cmNlIGZvb3RwcmludCBzbWFsbC5cblx0XHQgKiBXaGVuIHJlcXVlc3RlZCwgdGhlIENhblZHQ29udHJvbGxlciBkb3dubG9hZHMgdGhlIHJlc3Qgb2YgdGhlIHNvdXJjZSBwYWNrYWdlZFxuXHRcdCAqIHRvZ2V0aGVyIHdpdGggdGhlIGNhbnZnIGxpYnJhcnkuXG5cdFx0ICovXG5cdFx0SGlnaGNoYXJ0cy5DYW5WR1JlbmRlcmVyID0gQ2FuVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIE92ZXJyaWRlIHRoZSBnbG9iYWwgU1ZHIG5hbWVzcGFjZSB0byBmYWtlIFNWRy9IVE1MIHRoYXQgYWNjZXB0cyBDU1Ncblx0XHRcdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnQgd2l0aCBhbiBlbXB0eSBzeW1ib2xzIG9iamVjdC4gVGhpcyBpcyBuZWVkZWQgd2hlbiBleHBvcnRpbmcgaXMgdXNlZCAoZXhwb3J0aW5nLnNyYy5qcyB3aWxsIGFkZCBhIGZldyBzeW1ib2xzKSwgYnV0IFxuXHRcdCAqIHRoZSBpbXBsZW1lbnRhdGlvbiBmcm9tIFN2Z1JlbmRlcmVyIHdpbGwgbm90IGJlIG1lcmdlZCBpbiB1bnRpbCBmaXJzdCByZW5kZXIuXG5cdFx0ICovXG5cdFx0Q2FuVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9scyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBvbiBkZW1hbmQgZG93bmxvYWQgb2YgY2FudmcgcmVuZGVyaW5nIHN1cHBvcnQuXG5cdFx0ICovXG5cdFx0Q2FuVkdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIExpc3Qgb2YgcmVuZGVyZXJpbmcgY2FsbHNcblx0XHRcdHZhciBkZWZlcnJlZFJlbmRlckNhbGxzID0gW107XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiBkb3dubG9hZGVkLCB3ZSBhcmUgcmVhZHkgdG8gZHJhdyBkZWZlcnJlZCBjaGFydHMuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGRyYXdEZWZlcnJlZCgpIHtcblx0XHRcdFx0dmFyIGNhbGxMZW5ndGggPSBkZWZlcnJlZFJlbmRlckNhbGxzLmxlbmd0aCxcblx0XHRcdFx0XHRjYWxsSW5kZXg7XG5cblx0XHRcdFx0Ly8gRHJhdyBhbGwgcGVuZGluZyByZW5kZXIgY2FsbHNcblx0XHRcdFx0Zm9yIChjYWxsSW5kZXggPSAwOyBjYWxsSW5kZXggPCBjYWxsTGVuZ3RoOyBjYWxsSW5kZXgrKykge1xuXHRcdFx0XHRcdGRlZmVycmVkUmVuZGVyQ2FsbHNbY2FsbEluZGV4XSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENsZWFyIHRoZSBsaXN0XG5cdFx0XHRcdGRlZmVycmVkUmVuZGVyQ2FsbHMgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cHVzaDogZnVuY3Rpb24gKGZ1bmMsIHNjcmlwdExvY2F0aW9uKSB7XG5cdFx0XHRcdFx0Ly8gT25seSBnZXQgdGhlIHNjcmlwdCBvbmNlXG5cdFx0XHRcdFx0aWYgKGRlZmVycmVkUmVuZGVyQ2FsbHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRnZXRTY3JpcHQoc2NyaXB0TG9jYXRpb24sIGRyYXdEZWZlcnJlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlZ2lzdGVyIHJlbmRlciBjYWxsXG5cdFx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxscy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0oKSk7XG5cblx0XHRSZW5kZXJlciA9IENhblZHUmVuZGVyZXI7XG5cdH0gLy8gZW5kIENhblZHUmVuZGVyZXJcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogRU5EIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvKipcblx0ICogVGhlIFRpY2sgY2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIFRpY2soYXhpcywgcG9zLCB0eXBlLCBub0xhYmVsKSB7XG5cdFx0dGhpcy5heGlzID0gYXhpcztcblx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8ICcnO1xuXHRcdHRoaXMuaXNOZXcgPSB0cnVlO1xuXG5cdFx0aWYgKCF0eXBlICYmICFub0xhYmVsKSB7XG5cdFx0XHR0aGlzLmFkZExhYmVsKCk7XG5cdFx0fVxuXHR9XG5cblx0VGljay5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogV3JpdGUgdGhlIHRpY2sgbGFiZWxcblx0XHQgKi9cblx0XHRhZGRMYWJlbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0XHRheGlzID0gdGljay5heGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdGNhdGVnb3JpZXMgPSBheGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdG5hbWVzID0gYXhpcy5uYW1lcyxcblx0XHRcdFx0cG9zID0gdGljay5wb3MsXG5cdFx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRzdHIsXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRcdGlzRmlyc3QgPSBwb3MgPT09IHRpY2tQb3NpdGlvbnNbMF0sXG5cdFx0XHRcdGlzTGFzdCA9IHBvcyA9PT0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHR2YWx1ZSA9IGNhdGVnb3JpZXMgP1xuXHRcdFx0XHRcdHBpY2soY2F0ZWdvcmllc1twb3NdLCBuYW1lc1twb3NdLCBwb3MpIDpcblx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdFx0dGlja1Bvc2l0aW9uSW5mbyA9IHRpY2tQb3NpdGlvbnMuaW5mbyxcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdDtcblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRldGltZSBsYWJlbCBmb3JtYXQuIElmIGEgaGlnaGVyIHJhbmsgaXMgc2V0IGZvciB0aGlzIHBvc2l0aW9uLCB1c2UgdGhhdC4gSWYgbm90LFxuXHRcdFx0Ly8gdXNlIHRoZSBnZW5lcmFsIGZvcm1hdC5cblx0XHRcdGlmIChheGlzLmlzRGF0ZXRpbWVBeGlzICYmIHRpY2tQb3NpdGlvbkluZm8pIHtcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHNbdGlja1Bvc2l0aW9uSW5mby5oaWdoZXJSYW5rc1twb3NdIHx8IHRpY2tQb3NpdGlvbkluZm8udW5pdE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2V0IHByb3BlcnRpZXMgZm9yIGFjY2VzcyBpbiByZW5kZXIgbWV0aG9kXG5cdFx0XHR0aWNrLmlzRmlyc3QgPSBpc0ZpcnN0O1xuXHRcdFx0dGljay5pc0xhc3QgPSBpc0xhc3Q7XG5cblx0XHRcdC8vIGdldCB0aGUgc3RyaW5nXG5cdFx0XHRzdHIgPSBheGlzLmxhYmVsRm9ybWF0dGVyLmNhbGwoe1xuXHRcdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdGlzRmlyc3Q6IGlzRmlyc3QsXG5cdFx0XHRcdGlzTGFzdDogaXNMYXN0LFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0OiBkYXRlVGltZUxhYmVsRm9ybWF0LFxuXHRcdFx0XHR2YWx1ZTogYXhpcy5pc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKHZhbHVlKSkgOiB2YWx1ZVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHByZXBhcmUgQ1NTXG5cdFx0XHQvL2NzcyA9IHdpZHRoICYmIHsgd2lkdGg6IG1hdGhNYXgoMSwgbWF0aFJvdW5kKHdpZHRoIC0gMiAqIChsYWJlbE9wdGlvbnMucGFkZGluZyB8fCAxMCkpKSArIFBYIH07XG5cdFx0XHRcblx0XHRcdC8vIGZpcnN0IGNhbGxcblx0XHRcdGlmICghZGVmaW5lZChsYWJlbCkpIHtcblxuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWwgPVxuXHRcdFx0XHRcdGRlZmluZWQoc3RyKSAmJiBsYWJlbE9wdGlvbnMuZW5hYmxlZCA/XG5cdFx0XHRcdFx0XHRjaGFydC5yZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0XHRcdHN0cixcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxPcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQvLy5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHRcdC8vIHdpdGhvdXQgcG9zaXRpb24gYWJzb2x1dGUsIElFIGV4cG9ydCBzb21ldGltZXMgaXMgd3Jvbmdcblx0XHRcdFx0XHRcdFx0LmNzcyhtZXJnZShsYWJlbE9wdGlvbnMuc3R5bGUpKVxuXHRcdFx0XHRcdFx0XHQuYWRkKGF4aXMubGFiZWxHcm91cCkgOlxuXHRcdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0dGljay5sYWJlbExlbmd0aCA9IGxhYmVsICYmIGxhYmVsLmdldEJCb3goKS53aWR0aDsgLy8gVW4tcm90YXRlZCBsZW5ndGhcblx0XHRcdFx0dGljay5yb3RhdGlvbiA9IDA7IC8vIEJhc2UgdmFsdWUgdG8gZGV0ZWN0IGNoYW5nZSBmb3IgbmV3IGNhbGxzIHRvIGdldEJCb3hcblxuXHRcdFx0Ly8gdXBkYXRlXG5cdFx0XHR9IGVsc2UgaWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLmF0dHIoeyB0ZXh0OiBzdHIgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgb2Zmc2V0IGhlaWdodCBvciB3aWR0aCBvZiB0aGUgbGFiZWxcblx0XHQgKi9cblx0XHRnZXRMYWJlbFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmxhYmVsID9cblx0XHRcdFx0dGhpcy5sYWJlbC5nZXRCQm94KClbdGhpcy5heGlzLmhvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnXSA6XG5cdFx0XHRcdDA7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSB0aGUgbGFiZWwgb3ZlcmZsb3cgYnkgYWRqdXN0aW5nIHRoZSBsYWJlbHMgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2UsIG9yXG5cdFx0ICogaGlkZSB0aGVtIGlmIHRoZXkgY29sbGlkZSBpbnRvIHRoZSBuZWlnaGJvdXIgbGFiZWwuXG5cdFx0ICovXG5cdFx0aGFuZGxlT3ZlcmZsb3c6IGZ1bmN0aW9uICh4eSkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdHB4UG9zID0geHkueCxcblx0XHRcdFx0Y2hhcnRXaWR0aCA9IGF4aXMuY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0c3BhY2luZyA9IGF4aXMuY2hhcnQuc3BhY2luZyxcblx0XHRcdFx0bGVmdEJvdW5kID0gcGljayhheGlzLmxhYmVsTGVmdCwgbWF0aE1pbihheGlzLnBvcywgc3BhY2luZ1szXSkpLFxuXHRcdFx0XHRyaWdodEJvdW5kID0gcGljayhheGlzLmxhYmVsUmlnaHQsIG1hdGhNYXgoYXhpcy5wb3MgKyBheGlzLmxlbiwgY2hhcnRXaWR0aCAtIHNwYWNpbmdbMV0pKSxcblx0XHRcdFx0bGFiZWwgPSB0aGlzLmxhYmVsLFxuXHRcdFx0XHRyb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG5cdFx0XHRcdGZhY3RvciA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bYXhpcy5sYWJlbEFsaWduXSxcblx0XHRcdFx0bGFiZWxXaWR0aCA9IGxhYmVsLmdldEJCb3goKS53aWR0aCxcblx0XHRcdFx0c2xvdFdpZHRoID0gYXhpcy5zbG90V2lkdGgsXG5cdFx0XHRcdHhDb3JyZWN0aW9uID0gZmFjdG9yLFxuXHRcdFx0XHRnb1JpZ2h0ID0gMSxcblx0XHRcdFx0bGVmdFBvcyxcblx0XHRcdFx0cmlnaHRQb3MsXG5cdFx0XHRcdHRleHRXaWR0aCxcblx0XHRcdFx0Y3NzID0ge307XG5cblx0XHRcdC8vIENoZWNrIGlmIHRoZSBsYWJlbCBvdmVyc2hvb3RzIHRoZSBjaGFydCBzcGFjaW5nIGJveC4gSWYgaXQgZG9lcywgbW92ZSBpdC5cblx0XHRcdC8vIElmIGl0IG5vdyBvdmVyc2hvb3RzIHRoZSBzbG90V2lkdGgsIGFkZCBlbGxpcHNpcy5cblx0XHRcdGlmICghcm90YXRpb24pIHtcblx0XHRcdFx0bGVmdFBvcyA9IHB4UG9zIC0gZmFjdG9yICogbGFiZWxXaWR0aDtcblx0XHRcdFx0cmlnaHRQb3MgPSBweFBvcyArICgxIC0gZmFjdG9yKSAqIGxhYmVsV2lkdGg7XG5cblx0XHRcdFx0aWYgKGxlZnRQb3MgPCBsZWZ0Qm91bmQpIHtcblx0XHRcdFx0XHRzbG90V2lkdGggPSB4eS54ICsgc2xvdFdpZHRoICogKDEgLSBmYWN0b3IpIC0gbGVmdEJvdW5kO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJpZ2h0UG9zID4gcmlnaHRCb3VuZCkge1xuXHRcdFx0XHRcdHNsb3RXaWR0aCA9IHJpZ2h0Qm91bmQgLSB4eS54ICsgc2xvdFdpZHRoICogZmFjdG9yO1xuXHRcdFx0XHRcdGdvUmlnaHQgPSAtMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNsb3RXaWR0aCA9IG1hdGhNaW4oYXhpcy5zbG90V2lkdGgsIHNsb3RXaWR0aCk7IC8vICM0MTc3XG5cdFx0XHRcdGlmIChzbG90V2lkdGggPCBheGlzLnNsb3RXaWR0aCAmJiBheGlzLmxhYmVsQWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdFx0eHkueCArPSBnb1JpZ2h0ICogKGF4aXMuc2xvdFdpZHRoIC0gc2xvdFdpZHRoIC0geENvcnJlY3Rpb24gKiAoYXhpcy5zbG90V2lkdGggLSBtYXRoTWluKGxhYmVsV2lkdGgsIHNsb3RXaWR0aCkpKTtcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSBsYWJlbCB3aWR0aCBleGNlZWRzIHRoZSBhdmFpbGFibGUgc3BhY2UsIHNldCBhIHRleHQgd2lkdGggdG8gYmUgXG5cdFx0XHRcdC8vIHBpY2tlZCB1cCBiZWxvdy4gQWxzbywgaWYgYSB3aWR0aCBoYXMgYmVlbiBzZXQgYmVmb3JlLCB3ZSBuZWVkIHRvIHNldCBhIG5ld1xuXHRcdFx0XHQvLyBvbmUgYmVjYXVzZSB0aGUgcmVwb3J0ZWQgbGFiZWxXaWR0aCB3aWxsIGJlIGxpbWl0ZWQgYnkgdGhlIGJveCAoIzM5MzgpLlxuXHRcdFx0XHRpZiAobGFiZWxXaWR0aCA+IHNsb3RXaWR0aCB8fCAoYXhpcy5hdXRvUm90YXRpb24gJiYgbGFiZWwuc3R5bGVzLndpZHRoKSkge1xuXHRcdFx0XHRcdHRleHRXaWR0aCA9IHNsb3RXaWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxsaXBzaXMgdG8gcHJldmVudCByb3RhdGVkIGxhYmVscyB0byBiZSBjbGlwcGVkIGFnYWluc3QgdGhlIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdFx0XHR9IGVsc2UgaWYgKHJvdGF0aW9uIDwgMCAmJiBweFBvcyAtIGZhY3RvciAqIGxhYmVsV2lkdGggPCBsZWZ0Qm91bmQpIHtcblx0XHRcdFx0dGV4dFdpZHRoID0gbWF0aFJvdW5kKHB4UG9zIC8gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpIC0gbGVmdEJvdW5kKTtcblx0XHRcdH0gZWxzZSBpZiAocm90YXRpb24gPiAwICYmIHB4UG9zICsgZmFjdG9yICogbGFiZWxXaWR0aCA+IHJpZ2h0Qm91bmQpIHtcblx0XHRcdFx0dGV4dFdpZHRoID0gbWF0aFJvdW5kKChjaGFydFdpZHRoIC0gcHhQb3MpIC8gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0XHRjc3Mud2lkdGggPSB0ZXh0V2lkdGg7XG5cdFx0XHRcdGlmICghYXhpcy5vcHRpb25zLmxhYmVscy5zdHlsZS50ZXh0T3ZlcmZsb3cpIHtcblx0XHRcdFx0XHRjc3MudGV4dE92ZXJmbG93ID0gJ2VsbGlwc2lzJztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYWJlbC5jc3MoY3NzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSB4IGFuZCB5IHBvc2l0aW9uIGZvciB0aWNrcyBhbmQgbGFiZWxzXG5cdFx0ICovXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChob3JpeiwgcG9zLCB0aWNrbWFya09mZnNldCwgb2xkKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRjSGVpZ2h0ID0gKG9sZCAmJiBjaGFydC5vbGRDaGFydEhlaWdodCkgfHwgY2hhcnQuY2hhcnRIZWlnaHQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6ID9cblx0XHRcdFx0XHRheGlzLnRyYW5zbGF0ZShwb3MgKyB0aWNrbWFya09mZnNldCwgbnVsbCwgbnVsbCwgb2xkKSArIGF4aXMudHJhbnNCIDpcblx0XHRcdFx0XHRheGlzLmxlZnQgKyBheGlzLm9mZnNldCArIChheGlzLm9wcG9zaXRlID8gKChvbGQgJiYgY2hhcnQub2xkQ2hhcnRXaWR0aCkgfHwgY2hhcnQuY2hhcnRXaWR0aCkgLSBheGlzLnJpZ2h0IC0gYXhpcy5sZWZ0IDogMCksXG5cblx0XHRcdFx0eTogaG9yaXogP1xuXHRcdFx0XHRcdGNIZWlnaHQgLSBheGlzLmJvdHRvbSArIGF4aXMub2Zmc2V0IC0gKGF4aXMub3Bwb3NpdGUgPyBheGlzLmhlaWdodCA6IDApIDpcblx0XHRcdFx0XHRjSGVpZ2h0IC0gYXhpcy50cmFuc2xhdGUocG9zICsgdGlja21hcmtPZmZzZXQsIG51bGwsIG51bGwsIG9sZCkgLSBheGlzLnRyYW5zQlxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHgsIHkgcG9zaXRpb24gb2YgdGhlIHRpY2sgbGFiZWxcblx0XHQgKi9cblx0XHRnZXRMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSwgbGFiZWwsIGhvcml6LCBsYWJlbE9wdGlvbnMsIHRpY2ttYXJrT2Zmc2V0LCBpbmRleCwgc3RlcCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdHRyYW5zQSA9IGF4aXMudHJhbnNBLFxuXHRcdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRcdHN0YWdnZXJMaW5lcyA9IGF4aXMuc3RhZ2dlckxpbmVzLFxuXHRcdFx0XHRyb3RDb3JyID0gYXhpcy50aWNrUm90Q29yciB8fCB7IHg6IDAsIHk6IDAgfSxcblx0XHRcdFx0eU9mZnNldCA9IHBpY2sobGFiZWxPcHRpb25zLnksIHJvdENvcnIueSArIChheGlzLnNpZGUgPT09IDIgPyA4IDogLShsYWJlbC5nZXRCQm94KCkuaGVpZ2h0IC8gMikpKSxcblx0XHRcdFx0bGluZTtcblxuXHRcdFx0eCA9IHggKyBsYWJlbE9wdGlvbnMueCArIHJvdENvcnIueCAtICh0aWNrbWFya09mZnNldCAmJiBob3JpeiA/XG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ICogdHJhbnNBICogKHJldmVyc2VkID8gLTEgOiAxKSA6IDApO1xuXHRcdFx0eSA9IHkgKyB5T2Zmc2V0IC0gKHRpY2ttYXJrT2Zmc2V0ICYmICFob3JpeiA/XG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ICogdHJhbnNBICogKHJldmVyc2VkID8gMSA6IC0xKSA6IDApO1xuXG5cdFx0XHQvLyBDb3JyZWN0IGZvciBzdGFnZ2VyZWQgbGFiZWxzXG5cdFx0XHRpZiAoc3RhZ2dlckxpbmVzKSB7XG5cdFx0XHRcdGxpbmUgPSAoaW5kZXggLyAoc3RlcCB8fCAxKSAlIHN0YWdnZXJMaW5lcyk7XG5cdFx0XHRcdHkgKz0gbGluZSAqIChheGlzLmxhYmVsT2Zmc2V0IC8gc3RhZ2dlckxpbmVzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogbWF0aFJvdW5kKHkpXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmRpYmxlIG1ldGhvZCB0byByZXR1cm4gdGhlIHBhdGggb2YgdGhlIG1hcmtlclxuXHRcdCAqL1xuXHRcdGdldE1hcmtQYXRoOiBmdW5jdGlvbiAoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoLCBob3JpeiwgcmVuZGVyZXIpIHtcblx0XHRcdHJldHVybiByZW5kZXJlci5jcmlzcExpbmUoW1xuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0eCxcblx0XHRcdFx0XHR5LFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0eCArIChob3JpeiA/IDAgOiAtdGlja0xlbmd0aCksXG5cdFx0XHRcdFx0eSArIChob3JpeiA/IHRpY2tMZW5ndGggOiAwKVxuXHRcdFx0XHRdLCB0aWNrV2lkdGgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQdXQgZXZlcnl0aGluZyBpbiBwbGFjZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9XG5cdFx0ICogQHBhcmFtIG9sZCB7Qm9vbGVhbn0gVXNlIG9sZCBjb29yZGluYXRlcyB0byBwcmVwYXJlIGFuIGFuaW1hdGlvbiBpbnRvIG5ldyBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKGluZGV4LCBvbGQsIG9wYWNpdHkpIHtcblx0XHRcdHZhciB0aWNrID0gdGhpcyxcblx0XHRcdFx0YXhpcyA9IHRpY2suYXhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdHR5cGUgPSB0aWNrLnR5cGUsXG5cdFx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdFx0cG9zID0gdGljay5wb3MsXG5cdFx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRncmlkTGluZSA9IHRpY2suZ3JpZExpbmUsXG5cdFx0XHRcdGdyaWRQcmVmaXggPSB0eXBlID8gdHlwZSArICdHcmlkJyA6ICdncmlkJyxcblx0XHRcdFx0dGlja1ByZWZpeCA9IHR5cGUgPyB0eXBlICsgJ1RpY2snIDogJ3RpY2snLFxuXHRcdFx0XHRncmlkTGluZVdpZHRoID0gb3B0aW9uc1tncmlkUHJlZml4ICsgJ0xpbmVXaWR0aCddLFxuXHRcdFx0XHRncmlkTGluZUNvbG9yID0gb3B0aW9uc1tncmlkUHJlZml4ICsgJ0xpbmVDb2xvciddLFxuXHRcdFx0XHRkYXNoU3R5bGUgPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZURhc2hTdHlsZSddLFxuXHRcdFx0XHR0aWNrTGVuZ3RoID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ0xlbmd0aCddLFxuXHRcdFx0XHR0aWNrV2lkdGggPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnV2lkdGgnXSB8fCAwLFxuXHRcdFx0XHR0aWNrQ29sb3IgPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnQ29sb3InXSxcblx0XHRcdFx0dGlja1Bvc2l0aW9uID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ1Bvc2l0aW9uJ10sXG5cdFx0XHRcdGdyaWRMaW5lUGF0aCxcblx0XHRcdFx0bWFyayA9IHRpY2subWFyayxcblx0XHRcdFx0bWFya1BhdGgsXG5cdFx0XHRcdHN0ZXAgPSAvKmF4aXMubGFiZWxTdGVwIHx8ICovbGFiZWxPcHRpb25zLnN0ZXAsXG5cdFx0XHRcdGF0dHJpYnMsXG5cdFx0XHRcdHNob3cgPSB0cnVlLFxuXHRcdFx0XHR0aWNrbWFya09mZnNldCA9IGF4aXMudGlja21hcmtPZmZzZXQsXG5cdFx0XHRcdHh5ID0gdGljay5nZXRQb3NpdGlvbihob3JpeiwgcG9zLCB0aWNrbWFya09mZnNldCwgb2xkKSxcblx0XHRcdFx0eCA9IHh5LngsXG5cdFx0XHRcdHkgPSB4eS55LFxuXHRcdFx0XHRyZXZlcnNlQ3Jpc3AgPSAoKGhvcml6ICYmIHggPT09IGF4aXMucG9zICsgYXhpcy5sZW4pIHx8ICghaG9yaXogJiYgeSA9PT0gYXhpcy5wb3MpKSA/IC0xIDogMTsgLy8gIzE0ODAsICMxNjg3XG5cblx0XHRcdG9wYWNpdHkgPSBwaWNrKG9wYWNpdHksIDEpO1xuXHRcdFx0dGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgZ3JpZCBsaW5lXG5cdFx0XHRpZiAoZ3JpZExpbmVXaWR0aCkge1xuXHRcdFx0XHRncmlkTGluZVBhdGggPSBheGlzLmdldFBsb3RMaW5lUGF0aChwb3MgKyB0aWNrbWFya09mZnNldCwgZ3JpZExpbmVXaWR0aCAqIHJldmVyc2VDcmlzcCwgb2xkLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoZ3JpZExpbmUgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0XHRzdHJva2U6IGdyaWRMaW5lQ29sb3IsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogZ3JpZExpbmVXaWR0aFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy56SW5kZXggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob2xkKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLm9wYWNpdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aWNrLmdyaWRMaW5lID0gZ3JpZExpbmUgPVxuXHRcdFx0XHRcdFx0Z3JpZExpbmVXaWR0aCA/XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnBhdGgoZ3JpZExpbmVQYXRoKVxuXHRcdFx0XHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZChheGlzLmdyaWRHcm91cCkgOlxuXHRcdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHBhcmFtZXRlciAnb2xkJyBpcyBzZXQsIHRoZSBjdXJyZW50IGNhbGwgd2lsbCBiZSBmb2xsb3dlZFxuXHRcdFx0XHQvLyBieSBhbm90aGVyIGNhbGwsIHRoZXJlZm9yZSBkbyBub3QgZG8gYW55IGFuaW1hdGlvbnMgdGhpcyB0aW1lXG5cdFx0XHRcdGlmICghb2xkICYmIGdyaWRMaW5lICYmIGdyaWRMaW5lUGF0aCkge1xuXHRcdFx0XHRcdGdyaWRMaW5lW3RpY2suaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHtcblx0XHRcdFx0XHRcdGQ6IGdyaWRMaW5lUGF0aCxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIHRpY2sgbWFya1xuXHRcdFx0aWYgKHRpY2tXaWR0aCAmJiB0aWNrTGVuZ3RoKSB7XG5cblx0XHRcdFx0Ly8gbmVnYXRlIHRoZSBsZW5ndGhcblx0XHRcdFx0aWYgKHRpY2tQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcblx0XHRcdFx0XHR0aWNrTGVuZ3RoID0gLXRpY2tMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGF4aXMub3Bwb3NpdGUpIHtcblx0XHRcdFx0XHR0aWNrTGVuZ3RoID0gLXRpY2tMZW5ndGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXJrUGF0aCA9IHRpY2suZ2V0TWFya1BhdGgoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoICogcmV2ZXJzZUNyaXNwLCBob3JpeiwgcmVuZGVyZXIpO1xuXHRcdFx0XHRpZiAobWFyaykgeyAvLyB1cGRhdGluZ1xuXHRcdFx0XHRcdG1hcmsuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHRkOiBtYXJrUGF0aCxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gZmlyc3QgdGltZVxuXHRcdFx0XHRcdHRpY2subWFyayA9IHJlbmRlcmVyLnBhdGgoXG5cdFx0XHRcdFx0XHRtYXJrUGF0aFxuXHRcdFx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6IHRpY2tDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB0aWNrV2lkdGgsXG5cdFx0XHRcdFx0XHRvcGFjaXR5OiBvcGFjaXR5XG5cdFx0XHRcdFx0fSkuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGUgbGFiZWwgaXMgY3JlYXRlZCBvbiBpbml0IC0gbm93IG1vdmUgaXQgaW50byBwbGFjZVxuXHRcdFx0aWYgKGxhYmVsICYmICFpc05hTih4KSkge1xuXHRcdFx0XHRsYWJlbC54eSA9IHh5ID0gdGljay5nZXRMYWJlbFBvc2l0aW9uKHgsIHksIGxhYmVsLCBob3JpeiwgbGFiZWxPcHRpb25zLCB0aWNrbWFya09mZnNldCwgaW5kZXgsIHN0ZXApO1xuXG5cdFx0XHRcdC8vIEFwcGx5IHNob3cgZmlyc3QgYW5kIHNob3cgbGFzdC4gSWYgdGhlIHRpY2sgaXMgYm90aCBmaXJzdCBhbmQgbGFzdCwgaXQgaXNcblx0XHRcdFx0Ly8gYSBzaW5nbGUgY2VudGVyZWQgdGljaywgaW4gd2hpY2ggY2FzZSB3ZSBzaG93IHRoZSBsYWJlbCBhbnl3YXkgKCMyMTAwKS5cblx0XHRcdFx0aWYgKCh0aWNrLmlzRmlyc3QgJiYgIXRpY2suaXNMYXN0ICYmICFwaWNrKG9wdGlvbnMuc2hvd0ZpcnN0TGFiZWwsIDEpKSB8fFxuXHRcdFx0XHRcdFx0KHRpY2suaXNMYXN0ICYmICF0aWNrLmlzRmlyc3QgJiYgIXBpY2sob3B0aW9ucy5zaG93TGFzdExhYmVsLCAxKSkpIHtcblx0XHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGxhYmVsIG92ZXJmbG93IGFuZCBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHlcblx0XHRcdFx0fSBlbHNlIGlmIChob3JpeiAmJiAhYXhpcy5pc1JhZGlhbCAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgIWxhYmVsT3B0aW9ucy5yb3RhdGlvbiAmJiAhb2xkICYmIG9wYWNpdHkgIT09IDApIHtcblx0XHRcdFx0XHR0aWNrLmhhbmRsZU92ZXJmbG93KHh5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IHN0ZXBcblx0XHRcdFx0aWYgKHN0ZXAgJiYgaW5kZXggJSBzdGVwKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdyB0aG9zZSBpbmRpY2VzIGRpdmlkYWJsZSBieSBzdGVwXG5cdFx0XHRcdFx0c2hvdyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBuZXcgcG9zaXRpb24sIGFuZCBzaG93IG9yIGhpZGVcblx0XHRcdFx0aWYgKHNob3cgJiYgIWlzTmFOKHh5LnkpKSB7XG5cdFx0XHRcdFx0eHkub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0XHRcdFx0bGFiZWxbdGljay5pc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10oeHkpO1xuXHRcdFx0XHRcdHRpY2suaXNOZXcgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKCd5JywgLTk5OTkpOyAvLyAjMTMzOFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3RydWN0b3IgZm9yIHRoZSB0aWNrIHByb3RvdHlwZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgb2JqZWN0IHdyYXBwZXIgZm9yIHBsb3QgbGluZXMgYW5kIHBsb3QgYmFuZHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdEhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQgPSBmdW5jdGlvbiAoYXhpcywgb3B0aW9ucykge1xuXHRcdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHRcdH1cblx0fTtcblxuXHRIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZSA9IHtcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIHBsb3QgbGluZSBvciBwbG90IGJhbmQuIElmIGl0IGlzIGFscmVhZHkgZXhpc3RpbmcsXG5cdFx0ICogbW92ZSBpdC5cblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwbG90TGluZSA9IHRoaXMsXG5cdFx0XHRcdGF4aXMgPSBwbG90TGluZS5heGlzLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdG9wdGlvbnMgPSBwbG90TGluZS5vcHRpb25zLFxuXHRcdFx0XHRvcHRpb25zTGFiZWwgPSBvcHRpb25zLmxhYmVsLFxuXHRcdFx0XHRsYWJlbCA9IHBsb3RMaW5lLmxhYmVsLFxuXHRcdFx0XHR3aWR0aCA9IG9wdGlvbnMud2lkdGgsXG5cdFx0XHRcdHRvID0gb3B0aW9ucy50byxcblx0XHRcdFx0ZnJvbSA9IG9wdGlvbnMuZnJvbSxcblx0XHRcdFx0aXNCYW5kID0gZGVmaW5lZChmcm9tKSAmJiBkZWZpbmVkKHRvKSxcblx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLnZhbHVlLFxuXHRcdFx0XHRkYXNoU3R5bGUgPSBvcHRpb25zLmRhc2hTdHlsZSxcblx0XHRcdFx0c3ZnRWxlbSA9IHBsb3RMaW5lLnN2Z0VsZW0sXG5cdFx0XHRcdHBhdGggPSBbXSxcblx0XHRcdFx0YWRkRXZlbnQsXG5cdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0eHMsXG5cdFx0XHRcdHlzLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRjb2xvciA9IG9wdGlvbnMuY29sb3IsXG5cdFx0XHRcdHpJbmRleCA9IG9wdGlvbnMuekluZGV4LFxuXHRcdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0YXR0cmlicyA9IHt9LFxuXHRcdFx0XHRyZW5kZXJlciA9IGF4aXMuY2hhcnQucmVuZGVyZXI7XG5cblx0XHRcdC8vIGxvZ2FyaXRobWljIGNvbnZlcnNpb25cblx0XHRcdGlmIChheGlzLmlzTG9nKSB7XG5cdFx0XHRcdGZyb20gPSBsb2cybGluKGZyb20pO1xuXHRcdFx0XHR0byA9IGxvZzJsaW4odG8pO1xuXHRcdFx0XHR2YWx1ZSA9IGxvZzJsaW4odmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwbG90IGxpbmVcblx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHRwYXRoID0gYXhpcy5nZXRQbG90TGluZVBhdGgodmFsdWUsIHdpZHRoKTtcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRzdHJva2U6IGNvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB3aWR0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaXNCYW5kKSB7IC8vIHBsb3QgYmFuZFxuXG5cdFx0XHRcdHBhdGggPSBheGlzLmdldFBsb3RCYW5kUGF0aChmcm9tLCB0bywgb3B0aW9ucyk7XG5cdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdGF0dHJpYnMuZmlsbCA9IGNvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcHRpb25zLmJvcmRlcldpZHRoKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5zdHJva2UgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS13aWR0aCddID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gekluZGV4XG5cdFx0XHRpZiAoZGVmaW5lZCh6SW5kZXgpKSB7XG5cdFx0XHRcdGF0dHJpYnMuekluZGV4ID0gekluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb21tb24gZm9yIGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0aWYgKHN2Z0VsZW0pIHtcblx0XHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0XHRzdmdFbGVtLmFuaW1hdGUoe1xuXHRcdFx0XHRcdFx0ZDogcGF0aFxuXHRcdFx0XHRcdH0sIG51bGwsIHN2Z0VsZW0ub25HZXRQYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdmdFbGVtLmhpZGUoKTtcblx0XHRcdFx0XHRzdmdFbGVtLm9uR2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHN2Z0VsZW0uc2hvdygpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0XHRwbG90TGluZS5sYWJlbCA9IGxhYmVsID0gbGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdHBsb3RMaW5lLnN2Z0VsZW0gPSBzdmdFbGVtID0gcmVuZGVyZXIucGF0aChwYXRoKVxuXHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZCgpO1xuXG5cdFx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRzdmdFbGVtLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRzW2V2ZW50VHlwZV0uYXBwbHkocGxvdExpbmUsIFtlXSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRcdFx0YWRkRXZlbnQoZXZlbnRUeXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlIHBsb3QgYmFuZC9saW5lIGxhYmVsXG5cdFx0XHRpZiAob3B0aW9uc0xhYmVsICYmIGRlZmluZWQob3B0aW9uc0xhYmVsLnRleHQpICYmIHBhdGggJiYgcGF0aC5sZW5ndGggJiYgYXhpcy53aWR0aCA+IDAgJiYgYXhpcy5oZWlnaHQgPiAwKSB7XG5cdFx0XHRcdC8vIGFwcGx5IGRlZmF1bHRzXG5cdFx0XHRcdG9wdGlvbnNMYWJlbCA9IG1lcmdlKHtcblx0XHRcdFx0XHRhbGlnbjogaG9yaXogJiYgaXNCYW5kICYmICdjZW50ZXInLFxuXHRcdFx0XHRcdHg6IGhvcml6ID8gIWlzQmFuZCAmJiA0IDogMTAsXG5cdFx0XHRcdFx0dmVydGljYWxBbGlnbiA6ICFob3JpeiAmJiBpc0JhbmQgJiYgJ21pZGRsZScsXG5cdFx0XHRcdFx0eTogaG9yaXogPyBpc0JhbmQgPyAxNiA6IDEwIDogaXNCYW5kID8gNiA6IC00LFxuXHRcdFx0XHRcdHJvdGF0aW9uOiBob3JpeiAmJiAhaXNCYW5kICYmIDkwXG5cdFx0XHRcdH0sIG9wdGlvbnNMYWJlbCk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBTVkcgZWxlbWVudFxuXHRcdFx0XHRpZiAoIWxhYmVsKSB7XG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdGFsaWduOiBvcHRpb25zTGFiZWwudGV4dEFsaWduIHx8IG9wdGlvbnNMYWJlbC5hbGlnbixcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBvcHRpb25zTGFiZWwucm90YXRpb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChkZWZpbmVkKHpJbmRleCkpIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMuekluZGV4ID0gekluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbG90TGluZS5sYWJlbCA9IGxhYmVsID0gcmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRcdFx0b3B0aW9uc0xhYmVsLnRleHQsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnNMYWJlbC51c2VIVE1MXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKVxuXHRcdFx0XHRcdFx0LmNzcyhvcHRpb25zTGFiZWwuc3R5bGUpXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBhbmQgYWxpZ24gdGhlIGxhYmVsXG5cdFx0XHRcdC8vICMzMDAwIGNoYW5nZWQgdG8gYmV0dGVyIGhhbmRsZSBjaG9pY2UgYmV0d2VlbiBwbG90YmFuZCBvciBwbG90bGluZVxuXHRcdFx0XHR4cyA9IFtwYXRoWzFdLCBwYXRoWzRdLCAoaXNCYW5kID8gcGF0aFs2XSA6IHBhdGhbMV0pXTtcblx0XHRcdFx0eXMgPSBbcGF0aFsyXSwgcGF0aFs1XSwgKGlzQmFuZCA/IHBhdGhbN10gOiBwYXRoWzJdKV07XG5cdFx0XHRcdHggPSBhcnJheU1pbih4cyk7XG5cdFx0XHRcdHkgPSBhcnJheU1pbih5cyk7XG5cblx0XHRcdFx0bGFiZWwuYWxpZ24ob3B0aW9uc0xhYmVsLCBmYWxzZSwge1xuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHR3aWR0aDogYXJyYXlNYXgoeHMpIC0geCxcblx0XHRcdFx0XHRoZWlnaHQ6IGFycmF5TWF4KHlzKSAtIHlcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGxhYmVsLnNob3coKTtcblxuXHRcdFx0fSBlbHNlIGlmIChsYWJlbCkgeyAvLyBtb3ZlIG91dCBvZiBzaWdodFxuXHRcdFx0XHRsYWJlbC5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoYWluYWJsZVxuXHRcdFx0cmV0dXJuIHBsb3RMaW5lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIHBsb3QgbGluZSBvciBiYW5kXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gcmVtb3ZlIGl0IGZyb20gdGhlIGxvb2t1cFxuXHRcdFx0ZXJhc2UodGhpcy5heGlzLnBsb3RMaW5lc0FuZEJhbmRzLCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0ZGVsZXRlIHRoaXMuYXhpcztcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogT2JqZWN0IHdpdGggbWVtYmVycyBmb3IgZXh0ZW5kaW5nIHRoZSBBeGlzIHByb3RvdHlwZVxuXHQgKi9cblxuXHRBeGlzUGxvdExpbmVPckJhbmRFeHRlbnNpb24gPSB7XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgdGhlIHBhdGggZm9yIGEgcGxvdCBiYW5kXG5cdFx0ICovIFxuXHRcdGdldFBsb3RCYW5kUGF0aDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG5cdFx0XHR2YXIgdG9QYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgodG8sIG51bGwsIG51bGwsIHRydWUpLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgoZnJvbSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG5cblx0XHRcdGlmIChwYXRoICYmIHRvUGF0aCAmJiBwYXRoLnRvU3RyaW5nKCkgIT09IHRvUGF0aC50b1N0cmluZygpKSB7IC8vICMzODM2XG5cdFx0XHRcdHBhdGgucHVzaChcblx0XHRcdFx0XHR0b1BhdGhbNF0sXG5cdFx0XHRcdFx0dG9QYXRoWzVdLFxuXHRcdFx0XHRcdHRvUGF0aFsxXSxcblx0XHRcdFx0XHR0b1BhdGhbMl1cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7IC8vIG91dHNpZGUgdGhlIGF4aXMgYXJlYVxuXHRcdFx0XHRwYXRoID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fSxcblxuXHRcdGFkZFBsb3RCYW5kOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUob3B0aW9ucywgJ3Bsb3RCYW5kcycpO1xuXHRcdH0sXG5cdFx0XG5cdFx0YWRkUGxvdExpbmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShvcHRpb25zLCAncGxvdExpbmVzJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHBsb3QgYmFuZCBvciBwbG90IGxpbmUgYWZ0ZXIgcmVuZGVyIHRpbWVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFRoZSBwbG90QmFuZCBvciBwbG90TGluZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqL1xuXHRcdGFkZFBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAob3B0aW9ucywgY29sbCkge1xuXHRcdFx0dmFyIG9iaiA9IG5ldyBIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kKHRoaXMsIG9wdGlvbnMpLnJlbmRlcigpLFxuXHRcdFx0XHR1c2VyT3B0aW9ucyA9IHRoaXMudXNlck9wdGlvbnM7XG5cblx0XHRcdGlmIChvYmopIHsgLy8gIzIxODlcblx0XHRcdFx0Ly8gQWRkIGl0IHRvIHRoZSB1c2VyIG9wdGlvbnMgZm9yIGV4cG9ydGluZyBhbmQgQXhpcy51cGRhdGVcblx0XHRcdFx0aWYgKGNvbGwpIHtcblx0XHRcdFx0XHR1c2VyT3B0aW9uc1tjb2xsXSA9IHVzZXJPcHRpb25zW2NvbGxdIHx8IFtdO1xuXHRcdFx0XHRcdHVzZXJPcHRpb25zW2NvbGxdLnB1c2gob3B0aW9ucyk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChvYmopOyBcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcGxvdCBiYW5kIG9yIHBsb3QgbGluZSBmcm9tIHRoZSBjaGFydCBieSBpZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpZFxuXHRcdCAqL1xuXHRcdHJlbW92ZVBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHZhciBwbG90TGluZXNBbmRCYW5kcyA9IHRoaXMucGxvdExpbmVzQW5kQmFuZHMsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHBsb3RMaW5lc0FuZEJhbmRzW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzW2ldLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWFjaChbb3B0aW9ucy5wbG90TGluZXMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RMaW5lcyB8fCBbXSwgb3B0aW9ucy5wbG90QmFuZHMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RCYW5kcyB8fCBbXV0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdFx0aSA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAoYXJyW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdFx0ZXJhc2UoYXJyLCBhcnJbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgYXhpcyBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHR2YXIgQXhpcyA9IEhpZ2hjaGFydHMuQXhpcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRBeGlzLnByb3RvdHlwZSA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIFggYXhpcyAtIHRoZSBZIGF4aXMgaGFzIGV4dGVuZGVkIGRlZmF1bHRzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdE9wdGlvbnM6IHtcblx0XHRcdC8vIGFsbG93RGVjaW1hbHM6IG51bGwsXG5cdFx0XHQvLyBhbHRlcm5hdGVHcmlkQ29sb3I6IG51bGwsXG5cdFx0XHQvLyBjYXRlZ29yaWVzOiBbXSxcblx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7XG5cdFx0XHRcdG1pbGxpc2Vjb25kOiAnJUg6JU06JVMuJUwnLFxuXHRcdFx0XHRzZWNvbmQ6ICclSDolTTolUycsXG5cdFx0XHRcdG1pbnV0ZTogJyVIOiVNJyxcblx0XHRcdFx0aG91cjogJyVIOiVNJyxcblx0XHRcdFx0ZGF5OiAnJWUuICViJyxcblx0XHRcdFx0d2VlazogJyVlLiAlYicsXG5cdFx0XHRcdG1vbnRoOiAnJWIgXFwnJXknLFxuXHRcdFx0XHR5ZWFyOiAnJVknXG5cdFx0XHR9LFxuXHRcdFx0ZW5kT25UaWNrOiBmYWxzZSxcblx0XHRcdGdyaWRMaW5lQ29sb3I6ICcjRDhEOEQ4Jyxcblx0XHRcdC8vIGdyaWRMaW5lRGFzaFN0eWxlOiAnc29saWQnLFxuXHRcdFx0Ly8gZ3JpZExpbmVXaWR0aDogMCxcblx0XHRcdC8vIHJldmVyc2VkOiBmYWxzZSxcblxuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdC8vIHJvdGF0aW9uOiAwLFxuXHRcdFx0XHQvLyBhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHRcdC8vIHN0ZXA6IG51bGwsXG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0Y29sb3I6ICcjNjA2MDYwJyxcblx0XHRcdFx0XHRjdXJzb3I6ICdkZWZhdWx0Jyxcblx0XHRcdFx0XHRmb250U2l6ZTogJzExcHgnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHg6IDAsXG5cdFx0XHRcdHk6IDE1XG5cdFx0XHRcdC8qZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sKi9cblx0XHRcdH0sXG5cdFx0XHRsaW5lQ29sb3I6ICcjQzBEMEUwJyxcblx0XHRcdGxpbmVXaWR0aDogMSxcblx0XHRcdC8vbGlua2VkVG86IG51bGwsXG5cdFx0XHQvL21heDogdW5kZWZpbmVkLFxuXHRcdFx0Ly9taW46IHVuZGVmaW5lZCxcblx0XHRcdG1pblBhZGRpbmc6IDAuMDEsXG5cdFx0XHRtYXhQYWRkaW5nOiAwLjAxLFxuXHRcdFx0Ly9taW5SYW5nZTogbnVsbCxcblx0XHRcdG1pbm9yR3JpZExpbmVDb2xvcjogJyNFMEUwRTAnLFxuXHRcdFx0Ly8gbWlub3JHcmlkTGluZURhc2hTdHlsZTogbnVsbCxcblx0XHRcdG1pbm9yR3JpZExpbmVXaWR0aDogMSxcblx0XHRcdG1pbm9yVGlja0NvbG9yOiAnI0EwQTBBMCcsXG5cdFx0XHQvL21pbm9yVGlja0ludGVydmFsOiBudWxsLFxuXHRcdFx0bWlub3JUaWNrTGVuZ3RoOiAyLFxuXHRcdFx0bWlub3JUaWNrUG9zaXRpb246ICdvdXRzaWRlJywgLy8gaW5zaWRlIG9yIG91dHNpZGVcblx0XHRcdC8vbWlub3JUaWNrV2lkdGg6IDAsXG5cdFx0XHQvL29wcG9zaXRlOiBmYWxzZSxcblx0XHRcdC8vb2Zmc2V0OiAwLFxuXHRcdFx0Ly9wbG90QmFuZHM6IFt7XG5cdFx0XHQvL1x0ZXZlbnRzOiB7fSxcblx0XHRcdC8vXHR6SW5kZXg6IDEsXG5cdFx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0XHQvL31dLFxuXHRcdFx0Ly9wbG90TGluZXM6IFt7XG5cdFx0XHQvL1x0ZXZlbnRzOiB7fVxuXHRcdFx0Ly8gIGRhc2hTdHlsZToge31cblx0XHRcdC8vXHR6SW5kZXg6XG5cdFx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0XHQvL31dLFxuXHRcdFx0Ly9yZXZlcnNlZDogZmFsc2UsXG5cdFx0XHQvLyBzaG93Rmlyc3RMYWJlbDogdHJ1ZSxcblx0XHRcdC8vIHNob3dMYXN0TGFiZWw6IHRydWUsXG5cdFx0XHRzdGFydE9mV2VlazogMSxcblx0XHRcdHN0YXJ0T25UaWNrOiBmYWxzZSxcblx0XHRcdHRpY2tDb2xvcjogJyNDMEQwRTAnLFxuXHRcdFx0Ly90aWNrSW50ZXJ2YWw6IG51bGwsXG5cdFx0XHR0aWNrTGVuZ3RoOiAxMCxcblx0XHRcdHRpY2ttYXJrUGxhY2VtZW50OiAnYmV0d2VlbicsIC8vIG9uIG9yIGJldHdlZW5cblx0XHRcdHRpY2tQaXhlbEludGVydmFsOiAxMDAsXG5cdFx0XHR0aWNrUG9zaXRpb246ICdvdXRzaWRlJyxcblx0XHRcdHRpY2tXaWR0aDogMSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdC8vdGV4dDogbnVsbCxcblx0XHRcdFx0YWxpZ246ICdtaWRkbGUnLCAvLyBsb3csIG1pZGRsZSBvciBoaWdoXG5cdFx0XHRcdC8vbWFyZ2luOiAwIGZvciBob3Jpem9udGFsLCAxMCBmb3IgdmVydGljYWwgYXhlcyxcblx0XHRcdFx0Ly9yb3RhdGlvbjogMCxcblx0XHRcdFx0Ly9zaWRlOiAnb3V0c2lkZScsXG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0Y29sb3I6ICcjNzA3MDcwJ1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8veDogMCxcblx0XHRcdFx0Ly95OiAwXG5cdFx0XHR9LFxuXHRcdFx0dHlwZTogJ2xpbmVhcicgLy8gbGluZWFyLCBsb2dhcml0aG1pYyBvciBkYXRldGltZVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG9wdGlvbnMgc2V0IGV4dGVuZHMgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBZIGF4ZXNcblx0XHQgKi9cblx0XHRkZWZhdWx0WUF4aXNPcHRpb25zOiB7XG5cdFx0XHRlbmRPblRpY2s6IHRydWUsXG5cdFx0XHRncmlkTGluZVdpZHRoOiAxLFxuXHRcdFx0dGlja1BpeGVsSW50ZXJ2YWw6IDcyLFxuXHRcdFx0c2hvd0xhc3RMYWJlbDogdHJ1ZSxcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHR4OiAtOCxcblx0XHRcdFx0eTogM1xuXHRcdFx0fSxcblx0XHRcdGxpbmVXaWR0aDogMCxcblx0XHRcdG1heFBhZGRpbmc6IDAuMDUsXG5cdFx0XHRtaW5QYWRkaW5nOiAwLjA1LFxuXHRcdFx0c3RhcnRPblRpY2s6IHRydWUsXG5cdFx0XHR0aWNrV2lkdGg6IDAsXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogMjcwLFxuXHRcdFx0XHR0ZXh0OiAnVmFsdWVzJ1xuXHRcdFx0fSxcblx0XHRcdHN0YWNrTGFiZWxzOiB7XG5cdFx0XHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0XHQvL2FsaWduOiBkeW5hbWljLFxuXHRcdFx0XHQvL3k6IGR5bmFtaWMsXG5cdFx0XHRcdC8veDogZHluYW1pYyxcblx0XHRcdFx0Ly92ZXJ0aWNhbEFsaWduOiBkeW5hbWljLFxuXHRcdFx0XHQvL3RleHRBbGlnbjogZHluYW1pYyxcblx0XHRcdFx0Ly9yb3RhdGlvbjogMCxcblx0XHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHRoaXMudG90YWwsIC0xKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c3R5bGU6IG1lcmdlKGRlZmF1bHRQbG90T3B0aW9ucy5saW5lLmRhdGFMYWJlbHMuc3R5bGUsIHsgY29sb3I6ICcjMDAwMDAwJyB9KVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIGxlZnQgYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6IHtcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHR4OiAtMTUsXG5cdFx0XHRcdHk6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogMjcwXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZXNlIG9wdGlvbnMgZXh0ZW5kIHRoZSBkZWZhdWx0T3B0aW9ucyBmb3IgcmlnaHQgYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRSaWdodEF4aXNPcHRpb25zOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0eDogMTUsXG5cdFx0XHRcdHk6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogOTBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBib3R0b20gYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRCb3R0b21BeGlzT3B0aW9uczoge1xuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdGF1dG9Sb3RhdGlvbjogWy00NV0sXG5cdFx0XHRcdHg6IDAsXG5cdFx0XHRcdHk6IG51bGwgLy8gYmFzZWQgb24gZm9udCBzaXplXG5cdFx0XHRcdC8vIG92ZXJmbG93OiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIHN0YWdnZXJMaW5lczogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIHRvcCBheGVzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdFRvcEF4aXNPcHRpb25zOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0YXV0b1JvdGF0aW9uOiBbLTQ1XSxcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogLTE1XG5cdFx0XHRcdC8vIG92ZXJmbG93OiB1bmRlZmluZWRcblx0XHRcdFx0Ly8gc3RhZ2dlckxpbmVzOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dGl0bGU6IHtcblx0XHRcdFx0cm90YXRpb246IDBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgYXhpc1xuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgdXNlck9wdGlvbnMpIHtcblxuXG5cdFx0XHR2YXIgaXNYQXhpcyA9IHVzZXJPcHRpb25zLmlzWCxcblx0XHRcdFx0YXhpcyA9IHRoaXM7XG5cblx0XHRcdC8vIEZsYWcsIGlzIHRoZSBheGlzIGhvcml6b250YWxcblx0XHRcdGF4aXMuaG9yaXogPSBjaGFydC5pbnZlcnRlZCA/ICFpc1hBeGlzIDogaXNYQXhpcztcblxuXHRcdFx0Ly8gRmxhZywgaXNYQXhpc1xuXHRcdFx0YXhpcy5pc1hBeGlzID0gaXNYQXhpcztcblx0XHRcdGF4aXMuY29sbCA9IGlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJztcblxuXHRcdFx0YXhpcy5vcHBvc2l0ZSA9IHVzZXJPcHRpb25zLm9wcG9zaXRlOyAvLyBuZWVkZWQgaW4gc2V0T3B0aW9uc1xuXHRcdFx0YXhpcy5zaWRlID0gdXNlck9wdGlvbnMuc2lkZSB8fCAoYXhpcy5ob3JpeiA/XG5cdFx0XHRcdFx0KGF4aXMub3Bwb3NpdGUgPyAwIDogMikgOiAvLyB0b3AgOiBib3R0b21cblx0XHRcdFx0XHQoYXhpcy5vcHBvc2l0ZSA/IDEgOiAzKSk7ICAvLyByaWdodCA6IGxlZnRcblxuXHRcdFx0YXhpcy5zZXRPcHRpb25zKHVzZXJPcHRpb25zKTtcblxuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dHlwZSA9IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0aXNEYXRldGltZUF4aXMgPSB0eXBlID09PSAnZGF0ZXRpbWUnO1xuXG5cdFx0XHRheGlzLmxhYmVsRm9ybWF0dGVyID0gb3B0aW9ucy5sYWJlbHMuZm9ybWF0dGVyIHx8IGF4aXMuZGVmYXVsdExhYmVsRm9ybWF0dGVyOyAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZHluYW1pYyBmb3JtYXRcblxuXG5cdFx0XHQvLyBGbGFnLCBzdGFnZ2VyIGxpbmVzIG9yIG5vdFxuXHRcdFx0YXhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuXG5cdFx0XHQvL2F4aXMuYXhpc1RpdGxlTWFyZ2luID0gVU5ERUZJTkVELC8vID0gb3B0aW9ucy50aXRsZS5tYXJnaW4sXG5cdFx0XHRheGlzLm1pblBpeGVsUGFkZGluZyA9IDA7XG5cdFx0XHQvL2F4aXMuaWdub3JlTWluUGFkZGluZyA9IFVOREVGSU5FRDsgLy8gY2FuIGJlIHNldCB0byB0cnVlIGJ5IGEgY29sdW1uIG9yIGJhciBzZXJpZXNcblx0XHRcdC8vYXhpcy5pZ25vcmVNYXhQYWRkaW5nID0gVU5ERUZJTkVEO1xuXG5cdFx0XHRheGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRheGlzLnJldmVyc2VkID0gb3B0aW9ucy5yZXZlcnNlZDtcblx0XHRcdGF4aXMuem9vbUVuYWJsZWQgPSBvcHRpb25zLnpvb21FbmFibGVkICE9PSBmYWxzZTtcblxuXHRcdFx0Ly8gSW5pdGlhbCBjYXRlZ29yaWVzXG5cdFx0XHRheGlzLmNhdGVnb3JpZXMgPSBvcHRpb25zLmNhdGVnb3JpZXMgfHwgdHlwZSA9PT0gJ2NhdGVnb3J5Jztcblx0XHRcdGF4aXMubmFtZXMgPSBheGlzLm5hbWVzIHx8IFtdOyAvLyBQcmVzZXJ2ZSBvbiB1cGRhdGUgKCMzODMwKVxuXG5cdFx0XHQvLyBFbGVtZW50c1xuXHRcdFx0Ly9heGlzLmF4aXNHcm91cCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5ncmlkR3JvdXAgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuYXhpc1RpdGxlID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLmF4aXNMaW5lID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBTaG9ydGhhbmQgdHlwZXNcblx0XHRcdGF4aXMuaXNMb2cgPSB0eXBlID09PSAnbG9nYXJpdGhtaWMnO1xuXHRcdFx0YXhpcy5pc0RhdGV0aW1lQXhpcyA9IGlzRGF0ZXRpbWVBeGlzO1xuXG5cdFx0XHQvLyBGbGFnLCBpZiBheGlzIGlzIGxpbmtlZCB0byBhbm90aGVyIGF4aXNcblx0XHRcdGF4aXMuaXNMaW5rZWQgPSBkZWZpbmVkKG9wdGlvbnMubGlua2VkVG8pO1xuXHRcdFx0Ly8gTGlua2VkIGF4aXMuXG5cdFx0XHQvL2F4aXMubGlua2VkUGFyZW50ID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBUaWNrIHBvc2l0aW9uc1xuXHRcdFx0Ly9heGlzLnRpY2tQb3NpdGlvbnMgPSBVTkRFRklORUQ7IC8vIGFycmF5IGNvbnRhaW5pbmcgcHJlZGVmaW5lZCBwb3NpdGlvbnNcblx0XHRcdC8vIFRpY2sgaW50ZXJ2YWxzXG5cdFx0XHQvL2F4aXMudGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm1pbm9yVGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXG5cdFx0XHRcblx0XHRcdC8vIE1ham9yIHRpY2tzXG5cdFx0XHRheGlzLnRpY2tzID0ge307XG5cdFx0XHRheGlzLmxhYmVsRWRnZSA9IFtdO1xuXHRcdFx0Ly8gTWlub3IgdGlja3Ncblx0XHRcdGF4aXMubWlub3JUaWNrcyA9IHt9O1xuXG5cdFx0XHQvLyBMaXN0IG9mIHBsb3RMaW5lcy9CYW5kc1xuXHRcdFx0YXhpcy5wbG90TGluZXNBbmRCYW5kcyA9IFtdO1xuXG5cdFx0XHQvLyBBbHRlcm5hdGUgYmFuZHNcblx0XHRcdGF4aXMuYWx0ZXJuYXRlQmFuZHMgPSB7fTtcblxuXHRcdFx0Ly8gQXhpcyBtZXRyaWNzXG5cdFx0XHQvL2F4aXMubGVmdCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy50b3AgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMud2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuaGVpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLmJvdHRvbSA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5yaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy50cmFuc0EgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMudHJhbnNCID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm9sZFRyYW5zQSA9IFVOREVGSU5FRDtcblx0XHRcdGF4aXMubGVuID0gMDtcblx0XHRcdC8vYXhpcy5vbGRNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkTWF4ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm9sZFVzZXJNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkVXNlck1heCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5vbGRBeGlzTGVuZ3RoID0gVU5ERUZJTkVEO1xuXHRcdFx0YXhpcy5taW5SYW5nZSA9IGF4aXMudXNlck1pblJhbmdlID0gb3B0aW9ucy5taW5SYW5nZSB8fCBvcHRpb25zLm1heFpvb207XG5cdFx0XHRheGlzLnJhbmdlID0gb3B0aW9ucy5yYW5nZTtcblx0XHRcdGF4aXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcblxuXG5cdFx0XHQvLyBEaWN0aW9uYXJ5IGZvciBzdGFja3Ncblx0XHRcdGF4aXMuc3RhY2tzID0ge307XG5cdFx0XHRheGlzLm9sZFN0YWNrcyA9IHt9O1xuXHRcdFx0YXhpcy5zdGFja3NUb3VjaGVkID0gMDtcblxuXHRcdFx0Ly8gTWluIGFuZCBtYXggaW4gdGhlIGRhdGFcblx0XHRcdC8vYXhpcy5kYXRhTWluID0gVU5ERUZJTkVELFxuXHRcdFx0Ly9heGlzLmRhdGFNYXggPSBVTkRFRklORUQsXG5cblx0XHRcdC8vIFRoZSBheGlzIHJhbmdlXG5cdFx0XHRheGlzLm1heCA9IG51bGw7XG5cdFx0XHRheGlzLm1pbiA9IG51bGw7XG5cblx0XHRcdC8vIFVzZXIgc2V0IG1pbiBhbmQgbWF4XG5cdFx0XHQvL2F4aXMudXNlck1pbiA9IFVOREVGSU5FRCxcblx0XHRcdC8vYXhpcy51c2VyTWF4ID0gVU5ERUZJTkVELFxuXG5cdFx0XHQvLyBDcm9zc2hhaXIgb3B0aW9uc1xuXHRcdFx0YXhpcy5jcm9zc2hhaXIgPSBwaWNrKG9wdGlvbnMuY3Jvc3NoYWlyLCBzcGxhdChjaGFydC5vcHRpb25zLnRvb2x0aXAuY3Jvc3NoYWlycylbaXNYQXhpcyA/IDAgOiAxXSwgZmFsc2UpO1xuXHRcdFx0Ly8gUnVuIEF4aXNcblxuXHRcdFx0dmFyIGV2ZW50VHlwZSxcblx0XHRcdFx0ZXZlbnRzID0gYXhpcy5vcHRpb25zLmV2ZW50cztcblxuXHRcdFx0Ly8gUmVnaXN0ZXJcblx0XHRcdGlmIChpbkFycmF5KGF4aXMsIGNoYXJ0LmF4ZXMpID09PSAtMSkgeyAvLyBkb24ndCBhZGQgaXQgYWdhaW4gb24gQXhpcy51cGRhdGUoKVxuXHRcdFx0XHRpZiAoaXNYQXhpcyAmJiAhdGhpcy5pc0NvbG9yQXhpcykgeyAvLyAjMjcxM1xuXHRcdFx0XHRcdGNoYXJ0LmF4ZXMuc3BsaWNlKGNoYXJ0LnhBeGlzLmxlbmd0aCwgMCwgYXhpcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hhcnQuYXhlcy5wdXNoKGF4aXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2hhcnRbYXhpcy5jb2xsXS5wdXNoKGF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRheGlzLnNlcmllcyA9IGF4aXMuc2VyaWVzIHx8IFtdOyAvLyBwb3B1bGF0ZWQgYnkgU2VyaWVzXG5cblx0XHRcdC8vIGludmVydGVkIGNoYXJ0cyBoYXZlIHJldmVyc2VkIHhBeGVzIGFzIGRlZmF1bHRcblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCAmJiBpc1hBeGlzICYmIGF4aXMucmV2ZXJzZWQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRheGlzLnJldmVyc2VkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YXhpcy5yZW1vdmVQbG90QmFuZCA9IGF4aXMucmVtb3ZlUGxvdEJhbmRPckxpbmU7XG5cdFx0XHRheGlzLnJlbW92ZVBsb3RMaW5lID0gYXhpcy5yZW1vdmVQbG90QmFuZE9yTGluZTtcblxuXG5cdFx0XHQvLyByZWdpc3RlciBldmVudCBsaXN0ZW5lcnNcblx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudChheGlzLCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXh0ZW5kIGxvZ2FyaXRobWljIGF4aXNcblx0XHRcdGlmIChheGlzLmlzTG9nKSB7XG5cdFx0XHRcdGF4aXMudmFsMmxpbiA9IGxvZzJsaW47XG5cdFx0XHRcdGF4aXMubGluMnZhbCA9IGxpbjJsb2c7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1lcmdlIGFuZCBzZXQgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uICh1c2VyT3B0aW9ucykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gbWVyZ2UoXG5cdFx0XHRcdHRoaXMuZGVmYXVsdE9wdGlvbnMsXG5cdFx0XHRcdHRoaXMuaXNYQXhpcyA/IHt9IDogdGhpcy5kZWZhdWx0WUF4aXNPcHRpb25zLFxuXHRcdFx0XHRbdGhpcy5kZWZhdWx0VG9wQXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnMsXG5cdFx0XHRcdFx0dGhpcy5kZWZhdWx0Qm90dG9tQXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdExlZnRBeGlzT3B0aW9uc11bdGhpcy5zaWRlXSxcblx0XHRcdFx0bWVyZ2UoXG5cdFx0XHRcdFx0ZGVmYXVsdE9wdGlvbnNbdGhpcy5jb2xsXSwgLy8gaWYgc2V0IGluIHNldE9wdGlvbnMgKCMxMDUzKVxuXHRcdFx0XHRcdHVzZXJPcHRpb25zXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IGxhYmVsIGZvcm1hdHRlci4gVGhlIGNvbnRleHQgaXMgYSBzcGVjaWFsIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsYWJlbC5cblx0XHQgKi9cblx0XHRkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcy5heGlzLFxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRcdGNhdGVnb3JpZXMgPSBheGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXQgPSB0aGlzLmRhdGVUaW1lTGFiZWxGb3JtYXQsXG5cdFx0XHRcdG51bWVyaWNTeW1ib2xzID0gZGVmYXVsdE9wdGlvbnMubGFuZy5udW1lcmljU3ltYm9scyxcblx0XHRcdFx0aSA9IG51bWVyaWNTeW1ib2xzICYmIG51bWVyaWNTeW1ib2xzLmxlbmd0aCxcblx0XHRcdFx0bXVsdGksXG5cdFx0XHRcdHJldCxcblx0XHRcdFx0Zm9ybWF0T3B0aW9uID0gYXhpcy5vcHRpb25zLmxhYmVscy5mb3JtYXQsXG5cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBzYW1lIHN5bWJvbCBpcyBhZGRlZCBmb3IgYWxsIGxhYmVscyBvbiBhIGxpbmVhciBheGlzXG5cdFx0XHRcdG51bWVyaWNTeW1ib2xEZXRlY3RvciA9IGF4aXMuaXNMb2cgPyB2YWx1ZSA6IGF4aXMudGlja0ludGVydmFsO1xuXG5cdFx0XHRpZiAoZm9ybWF0T3B0aW9uKSB7XG5cdFx0XHRcdHJldCA9IGZvcm1hdChmb3JtYXRPcHRpb24sIHRoaXMpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGNhdGVnb3JpZXMpIHtcblx0XHRcdFx0cmV0ID0gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoZGF0ZVRpbWVMYWJlbEZvcm1hdCkgeyAvLyBkYXRldGltZSBheGlzXG5cdFx0XHRcdHJldCA9IGRhdGVGb3JtYXQoZGF0ZVRpbWVMYWJlbEZvcm1hdCwgdmFsdWUpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGkgJiYgbnVtZXJpY1N5bWJvbERldGVjdG9yID49IDEwMDApIHtcblx0XHRcdFx0Ly8gRGVjaWRlIHdoZXRoZXIgd2Ugc2hvdWxkIGFkZCBhIG51bWVyaWMgc3ltYm9sIGxpa2UgayAodGhvdXNhbmRzKSBvciBNIChtaWxsaW9ucykuXG5cdFx0XHRcdC8vIElmIHdlIGFyZSB0byBlbmFibGUgdGhpcyBpbiB0b29sdGlwIG9yIG90aGVyIHBsYWNlcyBhcyB3ZWxsLCB3ZSBjYW4gbW92ZSB0aGlzXG5cdFx0XHRcdC8vIGxvZ2ljIHRvIHRoZSBudW1iZXJGb3JtYXR0ZXIgYW5kIGVuYWJsZSBpdCBieSBhIHBhcmFtZXRlci5cblx0XHRcdFx0d2hpbGUgKGktLSAmJiByZXQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdG11bHRpID0gTWF0aC5wb3coMTAwMCwgaSArIDEpO1xuXHRcdFx0XHRcdGlmIChudW1lcmljU3ltYm9sRGV0ZWN0b3IgPj0gbXVsdGkgJiYgKHZhbHVlICogMTApICUgbXVsdGkgPT09IDAgJiYgbnVtZXJpY1N5bWJvbHNbaV0gIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHZhbHVlIC8gbXVsdGksIC0xKSArIG51bWVyaWNTeW1ib2xzW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmV0ID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0aWYgKG1hdGhBYnModmFsdWUpID49IDEwMDAwKSB7IC8vIGFkZCB0aG91c2FuZHMgc2VwYXJhdG9yc1xuXHRcdFx0XHRcdHJldCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHZhbHVlLCAtMSk7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gc21hbGwgbnVtYmVyc1xuXHRcdFx0XHRcdHJldCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHZhbHVlLCAtMSwgVU5ERUZJTkVELCAnJyk7IC8vICMyNDY2XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciB0aGUgc2VyaWVzIG9mIGVhY2ggYXhpc1xuXHRcdCAqL1xuXHRcdGdldFNlcmllc0V4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydDtcblxuXHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gZmFsc2U7XG5cblx0XHRcdC8vIFJlc2V0IHByb3BlcnRpZXMgaW4gY2FzZSB3ZSdyZSByZWRyYXdpbmcgKCMzMzUzKVxuXHRcdFx0YXhpcy5kYXRhTWluID0gYXhpcy5kYXRhTWF4ID0gYXhpcy5pZ25vcmVNaW5QYWRkaW5nID0gYXhpcy5pZ25vcmVNYXhQYWRkaW5nID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKGF4aXMuYnVpbGRTdGFja3MpIHtcblx0XHRcdFx0YXhpcy5idWlsZFN0YWNrcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggdGhpcyBheGlzJyBzZXJpZXNcblx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblxuXHRcdFx0XHRpZiAoc2VyaWVzLnZpc2libGUgfHwgIWNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cblx0XHRcdFx0XHR2YXIgc2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRcdFx0eERhdGEsXG5cdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNaW4sXG5cdFx0XHRcdFx0XHRzZXJpZXNEYXRhTWF4O1xuXG5cdFx0XHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIFZhbGlkYXRlIHRocmVzaG9sZCBpbiBsb2dhcml0aG1pYyBheGVzXG5cdFx0XHRcdFx0aWYgKGF4aXMuaXNMb2cgJiYgdGhyZXNob2xkIDw9IDApIHtcblx0XHRcdFx0XHRcdHRocmVzaG9sZCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR2V0IGRhdGFNaW4gYW5kIGRhdGFNYXggZm9yIFggYXhlc1xuXHRcdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHRcdHhEYXRhID0gc2VyaWVzLnhEYXRhO1xuXHRcdFx0XHRcdFx0aWYgKHhEYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCB4RGF0YVswXSksIGFycmF5TWluKHhEYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IG1hdGhNYXgocGljayhheGlzLmRhdGFNYXgsIHhEYXRhWzBdKSwgYXJyYXlNYXgoeERhdGEpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBkYXRhTWluIGFuZCBkYXRhTWF4IGZvciBZIGF4ZXMsIGFzIHdlbGwgYXMgaGFuZGxlIHN0YWNraW5nIGFuZCBwcm9jZXNzZWQgZGF0YVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGlzIHBhcnRpY3VsYXIgc2VyaWVzIGV4dHJlbWVzXG5cdFx0XHRcdFx0XHRzZXJpZXMuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNYXggPSBzZXJpZXMuZGF0YU1heDtcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNaW4gPSBzZXJpZXMuZGF0YU1pbjtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBkYXRhTWluIGFuZCBkYXRhTWF4IHNvIGZhci4gSWYgcGVyY2VudGFnZSBpcyB1c2VkLCB0aGUgbWluIGFuZCBtYXggYXJlXG5cdFx0XHRcdFx0XHQvLyBhbHdheXMgMCBhbmQgMTAwLiBJZiBzZXJpZXNEYXRhTWluIGFuZCBzZXJpZXNEYXRhTWF4IGlzIG51bGwsIHRoZW4gc2VyaWVzXG5cdFx0XHRcdFx0XHQvLyBkb2Vzbid0IGhhdmUgYWN0aXZlIHkgZGF0YSwgd2UgY29udGludWUgd2l0aCBudWxsc1xuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQoc2VyaWVzRGF0YU1pbikgJiYgZGVmaW5lZChzZXJpZXNEYXRhTWF4KSkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCBzZXJpZXNEYXRhTWluKSwgc2VyaWVzRGF0YU1pbik7XG5cdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IG1hdGhNYXgocGljayhheGlzLmRhdGFNYXgsIHNlcmllc0RhdGFNYXgpLCBzZXJpZXNEYXRhTWF4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQWRqdXN0IHRvIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQodGhyZXNob2xkKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXhpcy5kYXRhTWluID49IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1pbiA9IHRocmVzaG9sZDtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmlnbm9yZU1pblBhZGRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGF4aXMuZGF0YU1heCA8IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IHRocmVzaG9sZDtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmlnbm9yZU1heFBhZGRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNsYXRlIGZyb20gYXhpcyB2YWx1ZSB0byBwaXhlbCBwb3NpdGlvbiBvbiB0aGUgY2hhcnQsIG9yIGJhY2tcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKHZhbCwgYmFja3dhcmRzLCBjdnNDb29yZCwgb2xkLCBoYW5kbGVMb2csIHBvaW50UGxhY2VtZW50KSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMubGlua2VkUGFyZW50IHx8IHRoaXMsIC8vICMxNDE3XG5cdFx0XHRcdHNpZ24gPSAxLFxuXHRcdFx0XHRjdnNPZmZzZXQgPSAwLFxuXHRcdFx0XHRsb2NhbEEgPSBvbGQgPyBheGlzLm9sZFRyYW5zQSA6IGF4aXMudHJhbnNBLFxuXHRcdFx0XHRsb2NhbE1pbiA9IG9sZCA/IGF4aXMub2xkTWluIDogYXhpcy5taW4sXG5cdFx0XHRcdHJldHVyblZhbHVlLFxuXHRcdFx0XHRtaW5QaXhlbFBhZGRpbmcgPSBheGlzLm1pblBpeGVsUGFkZGluZyxcblx0XHRcdFx0ZG9Qb3N0VHJhbnNsYXRlID0gKGF4aXMuZG9Qb3N0VHJhbnNsYXRlIHx8IChheGlzLmlzTG9nICYmIGhhbmRsZUxvZykpICYmIGF4aXMubGluMnZhbDtcblxuXHRcdFx0aWYgKCFsb2NhbEEpIHtcblx0XHRcdFx0bG9jYWxBID0gYXhpcy50cmFuc0E7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIHZlcnRpY2FsIGF4ZXMsIHRoZSBjYW52YXMgY29vcmRpbmF0ZXMgc3RhcnQgZnJvbSAwIGF0IHRoZSB0b3AgbGlrZSBpblxuXHRcdFx0Ly8gU1ZHLlxuXHRcdFx0aWYgKGN2c0Nvb3JkKSB7XG5cdFx0XHRcdHNpZ24gKj0gLTE7IC8vIGNhbnZhcyBjb29yZGluYXRlcyBpbnZlcnRzIHRoZSB2YWx1ZVxuXHRcdFx0XHRjdnNPZmZzZXQgPSBheGlzLmxlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHJldmVyc2VkIGF4aXNcblx0XHRcdGlmIChheGlzLnJldmVyc2VkKSB7XG5cdFx0XHRcdHNpZ24gKj0gLTE7XG5cdFx0XHRcdGN2c09mZnNldCAtPSBzaWduICogKGF4aXMuc2VjdG9yIHx8IGF4aXMubGVuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRnJvbSBwaXhlbHMgdG8gdmFsdWVcblx0XHRcdGlmIChiYWNrd2FyZHMpIHsgLy8gcmV2ZXJzZSB0cmFuc2xhdGlvblxuXG5cdFx0XHRcdHZhbCA9IHZhbCAqIHNpZ24gKyBjdnNPZmZzZXQ7XG5cdFx0XHRcdHZhbCAtPSBtaW5QaXhlbFBhZGRpbmc7XG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsIC8gbG9jYWxBICsgbG9jYWxNaW47IC8vIGZyb20gY2hhcnQgcGl4ZWwgdG8gdmFsdWVcblx0XHRcdFx0aWYgKGRvUG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gYXhpcy5saW4ydmFsKHJldHVyblZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBGcm9tIHZhbHVlIHRvIHBpeGVsc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGRvUG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRcdHZhbCA9IGF4aXMudmFsMmxpbih2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nKSB7XG5cdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSBzaWduICogKHZhbCAtIGxvY2FsTWluKSAqIGxvY2FsQSArIGN2c09mZnNldCArIChzaWduICogbWluUGl4ZWxQYWRkaW5nKSArXG5cdFx0XHRcdFx0KGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSA/IGxvY2FsQSAqIHBvaW50UGxhY2VtZW50ICogYXhpcy5wb2ludFJhbmdlIDogMCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSBtZXRob2QgdG8gdHJhbnNsYXRlIGFuIGF4aXMgdmFsdWUgdG8gcGl4ZWwgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgaW4gdGVybXMgb2YgYXhpcyB1bml0c1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaW5hdGVzIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBjaGFydFxuXHRcdCAqICAgICAgICBvciBqdXN0IHRoZSBheGlzL3BhbmUgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHRvUGl4ZWxzOiBmdW5jdGlvbiAodmFsdWUsIHBhbmVDb29yZGluYXRlcykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlKHZhbHVlLCBmYWxzZSwgIXRoaXMuaG9yaXosIG51bGwsIHRydWUpICsgKHBhbmVDb29yZGluYXRlcyA/IDAgOiB0aGlzLnBvcyk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0ICogVXRpbGl0eSBtZXRob2QgdG8gdHJhbnNsYXRlIGEgcGl4ZWwgcG9zaXRpb24gaW4gdG8gYW4gYXhpcyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbCBUaGUgcGl4ZWwgdmFsdWUgY29vcmRpbmF0ZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaWFudGVzIFdoZXRoZXIgdGhlIGlucHV0IHBpeGVsIGlzIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBvciBqdXN0IHRoZVxuXHRcdCAqICAgICAgICBheGlzL3BhbmUgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHRvVmFsdWU6IGZ1bmN0aW9uIChwaXhlbCwgcGFuZUNvb3JkaW5hdGVzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGUocGl4ZWwgLSAocGFuZUNvb3JkaW5hdGVzID8gMCA6IHRoaXMucG9zKSwgdHJ1ZSwgIXRoaXMuaG9yaXosIG51bGwsIHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgdGhlIHBhdGggZm9yIGEgcGxvdCBsaW5lIHRoYXQgZ29lcyBmcm9tIHRoZSBnaXZlbiB2YWx1ZSBvblxuXHRcdCAqIHRoaXMgYXhpcywgYWNyb3NzIHRoZSBwbG90IHRvIHRoZSBvcHBvc2l0ZSBzaWRlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVXaWR0aCBVc2VkIGZvciBjYWxjdWxhdGlvbiBjcmlzcCBsaW5lXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJdIG9sZCBVc2Ugb2xkIGNvb3JkaW5hdGVzIChmb3IgcmVzaXppbmcgYW5kIHJlc2NhbGluZylcblx0XHQgKi9cblx0XHRnZXRQbG90TGluZVBhdGg6IGZ1bmN0aW9uICh2YWx1ZSwgbGluZVdpZHRoLCBvbGQsIGZvcmNlLCB0cmFuc2xhdGVkVmFsdWUpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRheGlzTGVmdCA9IGF4aXMubGVmdCxcblx0XHRcdFx0YXhpc1RvcCA9IGF4aXMudG9wLFxuXHRcdFx0XHR4MSxcblx0XHRcdFx0eTEsXG5cdFx0XHRcdHgyLFxuXHRcdFx0XHR5Mixcblx0XHRcdFx0Y0hlaWdodCA9IChvbGQgJiYgY2hhcnQub2xkQ2hhcnRIZWlnaHQpIHx8IGNoYXJ0LmNoYXJ0SGVpZ2h0LFxuXHRcdFx0XHRjV2lkdGggPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0V2lkdGgpIHx8IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdHNraXAsXG5cdFx0XHRcdHRyYW5zQiA9IGF4aXMudHJhbnNCLFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQ2hlY2sgaWYgeCBpcyBiZXR3ZWVuIGEgYW5kIGIuIElmIG5vdCwgZWl0aGVyIG1vdmUgdG8gYS9iIG9yIHNraXAsIFxuXHRcdFx0XHQgKiBkZXBlbmRpbmcgb24gdGhlIGZvcmNlIHBhcmFtZXRlci5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGJldHdlZW4gPSBmdW5jdGlvbiAoeCwgYSwgYikge1xuXHRcdFx0XHRcdGlmICh4IDwgYSB8fCB4ID4gYikge1xuXHRcdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHRcdHggPSBtYXRoTWluKG1hdGhNYXgoYSwgeCksIGIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR0cmFuc2xhdGVkVmFsdWUgPSBwaWNrKHRyYW5zbGF0ZWRWYWx1ZSwgYXhpcy50cmFuc2xhdGUodmFsdWUsIG51bGwsIG51bGwsIG9sZCkpO1xuXHRcdFx0eDEgPSB4MiA9IG1hdGhSb3VuZCh0cmFuc2xhdGVkVmFsdWUgKyB0cmFuc0IpO1xuXHRcdFx0eTEgPSB5MiA9IG1hdGhSb3VuZChjSGVpZ2h0IC0gdHJhbnNsYXRlZFZhbHVlIC0gdHJhbnNCKTtcblxuXHRcdFx0aWYgKGlzTmFOKHRyYW5zbGF0ZWRWYWx1ZSkpIHsgLy8gbm8gbWluIG9yIG1heFxuXHRcdFx0XHRza2lwID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmIChheGlzLmhvcml6KSB7XG5cdFx0XHRcdHkxID0gYXhpc1RvcDtcblx0XHRcdFx0eTIgPSBjSGVpZ2h0IC0gYXhpcy5ib3R0b207XG5cdFx0XHRcdHgxID0geDIgPSBiZXR3ZWVuKHgxLCBheGlzTGVmdCwgYXhpc0xlZnQgKyBheGlzLndpZHRoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgxID0gYXhpc0xlZnQ7XG5cdFx0XHRcdHgyID0gY1dpZHRoIC0gYXhpcy5yaWdodDtcblx0XHRcdFx0eTEgPSB5MiA9IGJldHdlZW4oeTEsIGF4aXNUb3AsIGF4aXNUb3AgKyBheGlzLmhlaWdodCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2tpcCAmJiAhZm9yY2UgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0Y2hhcnQucmVuZGVyZXIuY3Jpc3BMaW5lKFtNLCB4MSwgeTEsIEwsIHgyLCB5Ml0sIGxpbmVXaWR0aCB8fCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiBhIGxpbmVhciBheGlzIHRvIHJvdW5kIHZhbHVlcyBsaWtlIHdob2xlIHRlbnMgb3IgZXZlcnkgZml2ZS5cblx0XHQgKi9cblx0XHRnZXRMaW5lYXJUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAodGlja0ludGVydmFsLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIHBvcyxcblx0XHRcdFx0bGFzdFBvcyxcblx0XHRcdFx0cm91bmRlZE1pbiA9IGNvcnJlY3RGbG9hdChtYXRoRmxvb3IobWluIC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdHJvdW5kZWRNYXggPSBjb3JyZWN0RmxvYXQobWF0aENlaWwobWF4IC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBbXTtcblxuXHRcdFx0Ly8gRm9yIHNpbmdsZSBwb2ludHMsIGFkZCBhIHRpY2sgcmVnYXJkbGVzcyBvZiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gKCMyNjYyKVxuXHRcdFx0aWYgKG1pbiA9PT0gbWF4ICYmIGlzTnVtYmVyKG1pbikpIHtcblx0XHRcdFx0cmV0dXJuIFttaW5dO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQb3B1bGF0ZSB0aGUgaW50ZXJtZWRpYXRlIHZhbHVlc1xuXHRcdFx0cG9zID0gcm91bmRlZE1pbjtcblx0XHRcdHdoaWxlIChwb3MgPD0gcm91bmRlZE1heCkge1xuXG5cdFx0XHRcdC8vIFBsYWNlIHRoZSB0aWNrIG9uIHRoZSByb3VuZGVkIHZhbHVlXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaChwb3MpO1xuXG5cdFx0XHRcdC8vIEFsd2F5cyBhZGQgdGhlIHJhdyB0aWNrSW50ZXJ2YWwsIG5vdCB0aGUgY29ycmVjdGVkIG9uZS5cblx0XHRcdFx0cG9zID0gY29ycmVjdEZsb2F0KHBvcyArIHRpY2tJbnRlcnZhbCk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGludGVydmFsIGlzIG5vdCBiaWcgZW5vdWdoIGluIHRoZSBjdXJyZW50IG1pbiAtIG1heCByYW5nZSB0byBhY3R1YWxseSBpbmNyZWFzZVxuXHRcdFx0XHQvLyB0aGUgbG9vcCB2YXJpYWJsZSwgd2UgbmVlZCB0byBicmVhayBvdXQgdG8gcHJldmVudCBlbmRsZXNzIGxvb3AuIElzc3VlICM2MTlcblx0XHRcdFx0aWYgKHBvcyA9PT0gbGFzdFBvcykge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjb3JkIHRoZSBsYXN0IHZhbHVlXG5cdFx0XHRcdGxhc3RQb3MgPSBwb3M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGlja1Bvc2l0aW9ucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBtaW5vciB0aWNrIHBvc2l0aW9ucy4gRm9yIGxvZ2FyaXRobWljIGF4ZXMsIHJldXNlIHRoZSBzYW1lIGxvZ2ljXG5cdFx0ICogYXMgZm9yIG1ham9yIHRpY2tzLlxuXHRcdCAqL1xuXHRcdGdldE1pbm9yVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHRtaW5vclRpY2tJbnRlcnZhbCA9IGF4aXMubWlub3JUaWNrSW50ZXJ2YWwsXG5cdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IFtdLFxuXHRcdFx0XHRwb3MsXG5cdFx0XHRcdGksXG5cdFx0XHRcdG1pbiA9IGF4aXMubWluLFxuXHRcdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdFx0cmFuZ2UgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGxlbjtcblxuXHRcdFx0Ly8gSWYgbWlub3IgdGlja3MgZ2V0IHRvbyBkZW5zZSwgdGhleSBhcmUgaGFyZCB0byByZWFkLCBhbmQgbWF5IGNhdXNlIGxvbmcgcnVubmluZyBzY3JpcHQuIFNvIHdlIGRvbid0IGRyYXcgdGhlbS5cblx0XHRcdGlmIChyYW5nZSAmJiByYW5nZSAvIG1pbm9yVGlja0ludGVydmFsIDwgYXhpcy5sZW4gLyAzKSB7IC8vICMzODc1XG5cblx0XHRcdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0XHRsZW4gPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdGF4aXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyhtaW5vclRpY2tJbnRlcnZhbCwgdGlja1Bvc2l0aW9uc1tpIC0gMV0sIHRpY2tQb3NpdGlvbnNbaV0sIHRydWUpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChheGlzLmlzRGF0ZXRpbWVBeGlzICYmIG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWwgPT09ICdhdXRvJykgeyAvLyAjMTMxNFxuXHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0XHRheGlzLmdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHRcdFx0YXhpcy5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKG1pbm9yVGlja0ludGVydmFsKSxcblx0XHRcdFx0XHRcdFx0bWluLFxuXHRcdFx0XHRcdFx0XHRtYXgsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RhcnRPZldlZWtcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAocG9zID0gbWluICsgKHRpY2tQb3NpdGlvbnNbMF0gLSBtaW4pICUgbWlub3JUaWNrSW50ZXJ2YWw7IHBvcyA8PSBtYXg7IHBvcyArPSBtaW5vclRpY2tJbnRlcnZhbCkge1xuXHRcdFx0XHRcdFx0bWlub3JUaWNrUG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YXhpcy50cmltVGlja3MobWlub3JUaWNrUG9zaXRpb25zKTsgLy8gIzM2NTIgIzM3NDNcblx0XHRcdHJldHVybiBtaW5vclRpY2tQb3NpdGlvbnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkanVzdCB0aGUgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc2VyaWVzIGRhdGEgaXNcblx0XHQgKiBub3QgeWV0IHByb2Nlc3NlZCwgc28gd2UgZG9uJ3QgaGF2ZSBpbmZvcm1hdGlvbiBvbiBkYXRhIGNyb3BwaW5nIGFuZCBncm91cGluZywgb3Jcblx0XHQgKiB1cGRhdGVkIGF4aXMucG9pbnRSYW5nZSBvciBzZXJpZXMucG9pbnRSYW5nZS4gVGhlIGRhdGEgY2FuJ3QgYmUgcHJvY2Vzc2VkIHVudGlsXG5cdFx0ICogd2UgaGF2ZSBmaW5hbGx5IGVzdGFibGlzaGVkIG1pbiBhbmQgbWF4LlxuXHRcdCAqL1xuXHRcdGFkanVzdEZvck1pblJhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdG1pbiA9IGF4aXMubWluLFxuXHRcdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdFx0em9vbU9mZnNldCxcblx0XHRcdFx0c3BhY2VBdmFpbGFibGUgPSBheGlzLmRhdGFNYXggLSBheGlzLmRhdGFNaW4gPj0gYXhpcy5taW5SYW5nZSxcblx0XHRcdFx0Y2xvc2VzdERhdGFSYW5nZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdHhEYXRhLFxuXHRcdFx0XHRsb29wTGVuZ3RoLFxuXHRcdFx0XHRtaW5BcmdzLFxuXHRcdFx0XHRtYXhBcmdzO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGF1dG9tYXRpYyBtaW5pbXVtIHJhbmdlIGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGRpc3RhbmNlXG5cdFx0XHRpZiAoYXhpcy5pc1hBeGlzICYmIGF4aXMubWluUmFuZ2UgPT09IFVOREVGSU5FRCAmJiAhYXhpcy5pc0xvZykge1xuXG5cdFx0XHRcdGlmIChkZWZpbmVkKG9wdGlvbnMubWluKSB8fCBkZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuXHRcdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBudWxsOyAvLyBkb24ndCBkbyB0aGlzIGFnYWluXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiByYXcgZGF0YSBwb2ludHMsIGFzIG9wcG9zZWQgdG9cblx0XHRcdFx0XHQvLyBjbG9zZXN0UG9pbnRSYW5nZSB0aGF0IGFwcGxpZXMgdG8gcHJvY2Vzc2VkIHBvaW50cyAoY3JvcHBlZCBhbmQgZ3JvdXBlZClcblx0XHRcdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRcdGxvb3BMZW5ndGggPSBzZXJpZXMueEluY3JlbWVudCA/IDEgOiB4RGF0YS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gbG9vcExlbmd0aDsgaSA+IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHhEYXRhW2ldIC0geERhdGFbaSAtIDFdO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2xvc2VzdERhdGFSYW5nZSA9PT0gVU5ERUZJTkVEIHx8IGRpc3RhbmNlIDwgY2xvc2VzdERhdGFSYW5nZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REYXRhUmFuZ2UgPSBkaXN0YW5jZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBtYXRoTWluKGNsb3Nlc3REYXRhUmFuZ2UgKiA1LCBheGlzLmRhdGFNYXggLSBheGlzLmRhdGFNaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIG1pblJhbmdlIGlzIGV4Y2VlZGVkLCBhZGp1c3Rcblx0XHRcdGlmIChtYXggLSBtaW4gPCBheGlzLm1pblJhbmdlKSB7XG5cdFx0XHRcdHZhciBtaW5SYW5nZSA9IGF4aXMubWluUmFuZ2U7XG5cdFx0XHRcdHpvb21PZmZzZXQgPSAobWluUmFuZ2UgLSBtYXggKyBtaW4pIC8gMjtcblxuXHRcdFx0XHQvLyBpZiBtaW4gYW5kIG1heCBvcHRpb25zIGhhdmUgYmVlbiBzZXQsIGRvbid0IGdvIGJleW9uZCBpdFxuXHRcdFx0XHRtaW5BcmdzID0gW21pbiAtIHpvb21PZmZzZXQsIHBpY2sob3B0aW9ucy5taW4sIG1pbiAtIHpvb21PZmZzZXQpXTtcblx0XHRcdFx0aWYgKHNwYWNlQXZhaWxhYmxlKSB7IC8vIGlmIHNwYWNlIGlzIGF2YWlsYWJsZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRtaW5BcmdzWzJdID0gYXhpcy5kYXRhTWluO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1pbiA9IGFycmF5TWF4KG1pbkFyZ3MpO1xuXG5cdFx0XHRcdG1heEFyZ3MgPSBbbWluICsgbWluUmFuZ2UsIHBpY2sob3B0aW9ucy5tYXgsIG1pbiArIG1pblJhbmdlKV07XG5cdFx0XHRcdGlmIChzcGFjZUF2YWlsYWJsZSkgeyAvLyBpZiBzcGFjZSBpcyBhdmFpbGFiZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRtYXhBcmdzWzJdID0gYXhpcy5kYXRhTWF4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF4ID0gYXJyYXlNaW4obWF4QXJncyk7XG5cblx0XHRcdFx0Ly8gbm93IGlmIHRoZSBtYXggaXMgYWRqdXN0ZWQsIGFkanVzdCB0aGUgbWluIGJhY2tcblx0XHRcdFx0aWYgKG1heCAtIG1pbiA8IG1pblJhbmdlKSB7XG5cdFx0XHRcdFx0bWluQXJnc1swXSA9IG1heCAtIG1pblJhbmdlO1xuXHRcdFx0XHRcdG1pbkFyZ3NbMV0gPSBwaWNrKG9wdGlvbnMubWluLCBtYXggLSBtaW5SYW5nZSk7XG5cdFx0XHRcdFx0bWluID0gYXJyYXlNYXgobWluQXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIG1vZGlmaWVkIGV4dHJlbWVzXG5cdFx0XHRheGlzLm1pbiA9IG1pbjtcblx0XHRcdGF4aXMubWF4ID0gbWF4O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdHJhbnNsYXRpb24gaW5mb3JtYXRpb25cblx0XHQgKi9cblx0XHRzZXRBeGlzVHJhbnNsYXRpb246IGZ1bmN0aW9uIChzYXZlT2xkKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHJhbmdlID0gYXhpcy5tYXggLSBheGlzLm1pbixcblx0XHRcdFx0cG9pbnRSYW5nZSA9IGF4aXMuYXhpc1BvaW50UmFuZ2UgfHwgMCxcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gMCxcblx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSAwLFxuXHRcdFx0XHRsaW5rZWRQYXJlbnQgPSBheGlzLmxpbmtlZFBhcmVudCxcblx0XHRcdFx0b3JkaW5hbENvcnJlY3Rpb24sXG5cdFx0XHRcdGhhc0NhdGVnb3JpZXMgPSAhIWF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdFx0dHJhbnNBID0gYXhpcy50cmFuc0EsXG5cdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXM7XG5cblx0XHRcdC8vIEFkanVzdCB0cmFuc2xhdGlvbiBmb3IgcGFkZGluZy4gWSBheGlzIHdpdGggY2F0ZWdvcmllcyBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHNhbWUgKCMxNzg0KS5cblx0XHRcdGlmIChpc1hBeGlzIHx8IGhhc0NhdGVnb3JpZXMgfHwgcG9pbnRSYW5nZSkge1xuXHRcdFx0XHRpZiAobGlua2VkUGFyZW50KSB7XG5cdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSBsaW5rZWRQYXJlbnQubWluUG9pbnRPZmZzZXQ7XG5cdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSBsaW5rZWRQYXJlbnQucG9pbnRSYW5nZVBhZGRpbmc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2VyaWVzUG9pbnRSYW5nZSA9IGhhc0NhdGVnb3JpZXMgPyAxIDogKGlzWEF4aXMgPyBzZXJpZXMucG9pbnRSYW5nZSA6IChheGlzLmF4aXNQb2ludFJhbmdlIHx8IDApKSwgLy8gIzI4MDZcblx0XHRcdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBzZXJpZXMub3B0aW9ucy5wb2ludFBsYWNlbWVudCxcblx0XHRcdFx0XHRcdFx0c2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UgPSBzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2U7XG5cblx0XHRcdFx0XHRcdGlmIChzZXJpZXNQb2ludFJhbmdlID4gcmFuZ2UpIHsgLy8gIzE0NDZcblx0XHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRSYW5nZSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludFJhbmdlID0gbWF0aE1heChwb2ludFJhbmdlLCBzZXJpZXNQb2ludFJhbmdlKTtcblxuXHRcdFx0XHRcdFx0aWYgKCFheGlzLnNpbmdsZSkge1xuXHRcdFx0XHRcdFx0XHQvLyBtaW5Qb2ludE9mZnNldCBpcyB0aGUgdmFsdWUgcGFkZGluZyB0byB0aGUgbGVmdCBvZiB0aGUgYXhpcyBpbiBvcmRlciB0byBtYWtlXG5cdFx0XHRcdFx0XHRcdC8vIHJvb20gZm9yIHBvaW50cyB3aXRoIGEgcG9pbnRSYW5nZSwgdHlwaWNhbGx5IGNvbHVtbnMuIFdoZW4gdGhlIHBvaW50UGxhY2VtZW50IG9wdGlvblxuXHRcdFx0XHRcdFx0XHQvLyBpcyAnYmV0d2Vlbicgb3IgJ29uJywgdGhpcyBwYWRkaW5nIGRvZXMgbm90IGFwcGx5LlxuXHRcdFx0XHRcdFx0XHRtaW5Qb2ludE9mZnNldCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQsXG5cdFx0XHRcdFx0XHRcdFx0aXNTdHJpbmcocG9pbnRQbGFjZW1lbnQpID8gMCA6IHNlcmllc1BvaW50UmFuZ2UgLyAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSB0b3RhbCBwYWRkaW5nIG5lZWRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBheGlzIHRvIG1ha2Ugcm9vbSBmb3IgdGhlXG5cdFx0XHRcdFx0XHRcdC8vIHBvaW50UmFuZ2UuIElmIHRoZSBzZXJpZXMnIHBvaW50UGxhY2VtZW50IGlzICdvbicsIG5vIHBhZGRpbmcgaXMgYWRkZWQuXG5cdFx0XHRcdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gbWF0aE1heChcblx0XHRcdFx0XHRcdFx0XHRwb2ludFJhbmdlUGFkZGluZyxcblx0XHRcdFx0XHRcdFx0XHRwb2ludFBsYWNlbWVudCA9PT0gJ29uJyA/IDAgOiBzZXJpZXNQb2ludFJhbmdlXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFNldCB0aGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdFx0XHRcdGlmICghc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCAmJiBkZWZpbmVkKHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlKSkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IGRlZmluZWQoY2xvc2VzdFBvaW50UmFuZ2UpID9cblx0XHRcdFx0XHRcdFx0XHRtYXRoTWluKGNsb3Nlc3RQb2ludFJhbmdlLCBzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZSkgOlxuXHRcdFx0XHRcdFx0XHRcdHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjb3JkIG1pblBvaW50T2Zmc2V0IGFuZCBwb2ludFJhbmdlUGFkZGluZ1xuXHRcdFx0XHRvcmRpbmFsQ29ycmVjdGlvbiA9IGF4aXMub3JkaW5hbFNsb3BlICYmIGNsb3Nlc3RQb2ludFJhbmdlID8gYXhpcy5vcmRpbmFsU2xvcGUgLyBjbG9zZXN0UG9pbnRSYW5nZSA6IDE7IC8vICM5ODgsICMxODUzXG5cdFx0XHRcdGF4aXMubWluUG9pbnRPZmZzZXQgPSBtaW5Qb2ludE9mZnNldCA9IG1pblBvaW50T2Zmc2V0ICogb3JkaW5hbENvcnJlY3Rpb247XG5cdFx0XHRcdGF4aXMucG9pbnRSYW5nZVBhZGRpbmcgPSBwb2ludFJhbmdlUGFkZGluZyA9IHBvaW50UmFuZ2VQYWRkaW5nICogb3JkaW5hbENvcnJlY3Rpb247XG5cblx0XHRcdFx0Ly8gcG9pbnRSYW5nZSBtZWFucyB0aGUgd2lkdGggcmVzZXJ2ZWQgZm9yIGVhY2ggcG9pbnQsIGxpa2UgaW4gYSBjb2x1bW4gY2hhcnRcblx0XHRcdFx0YXhpcy5wb2ludFJhbmdlID0gbWF0aE1pbihwb2ludFJhbmdlLCByYW5nZSk7XG5cblx0XHRcdFx0Ly8gY2xvc2VzdFBvaW50UmFuZ2UgbWVhbnMgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMuIEluIGNvbHVtbnNcblx0XHRcdFx0Ly8gaXQgaXMgbW9zdGx5IGVxdWFsIHRvIHBvaW50UmFuZ2UsIGJ1dCBpbiBsaW5lcyBwb2ludFJhbmdlIGlzIDAgd2hpbGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdFx0Ly8gaXMgc29tZSBvdGhlciB2YWx1ZVxuXHRcdFx0XHRpZiAoaXNYQXhpcykge1xuXHRcdFx0XHRcdGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWNvbmRhcnkgdmFsdWVzXG5cdFx0XHRpZiAoc2F2ZU9sZCkge1xuXHRcdFx0XHRheGlzLm9sZFRyYW5zQSA9IHRyYW5zQTtcblx0XHRcdH1cblx0XHRcdGF4aXMudHJhbnNsYXRpb25TbG9wZSA9IGF4aXMudHJhbnNBID0gdHJhbnNBID0gYXhpcy5sZW4gLyAoKHJhbmdlICsgcG9pbnRSYW5nZVBhZGRpbmcpIHx8IDEpO1xuXHRcdFx0YXhpcy50cmFuc0IgPSBheGlzLmhvcml6ID8gYXhpcy5sZWZ0IDogYXhpcy5ib3R0b207IC8vIHRyYW5zbGF0aW9uIGFkZGVuZFxuXHRcdFx0YXhpcy5taW5QaXhlbFBhZGRpbmcgPSB0cmFuc0EgKiBtaW5Qb2ludE9mZnNldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byByb3VuZCB2YWx1ZXMgYW5kIG9wdGlvbmFsbHkgZXh0ZW5kIHRoZSBleHRyZW1lc1xuXHRcdCAqIHRvIHRoZSBuZWFyZXN0IHRpY2tcblx0XHQgKi9cblx0XHRzZXRUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uIChzZWNvbmRQYXNzKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nLFxuXHRcdFx0XHRpc0RhdGV0aW1lQXhpcyA9IGF4aXMuaXNEYXRldGltZUF4aXMsXG5cdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXMsXG5cdFx0XHRcdGlzTGlua2VkID0gYXhpcy5pc0xpbmtlZCxcblx0XHRcdFx0bWF4UGFkZGluZyA9IG9wdGlvbnMubWF4UGFkZGluZyxcblx0XHRcdFx0bWluUGFkZGluZyA9IG9wdGlvbnMubWluUGFkZGluZyxcblx0XHRcdFx0bGVuZ3RoLFxuXHRcdFx0XHRsaW5rZWRQYXJlbnRFeHRyZW1lcyxcblx0XHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrSW50ZXJ2YWwsXG5cdFx0XHRcdG1pblRpY2tJbnRlcnZhbCxcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLnRpY2tQaXhlbEludGVydmFsLFxuXHRcdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzO1xuXG5cdFx0XHRpZiAoIWlzRGF0ZXRpbWVBeGlzICYmICFjYXRlZ29yaWVzICYmICFpc0xpbmtlZCkge1xuXHRcdFx0XHR0aGlzLmdldFRpY2tBbW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbGlua2VkIGF4aXMgZ2V0cyB0aGUgZXh0cmVtZXMgZnJvbSB0aGUgcGFyZW50IGF4aXNcblx0XHRcdGlmIChpc0xpbmtlZCkge1xuXHRcdFx0XHRheGlzLmxpbmtlZFBhcmVudCA9IGNoYXJ0W2F4aXMuY29sbF1bb3B0aW9ucy5saW5rZWRUb107XG5cdFx0XHRcdGxpbmtlZFBhcmVudEV4dHJlbWVzID0gYXhpcy5saW5rZWRQYXJlbnQuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0YXhpcy5taW4gPSBwaWNrKGxpbmtlZFBhcmVudEV4dHJlbWVzLm1pbiwgbGlua2VkUGFyZW50RXh0cmVtZXMuZGF0YU1pbik7XG5cdFx0XHRcdGF4aXMubWF4ID0gcGljayhsaW5rZWRQYXJlbnRFeHRyZW1lcy5tYXgsIGxpbmtlZFBhcmVudEV4dHJlbWVzLmRhdGFNYXgpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy50eXBlICE9PSBheGlzLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUpIHtcblx0XHRcdFx0XHRlcnJvcigxMSwgMSk7IC8vIENhbid0IGxpbmsgYXhlcyBvZiBkaWZmZXJlbnQgdHlwZVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgeyAvLyBpbml0aWFsIG1pbiBhbmQgbWF4IGZyb20gdGhlIGV4dHJlbWUgZGF0YSB2YWx1ZXNcblx0XHRcdFx0YXhpcy5taW4gPSBwaWNrKGF4aXMudXNlck1pbiwgb3B0aW9ucy5taW4sIGF4aXMuZGF0YU1pbik7XG5cdFx0XHRcdGF4aXMubWF4ID0gcGljayhheGlzLnVzZXJNYXgsIG9wdGlvbnMubWF4LCBheGlzLmRhdGFNYXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNMb2cpIHtcblx0XHRcdFx0aWYgKCFzZWNvbmRQYXNzICYmIG1hdGhNaW4oYXhpcy5taW4sIHBpY2soYXhpcy5kYXRhTWluLCBheGlzLm1pbikpIDw9IDApIHsgLy8gIzk3OFxuXHRcdFx0XHRcdGVycm9yKDEwLCAxKTsgLy8gQ2FuJ3QgcGxvdCBuZWdhdGl2ZSB2YWx1ZXMgb24gbG9nIGF4aXNcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUaGUgY29ycmVjdEZsb2F0IGN1cmVzICM5MzQsIGZsb2F0IGVycm9ycyBvbiBmdWxsIHRlbnMuIEJ1dCBpdFxuXHRcdFx0XHQvLyB3YXMgdG9vIGFnZ3Jlc3NpdmUgZm9yICM0MzYwIGJlY2F1c2Ugb2YgY29udmVyc2lvbiBiYWNrIHRvIGxpbixcblx0XHRcdFx0Ly8gdGhlcmVmb3JlIHVzZSBwcmVjaXNpb24gMTUuXG5cdFx0XHRcdGF4aXMubWluID0gY29ycmVjdEZsb2F0KGxvZzJsaW4oYXhpcy5taW4pLCAxNSk7XG5cdFx0XHRcdGF4aXMubWF4ID0gY29ycmVjdEZsb2F0KGxvZzJsaW4oYXhpcy5tYXgpLCAxNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSB6b29tZWQgcmFuZ2Vcblx0XHRcdGlmIChheGlzLnJhbmdlICYmIGRlZmluZWQoYXhpcy5tYXgpKSB7XG5cdFx0XHRcdGF4aXMudXNlck1pbiA9IGF4aXMubWluID0gbWF0aE1heChheGlzLm1pbiwgYXhpcy5tYXggLSBheGlzLnJhbmdlKTsgLy8gIzYxOFxuXHRcdFx0XHRheGlzLnVzZXJNYXggPSBheGlzLm1heDtcblxuXHRcdFx0XHRheGlzLnJhbmdlID0gbnVsbDsgIC8vIGRvbid0IHVzZSBpdCB3aGVuIHJ1bm5pbmcgc2V0RXh0cmVtZXNcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBmb3IgYWRqdXN0aW5nIHRoaXMubWluIGFuZCB0aGlzLm1heC4gVXNlZCBieSBidWJibGUgc2VyaWVzLlxuXHRcdFx0aWYgKGF4aXMuYmVmb3JlUGFkZGluZykge1xuXHRcdFx0XHRheGlzLmJlZm9yZVBhZGRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IG1pbiBhbmQgbWF4IGZvciB0aGUgbWluaW11bSByYW5nZVxuXHRcdFx0YXhpcy5hZGp1c3RGb3JNaW5SYW5nZSgpO1xuXG5cdFx0XHQvLyBQYWQgdGhlIHZhbHVlcyB0byBnZXQgY2xlYXIgb2YgdGhlIGNoYXJ0J3MgZWRnZXMuIFRvIGF2b2lkIHRpY2tJbnRlcnZhbCB0YWtpbmcgdGhlIHBhZGRpbmdcblx0XHRcdC8vIGludG8gYWNjb3VudCwgd2UgZG8gdGhpcyBhZnRlciBjb21wdXRpbmcgdGljayBpbnRlcnZhbCAoIzEzMzcpLlxuXHRcdFx0aWYgKCFjYXRlZ29yaWVzICYmICFheGlzLmF4aXNQb2ludFJhbmdlICYmICFheGlzLnVzZVBlcmNlbnRhZ2UgJiYgIWlzTGlua2VkICYmIGRlZmluZWQoYXhpcy5taW4pICYmIGRlZmluZWQoYXhpcy5tYXgpKSB7XG5cdFx0XHRcdGxlbmd0aCA9IGF4aXMubWF4IC0gYXhpcy5taW47XG5cdFx0XHRcdGlmIChsZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAoIWRlZmluZWQob3B0aW9ucy5taW4pICYmICFkZWZpbmVkKGF4aXMudXNlck1pbikgJiYgbWluUGFkZGluZyAmJiAoYXhpcy5kYXRhTWluIDwgMCB8fCAhYXhpcy5pZ25vcmVNaW5QYWRkaW5nKSkge1xuXHRcdFx0XHRcdFx0YXhpcy5taW4gLT0gbGVuZ3RoICogbWluUGFkZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFkZWZpbmVkKG9wdGlvbnMubWF4KSAmJiAhZGVmaW5lZChheGlzLnVzZXJNYXgpICAmJiBtYXhQYWRkaW5nICYmIChheGlzLmRhdGFNYXggPiAwIHx8ICFheGlzLmlnbm9yZU1heFBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0XHRheGlzLm1heCArPSBsZW5ndGggKiBtYXhQYWRkaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF5IHdpdGhpbiBmbG9vciBhbmQgY2VpbGluZ1xuXHRcdFx0aWYgKGlzTnVtYmVyKG9wdGlvbnMuZmxvb3IpKSB7XG5cdFx0XHRcdGF4aXMubWluID0gbWF0aE1heChheGlzLm1pbiwgb3B0aW9ucy5mbG9vcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNOdW1iZXIob3B0aW9ucy5jZWlsaW5nKSkge1xuXHRcdFx0XHRheGlzLm1heCA9IG1hdGhNaW4oYXhpcy5tYXgsIG9wdGlvbnMuY2VpbGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aWNrSW50ZXJ2YWxcblx0XHRcdGlmIChheGlzLm1pbiA9PT0gYXhpcy5tYXggfHwgYXhpcy5taW4gPT09IHVuZGVmaW5lZCB8fCBheGlzLm1heCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWQgJiYgIXRpY2tJbnRlcnZhbE9wdGlvbiAmJlxuXHRcdFx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID09PSBheGlzLmxpbmtlZFBhcmVudC5vcHRpb25zLnRpY2tQaXhlbEludGVydmFsKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gdGlja0ludGVydmFsT3B0aW9uID0gYXhpcy5saW5rZWRQYXJlbnQudGlja0ludGVydmFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBwaWNrKFxuXHRcdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0XHR0aGlzLnRpY2tBbW91bnQgPyAoKGF4aXMubWF4IC0gYXhpcy5taW4pIC8gbWF0aE1heCh0aGlzLnRpY2tBbW91bnQgLSAxLCAxKSkgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0Y2F0ZWdvcmllcyA/IC8vIGZvciBjYXRlZ29yaWVkIGF4aXMsIDEgaXMgZGVmYXVsdCwgZm9yIGxpbmVhciBheGlzIHVzZSB0aWNrUGl4XG5cdFx0XHRcdFx0XHQxIDpcblx0XHRcdFx0XHRcdC8vIGRvbid0IGxldCBpdCBiZSBtb3JlIHRoYW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRcdChheGlzLm1heCAtIGF4aXMubWluKSAqIHRpY2tQaXhlbEludGVydmFsT3B0aW9uIC8gbWF0aE1heChheGlzLmxlbiwgdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdyB3ZSdyZSBmaW5pc2hlZCBkZXRlY3RpbmcgbWluIGFuZCBtYXgsIGNyb3AgYW5kIGdyb3VwIHNlcmllcyBkYXRhLiBUaGlzXG5cdFx0XHQvLyBpcyBpbiB0dXJuIG5lZWRlZCBpbiBvcmRlciB0byBmaW5kIHRpY2sgcG9zaXRpb25zIGluIG9yZGluYWwgYXhlcy5cblx0XHRcdGlmIChpc1hBeGlzICYmICFzZWNvbmRQYXNzKSB7XG5cdFx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHRzZXJpZXMucHJvY2Vzc0RhdGEoYXhpcy5taW4gIT09IGF4aXMub2xkTWluIHx8IGF4aXMubWF4ICE9PSBheGlzLm9sZE1heCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgdGhlIHRyYW5zbGF0aW9uIGZhY3RvciB1c2VkIGluIHRyYW5zbGF0ZSBmdW5jdGlvblxuXHRcdFx0YXhpcy5zZXRBeGlzVHJhbnNsYXRpb24odHJ1ZSk7XG5cblx0XHRcdC8vIGhvb2sgZm9yIG9yZGluYWwgYXhlcyBhbmQgcmFkaWFsIGF4ZXNcblx0XHRcdGlmIChheGlzLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMpIHtcblx0XHRcdFx0YXhpcy5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhvb2sgZm9yIGV4dGVuc2lvbnMsIHVzZWQgaW4gSGlnaHN0b2NrIG9yZGluYWwgYXhlc1xuXHRcdFx0aWYgKGF4aXMucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLnBvc3RQcm9jZXNzVGlja0ludGVydmFsKGF4aXMudGlja0ludGVydmFsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW4gY29sdW1uLWxpa2UgY2hhcnRzLCBkb24ndCBjcmFtcCBpbiBtb3JlIHRpY2tzIHRoYW4gdGhlcmUgYXJlIHBvaW50cyAoIzE5NDMpXG5cdFx0XHRpZiAoYXhpcy5wb2ludFJhbmdlKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gbWF0aE1heChheGlzLnBvaW50UmFuZ2UsIGF4aXMudGlja0ludGVydmFsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQmVmb3JlIG5vcm1hbGl6aW5nIHRoZSB0aWNrIGludGVydmFsLCBoYW5kbGUgbWluaW11bSB0aWNrIGludGVydmFsLiBUaGlzIGFwcGxpZXMgb25seSBpZiB0aWNrSW50ZXJ2YWwgaXMgbm90IGRlZmluZWQuXG5cdFx0XHRtaW5UaWNrSW50ZXJ2YWwgPSBwaWNrKG9wdGlvbnMubWluVGlja0ludGVydmFsLCBheGlzLmlzRGF0ZXRpbWVBeGlzICYmIGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UpO1xuXHRcdFx0aWYgKCF0aWNrSW50ZXJ2YWxPcHRpb24gJiYgYXhpcy50aWNrSW50ZXJ2YWwgPCBtaW5UaWNrSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtaW5UaWNrSW50ZXJ2YWw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBsaW5lYXIgYXhlcywgZ2V0IG1hZ25pdHVkZSBhbmQgbm9ybWFsaXplIHRoZSBpbnRlcnZhbFxuXHRcdFx0aWYgKCFpc0RhdGV0aW1lQXhpcyAmJiAhaXNMb2cgJiYgIXRpY2tJbnRlcnZhbE9wdGlvbikge1xuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChcblx0XHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCwgXG5cdFx0XHRcdFx0bnVsbCwgXG5cdFx0XHRcdFx0Z2V0TWFnbml0dWRlKGF4aXMudGlja0ludGVydmFsKSwgXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHRpY2sgaW50ZXJ2YWwgaXMgYmV0d2VlbiAwLjUgYW5kIDUgYW5kIHRoZSBheGlzIG1heCBpcyBpbiB0aGUgb3JkZXIgb2Zcblx0XHRcdFx0XHQvLyB0aG91c2FuZHMsIGNoYW5jZXMgYXJlIHdlIGFyZSBkZWFsaW5nIHdpdGggeWVhcnMuIERvbid0IGFsbG93IGRlY2ltYWxzLiAjMzM2My5cblx0XHRcdFx0XHRwaWNrKG9wdGlvbnMuYWxsb3dEZWNpbWFscywgIShheGlzLnRpY2tJbnRlcnZhbCA+IDAuNSAmJiBheGlzLnRpY2tJbnRlcnZhbCA8IDUgJiYgYXhpcy5tYXggPiAxMDAwICYmIGF4aXMubWF4IDwgOTk5OSkpLFxuXHRcdFx0XHRcdCEhdGhpcy50aWNrQW1vdW50XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFByZXZlbnQgdGlja3MgZnJvbSBnZXR0aW5nIHNvIGNsb3NlIHRoYXQgd2UgY2FuJ3QgZHJhdyB0aGUgbGFiZWxzXG5cdFx0XHRpZiAoIXRoaXMudGlja0Ftb3VudCAmJiB0aGlzLmxlbikgeyAvLyBDb2xvciBheGlzIHdpdGggZGlzYWJsZWQgbGVnZW5kIGhhcyBubyBsZW5ndGhcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLnVuc3F1aXNoKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOb3cgd2UgaGF2ZSBjb21wdXRlZCB0aGUgbm9ybWFsaXplZCB0aWNrSW50ZXJ2YWwsIGdldCB0aGUgdGljayBwb3NpdGlvbnNcblx0XHQgKi9cblx0XHRzZXRUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zT3B0aW9uID0gb3B0aW9ucy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25lciA9IG9wdGlvbnMudGlja1Bvc2l0aW9uZXIsXG5cdFx0XHRcdHN0YXJ0T25UaWNrID0gb3B0aW9ucy5zdGFydE9uVGljayxcblx0XHRcdFx0ZW5kT25UaWNrID0gb3B0aW9ucy5lbmRPblRpY2ssXG5cdFx0XHRcdHNpbmdsZTtcblxuXHRcdFx0Ly8gU2V0IHRoZSB0aWNrbWFya09mZnNldFxuXHRcdFx0dGhpcy50aWNrbWFya09mZnNldCA9ICh0aGlzLmNhdGVnb3JpZXMgJiYgb3B0aW9ucy50aWNrbWFya1BsYWNlbWVudCA9PT0gJ2JldHdlZW4nICYmIFxuXHRcdFx0XHR0aGlzLnRpY2tJbnRlcnZhbCA9PT0gMSkgPyAwLjUgOiAwOyAvLyAjMzIwMlxuXG5cblx0XHRcdC8vIGdldCBtaW5vclRpY2tJbnRlcnZhbFxuXHRcdFx0dGhpcy5taW5vclRpY2tJbnRlcnZhbCA9IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWwgPT09ICdhdXRvJyAmJiB0aGlzLnRpY2tJbnRlcnZhbCA/XG5cdFx0XHRcdHRoaXMudGlja0ludGVydmFsIC8gNSA6IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWw7XG5cblx0XHRcdC8vIEZpbmQgdGhlIHRpY2sgcG9zaXRpb25zXG5cdFx0XHR0aGlzLnRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9uc09wdGlvbiAmJiB0aWNrUG9zaXRpb25zT3B0aW9uLnNsaWNlKCk7IC8vIFdvcmsgb24gYSBjb3B5ICgjMTU2NSlcblx0XHRcdGlmICghdGlja1Bvc2l0aW9ucykge1xuXG5cdFx0XHRcdGlmICh0aGlzLmlzRGF0ZXRpbWVBeGlzKSB7XG5cdFx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMuZ2V0VGltZVRpY2tzKFxuXHRcdFx0XHRcdFx0dGhpcy5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKHRoaXMudGlja0ludGVydmFsLCBvcHRpb25zLnVuaXRzKSxcblx0XHRcdFx0XHRcdHRoaXMubWluLFxuXHRcdFx0XHRcdFx0dGhpcy5tYXgsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0YXJ0T2ZXZWVrLFxuXHRcdFx0XHRcdFx0dGhpcy5vcmRpbmFsUG9zaXRpb25zLFxuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRSYW5nZSxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNMb2cpIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25zID0gdGhpcy5nZXRMb2dUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsIHRoaXMubWluLCB0aGlzLm1heCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25zO1xuXG5cdFx0XHRcdC8vIFJ1biB0aGUgdGljayBwb3NpdGlvbmVyIGNhbGxiYWNrLCB0aGF0IGFsbG93cyBtb2RpZnlpbmcgYXV0byB0aWNrIHBvc2l0aW9ucy5cblx0XHRcdFx0aWYgKHRpY2tQb3NpdGlvbmVyKSB7XG5cdFx0XHRcdFx0dGlja1Bvc2l0aW9uZXIgPSB0aWNrUG9zaXRpb25lci5hcHBseSh0aGlzLCBbdGhpcy5taW4sIHRoaXMubWF4XSk7XG5cdFx0XHRcdFx0aWYgKHRpY2tQb3NpdGlvbmVyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9uZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmlzTGlua2VkKSB7XG5cblx0XHRcdFx0Ly8gcmVzZXQgbWluL21heCBvciByZW1vdmUgZXh0cmVtZXMgYmFzZWQgb24gc3RhcnQvZW5kIG9uIHRpY2tcblx0XHRcdFx0dGhpcy50cmltVGlja3ModGlja1Bvc2l0aW9ucywgc3RhcnRPblRpY2ssIGVuZE9uVGljayk7XG5cblx0XHRcdFx0Ly8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludCwgb3IgYWxsIHBvaW50cyBoYXZlIHRoZSBzYW1lIHZhbHVlIG9uIHRoaXMgYXhpcywgdGhlbiBtaW5cblx0XHRcdFx0Ly8gYW5kIG1heCBhcmUgZXF1YWwgYW5kIHRpY2tQb3NpdGlvbnMubGVuZ3RoIGlzIDAgb3IgMS4gSW4gdGhpcyBjYXNlLCBhZGQgc29tZSBwYWRkaW5nXG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIGNlbnRlciB0aGUgcG9pbnQsIGJ1dCBsZWF2ZSBpdCB3aXRoIG9uZSB0aWNrLiAjMTMzNy5cblx0XHRcdFx0aWYgKHRoaXMubWluID09PSB0aGlzLm1heCAmJiBkZWZpbmVkKHRoaXMubWluKSAmJiAhdGhpcy50aWNrQW1vdW50KSB7XG5cdFx0XHRcdFx0Ly8gU3Vic3RyYWN0IGhhbGYgYSB1bml0ICgjMjYxOSwgIzI4NDYsICMyNTE1LCAjMzM5MClcblx0XHRcdFx0XHRzaW5nbGUgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMubWluIC09IDAuNTtcblx0XHRcdFx0XHR0aGlzLm1heCArPSAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zaW5nbGUgPSBzaW5nbGU7XG5cblx0XHRcdFx0aWYgKCF0aWNrUG9zaXRpb25zT3B0aW9uICYmICF0aWNrUG9zaXRpb25lcikge1xuXHRcdFx0XHRcdHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSBzdGFydE9uVGljayBhbmQgZW5kT25UaWNrIGJ5IGVpdGhlciBhZGFwdGluZyB0byBwYWRkaW5nIG1pbi9tYXggb3Igcm91bmRlZCBtaW4vbWF4XG5cdFx0ICovXG5cdFx0dHJpbVRpY2tzOiBmdW5jdGlvbiAodGlja1Bvc2l0aW9ucywgc3RhcnRPblRpY2ssIGVuZE9uVGljaykge1xuXHRcdFx0dmFyIHJvdW5kZWRNaW4gPSB0aWNrUG9zaXRpb25zWzBdLFxuXHRcdFx0XHRyb3VuZGVkTWF4ID0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRtaW5Qb2ludE9mZnNldCA9IHRoaXMubWluUG9pbnRPZmZzZXQgfHwgMDtcblx0XHRcdFx0XG5cdFx0XHRpZiAoc3RhcnRPblRpY2spIHtcblx0XHRcdFx0dGhpcy5taW4gPSByb3VuZGVkTWluO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm1pbiAtIG1pblBvaW50T2Zmc2V0ID4gcm91bmRlZE1pbikge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlbmRPblRpY2spIHtcblx0XHRcdFx0dGhpcy5tYXggPSByb3VuZGVkTWF4O1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm1heCArIG1pblBvaW50T2Zmc2V0IDwgcm91bmRlZE1heCkge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnBvcCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBubyB0aWNrIGFyZSBsZWZ0LCBzZXQgb25lIHRpY2sgaW4gdGhlIG1pZGRsZSAoIzMxOTUpIFxuXHRcdFx0aWYgKHRpY2tQb3NpdGlvbnMubGVuZ3RoID09PSAwICYmIGRlZmluZWQocm91bmRlZE1pbikpIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucy5wdXNoKChyb3VuZGVkTWF4ICsgcm91bmRlZE1pbikgLyAyKTtcblx0XHRcdH1cdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgbWF4IHRpY2tzIG9mIGVpdGhlciB0aGUgeCBhbmQgeSBheGlzIGNvbGxlY3Rpb25cblx0XHQgKi9cblx0XHRnZXRUaWNrQW1vdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgb3RoZXJzID0ge30sIC8vIFdoZXRoZXIgdGhlcmUgaXMgYW5vdGhlciBheGlzIHRvIHBhaXIgd2l0aCB0aGlzIG9uZVxuXHRcdFx0XHRoYXNPdGhlcixcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dGlja0Ftb3VudCA9IG9wdGlvbnMudGlja0Ftb3VudCxcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWwgPSBvcHRpb25zLnRpY2tQaXhlbEludGVydmFsO1xuXG5cdFx0XHRpZiAoIWRlZmluZWQob3B0aW9ucy50aWNrSW50ZXJ2YWwpICYmIHRoaXMubGVuIDwgdGlja1BpeGVsSW50ZXJ2YWwgJiYgIXRoaXMuaXNSYWRpYWwgJiZcblx0XHRcdFx0XHQhdGhpcy5pc0xvZyAmJiBvcHRpb25zLnN0YXJ0T25UaWNrICYmIG9wdGlvbnMuZW5kT25UaWNrKSB7XG5cdFx0XHRcdHRpY2tBbW91bnQgPSAyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRpY2tBbW91bnQgJiYgdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3MgIT09IGZhbHNlICYmIG9wdGlvbnMuYWxpZ25UaWNrcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGF4ZXMgaW4gdGhlIHNhbWUgcGFuZVxuXHRcdFx0XHRlYWNoKHRoaXMuY2hhcnRbdGhpcy5jb2xsXSwgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHR2YXIgb3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0XHRcdGtleSA9IFtob3JpeiA/IG9wdGlvbnMubGVmdCA6IG9wdGlvbnMudG9wLCBob3JpeiA/IG9wdGlvbnMud2lkdGggOiBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5wYW5lXS5qb2luKCcsJyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG90aGVyc1trZXldKSB7XG5cdFx0XHRcdFx0XHRpZiAoYXhpcy5zZXJpZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGhhc090aGVyID0gdHJ1ZTsgLy8gIzQyMDFcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3RoZXJzW2tleV0gPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGhhc090aGVyKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIDEgYmVjYXVzZSA0IHRpY2sgaW50ZXJ2YWxzIHJlcXVpcmUgNSB0aWNrcyAoaW5jbHVkaW5nIGZpcnN0IGFuZCBsYXN0KVxuXHRcdFx0XHRcdHRpY2tBbW91bnQgPSBtYXRoQ2VpbCh0aGlzLmxlbiAvIHRpY2tQaXhlbEludGVydmFsKSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIHRpY2sgYW1vdW50cyBvZiAyIGFuZCAzLCBjb21wdXRlIGZpdmUgdGlja3MgYW5kIHJlbW92ZSB0aGUgaW50ZXJtZWRpYXRlIG9uZXMuIFRoaXNcblx0XHRcdC8vIHByZXZlbnRzIHRoZSBheGlzIGZyb20gYWRkaW5nIHRpY2tzIHRoYXQgYXJlIHRvbyBmYXIgYXdheSBmcm9tIHRoZSBkYXRhIGV4dHJlbWVzLlxuXHRcdFx0aWYgKHRpY2tBbW91bnQgPCA0KSB7XG5cdFx0XHRcdHRoaXMuZmluYWxUaWNrQW10ID0gdGlja0Ftb3VudDtcblx0XHRcdFx0dGlja0Ftb3VudCA9IDU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMudGlja0Ftb3VudCA9IHRpY2tBbW91bnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdXNpbmcgbXVsdGlwbGUgYXhlcywgYWRqdXN0IHRoZSBudW1iZXIgb2YgdGlja3MgdG8gbWF0Y2ggdGhlIGhpZ2hlc3Rcblx0XHQgKiBudW1iZXIgb2YgdGlja3MgaW4gdGhhdCBncm91cFxuXHRcdCAqL1xuXHRcdGFkanVzdFRpY2tBbW91bnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja0Ftb3VudCA9IHRoaXMudGlja0Ftb3VudCxcblx0XHRcdFx0ZmluYWxUaWNrQW10ID0gdGhpcy5maW5hbFRpY2tBbXQsXG5cdFx0XHRcdGN1cnJlbnRUaWNrQW1vdW50ID0gdGlja1Bvc2l0aW9ucyAmJiB0aWNrUG9zaXRpb25zLmxlbmd0aCxcblx0XHRcdFx0aSxcblx0XHRcdFx0bGVuO1xuXG5cdFx0XHRpZiAoY3VycmVudFRpY2tBbW91bnQgPCB0aWNrQW1vdW50KSB7IC8vIFRPRE86IENoZWNrICMzNDExXG5cdFx0XHRcdHdoaWxlICh0aWNrUG9zaXRpb25zLmxlbmd0aCA8IHRpY2tBbW91bnQpIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2goY29ycmVjdEZsb2F0KFxuXHRcdFx0XHRcdFx0dGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdICsgdGlja0ludGVydmFsXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc0EgKj0gKGN1cnJlbnRUaWNrQW1vdW50IC0gMSkgLyAodGlja0Ftb3VudCAtIDEpO1xuXHRcdFx0XHR0aGlzLm1heCA9IHRpY2tQb3NpdGlvbnNbdGlja1Bvc2l0aW9ucy5sZW5ndGggLSAxXTtcblxuXHRcdFx0Ly8gV2UgaGF2ZSB0b28gbWFueSB0aWNrcywgcnVuIHNlY29uZCBwYXNzIHRvIHRyeSB0byByZWR1Y2UgdGlja3Ncblx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFRpY2tBbW91bnQgPiB0aWNrQW1vdW50KSB7XG5cdFx0XHRcdHRoaXMudGlja0ludGVydmFsICo9IDI7XG5cdFx0XHRcdHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZmluYWxUaWNrQW10IHByb3BlcnR5IGlzIHNldCBpbiBnZXRUaWNrQW1vdW50XG5cdFx0XHRpZiAoZGVmaW5lZChmaW5hbFRpY2tBbXQpKSB7XG5cdFx0XHRcdGkgPSBsZW4gPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdChmaW5hbFRpY2tBbXQgPT09IDMgJiYgaSAlIDIgPT09IDEpIHx8IC8vIFJlbW92ZSBldmVyeSBvdGhlciB0aWNrXG5cdFx0XHRcdFx0XHQoZmluYWxUaWNrQW10IDw9IDIgJiYgaSA+IDAgJiYgaSA8IGxlbiAtIDEpIC8vIFJlbW92ZSBhbGwgYnV0IGZpcnN0IGFuZCBsYXN0XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aWNrUG9zaXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpbmFsVGlja0FtdCA9IFVOREVGSU5FRDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzY2FsZSBiYXNlZCBvbiBkYXRhIG1pbiBhbmQgbWF4LCB1c2VyIHNldCBtaW4gYW5kIG1heCBvciBvcHRpb25zXG5cdFx0ICpcblx0XHQgKi9cblx0XHRzZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRpc0RpcnR5RGF0YSxcblx0XHRcdFx0aXNEaXJ0eUF4aXNMZW5ndGg7XG5cblx0XHRcdGF4aXMub2xkTWluID0gYXhpcy5taW47XG5cdFx0XHRheGlzLm9sZE1heCA9IGF4aXMubWF4O1xuXHRcdFx0YXhpcy5vbGRBeGlzTGVuZ3RoID0gYXhpcy5sZW47XG5cblx0XHRcdC8vIHNldCB0aGUgbmV3IGF4aXNMZW5ndGhcblx0XHRcdGF4aXMuc2V0QXhpc1NpemUoKTtcblx0XHRcdC8vYXhpc0xlbmd0aCA9IGhvcml6ID8gYXhpc1dpZHRoIDogYXhpc0hlaWdodDtcblx0XHRcdGlzRGlydHlBeGlzTGVuZ3RoID0gYXhpcy5sZW4gIT09IGF4aXMub2xkQXhpc0xlbmd0aDtcblxuXHRcdFx0Ly8gaXMgdGhlcmUgbmV3IGRhdGE/XG5cdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdGlmIChzZXJpZXMuaXNEaXJ0eURhdGEgfHwgc2VyaWVzLmlzRGlydHkgfHxcblx0XHRcdFx0XHRcdHNlcmllcy54QXhpcy5pc0RpcnR5KSB7IC8vIHdoZW4geCBheGlzIGlzIGRpcnR5LCB3ZSBuZWVkIG5ldyBkYXRhIGV4dHJlbWVzIGZvciB5IGFzIHdlbGxcblx0XHRcdFx0XHRpc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkbyB3ZSByZWFsbHkgbmVlZCB0byBnbyB0aHJvdWdoIGFsbCB0aGlzP1xuXHRcdFx0aWYgKGlzRGlydHlBeGlzTGVuZ3RoIHx8IGlzRGlydHlEYXRhIHx8IGF4aXMuaXNMaW5rZWQgfHwgYXhpcy5mb3JjZVJlZHJhdyB8fFxuXHRcdFx0XHRheGlzLnVzZXJNaW4gIT09IGF4aXMub2xkVXNlck1pbiB8fCBheGlzLnVzZXJNYXggIT09IGF4aXMub2xkVXNlck1heCkge1xuXG5cdFx0XHRcdGlmIChheGlzLnJlc2V0U3RhY2tzKSB7XG5cdFx0XHRcdFx0YXhpcy5yZXNldFN0YWNrcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXhpcy5mb3JjZVJlZHJhdyA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGdldCBkYXRhIGV4dHJlbWVzIGlmIG5lZWRlZFxuXHRcdFx0XHRheGlzLmdldFNlcmllc0V4dHJlbWVzKCk7XG5cblx0XHRcdFx0Ly8gZ2V0IGZpeGVkIHBvc2l0aW9ucyBiYXNlZCBvbiB0aWNrSW50ZXJ2YWxcblx0XHRcdFx0YXhpcy5zZXRUaWNrSW50ZXJ2YWwoKTtcblxuXHRcdFx0XHQvLyByZWNvcmQgb2xkIHZhbHVlcyB0byBkZWNpZGUgd2hldGhlciBhIHJlc2NhbGUgaXMgbmVjZXNzYXJ5IGxhdGVyIG9uICgjNTQwKVxuXHRcdFx0XHRheGlzLm9sZFVzZXJNaW4gPSBheGlzLnVzZXJNaW47XG5cdFx0XHRcdGF4aXMub2xkVXNlck1heCA9IGF4aXMudXNlck1heDtcblxuXHRcdFx0XHQvLyBNYXJrIGFzIGRpcnR5IGlmIGl0IGlzIG5vdCBhbHJlYWR5IHNldCB0byBkaXJ0eSBhbmQgZXh0cmVtZXMgaGF2ZSBjaGFuZ2VkLiAjNTk1LlxuXHRcdFx0XHRpZiAoIWF4aXMuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGlzRGlydHlBeGlzTGVuZ3RoIHx8IGF4aXMubWluICE9PSBheGlzLm9sZE1pbiB8fCBheGlzLm1heCAhPT0gYXhpcy5vbGRNYXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXhpcy5jbGVhblN0YWNrcykge1xuXHRcdFx0XHRheGlzLmNsZWFuU3RhY2tzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgZXh0cmVtZXMgYW5kIG9wdGlvbmFsbHkgcmVkcmF3XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG5ld01pblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNYXhcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhd1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3VtZW50c1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0c2V0RXh0cmVtZXM6IGZ1bmN0aW9uIChuZXdNaW4sIG5ld01heCwgcmVkcmF3LCBhbmltYXRpb24sIGV2ZW50QXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydDtcblxuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpOyAvLyBkZWZhdWx0cyB0byB0cnVlXG5cblx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRkZWxldGUgc2VyaWUua2RUcmVlO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYXJndW1lbnRzIHdpdGggbWluIGFuZCBtYXhcblx0XHRcdGV2ZW50QXJndW1lbnRzID0gZXh0ZW5kKGV2ZW50QXJndW1lbnRzLCB7XG5cdFx0XHRcdG1pbjogbmV3TWluLFxuXHRcdFx0XHRtYXg6IG5ld01heFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEZpcmUgdGhlIGV2ZW50XG5cdFx0XHRmaXJlRXZlbnQoYXhpcywgJ3NldEV4dHJlbWVzJywgZXZlbnRBcmd1bWVudHMsIGZ1bmN0aW9uICgpIHsgLy8gdGhlIGRlZmF1bHQgZXZlbnQgaGFuZGxlclxuXG5cdFx0XHRcdGF4aXMudXNlck1pbiA9IG5ld01pbjtcblx0XHRcdFx0YXhpcy51c2VyTWF4ID0gbmV3TWF4O1xuXHRcdFx0XHRheGlzLmV2ZW50QXJncyA9IGV2ZW50QXJndW1lbnRzO1xuXG5cdFx0XHRcdC8vIE1hcmsgZm9yIHJ1bm5pbmcgYWZ0ZXJTZXRFeHRyZW1lc1xuXHRcdFx0XHRheGlzLmlzRGlydHlFeHRyZW1lcyA9IHRydWU7XG5cblx0XHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3Igem9vbWluZyBjaGFydC4gUHVsbGVkIG91dCBpbiBhIHNlcGFyYXRlIG1ldGhvZCB0byBhbGxvdyBvdmVycmlkaW5nXG5cdFx0ICogaW4gc3RvY2sgY2hhcnRzLlxuXHRcdCAqL1xuXHRcdHpvb206IGZ1bmN0aW9uIChuZXdNaW4sIG5ld01heCkge1xuXHRcdFx0dmFyIGRhdGFNaW4gPSB0aGlzLmRhdGFNaW4sXG5cdFx0XHRcdGRhdGFNYXggPSB0aGlzLmRhdGFNYXgsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRcdC8vIFByZXZlbnQgcGluY2ggem9vbWluZyBvdXQgb2YgcmFuZ2UuIENoZWNrIGZvciBkZWZpbmVkIGlzIGZvciAjMTk0Ni4gIzE3MzQuXG5cdFx0XHRpZiAoIXRoaXMuYWxsb3dab29tT3V0c2lkZSkge1xuXHRcdFx0XHRpZiAoZGVmaW5lZChkYXRhTWluKSAmJiBuZXdNaW4gPD0gbWF0aE1pbihkYXRhTWluLCBwaWNrKG9wdGlvbnMubWluLCBkYXRhTWluKSkpIHtcblx0XHRcdFx0XHRuZXdNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRlZmluZWQoZGF0YU1heCkgJiYgbmV3TWF4ID49IG1hdGhNYXgoZGF0YU1heCwgcGljayhvcHRpb25zLm1heCwgZGF0YU1heCkpKSB7XG5cdFx0XHRcdFx0bmV3TWF4ID0gVU5ERUZJTkVEO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIGZ1bGwgdmlldywgZGlzcGxheWluZyB0aGUgcmVzZXQgem9vbSBidXR0b24gaXMgbm90IHJlcXVpcmVkXG5cdFx0XHR0aGlzLmRpc3BsYXlCdG4gPSBuZXdNaW4gIT09IFVOREVGSU5FRCB8fCBuZXdNYXggIT09IFVOREVGSU5FRDtcblxuXHRcdFx0Ly8gRG8gaXRcblx0XHRcdHRoaXMuc2V0RXh0cmVtZXMoXG5cdFx0XHRcdG5ld01pbixcblx0XHRcdFx0bmV3TWF4LFxuXHRcdFx0XHRmYWxzZSxcblx0XHRcdFx0VU5ERUZJTkVELFxuXHRcdFx0XHR7IHRyaWdnZXI6ICd6b29tJyB9XG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgYXhpcyBtZXRyaWNzXG5cdFx0ICovXG5cdFx0c2V0QXhpc1NpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdG9mZnNldExlZnQgPSBvcHRpb25zLm9mZnNldExlZnQgfHwgMCxcblx0XHRcdFx0b2Zmc2V0UmlnaHQgPSBvcHRpb25zLm9mZnNldFJpZ2h0IHx8IDAsXG5cdFx0XHRcdGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdFx0d2lkdGggPSBwaWNrKG9wdGlvbnMud2lkdGgsIGNoYXJ0LnBsb3RXaWR0aCAtIG9mZnNldExlZnQgKyBvZmZzZXRSaWdodCksXG5cdFx0XHRcdGhlaWdodCA9IHBpY2sob3B0aW9ucy5oZWlnaHQsIGNoYXJ0LnBsb3RIZWlnaHQpLFxuXHRcdFx0XHR0b3AgPSBwaWNrKG9wdGlvbnMudG9wLCBjaGFydC5wbG90VG9wKSxcblx0XHRcdFx0bGVmdCA9IHBpY2sob3B0aW9ucy5sZWZ0LCBjaGFydC5wbG90TGVmdCArIG9mZnNldExlZnQpLFxuXHRcdFx0XHRwZXJjZW50UmVnZXggPSAvJSQvO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgcGVyY2VudGFnZSBiYXNlZCBpbnB1dCB2YWx1ZXNcblx0XHRcdGlmIChwZXJjZW50UmVnZXgudGVzdChoZWlnaHQpKSB7XG5cdFx0XHRcdGhlaWdodCA9IHBhcnNlRmxvYXQoaGVpZ2h0KSAvIDEwMCAqIGNoYXJ0LnBsb3RIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGVyY2VudFJlZ2V4LnRlc3QodG9wKSkge1xuXHRcdFx0XHR0b3AgPSBwYXJzZUZsb2F0KHRvcCkgLyAxMDAgKiBjaGFydC5wbG90SGVpZ2h0ICsgY2hhcnQucGxvdFRvcDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRXhwb3NlIGJhc2ljIHZhbHVlcyB0byB1c2UgaW4gU2VyaWVzIG9iamVjdCBhbmQgbmF2aWdhdG9yXG5cdFx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdFx0dGhpcy50b3AgPSB0b3A7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMuYm90dG9tID0gY2hhcnQuY2hhcnRIZWlnaHQgLSBoZWlnaHQgLSB0b3A7XG5cdFx0XHR0aGlzLnJpZ2h0ID0gY2hhcnQuY2hhcnRXaWR0aCAtIHdpZHRoIC0gbGVmdDtcblxuXHRcdFx0Ly8gRGlyZWN0aW9uIGFnbm9zdGljIHByb3BlcnRpZXNcblx0XHRcdHRoaXMubGVuID0gbWF0aE1heChob3JpeiA/IHdpZHRoIDogaGVpZ2h0LCAwKTsgLy8gbWF0aE1heCBmaXhlcyAjOTA1XG5cdFx0XHR0aGlzLnBvcyA9IGhvcml6ID8gbGVmdCA6IHRvcDsgLy8gZGlzdGFuY2UgZnJvbSBTVkcgb3JpZ2luXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgYWN0dWFsIGF4aXMgZXh0cmVtZXNcblx0XHQgKi9cblx0XHRnZXRFeHRyZW1lczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2c7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1pbjogaXNMb2cgPyBjb3JyZWN0RmxvYXQobGluMmxvZyhheGlzLm1pbikpIDogYXhpcy5taW4sXG5cdFx0XHRcdG1heDogaXNMb2cgPyBjb3JyZWN0RmxvYXQobGluMmxvZyhheGlzLm1heCkpIDogYXhpcy5tYXgsXG5cdFx0XHRcdGRhdGFNaW46IGF4aXMuZGF0YU1pbixcblx0XHRcdFx0ZGF0YU1heDogYXhpcy5kYXRhTWF4LFxuXHRcdFx0XHR1c2VyTWluOiBheGlzLnVzZXJNaW4sXG5cdFx0XHRcdHVzZXJNYXg6IGF4aXMudXNlck1heFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSB6ZXJvIHBsYW5lIGVpdGhlciBiYXNlZCBvbiB6ZXJvIG9yIG9uIHRoZSBtaW4gb3IgbWF4IHZhbHVlLlxuXHRcdCAqIFVzZWQgaW4gYmFyIGFuZCBhcmVhIHBsb3RzXG5cdFx0ICovXG5cdFx0Z2V0VGhyZXNob2xkOiBmdW5jdGlvbiAodGhyZXNob2xkKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdFx0cmVhbE1pbiA9IGlzTG9nID8gbGluMmxvZyhheGlzLm1pbikgOiBheGlzLm1pbixcblx0XHRcdFx0cmVhbE1heCA9IGlzTG9nID8gbGluMmxvZyhheGlzLm1heCkgOiBheGlzLm1heDtcblxuXHRcdFx0Ly8gV2l0aCBhIHRocmVzaG9sZCBvZiBudWxsLCBtYWtlIHRoZSBjb2x1bW5zL2FyZWFzIHJpc2UgZnJvbSB0aGUgdG9wIG9yIGJvdHRvbSBcblx0XHRcdC8vIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGFzc3VtaW5nIGFuIGFjdHVhbCB0aHJlc2hvbGQgb2YgMCAoIzQyMzMpLlxuXHRcdFx0aWYgKHRocmVzaG9sZCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJlc2hvbGQgPSByZWFsTWF4IDwgMCA/IHJlYWxNYXggOiByZWFsTWluO1xuXHRcdFx0fSBlbHNlIGlmIChyZWFsTWluID4gdGhyZXNob2xkKSB7XG5cdFx0XHRcdHRocmVzaG9sZCA9IHJlYWxNaW47XG5cdFx0XHR9IGVsc2UgaWYgKHJlYWxNYXggPCB0aHJlc2hvbGQpIHtcblx0XHRcdFx0dGhyZXNob2xkID0gcmVhbE1heDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGF4aXMudHJhbnNsYXRlKHRocmVzaG9sZCwgMCwgMSwgMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbXB1dGUgYXV0byBhbGlnbm1lbnQgZm9yIHRoZSBheGlzIGxhYmVsIGJhc2VkIG9uIHdoaWNoIHNpZGUgdGhlIGF4aXMgaXMgb25cblx0XHQgKiBhbmQgdGhlIGdpdmVuIHJvdGF0aW9uIGZvciB0aGUgbGFiZWxcblx0XHQgKi9cblx0XHRhdXRvTGFiZWxBbGlnbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRhbmdsZSA9IChwaWNrKHJvdGF0aW9uLCAwKSAtICh0aGlzLnNpZGUgKiA5MCkgKyA3MjApICUgMzYwO1xuXG5cdFx0XHRpZiAoYW5nbGUgPiAxNSAmJiBhbmdsZSA8IDE2NSkge1xuXHRcdFx0XHRyZXQgPSAncmlnaHQnO1xuXHRcdFx0fSBlbHNlIGlmIChhbmdsZSA+IDE5NSAmJiBhbmdsZSA8IDM0NSkge1xuXHRcdFx0XHRyZXQgPSAnbGVmdCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQgPSAnY2VudGVyJztcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnQgdGhlIHRpY2tzIGZyb20gZ2V0dGluZyBzbyBjbG9zZSB3ZSBjYW4ndCBkcmF3IHRoZSBsYWJlbHMuIE9uIGEgaG9yaXpvbnRhbFxuXHRcdCAqIGF4aXMsIHRoaXMgaXMgaGFuZGxlZCBieSByb3RhdGluZyB0aGUgbGFiZWxzLCByZW1vdmluZyB0aWNrcyBhbmQgYWRkaW5nIGVsbGlwc2lzLiBcblx0XHQgKiBPbiBhIHZlcnRpY2FsIGF4aXMgcmVtb3ZlIHRpY2tzIGFuZCBhZGQgZWxsaXBzaXMuXG5cdFx0ICovXG5cdFx0dW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHRpY2tzID0gdGhpcy50aWNrcyxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gdGhpcy5vcHRpb25zLmxhYmVscyxcblx0XHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHR0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcblx0XHRcdFx0bmV3VGlja0ludGVydmFsID0gdGlja0ludGVydmFsLFxuXHRcdFx0XHRzbG90U2l6ZSA9IHRoaXMubGVuIC8gKCgodGhpcy5jYXRlZ29yaWVzID8gMSA6IDApICsgdGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0XHRyb3RhdGlvbixcblx0XHRcdFx0cm90YXRpb25PcHRpb24gPSBsYWJlbE9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRcdGxhYmVsTWV0cmljcyA9IGNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGxhYmVsT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGlja3NbMF0gJiYgdGlja3NbMF0ubGFiZWwpLFxuXHRcdFx0XHRzdGVwLFxuXHRcdFx0XHRiZXN0U2NvcmUgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuXHRcdFx0XHRhdXRvUm90YXRpb24sXG5cdFx0XHRcdC8vIFJldHVybiB0aGUgbXVsdGlwbGUgb2YgdGlja0ludGVydmFsIHRoYXQgaXMgbmVlZGVkIHRvIGF2b2lkIGNvbGxpc2lvblxuXHRcdFx0XHRnZXRTdGVwID0gZnVuY3Rpb24gKHNwYWNlTmVlZGVkKSB7XG5cdFx0XHRcdFx0dmFyIHN0ZXAgPSBzcGFjZU5lZWRlZCAvIChzbG90U2l6ZSB8fCAxKTtcblx0XHRcdFx0XHRzdGVwID0gc3RlcCA+IDEgPyBtYXRoQ2VpbChzdGVwKSA6IDE7XG5cdFx0XHRcdFx0cmV0dXJuIHN0ZXAgKiB0aWNrSW50ZXJ2YWw7XG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChob3Jpeikge1xuXHRcdFx0XHRhdXRvUm90YXRpb24gPSBkZWZpbmVkKHJvdGF0aW9uT3B0aW9uKSA/IFxuXHRcdFx0XHRcdFtyb3RhdGlvbk9wdGlvbl0gOlxuXHRcdFx0XHRcdHNsb3RTaXplIDwgcGljayhsYWJlbE9wdGlvbnMuYXV0b1JvdGF0aW9uTGltaXQsIDgwKSAmJiAhbGFiZWxPcHRpb25zLnN0YWdnZXJMaW5lcyAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgbGFiZWxPcHRpb25zLmF1dG9Sb3RhdGlvbjtcblxuXHRcdFx0XHRpZiAoYXV0b1JvdGF0aW9uKSB7XG5cblx0XHRcdFx0XHQvLyBMb29wIG92ZXIgdGhlIGdpdmVuIGF1dG9Sb3RhdGlvbiBvcHRpb25zLCBhbmQgZGV0ZXJtaW5lIHdoaWNoIGdpdmVzIHRoZSBiZXN0IHNjb3JlLiBUaGUgXG5cdFx0XHRcdFx0Ly8gYmVzdCBzY29yZSBpcyB0aGF0IHdpdGggdGhlIGxvd2VzdCBudW1iZXIgb2Ygc3RlcHMgYW5kIGEgcm90YXRpb24gY2xvc2VzdCB0byBob3Jpem9udGFsLlxuXHRcdFx0XHRcdGVhY2goYXV0b1JvdGF0aW9uLCBmdW5jdGlvbiAocm90KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2NvcmU7XG5cblx0XHRcdFx0XHRcdGlmIChyb3QgPT09IHJvdGF0aW9uT3B0aW9uIHx8IChyb3QgJiYgcm90ID49IC05MCAmJiByb3QgPD0gOTApKSB7IC8vICMzODkxXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0c3RlcCA9IGdldFN0ZXAobWF0aEFicyhsYWJlbE1ldHJpY3MuaCAvIG1hdGhTaW4oZGVnMnJhZCAqIHJvdCkpKTtcblxuXHRcdFx0XHRcdFx0XHRzY29yZSA9IHN0ZXAgKyBtYXRoQWJzKHJvdCAvIDM2MCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG5cdFx0XHRcdFx0XHRcdFx0YmVzdFNjb3JlID0gc2NvcmU7XG5cdFx0XHRcdFx0XHRcdFx0cm90YXRpb24gPSByb3Q7XG5cdFx0XHRcdFx0XHRcdFx0bmV3VGlja0ludGVydmFsID0gc3RlcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1RpY2tJbnRlcnZhbCA9IGdldFN0ZXAobGFiZWxNZXRyaWNzLmgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dG9Sb3RhdGlvbiA9IGF1dG9Sb3RhdGlvbjtcblx0XHRcdHRoaXMubGFiZWxSb3RhdGlvbiA9IHJvdGF0aW9uO1xuXG5cdFx0XHRyZXR1cm4gbmV3VGlja0ludGVydmFsO1xuXHRcdH0sXG5cblx0XHRyZW5kZXJVbnNxdWlzaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja3MgPSB0aGlzLnRpY2tzLFxuXHRcdFx0XHRsYWJlbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHRcdG1hcmdpbiA9IGNoYXJ0Lm1hcmdpbixcblx0XHRcdFx0c2xvdENvdW50ID0gdGhpcy5jYXRlZ29yaWVzID8gdGlja1Bvc2l0aW9ucy5sZW5ndGggOiB0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDEsXG5cdFx0XHRcdHNsb3RXaWR0aCA9IHRoaXMuc2xvdFdpZHRoID0gKGhvcml6ICYmICFsYWJlbE9wdGlvbnMuc3RlcCAmJiAhbGFiZWxPcHRpb25zLnJvdGF0aW9uICYmXG5cdFx0XHRcdFx0KCh0aGlzLnN0YWdnZXJMaW5lcyB8fCAxKSAqIGNoYXJ0LnBsb3RXaWR0aCkgLyBzbG90Q291bnQpIHx8XG5cdFx0XHRcdFx0KCFob3JpeiAmJiAoKG1hcmdpblszXSAmJiAobWFyZ2luWzNdIC0gY2hhcnQuc3BhY2luZ1szXSkpIHx8IGNoYXJ0LmNoYXJ0V2lkdGggKiAwLjMzKSksIC8vICMxNTgwLCAjMTkzMSxcblx0XHRcdFx0aW5uZXJXaWR0aCA9IG1hdGhNYXgoMSwgbWF0aFJvdW5kKHNsb3RXaWR0aCAtIDIgKiAobGFiZWxPcHRpb25zLnBhZGRpbmcgfHwgNSkpKSxcblx0XHRcdFx0YXR0ciA9IHt9LFxuXHRcdFx0XHRsYWJlbE1ldHJpY3MgPSByZW5kZXJlci5mb250TWV0cmljcyhsYWJlbE9wdGlvbnMuc3R5bGUuZm9udFNpemUsIHRpY2tzWzBdICYmIHRpY2tzWzBdLmxhYmVsKSxcblx0XHRcdFx0dGV4dE92ZXJmbG93T3B0aW9uID0gbGFiZWxPcHRpb25zLnN0eWxlLnRleHRPdmVyZmxvdyxcblx0XHRcdFx0Y3NzLFxuXHRcdFx0XHRsYWJlbExlbmd0aCA9IDAsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb3M7XG5cblx0XHRcdC8vIFNldCByb3RhdGlvbiBvcHRpb24gdW5sZXNzIGl0IGlzIFwiYXV0b1wiLCBsaWtlIGluIGdhdWdlc1xuXHRcdFx0aWYgKCFpc1N0cmluZyhsYWJlbE9wdGlvbnMucm90YXRpb24pKSB7XG5cdFx0XHRcdGF0dHIucm90YXRpb24gPSBsYWJlbE9wdGlvbnMucm90YXRpb247XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEhhbmRsZSBhdXRvIHJvdGF0aW9uIG9uIGhvcml6b250YWwgYXhpc1xuXHRcdFx0aWYgKHRoaXMuYXV0b1JvdGF0aW9uKSB7XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBsb25nZXN0IGxhYmVsIGxlbmd0aFxuXHRcdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uICh0aWNrKSB7XG5cdFx0XHRcdFx0dGljayA9IHRpY2tzW3RpY2tdO1xuXHRcdFx0XHRcdGlmICh0aWNrICYmIHRpY2subGFiZWxMZW5ndGggPiBsYWJlbExlbmd0aCkge1xuXHRcdFx0XHRcdFx0bGFiZWxMZW5ndGggPSB0aWNrLmxhYmVsTGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBcHBseSByb3RhdGlvbiBvbmx5IGlmIHRoZSBsYWJlbCBpcyB0b28gd2lkZSBmb3IgdGhlIHNsb3QsIGFuZFxuXHRcdFx0XHQvLyB0aGUgbGFiZWwgaXMgd2lkZXIgdGhhbiBpdHMgaGVpZ2h0LlxuXHRcdFx0XHRpZiAobGFiZWxMZW5ndGggPiBpbm5lcldpZHRoICYmIGxhYmVsTGVuZ3RoID4gbGFiZWxNZXRyaWNzLmgpIHtcblx0XHRcdFx0XHRhdHRyLnJvdGF0aW9uID0gdGhpcy5sYWJlbFJvdGF0aW9uO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubGFiZWxSb3RhdGlvbiA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHdvcmQtd3JhcCBvciBlbGxpcHNpcyBvbiB2ZXJ0aWNhbCBheGlzXG5cdFx0XHR9IGVsc2UgaWYgKHNsb3RXaWR0aCkge1xuXHRcdFx0XHQvLyBGb3Igd29yZC13cmFwIG9yIGVsbGlwc2lzXG5cdFx0XHRcdGNzcyA9IHsgd2lkdGg6IGlubmVyV2lkdGggKyBQWCB9O1xuXG5cdFx0XHRcdGlmICghdGV4dE92ZXJmbG93T3B0aW9uKSB7XG5cdFx0XHRcdFx0Y3NzLnRleHRPdmVyZmxvdyA9ICdjbGlwJztcblxuXHRcdFx0XHRcdC8vIE9uIHZlcnRpY2FsIGF4aXMsIG9ubHkgYWxsb3cgd29yZCB3cmFwIGlmIHRoZXJlIGlzIHJvb20gZm9yIG1vcmUgbGluZXMuXG5cdFx0XHRcdFx0aSA9IHRpY2tQb3NpdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICghaG9yaXogJiYgaS0tKSB7XG5cdFx0XHRcdFx0XHRwb3MgPSB0aWNrUG9zaXRpb25zW2ldO1xuXHRcdFx0XHRcdFx0bGFiZWwgPSB0aWNrc1twb3NdLmxhYmVsO1xuXHRcdFx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IGVsbGlwc2lzIGluIG9yZGVyIHRvIGdldCB0aGUgY29ycmVjdCBib3VuZGluZyBib3ggKCM0MDcwKVxuXHRcdFx0XHRcdFx0XHRpZiAobGFiZWwuc3R5bGVzLnRleHRPdmVyZmxvdyA9PT0gJ2VsbGlwc2lzJykge1xuXHRcdFx0XHRcdFx0XHRcdGxhYmVsLmNzcyh7IHRleHRPdmVyZmxvdzogJ2NsaXAnIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChsYWJlbC5nZXRCQm94KCkuaGVpZ2h0ID4gdGhpcy5sZW4gLyB0aWNrUG9zaXRpb25zLmxlbmd0aCAtIChsYWJlbE1ldHJpY3MuaCAtIGxhYmVsTWV0cmljcy5mKSkge1xuXHRcdFx0XHRcdFx0XHRcdGxhYmVsLnNwZWNDc3MgPSB7IHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyB9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gQWRkIGVsbGlwc2lzIGlmIHRoZSBsYWJlbCBsZW5ndGggaXMgc2lnbmlmaWNhbnRseSBsb25nZXIgdGhhbiBpZGVhbFxuXHRcdFx0aWYgKGF0dHIucm90YXRpb24pIHtcblx0XHRcdFx0Y3NzID0geyBcblx0XHRcdFx0XHR3aWR0aDogKGxhYmVsTGVuZ3RoID4gY2hhcnQuY2hhcnRIZWlnaHQgKiAwLjUgPyBjaGFydC5jaGFydEhlaWdodCAqIDAuMzMgOiBjaGFydC5jaGFydEhlaWdodCkgKyBQWFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIXRleHRPdmVyZmxvd09wdGlvbikge1xuXHRcdFx0XHRcdGNzcy50ZXh0T3ZlcmZsb3cgPSAnZWxsaXBzaXMnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZXhwbGljaXQgb3IgYXV0b21hdGljIGxhYmVsIGFsaWdubWVudFxuXHRcdFx0dGhpcy5sYWJlbEFsaWduID0gYXR0ci5hbGlnbiA9IGxhYmVsT3B0aW9ucy5hbGlnbiB8fCB0aGlzLmF1dG9MYWJlbEFsaWduKHRoaXMubGFiZWxSb3RhdGlvbik7XG5cblx0XHRcdC8vIEFwcGx5IGdlbmVyYWwgYW5kIHNwZWNpZmljIENTU1xuXHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRcdHZhciB0aWNrID0gdGlja3NbcG9zXSxcblx0XHRcdFx0XHRsYWJlbCA9IHRpY2sgJiYgdGljay5sYWJlbDtcblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdFx0bGFiZWwuY3NzKG1lcmdlKGNzcywgbGFiZWwuc3BlY0NzcykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgbGFiZWwuc3BlY0Nzcztcblx0XHRcdFx0XHRsYWJlbC5hdHRyKGF0dHIpO1xuXHRcdFx0XHRcdHRpY2sucm90YXRpb24gPSBhdHRyLnJvdGF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVE9ETzogV2h5IG5vdCBwYXJ0IG9mIGdldExhYmVsUG9zaXRpb24/XG5cdFx0XHR0aGlzLnRpY2tSb3RDb3JyID0gcmVuZGVyZXIucm90Q29ycihsYWJlbE1ldHJpY3MuYiwgdGhpcy5sYWJlbFJvdGF0aW9uIHx8IDAsIHRoaXMuc2lkZSA9PT0gMik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0cnVlIGlmIHRoZSBheGlzIGhhcyBhc3NvY2lhdGVkIGRhdGFcblx0XHQgKi9cblx0XHRoYXNEYXRhOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzIHx8IChkZWZpbmVkKHRoaXMubWluKSAmJiBkZWZpbmVkKHRoaXMubWF4KSAmJiAhIXRoaXMudGlja1Bvc2l0aW9ucyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgdGljayBsYWJlbHMgdG8gYSBwcmVsaW1pbmFyeSBwb3NpdGlvbiB0byBnZXQgdGhlaXIgc2l6ZXNcblx0XHQgKi9cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrcyA9IGF4aXMudGlja3MsXG5cdFx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0c2lkZSA9IGF4aXMuc2lkZSxcblx0XHRcdFx0aW52ZXJ0ZWRTaWRlID0gY2hhcnQuaW52ZXJ0ZWQgPyBbMSwgMCwgMywgMl1bc2lkZV0gOiBzaWRlLFxuXHRcdFx0XHRoYXNEYXRhLFxuXHRcdFx0XHRzaG93QXhpcyxcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSAwLFxuXHRcdFx0XHR0aXRsZU9mZnNldE9wdGlvbixcblx0XHRcdFx0dGl0bGVNYXJnaW4gPSAwLFxuXHRcdFx0XHRheGlzVGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRcdGxhYmVsT2Zmc2V0ID0gMCwgLy8gcmVzZXRcblx0XHRcdFx0bGFiZWxPZmZzZXRQYWRkZWQsXG5cdFx0XHRcdGF4aXNPZmZzZXQgPSBjaGFydC5heGlzT2Zmc2V0LFxuXHRcdFx0XHRjbGlwT2Zmc2V0ID0gY2hhcnQuY2xpcE9mZnNldCxcblx0XHRcdFx0Y2xpcCxcblx0XHRcdFx0ZGlyZWN0aW9uRmFjdG9yID0gWy0xLCAxLCAxLCAtMV1bc2lkZV0sXG5cdFx0XHRcdG4sXG5cdFx0XHRcdGxpbmVIZWlnaHRDb3JyZWN0aW9uO1xuXG5cdFx0XHQvLyBGb3IgcmV1c2UgaW4gQXhpcy5yZW5kZXJcblx0XHRcdGhhc0RhdGEgPSBheGlzLmhhc0RhdGEoKTtcblx0XHRcdGF4aXMuc2hvd0F4aXMgPSBzaG93QXhpcyA9IGhhc0RhdGEgfHwgcGljayhvcHRpb25zLnNob3dFbXB0eSwgdHJ1ZSk7XG5cblx0XHRcdC8vIFNldC9yZXNldCBzdGFnZ2VyTGluZXNcblx0XHRcdGF4aXMuc3RhZ2dlckxpbmVzID0gYXhpcy5ob3JpeiAmJiBsYWJlbE9wdGlvbnMuc3RhZ2dlckxpbmVzO1xuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGF4aXNHcm91cCBhbmQgZ3JpZEdyb3VwIGVsZW1lbnRzIG9uIGZpcnN0IGl0ZXJhdGlvblxuXHRcdFx0aWYgKCFheGlzLmF4aXNHcm91cCkge1xuXHRcdFx0XHRheGlzLmdyaWRHcm91cCA9IHJlbmRlcmVyLmcoJ2dyaWQnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiBvcHRpb25zLmdyaWRaSW5kZXggfHwgMSB9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0YXhpcy5heGlzR3JvdXAgPSByZW5kZXJlci5nKCdheGlzJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogb3B0aW9ucy56SW5kZXggfHwgMiB9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0YXhpcy5sYWJlbEdyb3VwID0gcmVuZGVyZXIuZygnYXhpcy1sYWJlbHMnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiBsYWJlbE9wdGlvbnMuekluZGV4IHx8IDcgfSlcblx0XHRcdFx0XHQuYWRkQ2xhc3MoUFJFRklYICsgYXhpcy5jb2xsLnRvTG93ZXJDYXNlKCkgKyAnLWxhYmVscycpXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzRGF0YSB8fCBheGlzLmlzTGlua2VkKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBHZW5lcmF0ZSB0aWNrc1xuXHRcdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdFx0XHRpZiAoIXRpY2tzW3Bvc10pIHtcblx0XHRcdFx0XHRcdHRpY2tzW3Bvc10gPSBuZXcgVGljayhheGlzLCBwb3MpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aWNrc1twb3NdLmFkZExhYmVsKCk7IC8vIHVwZGF0ZSBsYWJlbHMgZGVwZW5kaW5nIG9uIHRpY2sgaW50ZXJ2YWxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGF4aXMucmVuZGVyVW5zcXVpc2goKTtcblxuXHRcdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdFx0XHQvLyBsZWZ0IHNpZGUgbXVzdCBiZSBhbGlnbjogcmlnaHQgYW5kIHJpZ2h0IHNpZGUgbXVzdCBoYXZlIGFsaWduOiBsZWZ0IGZvciBsYWJlbHNcblx0XHRcdFx0XHRpZiAoc2lkZSA9PT0gMCB8fCBzaWRlID09PSAyIHx8IHsgMTogJ2xlZnQnLCAzOiAncmlnaHQnIH1bc2lkZV0gPT09IGF4aXMubGFiZWxBbGlnbikge1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGhpZ2hlc3Qgb2Zmc2V0XG5cdFx0XHRcdFx0XHRsYWJlbE9mZnNldCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10uZ2V0TGFiZWxTaXplKCksXG5cdFx0XHRcdFx0XHRcdGxhYmVsT2Zmc2V0XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGF4aXMuc3RhZ2dlckxpbmVzKSB7XG5cdFx0XHRcdFx0bGFiZWxPZmZzZXQgKj0gYXhpcy5zdGFnZ2VyTGluZXM7XG5cdFx0XHRcdFx0YXhpcy5sYWJlbE9mZnNldCA9IGxhYmVsT2Zmc2V0O1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0fSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGRhdGFcblx0XHRcdFx0Zm9yIChuIGluIHRpY2tzKSB7XG5cdFx0XHRcdFx0dGlja3Nbbl0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aWNrc1tuXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXhpc1RpdGxlT3B0aW9ucyAmJiBheGlzVGl0bGVPcHRpb25zLnRleHQgJiYgYXhpc1RpdGxlT3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAoIWF4aXMuYXhpc1RpdGxlKSB7XG5cdFx0XHRcdFx0YXhpcy5heGlzVGl0bGUgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0YXhpc1RpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ekluZGV4OiA3LFxuXHRcdFx0XHRcdFx0cm90YXRpb246IGF4aXNUaXRsZU9wdGlvbnMucm90YXRpb24gfHwgMCxcblx0XHRcdFx0XHRcdGFsaWduOlxuXHRcdFx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnRleHRBbGlnbiB8fFxuXHRcdFx0XHRcdFx0XHR7IGxvdzogJ2xlZnQnLCBtaWRkbGU6ICdjZW50ZXInLCBoaWdoOiAncmlnaHQnIH1bYXhpc1RpdGxlT3B0aW9ucy5hbGlnbl1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyB0aGlzLmNvbGwudG9Mb3dlckNhc2UoKSArICctdGl0bGUnKVxuXHRcdFx0XHRcdC5jc3MoYXhpc1RpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0XHQuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0XHRheGlzLmF4aXNUaXRsZS5pc05ldyA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2hvd0F4aXMpIHtcblx0XHRcdFx0XHR0aXRsZU9mZnNldCA9IGF4aXMuYXhpc1RpdGxlLmdldEJCb3goKVtob3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJ107XG5cdFx0XHRcdFx0dGl0bGVPZmZzZXRPcHRpb24gPSBheGlzVGl0bGVPcHRpb25zLm9mZnNldDtcblx0XHRcdFx0XHR0aXRsZU1hcmdpbiA9IGRlZmluZWQodGl0bGVPZmZzZXRPcHRpb24pID8gMCA6IHBpY2soYXhpc1RpdGxlT3B0aW9ucy5tYXJnaW4sIGhvcml6ID8gNSA6IDEwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGhpZGUgb3Igc2hvdyB0aGUgdGl0bGUgZGVwZW5kaW5nIG9uIHdoZXRoZXIgc2hvd0VtcHR5IGlzIHNldFxuXHRcdFx0XHRheGlzLmF4aXNUaXRsZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGFuZGxlIGF1dG9tYXRpYyBvciB1c2VyIHNldCBvZmZzZXRcblx0XHRcdGF4aXMub2Zmc2V0ID0gZGlyZWN0aW9uRmFjdG9yICogcGljayhvcHRpb25zLm9mZnNldCwgYXhpc09mZnNldFtzaWRlXSk7XG5cblx0XHRcdGF4aXMudGlja1JvdENvcnIgPSBheGlzLnRpY2tSb3RDb3JyIHx8IHsgeDogMCwgeTogMCB9OyAvLyBwb2xhclxuXHRcdFx0bGluZUhlaWdodENvcnJlY3Rpb24gPSBzaWRlID09PSAyID8gYXhpcy50aWNrUm90Q29yci55IDogMDtcblx0XHRcdGxhYmVsT2Zmc2V0UGFkZGVkID0gbGFiZWxPZmZzZXQgKyB0aXRsZU1hcmdpbiArXG5cdFx0XHRcdChsYWJlbE9mZnNldCAmJiAoZGlyZWN0aW9uRmFjdG9yICogKGhvcml6ID8gcGljayhsYWJlbE9wdGlvbnMueSwgYXhpcy50aWNrUm90Q29yci55ICsgOCkgOiBsYWJlbE9wdGlvbnMueCkgLSBsaW5lSGVpZ2h0Q29ycmVjdGlvbikpO1xuXHRcdFx0YXhpcy5heGlzVGl0bGVNYXJnaW4gPSBwaWNrKHRpdGxlT2Zmc2V0T3B0aW9uLCBsYWJlbE9mZnNldFBhZGRlZCk7XG5cblx0XHRcdGF4aXNPZmZzZXRbc2lkZV0gPSBtYXRoTWF4KFxuXHRcdFx0XHRheGlzT2Zmc2V0W3NpZGVdLFxuXHRcdFx0XHRheGlzLmF4aXNUaXRsZU1hcmdpbiArIHRpdGxlT2Zmc2V0ICsgZGlyZWN0aW9uRmFjdG9yICogYXhpcy5vZmZzZXQsXG5cdFx0XHRcdGxhYmVsT2Zmc2V0UGFkZGVkIC8vICMzMDI3XG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBEZWNpZGUgdGhlIGNsaXBwaW5nIG5lZWRlZCB0byBrZWVwIHRoZSBncmFwaCBpbnNpZGUgdGhlIHBsb3QgYXJlYSBhbmQgYXhpcyBsaW5lc1xuXHRcdFx0Y2xpcCA9IG1hdGhGbG9vcihvcHRpb25zLmxpbmVXaWR0aCAvIDIpICogMjtcblx0XHRcdGlmIChvcHRpb25zLm9mZnNldCkge1xuXHRcdFx0XHRjbGlwID0gbWF0aE1heCgwLCBjbGlwIC0gb3B0aW9ucy5vZmZzZXQpO1x0XHRcblx0XHRcdH1cblx0XHRcdGNsaXBPZmZzZXRbaW52ZXJ0ZWRTaWRlXSA9IG1hdGhNYXgoY2xpcE9mZnNldFtpbnZlcnRlZFNpZGVdLCBjbGlwKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBwYXRoIGZvciB0aGUgYXhpcyBsaW5lXG5cdFx0ICovXG5cdFx0Z2V0TGluZVBhdGg6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdG9wcG9zaXRlID0gdGhpcy5vcHBvc2l0ZSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQsXG5cdFx0XHRcdGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdFx0bGluZUxlZnQgPSB0aGlzLmxlZnQgKyAob3Bwb3NpdGUgPyB0aGlzLndpZHRoIDogMCkgKyBvZmZzZXQsXG5cdFx0XHRcdGxpbmVUb3AgPSBjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tIC0gKG9wcG9zaXRlID8gdGhpcy5oZWlnaHQgOiAwKSArIG9mZnNldDtcblxuXHRcdFx0aWYgKG9wcG9zaXRlKSB7XG5cdFx0XHRcdGxpbmVXaWR0aCAqPSAtMTsgLy8gY3Jpc3BpZnkgdGhlIG90aGVyIHdheSAtICMxNDgwLCAjMTY4N1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhcnQucmVuZGVyZXIuY3Jpc3BMaW5lKFtcblx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHRcdHRoaXMubGVmdCA6XG5cdFx0XHRcdFx0XHRsaW5lTGVmdCxcblx0XHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0XHRsaW5lVG9wIDpcblx0XHRcdFx0XHRcdHRoaXMudG9wLFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCAtIHRoaXMucmlnaHQgOlxuXHRcdFx0XHRcdFx0bGluZUxlZnQsXG5cdFx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdFx0bGluZVRvcCA6XG5cdFx0XHRcdFx0XHRjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tXG5cdFx0XHRcdF0sIGxpbmVXaWR0aCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uIHRoZSB0aXRsZVxuXHRcdCAqL1xuXHRcdGdldFRpdGxlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGNvbXB1dGUgYW5jaG9yIHBvaW50cyBmb3IgZWFjaCBvZiB0aGUgdGl0bGUgYWxpZ24gb3B0aW9uc1xuXHRcdFx0dmFyIGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdFx0YXhpc0xlZnQgPSB0aGlzLmxlZnQsXG5cdFx0XHRcdGF4aXNUb3AgPSB0aGlzLnRvcCxcblx0XHRcdFx0YXhpc0xlbmd0aCA9IHRoaXMubGVuLFxuXHRcdFx0XHRheGlzVGl0bGVPcHRpb25zID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuXHRcdFx0XHRtYXJnaW4gPSBob3JpeiA/IGF4aXNMZWZ0IDogYXhpc1RvcCxcblx0XHRcdFx0b3Bwb3NpdGUgPSB0aGlzLm9wcG9zaXRlLFxuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCxcblx0XHRcdFx0eE9wdGlvbiA9IGF4aXNUaXRsZU9wdGlvbnMueCB8fCAwLFxuXHRcdFx0XHR5T3B0aW9uID0gYXhpc1RpdGxlT3B0aW9ucy55IHx8IDAsXG5cdFx0XHRcdGZvbnRTaXplID0gcEludChheGlzVGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplIHx8IDEyKSxcblxuXHRcdFx0XHQvLyB0aGUgcG9zaXRpb24gaW4gdGhlIGxlbmd0aCBkaXJlY3Rpb24gb2YgdGhlIGF4aXNcblx0XHRcdFx0YWxvbmdBeGlzID0ge1xuXHRcdFx0XHRcdGxvdzogbWFyZ2luICsgKGhvcml6ID8gMCA6IGF4aXNMZW5ndGgpLFxuXHRcdFx0XHRcdG1pZGRsZTogbWFyZ2luICsgYXhpc0xlbmd0aCAvIDIsXG5cdFx0XHRcdFx0aGlnaDogbWFyZ2luICsgKGhvcml6ID8gYXhpc0xlbmd0aCA6IDApXG5cdFx0XHRcdH1bYXhpc1RpdGxlT3B0aW9ucy5hbGlnbl0sXG5cblx0XHRcdFx0Ly8gdGhlIHBvc2l0aW9uIGluIHRoZSBwZXJwZW5kaWN1bGFyIGRpcmVjdGlvbiBvZiB0aGUgYXhpc1xuXHRcdFx0XHRvZmZBeGlzID0gKGhvcml6ID8gYXhpc1RvcCArIHRoaXMuaGVpZ2h0IDogYXhpc0xlZnQpICtcblx0XHRcdFx0XHQoaG9yaXogPyAxIDogLTEpICogLy8gaG9yaXpvbnRhbCBheGlzIHJldmVyc2VzIHRoZSBtYXJnaW5cblx0XHRcdFx0XHQob3Bwb3NpdGUgPyAtMSA6IDEpICogLy8gc28gZG9lcyBvcHBvc2l0ZSBheGVzXG5cdFx0XHRcdFx0dGhpcy5heGlzVGl0bGVNYXJnaW4gK1xuXHRcdFx0XHRcdCh0aGlzLnNpZGUgPT09IDIgPyBmb250U2l6ZSA6IDApO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBob3JpeiA/XG5cdFx0XHRcdFx0YWxvbmdBeGlzICsgeE9wdGlvbiA6XG5cdFx0XHRcdFx0b2ZmQXhpcyArIChvcHBvc2l0ZSA/IHRoaXMud2lkdGggOiAwKSArIG9mZnNldCArIHhPcHRpb24sXG5cdFx0XHRcdHk6IGhvcml6ID9cblx0XHRcdFx0XHRvZmZBeGlzICsgeU9wdGlvbiAtIChvcHBvc2l0ZSA/IHRoaXMuaGVpZ2h0IDogMCkgKyBvZmZzZXQgOlxuXHRcdFx0XHRcdGFsb25nQXhpcyArIHlPcHRpb25cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgYXhpc1xuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdFx0aXNMaW5rZWQgPSBheGlzLmlzTGlua2VkLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHRheGlzVGl0bGUgPSBheGlzLmF4aXNUaXRsZSxcdFx0XHRcblx0XHRcdFx0dGlja3MgPSBheGlzLnRpY2tzLFxuXHRcdFx0XHRtaW5vclRpY2tzID0gYXhpcy5taW5vclRpY2tzLFxuXHRcdFx0XHRhbHRlcm5hdGVCYW5kcyA9IGF4aXMuYWx0ZXJuYXRlQmFuZHMsXG5cdFx0XHRcdHN0YWNrTGFiZWxPcHRpb25zID0gb3B0aW9ucy5zdGFja0xhYmVscyxcblx0XHRcdFx0YWx0ZXJuYXRlR3JpZENvbG9yID0gb3B0aW9ucy5hbHRlcm5hdGVHcmlkQ29sb3IsXG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ID0gYXhpcy50aWNrbWFya09mZnNldCxcblx0XHRcdFx0bGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGgsXG5cdFx0XHRcdGxpbmVQYXRoLFxuXHRcdFx0XHRoYXNSZW5kZXJlZCA9IGNoYXJ0Lmhhc1JlbmRlcmVkLFxuXHRcdFx0XHRzbGlkZUluVGlja3MgPSBoYXNSZW5kZXJlZCAmJiBkZWZpbmVkKGF4aXMub2xkTWluKSAmJiAhaXNOYU4oYXhpcy5vbGRNaW4pLFxuXHRcdFx0XHRzaG93QXhpcyA9IGF4aXMuc2hvd0F4aXMsXG5cdFx0XHRcdGZyb20sXG5cdFx0XHRcdHRvO1xuXG5cdFx0XHQvLyBSZXNldFxuXHRcdFx0YXhpcy5sYWJlbEVkZ2UubGVuZ3RoID0gMDtcblx0XHRcdC8vYXhpcy5qdXN0aWZ5VG9QbG90ID0gb3ZlcmZsb3cgPT09ICdqdXN0aWZ5Jztcblx0XHRcdGF4aXMub3ZlcmxhcCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBNYXJrIGFsbCBlbGVtZW50cyBpbkFjdGl2ZSBiZWZvcmUgd2UgZ28gb3ZlciBhbmQgbWFyayB0aGUgYWN0aXZlIG9uZXNcblx0XHRcdGVhY2goW3RpY2tzLCBtaW5vclRpY2tzLCBhbHRlcm5hdGVCYW5kc10sIGZ1bmN0aW9uIChjb2xsKSB7XG5cdFx0XHRcdHZhciBwb3M7XG5cdFx0XHRcdGZvciAocG9zIGluIGNvbGwpIHtcblx0XHRcdFx0XHRjb2xsW3Bvc10uaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHRoZSBzZXJpZXMgaGFzIGRhdGEgZHJhdyB0aGUgdGlja3MuIEVsc2Ugb25seSB0aGUgbGluZSBhbmQgdGl0bGVcblx0XHRcdGlmIChheGlzLmhhc0RhdGEoKSB8fCBpc0xpbmtlZCkge1xuXG5cdFx0XHRcdC8vIG1pbm9yIHRpY2tzXG5cdFx0XHRcdGlmIChheGlzLm1pbm9yVGlja0ludGVydmFsICYmICFheGlzLmNhdGVnb3JpZXMpIHtcblx0XHRcdFx0XHRlYWNoKGF4aXMuZ2V0TWlub3JUaWNrUG9zaXRpb25zKCksIGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdFx0XHRcdGlmICghbWlub3JUaWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdG1pbm9yVGlja3NbcG9zXSA9IG5ldyBUaWNrKGF4aXMsIHBvcywgJ21pbm9yJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRpZiAoc2xpZGVJblRpY2tzICYmIG1pbm9yVGlja3NbcG9zXS5pc05ldykge1xuXHRcdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10ucmVuZGVyKG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10ucmVuZGVyKG51bGwsIGZhbHNlLCAxKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ham9yIHRpY2tzLiBQdWxsIG91dCB0aGUgZmlyc3QgaXRlbSBhbmQgcmVuZGVyIGl0IGxhc3Qgc28gdGhhdFxuXHRcdFx0XHQvLyB3ZSBjYW4gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbmVpZ2hib3VyIGxhYmVsLiAjODA4LlxuXHRcdFx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGgpIHsgLy8gIzEzMDBcblx0XHRcdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3MsIGkpIHtcblxuXHRcdFx0XHRcdFx0Ly8gbGlua2VkIGF4ZXMgbmVlZCBhbiBleHRyYSBjaGVjayB0byBmaW5kIG91dCBpZlxuXHRcdFx0XHRcdFx0aWYgKCFpc0xpbmtlZCB8fCAocG9zID49IGF4aXMubWluICYmIHBvcyA8PSBheGlzLm1heCkpIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXRpY2tzW3Bvc10pIHtcblx0XHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdGlmIChzbGlkZUluVGlja3MgJiYgdGlja3NbcG9zXS5pc05ldykge1xuXHRcdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGksIHRydWUsIDAuMSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdLnJlbmRlcihpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vIEluIGEgY2F0ZWdvcml6ZWQgYXhpcywgdGhlIHRpY2sgbWFya3MgYXJlIGRpc3BsYXllZCBiZXR3ZWVuIGxhYmVscy4gU29cblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGFkZCBhIHRpY2sgbWFyayBhbmQgZ3JpZCBsaW5lIGF0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIFggYXhpcy5cblx0XHRcdFx0XHRpZiAodGlja21hcmtPZmZzZXQgJiYgKGF4aXMubWluID09PSAwIHx8IGF4aXMuc2luZ2xlKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0aWNrc1stMV0pIHtcblx0XHRcdFx0XHRcdFx0dGlja3NbLTFdID0gbmV3IFRpY2soYXhpcywgLTEsIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGlja3NbLTFdLnJlbmRlcigtMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhbHRlcm5hdGUgZ3JpZCBjb2xvclxuXHRcdFx0XHRpZiAoYWx0ZXJuYXRlR3JpZENvbG9yKSB7XG5cdFx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zLCBpKSB7XG5cdFx0XHRcdFx0XHRpZiAoaSAlIDIgPT09IDAgJiYgcG9zIDwgYXhpcy5tYXgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFhbHRlcm5hdGVCYW5kc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXSA9IG5ldyBIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kKGF4aXMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZyb20gPSBwb3MgKyB0aWNrbWFya09mZnNldDsgLy8gIzk0OVxuXHRcdFx0XHRcdFx0XHR0byA9IHRpY2tQb3NpdGlvbnNbaSArIDFdICE9PSBVTkRFRklORUQgPyB0aWNrUG9zaXRpb25zW2kgKyAxXSArIHRpY2ttYXJrT2Zmc2V0IDogYXhpcy5tYXg7XG5cdFx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10ub3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0XHRmcm9tOiBpc0xvZyA/IGxpbjJsb2coZnJvbSkgOiBmcm9tLFxuXHRcdFx0XHRcdFx0XHRcdHRvOiBpc0xvZyA/IGxpbjJsb2codG8pIDogdG8sXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6IGFsdGVybmF0ZUdyaWRDb2xvclxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLnJlbmRlcigpO1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLmlzQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGN1c3RvbSBwbG90IGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0XHRpZiAoIWF4aXMuX2FkZGVkUGxvdExCKSB7IC8vIG9ubHkgZmlyc3QgdGltZVxuXHRcdFx0XHRcdGVhY2goKG9wdGlvbnMucGxvdExpbmVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5wbG90QmFuZHMgfHwgW10pLCBmdW5jdGlvbiAocGxvdExpbmVPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRheGlzLmFkZFBsb3RCYW5kT3JMaW5lKHBsb3RMaW5lT3B0aW9ucyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YXhpcy5fYWRkZWRQbG90TEIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gZW5kIGlmIGhhc0RhdGFcblxuXHRcdFx0Ly8gUmVtb3ZlIGluYWN0aXZlIHRpY2tzXG5cdFx0XHRlYWNoKFt0aWNrcywgbWlub3JUaWNrcywgYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0XHR2YXIgcG9zLFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24gPSBbXSxcblx0XHRcdFx0XHRkZWxheSA9IGdsb2JhbEFuaW1hdGlvbiA/IGdsb2JhbEFuaW1hdGlvbi5kdXJhdGlvbiB8fCA1MDAgOiAwLFxuXHRcdFx0XHRcdGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aSA9IGZvckRlc3RydWN0aW9uLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2hlbiByZXNpemluZyByYXBpZGx5LCB0aGUgc2FtZSBpdGVtcyBtYXkgYmUgZGVzdHJveWVkIGluIGRpZmZlcmVudCB0aW1lb3V0cyxcblx0XHRcdFx0XHRcdFx0Ly8gb3IgdGhlIG1heSBiZSByZWFjdGl2YXRlZFxuXHRcdFx0XHRcdFx0XHRpZiAoY29sbFtmb3JEZXN0cnVjdGlvbltpXV0gJiYgIWNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29sbFtmb3JEZXN0cnVjdGlvbltpXV0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBjb2xsW2ZvckRlc3RydWN0aW9uW2ldXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRmb3IgKHBvcyBpbiBjb2xsKSB7XG5cblx0XHRcdFx0XHRpZiAoIWNvbGxbcG9zXS5pc0FjdGl2ZSkge1xuXHRcdFx0XHRcdFx0Ly8gUmVuZGVyIHRvIHplcm8gb3BhY2l0eVxuXHRcdFx0XHRcdFx0Y29sbFtwb3NdLnJlbmRlcihwb3MsIGZhbHNlLCAwKTtcblx0XHRcdFx0XHRcdGNvbGxbcG9zXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24ucHVzaChwb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdoZW4gdGhlIG9iamVjdHMgYXJlIGZpbmlzaGVkIGZhZGluZyBvdXQsIGRlc3Ryb3kgdGhlbVxuXHRcdFx0XHRpZiAoY29sbCA9PT0gYWx0ZXJuYXRlQmFuZHMgfHwgIWNoYXJ0Lmhhc1JlbmRlcmVkIHx8ICFkZWxheSkge1xuXHRcdFx0XHRcdGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGVsYXkpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zLCBkZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBTdGF0aWMgaXRlbXMuIEFzIHRoZSBheGlzIGdyb3VwIGlzIGNsZWFyZWQgb24gc3Vic2VxdWVudCBjYWxsc1xuXHRcdFx0Ly8gdG8gcmVuZGVyLCB0aGVzZSBpdGVtcyBhcmUgYWRkZWQgb3V0c2lkZSB0aGUgZ3JvdXAuXG5cdFx0XHQvLyBheGlzIGxpbmVcblx0XHRcdGlmIChsaW5lV2lkdGgpIHtcblx0XHRcdFx0bGluZVBhdGggPSBheGlzLmdldExpbmVQYXRoKGxpbmVXaWR0aCk7XG5cdFx0XHRcdGlmICghYXhpcy5heGlzTGluZSkge1xuXHRcdFx0XHRcdGF4aXMuYXhpc0xpbmUgPSByZW5kZXJlci5wYXRoKGxpbmVQYXRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMubGluZUNvbG9yLFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogbGluZVdpZHRoLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDdcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRheGlzLmF4aXNMaW5lLmFuaW1hdGUoeyBkOiBsaW5lUGF0aCB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNob3cgb3IgaGlkZSB0aGUgbGluZSBkZXBlbmRpbmcgb24gb3B0aW9ucy5zaG93RW1wdHlcblx0XHRcdFx0YXhpcy5heGlzTGluZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGF4aXNUaXRsZSAmJiBzaG93QXhpcykge1xuXG5cdFx0XHRcdGF4aXNUaXRsZVtheGlzVGl0bGUuaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRcdGF4aXMuZ2V0VGl0bGVQb3NpdGlvbigpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGF4aXNUaXRsZS5pc05ldyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFja2VkIHRvdGFsczpcblx0XHRcdGlmIChzdGFja0xhYmVsT3B0aW9ucyAmJiBzdGFja0xhYmVsT3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHRcdGF4aXMucmVuZGVyU3RhY2tUb3RhbHMoKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuZCBzdGFja2VkIHRvdGFsc1xuXG5cdFx0XHRheGlzLmlzRGlydHkgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IHRoZSBheGlzIHRvIHJlZmxlY3QgY2hhbmdlcyBpbiB0aGUgZGF0YSBvciBheGlzIGV4dHJlbWVzXG5cdFx0ICovXG5cdFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcblx0XHRcdC8vIHJlbmRlciB0aGUgYXhpc1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblxuXHRcdFx0Ly8gbW92ZSBwbG90IGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0ZWFjaCh0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLCBmdW5jdGlvbiAocGxvdExpbmUpIHtcblx0XHRcdFx0cGxvdExpbmUucmVuZGVyKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbWFyayBhc3NvY2lhdGVkIHNlcmllcyBhcyBkaXJ0eSBhbmQgcmVhZHkgZm9yIHJlZHJhd1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95cyBhbiBBeGlzIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChrZWVwRXZlbnRzKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzLFxuXHRcdFx0XHRzdGFja0tleSxcblx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHMgPSBheGlzLnBsb3RMaW5lc0FuZEJhbmRzLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIGV2ZW50c1xuXHRcdFx0aWYgKCFrZWVwRXZlbnRzKSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KGF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGVhY2ggc3RhY2sgdG90YWxcblx0XHRcdGZvciAoc3RhY2tLZXkgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHN0YWNrc1tzdGFja0tleV0pO1xuXG5cdFx0XHRcdHN0YWNrc1tzdGFja0tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGNvbGxlY3Rpb25zXG5cdFx0XHRlYWNoKFtheGlzLnRpY2tzLCBheGlzLm1pbm9yVGlja3MsIGF4aXMuYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyhjb2xsKTtcblx0XHRcdH0pO1xuXHRcdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHsgLy8gIzE5NzVcblx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGxvY2FsIHZhcmlhYmxlc1xuXHRcdFx0ZWFjaChbJ3N0YWNrVG90YWxHcm91cCcsICdheGlzTGluZScsICdheGlzVGl0bGUnLCAnYXhpc0dyb3VwJywgJ2Nyb3NzJywgJ2dyaWRHcm91cCcsICdsYWJlbEdyb3VwJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdGlmIChheGlzW3Byb3BdKSB7XG5cdFx0XHRcdFx0YXhpc1twcm9wXSA9IGF4aXNbcHJvcF0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRGVzdHJveSBjcm9zc2hhaXJcblx0XHRcdGlmICh0aGlzLmNyb3NzKSB7XG5cdFx0XHRcdHRoaXMuY3Jvc3MuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBjcm9zc2hhaXJcblx0XHQgKi9cblx0XHRkcmF3Q3Jvc3NoYWlyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHsgLy8gZG9jczogTWlzc2luZyBkb2NzIGZvciBBeGlzLmNyb3NzaGFpci4gQWxzbyBmb3IgcHJvcGVydGllcy5cblxuXHRcdFx0dmFyIHBhdGgsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmNyb3NzaGFpcixcblx0XHRcdFx0YW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24sXG5cdFx0XHRcdHBvcyxcblx0XHRcdFx0YXR0cmlicyxcblx0XHRcdFx0Y2F0ZWdvcml6ZWQ7XG5cdFx0XHRcblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gRGlzYWJsZWQgaW4gb3B0aW9uc1xuXHRcdFx0XHQhdGhpcy5jcm9zc2hhaXIgfHwgXG5cdFx0XHRcdC8vIFNuYXBcblx0XHRcdFx0KChkZWZpbmVkKHBvaW50KSB8fCAhcGljayh0aGlzLmNyb3NzaGFpci5zbmFwLCB0cnVlKSkgPT09IGZhbHNlKSB8fCBcblx0XHRcdFx0Ly8gTm90IG9uIHRoaXMgYXhpcyAoIzQwOTUsICMyODg4KVxuXHRcdFx0XHQocG9pbnQgJiYgcG9pbnQuc2VyaWVzICYmIHBvaW50LnNlcmllc1t0aGlzLmNvbGxdICE9PSB0aGlzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuaGlkZUNyb3NzaGFpcigpO1xuXHRcdFx0XG5cdFx0XHR9IGVsc2Uge1x0XHRcdFxuXG5cdFx0XHRcdC8vIEdldCB0aGUgcGF0aFxuXHRcdFx0XHRpZiAoIXBpY2sob3B0aW9ucy5zbmFwLCB0cnVlKSkge1xuXHRcdFx0XHRcdHBvcyA9ICh0aGlzLmhvcml6ID8gZS5jaGFydFggLSB0aGlzLnBvcyA6IHRoaXMubGVuIC0gZS5jaGFydFkgKyB0aGlzLnBvcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGVmaW5lZChwb2ludCkpIHtcblx0XHRcdFx0XHQvKmpzbGludCBlcWVxOiB0cnVlKi9cblx0XHRcdFx0XHRwb3MgPSB0aGlzLmlzWEF4aXMgPyBwb2ludC5wbG90WCA6IHRoaXMubGVuIC0gcG9pbnQucGxvdFk7IC8vICMzODM0XG5cdFx0XHRcdFx0Lypqc2xpbnQgZXFlcTogZmFsc2UqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuaXNSYWRpYWwpIHtcblx0XHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgodGhpcy5pc1hBeGlzID8gcG9pbnQueCA6IHBpY2socG9pbnQuc3RhY2tZLCBwb2ludC55KSkgfHwgbnVsbDsgLy8gIzMxODlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgcG9zKSB8fCBudWxsOyAvLyAjMzE4OVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhdGggPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHRoZSBjcm9zc1xuXHRcdFx0XHRpZiAodGhpcy5jcm9zcykge1xuXHRcdFx0XHRcdHRoaXMuY3Jvc3Ncblx0XHRcdFx0XHRcdC5hdHRyKHsgdmlzaWJpbGl0eTogVklTSUJMRSB9KVthbmltYXRpb24gPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgZDogcGF0aCB9LCBhbmltYXRpb24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhdGVnb3JpemVkID0gdGhpcy5jYXRlZ29yaWVzICYmICF0aGlzLmlzUmFkaWFsO1xuXHRcdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogb3B0aW9ucy53aWR0aCB8fCAoY2F0ZWdvcml6ZWQgPyB0aGlzLnRyYW5zQSA6IDEpLFxuXHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbG9yIHx8IChjYXRlZ29yaXplZCA/ICdyZ2JhKDE1NSwyMDAsMjU1LDAuMiknIDogJyNDMEMwQzAnKSxcblx0XHRcdFx0XHRcdHpJbmRleDogb3B0aW9ucy56SW5kZXggfHwgMlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IG9wdGlvbnMuZGFzaFN0eWxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmNyb3NzID0gdGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKHBhdGgpLmF0dHIoYXR0cmlicykuYWRkKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqXHRIaWRlIHRoZSBjcm9zc2hhaXIuXG5cdFx0ICovXG5cdFx0aGlkZUNyb3NzaGFpcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuY3Jvc3MpIHtcblx0XHRcdFx0dGhpcy5jcm9zcy5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9OyAvLyBlbmQgQXhpc1xuXG5cdGV4dGVuZChBeGlzLnByb3RvdHlwZSwgQXhpc1Bsb3RMaW5lT3JCYW5kRXh0ZW5zaW9uKTtcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byBhIHRpbWUgdW5pdCB0aGF0IG1ha2VzIHNlbnNlLCBmb3IgZXhhbXBsZVxuXHQgKiBvbiB0aGUgZmlyc3Qgb2YgZWFjaCBtb250aCBvciBvbiBldmVyeSBNb25kYXkuIFJldHVybiBhbiBhcnJheVxuXHQgKiB3aXRoIHRoZSB0aW1lIHBvc2l0aW9ucy4gVXNlZCBpbiBkYXRldGltZSBheGVzIGFzIHdlbGwgYXMgZm9yIGdyb3VwaW5nXG5cdCAqIGRhdGEgb24gYSBkYXRldGltZSBheGlzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsaXplZEludGVydmFsIFRoZSBpbnRlcnZhbCBpbiBheGlzIHZhbHVlcyAobXMpIGFuZCB0aGUgY291bnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbWluaW11bSBpbiBheGlzIHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIGluIGF4aXMgdmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mV2Vla1xuXHQgKi9cblx0QXhpcy5wcm90b3R5cGUuZ2V0VGltZVRpY2tzID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWRJbnRlcnZhbCwgbWluLCBtYXgsIHN0YXJ0T2ZXZWVrKSB7XG5cdFx0dmFyIHRpY2tQb3NpdGlvbnMgPSBbXSxcblx0XHRcdGksXG5cdFx0XHRoaWdoZXJSYW5rcyA9IHt9LFxuXHRcdFx0dXNlVVRDID0gZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLnVzZVVUQyxcblx0XHRcdG1pblllYXIsIC8vIHVzZWQgaW4gbW9udGhzIGFuZCB5ZWFycyBhcyBhIGJhc2lzIGZvciBEYXRlLlVUQygpXG5cdFx0XHRtaW5EYXRlID0gbmV3IERhdGUobWluIC0gZ2V0VFpPZmZzZXQobWluKSksXG5cdFx0XHRpbnRlcnZhbCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC51bml0UmFuZ2UsXG5cdFx0XHRjb3VudCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC5jb3VudDtcblxuXHRcdGlmIChkZWZpbmVkKG1pbikpIHsgLy8gIzEzMDBcblx0XHRcdG1pbkRhdGVbc2V0TWlsbGlzZWNvbmRzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMuc2Vjb25kID8gMCA6IC8vICMzOTM1XG5cdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLyBjb3VudCkpOyAvLyAjMzY1MiwgIzM2NTRcblxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5zZWNvbmQpIHsgLy8gc2Vjb25kXG5cdFx0XHRcdG1pbkRhdGVbc2V0U2Vjb25kc10oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1pbnV0ZSA/IDAgOiAvLyAjMzkzNVxuXHRcdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGUuZ2V0U2Vjb25kcygpIC8gY291bnQpKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMubWludXRlKSB7IC8vIG1pbnV0ZVxuXHRcdFx0XHRtaW5EYXRlW3NldE1pbnV0ZXNdKGludGVydmFsID49IHRpbWVVbml0cy5ob3VyID8gMCA6XG5cdFx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRNaW51dGVzXSgpIC8gY291bnQpKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMuaG91cikgeyAvLyBob3VyXG5cdFx0XHRcdG1pbkRhdGVbc2V0SG91cnNdKGludGVydmFsID49IHRpbWVVbml0cy5kYXkgPyAwIDpcblx0XHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldEhvdXJzXSgpIC8gY291bnQpKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMuZGF5KSB7IC8vIGRheVxuXHRcdFx0XHRtaW5EYXRlW3NldERhdGVdKGludGVydmFsID49IHRpbWVVbml0cy5tb250aCA/IDEgOlxuXHRcdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGVbZ2V0RGF0ZV0oKSAvIGNvdW50KSk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1vbnRoKSB7IC8vIG1vbnRoXG5cdFx0XHRcdG1pbkRhdGVbc2V0TW9udGhdKGludGVydmFsID49IHRpbWVVbml0cy55ZWFyID8gMCA6XG5cdFx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRNb250aF0oKSAvIGNvdW50KSk7XG5cdFx0XHRcdG1pblllYXIgPSBtaW5EYXRlW2dldEZ1bGxZZWFyXSgpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy55ZWFyKSB7IC8vIHllYXJcblx0XHRcdFx0bWluWWVhciAtPSBtaW5ZZWFyICUgY291bnQ7XG5cdFx0XHRcdG1pbkRhdGVbc2V0RnVsbFllYXJdKG1pblllYXIpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0Ly8gd2VlayBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHJ1bnMgb3V0c2lkZSB0aGUgaGllcmFyY2h5XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy53ZWVrKSB7XG5cdFx0XHRcdC8vIGdldCBzdGFydCBvZiBjdXJyZW50IHdlZWssIGluZGVwZW5kZW50IG9mIGNvdW50XG5cdFx0XHRcdG1pbkRhdGVbc2V0RGF0ZV0obWluRGF0ZVtnZXREYXRlXSgpIC0gbWluRGF0ZVtnZXREYXldKCkgK1xuXHRcdFx0XHRcdHBpY2soc3RhcnRPZldlZWssIDEpKTtcblx0XHRcdH1cblx0XHRcblx0XHRcblx0XHRcdC8vIGdldCB0aWNrIHBvc2l0aW9uc1xuXHRcdFx0aSA9IDE7XG5cdFx0XHRpZiAodGltZXpvbmVPZmZzZXQgfHwgZ2V0VGltZXpvbmVPZmZzZXQpIHtcblx0XHRcdFx0bWluRGF0ZSA9IG1pbkRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRtaW5EYXRlID0gbmV3IERhdGUobWluRGF0ZSArIGdldFRaT2Zmc2V0KG1pbkRhdGUpKTtcblx0XHRcdH1cblx0XHRcdG1pblllYXIgPSBtaW5EYXRlW2dldEZ1bGxZZWFyXSgpO1xuXHRcdFx0dmFyIHRpbWUgPSBtaW5EYXRlLmdldFRpbWUoKSxcblx0XHRcdFx0bWluTW9udGggPSBtaW5EYXRlW2dldE1vbnRoXSgpLFxuXHRcdFx0XHRtaW5EYXRlRGF0ZSA9IG1pbkRhdGVbZ2V0RGF0ZV0oKSxcblx0XHRcdFx0bG9jYWxUaW1lem9uZU9mZnNldCA9ICh0aW1lVW5pdHMuZGF5ICsgXG5cdFx0XHRcdFx0XHQodXNlVVRDID8gZ2V0VFpPZmZzZXQobWluRGF0ZSkgOiBtaW5EYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG5cdFx0XHRcdFx0KSAlIHRpbWVVbml0cy5kYXk7IC8vICM5NTAsICMzMzU5XG5cdFx0XG5cdFx0XHQvLyBpdGVyYXRlIGFuZCBhZGQgdGljayBwb3NpdGlvbnMgYXQgYXBwcm9wcmlhdGUgdmFsdWVzXG5cdFx0XHR3aGlsZSAodGltZSA8IG1heCkge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2godGltZSk7XG5cdFx0XG5cdFx0XHRcdC8vIGlmIHRoZSBpbnRlcnZhbCBpcyB5ZWFycywgdXNlIERhdGUuVVRDIHRvIGluY3JlYXNlIHllYXJzXG5cdFx0XHRcdGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLnllYXIpIHtcblx0XHRcdFx0XHR0aW1lID0gbWFrZVRpbWUobWluWWVhciArIGkgKiBjb3VudCwgMCk7XG5cdFx0XG5cdFx0XHRcdC8vIGlmIHRoZSBpbnRlcnZhbCBpcyBtb250aHMsIHVzZSBEYXRlLlVUQyB0byBpbmNyZWFzZSBtb250aHNcblx0XHRcdFx0fSBlbHNlIGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLm1vbnRoKSB7XG5cdFx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIsIG1pbk1vbnRoICsgaSAqIGNvdW50KTtcblx0XHRcblx0XHRcdFx0Ly8gaWYgd2UncmUgdXNpbmcgZ2xvYmFsIHRpbWUsIHRoZSBpbnRlcnZhbCBpcyBub3QgZml4ZWQgYXMgaXQganVtcHNcblx0XHRcdFx0Ly8gb25lIGhvdXIgYXQgdGhlIERTVCBjcm9zc292ZXJcblx0XHRcdFx0fSBlbHNlIGlmICghdXNlVVRDICYmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLmRheSB8fCBpbnRlcnZhbCA9PT0gdGltZVVuaXRzLndlZWspKSB7XG5cdFx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIsIG1pbk1vbnRoLCBtaW5EYXRlRGF0ZSArXG5cdFx0XHRcdFx0XHRpICogY291bnQgKiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy5kYXkgPyAxIDogNykpO1xuXHRcdFxuXHRcdFx0XHQvLyBlbHNlLCB0aGUgaW50ZXJ2YWwgaXMgZml4ZWQgYW5kIHdlIHVzZSBzaW1wbGUgYWRkaXRpb25cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aW1lICs9IGludGVydmFsICogY291bnQ7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0Ly8gcHVzaCB0aGUgbGFzdCB0aW1lXG5cdFx0XHR0aWNrUG9zaXRpb25zLnB1c2godGltZSk7XG5cblxuXHRcdFx0Ly8gbWFyayBuZXcgZGF5cyBpZiB0aGUgdGltZSBpcyBkaXZpZGlibGUgYnkgZGF5ICgjMTY0OSwgIzE3NjApXG5cdFx0XHRlYWNoKGdyZXAodGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHRpbWUpIHtcblx0XHRcdFx0cmV0dXJuIGludGVydmFsIDw9IHRpbWVVbml0cy5ob3VyICYmIHRpbWUgJSB0aW1lVW5pdHMuZGF5ID09PSBsb2NhbFRpbWV6b25lT2Zmc2V0O1xuXHRcdFx0fSksIGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHRcdGhpZ2hlclJhbmtzW3RpbWVdID0gJ2RheSc7XG5cdFx0XHR9KTtcblx0XHR9XG5cblxuXHRcdC8vIHJlY29yZCBpbmZvcm1hdGlvbiBvbiB0aGUgY2hvc2VuIHVuaXQgLSBmb3IgZHluYW1pYyBsYWJlbCBmb3JtYXR0ZXJcblx0XHR0aWNrUG9zaXRpb25zLmluZm8gPSBleHRlbmQobm9ybWFsaXplZEludGVydmFsLCB7XG5cdFx0XHRoaWdoZXJSYW5rczogaGlnaGVyUmFua3MsXG5cdFx0XHR0b3RhbFJhbmdlOiBpbnRlcnZhbCAqIGNvdW50XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGlja1Bvc2l0aW9ucztcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgbm9ybWFsaXplZCB0aWNrIGludGVydmFsIGZvciBkYXRlcy4gUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGhcblx0ICogdW5pdCByYW5nZSAoaW50ZXJ2YWwpLCBjb3VudCBhbmQgbmFtZS4gVXNlZCB0byBwcmVwYXJlIGRhdGEgZm9yIGdldFRpbWVUaWNrcy4gXG5cdCAqIFByZXZpb3VzbHkgdGhpcyBsb2dpYyB3YXMgcGFydCBvZiBnZXRUaW1lVGlja3MsIGJ1dCBhcyBnZXRUaW1lVGlja3Mgbm93IHJ1bnNcblx0ICogb2Ygc2VnbWVudHMgaW4gc3RvY2sgY2hhcnRzLCB0aGUgbm9ybWFsaXppbmcgbG9naWMgd2FzIGV4dHJhY3RlZCBpbiBvcmRlciB0byBcblx0ICogcHJldmVudCBpdCBmb3IgcnVubmluZyBvdmVyIGFnYWluIGZvciBlYWNoIHNlZ21lbnQgaGF2aW5nIHRoZSBzYW1lIGludGVydmFsLiBcblx0ICogIzY2MiwgIzY5Ny5cblx0ICovXG5cdEF4aXMucHJvdG90eXBlLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwgPSBmdW5jdGlvbiAodGlja0ludGVydmFsLCB1bml0c09wdGlvbikge1xuXHRcdHZhciB1bml0cyA9IHVuaXRzT3B0aW9uIHx8IFtbXG5cdFx0XHRcdFx0J21pbGxpc2Vjb25kJywgLy8gdW5pdCBuYW1lXG5cdFx0XHRcdFx0WzEsIDIsIDUsIDEwLCAyMCwgMjUsIDUwLCAxMDAsIDIwMCwgNTAwXSAvLyBhbGxvd2VkIG11bHRpcGxlc1xuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J3NlY29uZCcsXG5cdFx0XHRcdFx0WzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnbWludXRlJyxcblx0XHRcdFx0XHRbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCdob3VyJyxcblx0XHRcdFx0XHRbMSwgMiwgMywgNCwgNiwgOCwgMTJdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnZGF5Jyxcblx0XHRcdFx0XHRbMSwgMl1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCd3ZWVrJyxcblx0XHRcdFx0XHRbMSwgMl1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCdtb250aCcsXG5cdFx0XHRcdFx0WzEsIDIsIDMsIDQsIDZdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQneWVhcicsXG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRdXSxcblx0XHRcdHVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXSwgLy8gZGVmYXVsdCB1bml0IGlzIHllYXJzXG5cdFx0XHRpbnRlcnZhbCA9IHRpbWVVbml0c1t1bml0WzBdXSxcblx0XHRcdG11bHRpcGxlcyA9IHVuaXRbMV0sXG5cdFx0XHRjb3VudCxcblx0XHRcdGk7XG5cdFx0XHRcblx0XHQvLyBsb29wIHRocm91Z2ggdGhlIHVuaXRzIHRvIGZpbmQgdGhlIG9uZSB0aGF0IGJlc3QgZml0cyB0aGUgdGlja0ludGVydmFsXG5cdFx0Zm9yIChpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR1bml0ID0gdW5pdHNbaV07XG5cdFx0XHRpbnRlcnZhbCA9IHRpbWVVbml0c1t1bml0WzBdXTtcblx0XHRcdG11bHRpcGxlcyA9IHVuaXRbMV07XG5cblxuXHRcdFx0aWYgKHVuaXRzW2kgKyAxXSkge1xuXHRcdFx0XHQvLyBsZXNzVGhhbiBpcyBpbiB0aGUgbWlkZGxlIGJldHdlZW4gdGhlIGhpZ2hlc3QgbXVsdGlwbGUgYW5kIHRoZSBuZXh0IHVuaXQuXG5cdFx0XHRcdHZhciBsZXNzVGhhbiA9IChpbnRlcnZhbCAqIG11bHRpcGxlc1ttdWx0aXBsZXMubGVuZ3RoIC0gMV0gK1xuXHRcdFx0XHRcdFx0XHR0aW1lVW5pdHNbdW5pdHNbaSArIDFdWzBdXSkgLyAyO1xuXG5cdFx0XHRcdC8vIGJyZWFrIGFuZCBrZWVwIHRoZSBjdXJyZW50IHVuaXRcblx0XHRcdFx0aWYgKHRpY2tJbnRlcnZhbCA8PSBsZXNzVGhhbikge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCAyLjUgeWVhcnMgaW50ZXJ2YWxzLCB0aG91Z2ggMjUsIDI1MCBldGMuIGFyZSBhbGxvd2VkXG5cdFx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHMueWVhciAmJiB0aWNrSW50ZXJ2YWwgPCA1ICogaW50ZXJ2YWwpIHtcblx0XHRcdG11bHRpcGxlcyA9IFsxLCAyLCA1XTtcblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIGNvdW50XG5cdFx0Y291bnQgPSBub3JtYWxpemVUaWNrSW50ZXJ2YWwoXG5cdFx0XHR0aWNrSW50ZXJ2YWwgLyBpbnRlcnZhbCwgXG5cdFx0XHRtdWx0aXBsZXMsXG5cdFx0XHR1bml0WzBdID09PSAneWVhcicgPyBtYXRoTWF4KGdldE1hZ25pdHVkZSh0aWNrSW50ZXJ2YWwgLyBpbnRlcnZhbCksIDEpIDogMSAvLyAjMTkxMywgIzIzNjBcblx0XHQpO1xuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHR1bml0UmFuZ2U6IGludGVydmFsLFxuXHRcdFx0Y291bnQ6IGNvdW50LFxuXHRcdFx0dW5pdE5hbWU6IHVuaXRbMF1cblx0XHR9O1xuXHR9Oy8qKlxuXHQgKiBNZXRob2RzIGRlZmluZWQgb24gdGhlIEF4aXMgcHJvdG90eXBlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHRpY2sgcG9zaXRpb25zIG9mIGEgbG9nYXJpdGhtaWMgYXhpc1xuXHQgKi9cblx0QXhpcy5wcm90b3R5cGUuZ2V0TG9nVGlja1Bvc2l0aW9ucyA9IGZ1bmN0aW9uIChpbnRlcnZhbCwgbWluLCBtYXgsIG1pbm9yKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdGF4aXNMZW5ndGggPSBheGlzLmxlbixcblx0XHRcdC8vIFNpbmNlIHdlIHVzZSB0aGlzIG1ldGhvZCBmb3IgYm90aCBtYWpvciBhbmQgbWlub3IgdGlja3MsXG5cdFx0XHQvLyB1c2UgYSBsb2NhbCB2YXJpYWJsZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcblx0XHRcdHBvc2l0aW9ucyA9IFtdOyBcblx0XHRcblx0XHQvLyBSZXNldFxuXHRcdGlmICghbWlub3IpIHtcblx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmlyc3QgY2FzZTogQWxsIHRpY2tzIGZhbGwgb24gd2hvbGUgbG9nYXJpdGhtczogMSwgMTAsIDEwMCBldGMuXG5cdFx0aWYgKGludGVydmFsID49IDAuNSkge1xuXHRcdFx0aW50ZXJ2YWwgPSBtYXRoUm91bmQoaW50ZXJ2YWwpO1xuXHRcdFx0cG9zaXRpb25zID0gYXhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGludGVydmFsLCBtaW4sIG1heCk7XG5cdFx0XHRcblx0XHQvLyBTZWNvbmQgY2FzZTogV2UgbmVlZCBpbnRlcm1lZGlhcnkgdGlja3MuIEZvciBleGFtcGxlIFxuXHRcdC8vIDEsIDIsIDQsIDYsIDgsIDEwLCAyMCwgNDAgZXRjLiBcblx0XHR9IGVsc2UgaWYgKGludGVydmFsID49IDAuMDgpIHtcblx0XHRcdHZhciByb3VuZGVkTWluID0gbWF0aEZsb29yKG1pbiksXG5cdFx0XHRcdGludGVybWVkaWF0ZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0aixcblx0XHRcdFx0bGVuLFxuXHRcdFx0XHRwb3MsXG5cdFx0XHRcdGxhc3RQb3MsXG5cdFx0XHRcdGJyZWFrMjtcblx0XHRcdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPiAwLjMpIHtcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDRdO1xuXHRcdFx0fSBlbHNlIGlmIChpbnRlcnZhbCA+IDAuMTUpIHsgLy8gMC4yIGVxdWFscyBmaXZlIG1pbm9yIHRpY2tzIHBlciAxLCAxMCwgMTAwIGV0Y1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbMSwgMiwgNCwgNiwgOF07XG5cdFx0XHR9IGVsc2UgeyAvLyAwLjEgZXF1YWxzIHRlbiBtaW5vciB0aWNrcyBwZXIgMSwgMTAsIDEwMCBldGNcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGkgPSByb3VuZGVkTWluOyBpIDwgbWF4ICsgMSAmJiAhYnJlYWsyOyBpKyspIHtcblx0XHRcdFx0bGVuID0gaW50ZXJtZWRpYXRlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGxlbiAmJiAhYnJlYWsyOyBqKyspIHtcblx0XHRcdFx0XHRwb3MgPSBsb2cybGluKGxpbjJsb2coaSkgKiBpbnRlcm1lZGlhdGVbal0pO1xuXHRcdFx0XHRcdGlmIChwb3MgPiBtaW4gJiYgKCFtaW5vciB8fCBsYXN0UG9zIDw9IG1heCkgJiYgbGFzdFBvcyAhPT0gVU5ERUZJTkVEKSB7IC8vICMxNjcwLCBsYXN0UG9zIGlzICMzMTEzXG5cdFx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChsYXN0UG9zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGxhc3RQb3MgPiBtYXgpIHtcblx0XHRcdFx0XHRcdGJyZWFrMiA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3RQb3MgPSBwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdC8vIFRoaXJkIGNhc2U6IFdlIGFyZSBzbyBkZWVwIGluIGJldHdlZW4gd2hvbGUgbG9nYXJpdGhtaWMgdmFsdWVzIHRoYXRcblx0XHQvLyB3ZSBtaWdodCBhcyB3ZWxsIGhhbmRsZSB0aGUgdGljayBwb3NpdGlvbnMgbGlrZSBhIGxpbmVhciBheGlzLiBGb3Jcblx0XHQvLyBleGFtcGxlIDEuMDEsIDEuMDIsIDEuMDMsIDEuMDQuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciByZWFsTWluID0gbGluMmxvZyhtaW4pLFxuXHRcdFx0XHRyZWFsTWF4ID0gbGluMmxvZyhtYXgpLFxuXHRcdFx0XHR0aWNrSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zW21pbm9yID8gJ21pbm9yVGlja0ludGVydmFsJyA6ICd0aWNrSW50ZXJ2YWwnXSxcblx0XHRcdFx0ZmlsdGVyZWRUaWNrSW50ZXJ2YWxPcHRpb24gPSB0aWNrSW50ZXJ2YWxPcHRpb24gPT09ICdhdXRvJyA/IG51bGwgOiB0aWNrSW50ZXJ2YWxPcHRpb24sXG5cdFx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCAvIChtaW5vciA/IDUgOiAxKSxcblx0XHRcdFx0dG90YWxQaXhlbExlbmd0aCA9IG1pbm9yID8gYXhpc0xlbmd0aCAvIGF4aXMudGlja1Bvc2l0aW9ucy5sZW5ndGggOiBheGlzTGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHRpbnRlcnZhbCA9IHBpY2soXG5cdFx0XHRcdGZpbHRlcmVkVGlja0ludGVydmFsT3B0aW9uLFxuXHRcdFx0XHRheGlzLl9taW5vckF1dG9JbnRlcnZhbCxcblx0XHRcdFx0KHJlYWxNYXggLSByZWFsTWluKSAqIHRpY2tQaXhlbEludGVydmFsT3B0aW9uIC8gKHRvdGFsUGl4ZWxMZW5ndGggfHwgMSlcblx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdGludGVydmFsID0gbm9ybWFsaXplVGlja0ludGVydmFsKFxuXHRcdFx0XHRpbnRlcnZhbCwgXG5cdFx0XHRcdG51bGwsIFxuXHRcdFx0XHRnZXRNYWduaXR1ZGUoaW50ZXJ2YWwpXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRwb3NpdGlvbnMgPSBtYXAoYXhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKFxuXHRcdFx0XHRpbnRlcnZhbCwgXG5cdFx0XHRcdHJlYWxNaW4sXG5cdFx0XHRcdHJlYWxNYXhcdFxuXHRcdFx0KSwgbG9nMmxpbik7XG5cdFx0XHRcblx0XHRcdGlmICghbWlub3IpIHtcblx0XHRcdFx0YXhpcy5fbWlub3JBdXRvSW50ZXJ2YWwgPSBpbnRlcnZhbCAvIDU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFNldCB0aGUgYXhpcy1sZXZlbCB0aWNrSW50ZXJ2YWwgdmFyaWFibGUgXG5cdFx0aWYgKCFtaW5vcikge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHBvc2l0aW9ucztcblx0fTsvKipcblx0ICogVGhlIHRvb2x0aXAgb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgY2hhcnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVG9vbHRpcCBvcHRpb25zXG5cdCAqL1xuXHR2YXIgVG9vbHRpcCA9IEhpZ2hjaGFydHMuVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRUb29sdGlwLnByb3RvdHlwZSA9IHtcblxuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXG5cdFx0XHR2YXIgYm9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRzdHlsZSA9IG9wdGlvbnMuc3R5bGUsXG5cdFx0XHRcdHBhZGRpbmcgPSBwSW50KHN0eWxlLnBhZGRpbmcpO1xuXG5cdFx0XHQvLyBTYXZlIHRoZSBjaGFydCBhbmQgb3B0aW9uc1xuXHRcdFx0dGhpcy5jaGFydCA9IGNoYXJ0O1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBzZXJpZXNcblx0XHRcdC8vdGhpcy5jdXJyZW50U2VyaWVzID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBMaXN0IG9mIGNyb3NzaGFpcnNcblx0XHRcdHRoaXMuY3Jvc3NoYWlycyA9IFtdO1xuXG5cdFx0XHQvLyBDdXJyZW50IHZhbHVlcyBvZiB4IGFuZCB5IHdoZW4gYW5pbWF0aW5nXG5cdFx0XHR0aGlzLm5vdyA9IHsgeDogMCwgeTogMCB9O1xuXG5cdFx0XHQvLyBUaGUgdG9vbHRpcCBpcyBpbml0aWFsbHkgaGlkZGVuXG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcblxuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIGxhYmVsXHRcdFxuXHRcdFx0dGhpcy5sYWJlbCA9IGNoYXJ0LnJlbmRlcmVyLmxhYmVsKCcnLCAwLCAwLCBvcHRpb25zLnNoYXBlIHx8ICdjYWxsb3V0JywgbnVsbCwgbnVsbCwgb3B0aW9ucy51c2VIVE1MLCBudWxsLCAndG9vbHRpcCcpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRwYWRkaW5nOiBwYWRkaW5nLFxuXHRcdFx0XHRcdGZpbGw6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBib3JkZXJXaWR0aCxcblx0XHRcdFx0XHRyOiBvcHRpb25zLmJvcmRlclJhZGl1cyxcblx0XHRcdFx0XHR6SW5kZXg6IDhcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhzdHlsZSlcblx0XHRcdFx0LmNzcyh7IHBhZGRpbmc6IDAgfSkgLy8gUmVtb3ZlIGl0IGZyb20gVk1MLCB0aGUgcGFkZGluZyBpcyBhcHBsaWVkIGFzIGFuIGF0dHJpYnV0ZSBpbnN0ZWFkICgjMTExNylcblx0XHRcdFx0LmFkZCgpXG5cdFx0XHRcdC5hdHRyKHsgeTogLTk5OTkgfSk7IC8vICMyMzAxLCAjMjY1N1xuXG5cdFx0XHQvLyBXaGVuIHVzaW5nIGNhblZHIHRoZSBzaGFkb3cgc2hvd3MgdXAgYXMgYSBncmF5IGNpcmNsZVxuXHRcdFx0Ly8gZXZlbiBpZiB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0XHRpZiAoIXVzZUNhblZHKSB7XG5cdFx0XHRcdHRoaXMubGFiZWwuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHVibGljIHByb3BlcnR5IGZvciBnZXR0aW5nIHRoZSBzaGFyZWQgc3RhdGUuXG5cdFx0XHR0aGlzLnNoYXJlZCA9IG9wdGlvbnMuc2hhcmVkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IHRoZSB0b29sdGlwIGFuZCBpdHMgZWxlbWVudHMuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gRGVzdHJveSBhbmQgY2xlYXIgbG9jYWwgdmFyaWFibGVzXG5cdFx0XHRpZiAodGhpcy5sYWJlbCkge1xuXHRcdFx0XHR0aGlzLmxhYmVsID0gdGhpcy5sYWJlbC5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlIGEgc29mdCBtb3ZlbWVudCBmb3IgdGhlIHRvb2x0aXBcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG1vdmU6IGZ1bmN0aW9uICh4LCB5LCBhbmNob3JYLCBhbmNob3JZKSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRcdG5vdyA9IHRvb2x0aXAubm93LFxuXHRcdFx0XHRhbmltYXRlID0gdG9vbHRpcC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UgJiYgIXRvb2x0aXAuaXNIaWRkZW4gJiYgXG5cdFx0XHRcdFx0Ly8gV2hlbiB3ZSBnZXQgY2xvc2UgdG8gdGhlIHRhcmdldCBwb3NpdGlvbiwgYWJvcnQgYW5pbWF0aW9uIGFuZCBsYW5kIG9uIHRoZSByaWdodCBwbGFjZSAoIzMwNTYpXG5cdFx0XHRcdFx0KG1hdGhBYnMoeCAtIG5vdy54KSA+IDEgfHwgbWF0aEFicyh5IC0gbm93LnkpID4gMSksXG5cdFx0XHRcdHNraXBBbmNob3IgPSB0b29sdGlwLmZvbGxvd1BvaW50ZXIgfHwgdG9vbHRpcC5sZW4gPiAxO1xuXG5cdFx0XHQvLyBHZXQgaW50ZXJtZWRpYXRlIHZhbHVlcyBmb3IgYW5pbWF0aW9uXG5cdFx0XHRleHRlbmQobm93LCB7XG5cdFx0XHRcdHg6IGFuaW1hdGUgPyAoMiAqIG5vdy54ICsgeCkgLyAzIDogeCxcblx0XHRcdFx0eTogYW5pbWF0ZSA/IChub3cueSArIHkpIC8gMiA6IHksXG5cdFx0XHRcdGFuY2hvclg6IHNraXBBbmNob3IgPyBVTkRFRklORUQgOiBhbmltYXRlID8gKDIgKiBub3cuYW5jaG9yWCArIGFuY2hvclgpIC8gMyA6IGFuY2hvclgsXG5cdFx0XHRcdGFuY2hvclk6IHNraXBBbmNob3IgPyBVTkRFRklORUQgOiBhbmltYXRlID8gKG5vdy5hbmNob3JZICsgYW5jaG9yWSkgLyAyIDogYW5jaG9yWVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIE1vdmUgdG8gdGhlIGludGVybWVkaWF0ZSB2YWx1ZVxuXHRcdFx0dG9vbHRpcC5sYWJlbC5hdHRyKG5vdyk7XG5cblx0XHRcdFxuXHRcdFx0Ly8gUnVuIG9uIG5leHQgdGljayBvZiB0aGUgbW91c2UgdHJhY2tlclxuXHRcdFx0aWYgKGFuaW1hdGUpIHtcblx0XHRcdFxuXHRcdFx0XHQvLyBOZXZlciBhbGxvdyB0d28gdGltZW91dHNcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU2V0IHRoZSBmaXhlZCBpbnRlcnZhbCB0aWNraW5nIGZvciB0aGUgc21vb3RoIHRvb2x0aXBcblx0XHRcdFx0dGhpcy50b29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIFRoZSBpbnRlcnZhbCBmdW5jdGlvbiBtYXkgc3RpbGwgYmUgcnVubmluZyBkdXJpbmcgZGVzdHJveSwgc28gY2hlY2sgdGhhdCB0aGUgY2hhcnQgaXMgcmVhbGx5IHRoZXJlIGJlZm9yZSBjYWxsaW5nLlxuXHRcdFx0XHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRcdFx0XHR0b29sdGlwLm1vdmUoeCwgeSwgYW5jaG9yWCwgYW5jaG9yWSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAzMik7XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWRlIHRoZSB0b29sdGlwXG5cdFx0ICovXG5cdFx0aGlkZTogZnVuY3Rpb24gKGRlbGF5KSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRcdGhvdmVyUG9pbnRzO1xuXHRcdFx0XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpOyAvLyBkaXNhbGxvdyBkdXBsaWNhdGUgdGltZXJzICgjMTcyOCwgIzE3NjYpXG5cdFx0XHRpZiAoIXRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdFx0aG92ZXJQb2ludHMgPSB0aGlzLmNoYXJ0LmhvdmVyUG9pbnRzO1xuXG5cdFx0XHRcdHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dG9vbHRpcC5sYWJlbC5mYWRlT3V0KCk7XG5cdFx0XHRcdFx0dG9vbHRpcC5pc0hpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0sIHBpY2soZGVsYXksIHRoaXMub3B0aW9ucy5oaWRlRGVsYXksIDUwMCkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIEV4dGVuZGFibGUgbWV0aG9kIHRvIGdldCB0aGUgYW5jaG9yIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwXG5cdFx0ICogZnJvbSBhIHBvaW50IG9yIHNldCBvZiBwb2ludHNcblx0XHQgKi9cblx0XHRnZXRBbmNob3I6IGZ1bmN0aW9uIChwb2ludHMsIG1vdXNlRXZlbnQpIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdHBsb3RYID0gMCxcblx0XHRcdFx0cGxvdFkgPSAwLFxuXHRcdFx0XHR5QXhpcyxcblx0XHRcdFx0eEF4aXM7XG5cdFx0XHRcblx0XHRcdHBvaW50cyA9IHNwbGF0KHBvaW50cyk7XG5cdFx0XHRcblx0XHRcdC8vIFBpZSB1c2VzIGEgc3BlY2lhbCB0b29sdGlwUG9zXG5cdFx0XHRyZXQgPSBwb2ludHNbMF0udG9vbHRpcFBvcztcblx0XHRcdFxuXHRcdFx0Ly8gV2hlbiB0b29sdGlwIGZvbGxvd3MgbW91c2UsIHJlbGF0ZSB0aGUgcG9zaXRpb24gdG8gdGhlIG1vdXNlXG5cdFx0XHRpZiAodGhpcy5mb2xsb3dQb2ludGVyICYmIG1vdXNlRXZlbnQpIHtcblx0XHRcdFx0aWYgKG1vdXNlRXZlbnQuY2hhcnRYID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRtb3VzZUV2ZW50ID0gY2hhcnQucG9pbnRlci5ub3JtYWxpemUobW91c2VFdmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHQvLyBXaGVuIHNoYXJlZCwgdXNlIHRoZSBhdmVyYWdlIHBvc2l0aW9uXG5cdFx0XHRpZiAoIXJldCkge1xuXHRcdFx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0eUF4aXMgPSBwb2ludC5zZXJpZXMueUF4aXM7XG5cdFx0XHRcdFx0eEF4aXMgPSBwb2ludC5zZXJpZXMueEF4aXM7XG5cdFx0XHRcdFx0cGxvdFggKz0gcG9pbnQucGxvdFggICsgKCFpbnZlcnRlZCAmJiB4QXhpcyA/IHhBeGlzLmxlZnQgLSBwbG90TGVmdCA6IDApOyBcblx0XHRcdFx0XHRwbG90WSArPSAocG9pbnQucGxvdExvdyA/IChwb2ludC5wbG90TG93ICsgcG9pbnQucGxvdEhpZ2gpIC8gMiA6IHBvaW50LnBsb3RZKSArXG5cdFx0XHRcdFx0XHQoIWludmVydGVkICYmIHlBeGlzID8geUF4aXMudG9wIC0gcGxvdFRvcCA6IDApOyAvLyAjMTE1MVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHBsb3RYIC89IHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdHBsb3RZIC89IHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXQgPSBbXG5cdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5wbG90V2lkdGggLSBwbG90WSA6IHBsb3RYLFxuXHRcdFx0XHRcdHRoaXMuc2hhcmVkICYmICFpbnZlcnRlZCAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiBtb3VzZUV2ZW50ID8gXG5cdFx0XHRcdFx0XHRtb3VzZUV2ZW50LmNoYXJ0WSAtIHBsb3RUb3AgOiAvLyBwbGFjZSBzaGFyZWQgdG9vbHRpcCBuZXh0IHRvIHRoZSBtb3VzZSAoIzQyNClcblx0XHRcdFx0XHRcdGludmVydGVkID8gY2hhcnQucGxvdEhlaWdodCAtIHBsb3RYIDogcGxvdFlcblx0XHRcdFx0XTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hcChyZXQsIG1hdGhSb3VuZCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBQbGFjZSB0aGUgdG9vbHRpcCBpbiBhIGNoYXJ0IHdpdGhvdXQgc3BpbGxpbmcgb3ZlclxuXHRcdCAqIGFuZCBub3QgY292ZXJpbmcgdGhlIHBvaW50IGl0IHNlbGYuXG5cdFx0ICovXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChib3hXaWR0aCwgYm94SGVpZ2h0LCBwb2ludCkge1xuXHRcdFx0XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UsXG5cdFx0XHRcdHJldCA9IHt9LFxuXHRcdFx0XHRoID0gcG9pbnQuaCB8fCAwLCAvLyAjNDExN1xuXHRcdFx0XHRzd2FwcGVkLFxuXHRcdFx0XHRmaXJzdCA9IFsneScsIGNoYXJ0LmNoYXJ0SGVpZ2h0LCBib3hIZWlnaHQsIHBvaW50LnBsb3RZICsgY2hhcnQucGxvdFRvcF0sXG5cdFx0XHRcdHNlY29uZCA9IFsneCcsIGNoYXJ0LmNoYXJ0V2lkdGgsIGJveFdpZHRoLCBwb2ludC5wbG90WCArIGNoYXJ0LnBsb3RMZWZ0XSxcblx0XHRcdFx0Ly8gVGhlIGZhciBzaWRlIGlzIHJpZ2h0IG9yIGJvdHRvbVxuXHRcdFx0XHRwcmVmZXJGYXJTaWRlID0gcGljayhwb2ludC50dEJlbG93LCAoY2hhcnQuaW52ZXJ0ZWQgJiYgIXBvaW50Lm5lZ2F0aXZlKSB8fCAoIWNoYXJ0LmludmVydGVkICYmIHBvaW50Lm5lZ2F0aXZlKSksXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBIYW5kbGUgdGhlIHByZWZlcnJlZCBkaW1lbnNpb24uIFdoZW4gdGhlIHByZWZlcnJlZCBkaW1lbnNpb24gaXMgdG9vbHRpcFxuXHRcdFx0XHQgKiBvbiB0b3Agb3IgYm90dG9tIG9mIHRoZSBwb2ludCwgaXQgd2lsbCBsb29rIGZvciBzcGFjZSB0aGVyZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGZpcnN0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSwgb3V0ZXJTaXplLCBpbm5lclNpemUsIHBvaW50KSB7XG5cdFx0XHRcdFx0dmFyIHJvb21MZWZ0ID0gaW5uZXJTaXplIDwgcG9pbnQgLSBkaXN0YW5jZSxcblx0XHRcdFx0XHRcdHJvb21SaWdodCA9IHBvaW50ICsgZGlzdGFuY2UgKyBpbm5lclNpemUgPCBvdXRlclNpemUsXG5cdFx0XHRcdFx0XHRhbGlnbmVkTGVmdCA9IHBvaW50IC0gZGlzdGFuY2UgLSBpbm5lclNpemUsXG5cdFx0XHRcdFx0XHRhbGlnbmVkUmlnaHQgPSBwb2ludCArIGRpc3RhbmNlO1xuXG5cdFx0XHRcdFx0aWYgKHByZWZlckZhclNpZGUgJiYgcm9vbVJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRSaWdodDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFwcmVmZXJGYXJTaWRlICYmIHJvb21MZWZ0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRMZWZ0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocm9vbUxlZnQpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gYWxpZ25lZExlZnQgLSBoIDwgMCA/IGFsaWduZWRMZWZ0IDogYWxpZ25lZExlZnQgLSBoO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocm9vbVJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRSaWdodCArIGggKyBpbm5lclNpemUgPiBvdXRlclNpemUgPyBhbGlnbmVkUmlnaHQgOiBhbGlnbmVkUmlnaHQgKyBoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogSGFuZGxlIHRoZSBzZWNvbmRhcnkgZGltZW5zaW9uLiBJZiB0aGUgcHJlZmVycmVkIGRpbWVuc2lvbiBpcyB0b29sdGlwXG5cdFx0XHRcdCAqIG9uIHRvcCBvciBib3R0b20gb2YgdGhlIHBvaW50LCB0aGUgc2Vjb25kIGRpbWVuc2lvbiBpcyB0byBhbGlnbiB0aGUgdG9vbHRpcFxuXHRcdFx0XHQgKiBhYm92ZSB0aGUgcG9pbnQsIHRyeWluZyB0byBhbGlnbiBjZW50ZXIgYnV0IGFsbG93aW5nIGxlZnQgb3IgcmlnaHRcblx0XHRcdFx0ICogYWxpZ24gd2l0aGluIHRoZSBjaGFydCBib3guXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRzZWNvbmREaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltLCBvdXRlclNpemUsIGlubmVyU2l6ZSwgcG9pbnQpIHtcblx0XHRcdFx0XHQvLyBUb28gY2xvc2UgdG8gdGhlIGVkZ2UsIHJldHVybiBmYWxzZSBhbmQgc3dhcCBkaW1lbnNpb25zXG5cdFx0XHRcdFx0aWYgKHBvaW50IDwgZGlzdGFuY2UgfHwgcG9pbnQgPiBvdXRlclNpemUgLSBkaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEFsaWduIGxlZnQvdG9wXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb2ludCA8IGlubmVyU2l6ZSAvIDIpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gMTtcblx0XHRcdFx0XHQvLyBBbGlnbiByaWdodC9ib3R0b21cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvaW50ID4gb3V0ZXJTaXplIC0gaW5uZXJTaXplIC8gMikge1xuXHRcdFx0XHRcdFx0cmV0W2RpbV0gPSBvdXRlclNpemUgLSBpbm5lclNpemUgLSAyO1xuXHRcdFx0XHRcdC8vIEFsaWduIGNlbnRlclxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IHBvaW50IC0gaW5uZXJTaXplIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBTd2FwIHRoZSBkaW1lbnNpb25zIFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0c3dhcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuXHRcdFx0XHRcdHZhciB0ZW1wID0gZmlyc3Q7XG5cdFx0XHRcdFx0Zmlyc3QgPSBzZWNvbmQ7XG5cdFx0XHRcdFx0c2Vjb25kID0gdGVtcDtcblx0XHRcdFx0XHRzd2FwcGVkID0gY291bnQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJ1biA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoZmlyc3REaW1lbnNpb24uYXBwbHkoMCwgZmlyc3QpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0aWYgKHNlY29uZERpbWVuc2lvbi5hcHBseSgwLCBzZWNvbmQpID09PSBmYWxzZSAmJiAhc3dhcHBlZCkge1xuXHRcdFx0XHRcdFx0XHRzd2FwKHRydWUpO1xuXHRcdFx0XHRcdFx0XHRydW4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzd2FwcGVkKSB7XG5cdFx0XHRcdFx0XHRzd2FwKHRydWUpO1xuXHRcdFx0XHRcdFx0cnVuKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldC54ID0gcmV0LnkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gVW5kZXIgdGhlc2UgY29uZGl0aW9ucywgcHJlZmVyIHRoZSB0b29sdGlwIG9uIHRoZSBzaWRlIG9mIHRoZSBwb2ludFxuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkIHx8IHRoaXMubGVuID4gMSkge1xuXHRcdFx0XHRzd2FwKCk7XG5cdFx0XHR9XG5cdFx0XHRydW4oKTtcblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW4gY2FzZSBubyB1c2VyIGRlZmluZWQgZm9ybWF0dGVyIGlzIGdpdmVuLCB0aGlzIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHRoZSBjb250ZXh0XG5cdFx0ICogaGVyZSBpcyBhbiBvYmplY3QgaG9sZGluZyBwb2ludCwgc2VyaWVzLCB4LCB5IGV0Yy5cblx0XHQgKi9cblx0XHRkZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5wb2ludHMgfHwgc3BsYXQodGhpcyksXG5cdFx0XHRcdHM7XG5cblx0XHRcdC8vIGJ1aWxkIHRoZSBoZWFkZXJcblx0XHRcdHMgPSBbdG9vbHRpcC50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGl0ZW1zWzBdKV07IC8vIzMzOTc6IGFic3RyYWN0aW9uIHRvIGVuYWJsZSBmb3JtYXR0aW5nIG9mIGZvb3RlciBhbmQgaGVhZGVyXG5cblx0XHRcdC8vIGJ1aWxkIHRoZSB2YWx1ZXNcblx0XHRcdHMgPSBzLmNvbmNhdCh0b29sdGlwLmJvZHlGb3JtYXR0ZXIoaXRlbXMpKTtcblxuXHRcdFx0Ly8gZm9vdGVyXG5cdFx0XHRzLnB1c2godG9vbHRpcC50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGl0ZW1zWzBdLCB0cnVlKSk7IC8vIzMzOTc6IGFic3RyYWN0aW9uIHRvIGVuYWJsZSBmb3JtYXR0aW5nIG9mIGZvb3RlciBhbmQgaGVhZGVyXG5cblx0XHRcdHJldHVybiBzLmpvaW4oJycpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWZyZXNoIHRoZSB0b29sdGlwJ3MgdGV4dCBhbmQgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG5cdFx0ICovXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24gKHBvaW50LCBtb3VzZUV2ZW50KSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gdG9vbHRpcC5jaGFydCxcblx0XHRcdFx0bGFiZWwgPSB0b29sdGlwLmxhYmVsLFxuXHRcdFx0XHRvcHRpb25zID0gdG9vbHRpcC5vcHRpb25zLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRhbmNob3IsXG5cdFx0XHRcdHRleHRDb25maWcgPSB7fSxcblx0XHRcdFx0dGV4dCxcblx0XHRcdFx0cG9pbnRDb25maWcgPSBbXSxcblx0XHRcdFx0Zm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgdG9vbHRpcC5kZWZhdWx0Rm9ybWF0dGVyLFxuXHRcdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0XHRib3JkZXJDb2xvcixcblx0XHRcdFx0c2hhcmVkID0gdG9vbHRpcC5zaGFyZWQsXG5cdFx0XHRcdGN1cnJlbnRTZXJpZXM7XG5cdFx0XHRcdFxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcblx0XHRcdFxuXHRcdFx0Ly8gZ2V0IHRoZSByZWZlcmVuY2UgcG9pbnQgY29vcmRpbmF0ZXMgKHBpZSBjaGFydHMgdXNlIHRvb2x0aXBQb3MpXG5cdFx0XHR0b29sdGlwLmZvbGxvd1BvaW50ZXIgPSBzcGxhdChwb2ludClbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG5cdFx0XHRhbmNob3IgPSB0b29sdGlwLmdldEFuY2hvcihwb2ludCwgbW91c2VFdmVudCk7XG5cdFx0XHR4ID0gYW5jaG9yWzBdO1xuXHRcdFx0eSA9IGFuY2hvclsxXTtcblxuXHRcdFx0Ly8gc2hhcmVkIHRvb2x0aXAsIGFycmF5IGlzIHNlbnQgb3ZlclxuXHRcdFx0aWYgKHNoYXJlZCAmJiAhKHBvaW50LnNlcmllcyAmJiBwb2ludC5zZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaGlkZSBwcmV2aW91cyBob3ZlclBvaW50cyBhbmQgc2V0IG5ld1xuXHRcdFx0XHRcblx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBwb2ludDtcblx0XHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdFx0ZWFjaChob3ZlclBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWFjaChwb2ludCwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0XHRpdGVtLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblxuXHRcdFx0XHRcdHBvaW50Q29uZmlnLnB1c2goaXRlbS5nZXRMYWJlbENvbmZpZygpKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGV4dENvbmZpZyA9IHtcblx0XHRcdFx0XHR4OiBwb2ludFswXS5jYXRlZ29yeSxcblx0XHRcdFx0XHR5OiBwb2ludFswXS55XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRleHRDb25maWcucG9pbnRzID0gcG9pbnRDb25maWc7XG5cdFx0XHRcdHRoaXMubGVuID0gcG9pbnRDb25maWcubGVuZ3RoO1xuXHRcdFx0XHRwb2ludCA9IHBvaW50WzBdO1xuXG5cdFx0XHQvLyBzaW5nbGUgcG9pbnQgdG9vbHRpcFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGV4dENvbmZpZyA9IHBvaW50LmdldExhYmVsQ29uZmlnKCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0ID0gZm9ybWF0dGVyLmNhbGwodGV4dENvbmZpZywgdG9vbHRpcCk7XG5cblx0XHRcdC8vIHJlZ2lzdGVyIHRoZSBjdXJyZW50IHNlcmllc1xuXHRcdFx0Y3VycmVudFNlcmllcyA9IHBvaW50LnNlcmllcztcblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBwaWNrKGN1cnJlbnRTZXJpZXMudG9vbHRpcE9wdGlvbnMuZGlzdGFuY2UsIDE2KTtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBpbm5lciBIVE1MXG5cdFx0XHRpZiAodGV4dCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHNob3cgaXRcblx0XHRcdFx0aWYgKHRvb2x0aXAuaXNIaWRkZW4pIHtcblx0XHRcdFx0XHRzdG9wKGxhYmVsKTtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKCdvcGFjaXR5JywgMSkuc2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRleHRcblx0XHRcdFx0bGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBzZXQgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgYm94XG5cdFx0XHRcdGJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvciB8fCBwb2ludC5jb2xvciB8fCBjdXJyZW50U2VyaWVzLmNvbG9yIHx8ICcjNjA2MDYwJztcblx0XHRcdFx0bGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiBib3JkZXJDb2xvclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IFxuXHRcdFx0XHRcdHBsb3RYOiB4LCBcblx0XHRcdFx0XHRwbG90WTogeSwgXG5cdFx0XHRcdFx0bmVnYXRpdmU6IHBvaW50Lm5lZ2F0aXZlLCBcblx0XHRcdFx0XHR0dEJlbG93OiBwb2ludC50dEJlbG93LCBcblx0XHRcdFx0XHRoOiBhbmNob3JbMl0gfHwgMFxuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0XHR0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICd0b29sdGlwUmVmcmVzaCcsIHtcblx0XHRcdFx0XHR0ZXh0OiB0ZXh0LFxuXHRcdFx0XHRcdHg6IHggKyBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHR5OiB5ICsgY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogYm9yZGVyQ29sb3Jcblx0XHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kIHRoZSBuZXcgcG9zaXRpb24gYW5kIHBlcmZvcm0gdGhlIG1vdmVcblx0XHQgKi9cblx0XHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsIFxuXHRcdFx0XHRwb3MgPSAodGhpcy5vcHRpb25zLnBvc2l0aW9uZXIgfHwgdGhpcy5nZXRQb3NpdGlvbikuY2FsbChcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdGxhYmVsLndpZHRoLFxuXHRcdFx0XHRcdGxhYmVsLmhlaWdodCxcblx0XHRcdFx0XHRwb2ludFxuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBkbyB0aGUgbW92ZVxuXHRcdFx0dGhpcy5tb3ZlKFxuXHRcdFx0XHRtYXRoUm91bmQocG9zLngpLCBcblx0XHRcdFx0bWF0aFJvdW5kKHBvcy55IHx8IDApLCAvLyBjYW4gYmUgdW5kZWZpbmVkICgjMzk3NykgXG5cdFx0XHRcdHBvaW50LnBsb3RYICsgY2hhcnQucGxvdExlZnQsIFxuXHRcdFx0XHRwb2ludC5wbG90WSArIGNoYXJ0LnBsb3RUb3Bcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKiBcblx0XHQgKiBHZXQgdGhlIGJlc3QgWCBkYXRlIGZvcm1hdCBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCByYW5nZSBvbiB0aGUgYXhpcy5cblx0XHQgKi9cblx0XHRnZXRYRGF0ZUZvcm1hdDogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zLCB4QXhpcykge1xuXHRcdFx0dmFyIHhEYXRlRm9ybWF0LFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0cyA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHMsXG5cdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlID0geEF4aXMgJiYgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdG4sXG5cdFx0XHRcdGJsYW5rID0gJzAxLTAxIDAwOjAwOjAwLjAwMCcsXG5cdFx0XHRcdHN0cnBvcyA9IHtcblx0XHRcdFx0XHRtaWxsaXNlY29uZDogMTUsXG5cdFx0XHRcdFx0c2Vjb25kOiAxMixcblx0XHRcdFx0XHRtaW51dGU6IDksXG5cdFx0XHRcdFx0aG91cjogNixcblx0XHRcdFx0XHRkYXk6IDNcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGF0ZSxcblx0XHRcdFx0bGFzdE4gPSAnbWlsbGlzZWNvbmQnOyAvLyBmb3Igc3ViLW1pbGxpc2Vjb25kIGRhdGEsICM0MjIzXG5cblx0XHRcdGlmIChjbG9zZXN0UG9pbnRSYW5nZSkge1xuXHRcdFx0XHRkYXRlID0gZGF0ZUZvcm1hdCgnJW0tJWQgJUg6JU06JVMuJUwnLCBwb2ludC54KTtcblx0XHRcdFx0Zm9yIChuIGluIHRpbWVVbml0cykge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJhbmdlIGlzIGV4YWN0bHkgb25lIHdlZWsgYW5kIHdlJ3JlIGxvb2tpbmcgYXQgYSBTdW5kYXkvTW9uZGF5LCBnbyBmb3IgdGhlIHdlZWsgZm9ybWF0XG5cdFx0XHRcdFx0aWYgKGNsb3Nlc3RQb2ludFJhbmdlID09PSB0aW1lVW5pdHMud2VlayAmJiArZGF0ZUZvcm1hdCgnJXcnLCBwb2ludC54KSA9PT0geEF4aXMub3B0aW9ucy5zdGFydE9mV2VlayAmJiBcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zdWJzdHIoNikgPT09IGJsYW5rLnN1YnN0cig2KSkge1xuXHRcdFx0XHRcdFx0biA9ICd3ZWVrJztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIGZpcnN0IGZvcm1hdCB0aGF0IGlzIHRvbyBncmVhdCBmb3IgdGhlIHJhbmdlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aW1lVW5pdHNbbl0gPiBjbG9zZXN0UG9pbnRSYW5nZSkge1xuXHRcdFx0XHRcdFx0biA9IGxhc3ROO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBvaW50IGlzIHBsYWNlZCBldmVyeSBkYXkgYXQgMjM6NTksIHdlIG5lZWQgdG8gc2hvd1xuXHRcdFx0XHRcdC8vIHRoZSBtaW51dGVzIGFzIHdlbGwuICMyNjM3LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RycG9zW25dICYmIGRhdGUuc3Vic3RyKHN0cnBvc1tuXSkgIT09IGJsYW5rLnN1YnN0cihzdHJwb3Nbbl0pKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXZWVrcyBhcmUgb3V0c2lkZSB0aGUgaGllcmFyY2h5LCBvbmx5IGFwcGx5IHRoZW0gb24gTW9uZGF5cy9TdW5kYXlzIGxpa2UgaW4gdGhlIGZpcnN0IGNvbmRpdGlvblxuXHRcdFx0XHRcdGlmIChuICE9PSAnd2VlaycpIHtcblx0XHRcdFx0XHRcdGxhc3ROID0gbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuKSB7XG5cdFx0XHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0c1tuXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0cy5kYXk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB4RGF0ZUZvcm1hdCB8fCBkYXRlVGltZUxhYmVsRm9ybWF0cy55ZWFyOyAvLyAjMjU0NiwgMjU4MVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3JtYXQgdGhlIGZvb3Rlci9oZWFkZXIgb2YgdGhlIHRvb2x0aXBcblx0XHQgKiAjMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblx0XHQgKi9cblx0XHR0b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyOiBmdW5jdGlvbiAocG9pbnQsIGlzRm9vdGVyKSB7XG5cdFx0XHR2YXIgZm9vdE9ySGVhZCA9IGlzRm9vdGVyID8gJ2Zvb3RlcicgOiAnaGVhZGVyJyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHR0b29sdGlwT3B0aW9ucyA9IHNlcmllcy50b29sdGlwT3B0aW9ucyxcblx0XHRcdFx0eERhdGVGb3JtYXQgPSB0b29sdGlwT3B0aW9ucy54RGF0ZUZvcm1hdCxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGlzRGF0ZVRpbWUgPSB4QXhpcyAmJiB4QXhpcy5vcHRpb25zLnR5cGUgPT09ICdkYXRldGltZScgJiYgaXNOdW1iZXIocG9pbnQua2V5KSxcblx0XHRcdFx0Zm9ybWF0U3RyaW5nID0gdG9vbHRpcE9wdGlvbnNbZm9vdE9ySGVhZCsnRm9ybWF0J107XG5cblx0XHRcdC8vIEd1ZXNzIHRoZSBiZXN0IGRhdGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGRpc3RhbmNlICgjNTY4LCAjMzQxOClcblx0XHRcdGlmIChpc0RhdGVUaW1lICYmICF4RGF0ZUZvcm1hdCkge1xuXHRcdFx0XHR4RGF0ZUZvcm1hdCA9IHRoaXMuZ2V0WERhdGVGb3JtYXQocG9pbnQsIHRvb2x0aXBPcHRpb25zLCB4QXhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc2VydCB0aGUgZm9vdGVyIGRhdGUgZm9ybWF0IGlmIGFueVxuXHRcdFx0aWYgKGlzRGF0ZVRpbWUgJiYgeERhdGVGb3JtYXQpIHtcblx0XHRcdFx0Zm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UoJ3twb2ludC5rZXl9JywgJ3twb2ludC5rZXk6JyArIHhEYXRlRm9ybWF0ICsgJ30nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZvcm1hdChmb3JtYXRTdHJpbmcsIHtcblx0XHRcdFx0cG9pbnQ6IHBvaW50LFxuXHRcdFx0XHRzZXJpZXM6IHNlcmllc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHQgICAgICogQnVpbGQgdGhlIGJvZHkgKGxpbmVzKSBvZiB0aGUgdG9vbHRpcCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgaXRlbXMgYW5kIHJldHVybmluZyBvbmUgZW50cnkgZm9yIGVhY2ggaXRlbSxcblx0ICAgICAqIGFic3RyYWN0aW5nIHRoaXMgZnVuY3Rpb25hbGl0eSBhbGxvd3MgdG8gZWFzaWx5IG92ZXJ3cml0ZSBhbmQgZXh0ZW5kIGl0LiBcblx0XHQgKi9cblx0XHRib2R5Rm9ybWF0dGVyOiBmdW5jdGlvbiAoaXRlbXMpIHtcblx0ICAgICAgICByZXR1cm4gbWFwKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgdG9vbHRpcE9wdGlvbnMgPSBpdGVtLnNlcmllcy50b29sdGlwT3B0aW9ucztcblx0ICAgICAgICAgICAgcmV0dXJuICh0b29sdGlwT3B0aW9ucy5wb2ludEZvcm1hdHRlciB8fCBpdGVtLnBvaW50LnRvb2x0aXBGb3JtYXR0ZXIpLmNhbGwoaXRlbS5wb2ludCwgdG9vbHRpcE9wdGlvbnMucG9pbnRGb3JtYXQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgXG5cdH07XG5cblx0dmFyIGhvdmVyQ2hhcnRJbmRleDtcblxuXHQvLyBHbG9iYWwgZmxhZyBmb3IgdG91Y2ggc3VwcG9ydFxuXHRoYXNUb3VjaCA9IGRvYy5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0ICE9PSBVTkRFRklORUQ7XG5cblx0LyoqXG5cdCAqIFRoZSBtb3VzZSB0cmFja2VyIG9iamVjdC4gQWxsIG1ldGhvZHMgc3RhcnRpbmcgd2l0aCBcIm9uXCIgYXJlIHByaW1hcnkgRE9NIGV2ZW50IGhhbmRsZXJzLiBcblx0ICogU3Vic2VxdWVudCBtZXRob2RzIHNob3VsZCBiZSBuYW1lZCBkaWZmZXJlbnRseSBmcm9tIHdoYXQgdGhleSBhcmUgZG9pbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgQ2hhcnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHJvb3Qgb3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdHZhciBQb2ludGVyID0gSGlnaGNoYXJ0cy5Qb2ludGVyID0gZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcblx0fTtcblxuXHRQb2ludGVyLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIFBvaW50ZXJcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblx0XHRcdFxuXHRcdFx0dmFyIGNoYXJ0T3B0aW9ucyA9IG9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdGNoYXJ0RXZlbnRzID0gY2hhcnRPcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0em9vbVR5cGUgPSB1c2VDYW5WRyA/ICcnIDogY2hhcnRPcHRpb25zLnpvb21UeXBlLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHR6b29tWCxcblx0XHRcdFx0em9vbVk7XG5cblx0XHRcdC8vIFN0b3JlIHJlZmVyZW5jZXNcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHR0aGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRcblx0XHRcdC8vIFpvb20gc3RhdHVzXG5cdFx0XHR0aGlzLnpvb21YID0gem9vbVggPSAveC8udGVzdCh6b29tVHlwZSk7XG5cdFx0XHR0aGlzLnpvb21ZID0gem9vbVkgPSAveS8udGVzdCh6b29tVHlwZSk7XG5cdFx0XHR0aGlzLnpvb21Ib3IgPSAoem9vbVggJiYgIWludmVydGVkKSB8fCAoem9vbVkgJiYgaW52ZXJ0ZWQpO1xuXHRcdFx0dGhpcy56b29tVmVydCA9ICh6b29tWSAmJiAhaW52ZXJ0ZWQpIHx8ICh6b29tWCAmJiBpbnZlcnRlZCk7XG5cdFx0XHR0aGlzLmhhc1pvb20gPSB6b29tWCB8fCB6b29tWTtcblxuXHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBoYW5kbGUgY2xpY2sgb24gYSB0b3VjaCBkZXZpY2U/XG5cdFx0XHR0aGlzLnJ1bkNoYXJ0Q2xpY2sgPSBjaGFydEV2ZW50cyAmJiAhIWNoYXJ0RXZlbnRzLmNsaWNrO1xuXG5cdFx0XHR0aGlzLnBpbmNoRG93biA9IFtdO1xuXHRcdFx0dGhpcy5sYXN0VmFsaWRUb3VjaCA9IHt9O1xuXG5cdFx0XHRpZiAoSGlnaGNoYXJ0cy5Ub29sdGlwICYmIG9wdGlvbnMudG9vbHRpcC5lbmFibGVkKSB7XG5cdFx0XHRcdGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcChjaGFydCwgb3B0aW9ucy50b29sdGlwKTtcblx0XHRcdFx0dGhpcy5mb2xsb3dUb3VjaE1vdmUgPSBwaWNrKG9wdGlvbnMudG9vbHRpcC5mb2xsb3dUb3VjaE1vdmUsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldERPTUV2ZW50cygpO1xuXHRcdH0sIFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGNyb3NzYnJvd3NlciBzdXBwb3J0IGZvciBjaGFydFggYW5kIGNoYXJ0WVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QgaW4gc3RhbmRhcmQgYnJvd3NlcnNcblx0XHQgKi9cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uIChlLCBjaGFydFBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgY2hhcnRYLFxuXHRcdFx0XHRjaGFydFksXG5cdFx0XHRcdGVQb3M7XG5cblx0XHRcdC8vIGNvbW1vbiBJRSBub3JtYWxpemluZ1xuXHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0XHQvLyBGcmFtZXdvcmsgc3BlY2lmaWMgbm9ybWFsaXppbmcgKCMxMTY1KVxuXHRcdFx0ZSA9IHdhc2hNb3VzZUV2ZW50KGUpO1xuXG5cdFx0XHQvLyBNb3JlIElFIG5vcm1hbGl6aW5nLCBuZWVkcyB0byBnbyBhZnRlciB3YXNoTW91c2VFdmVudFxuXHRcdFx0aWYgKCFlLnRhcmdldCkge1xuXHRcdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gaU9TICgjMjc1Nylcblx0XHRcdGVQb3MgPSBlLnRvdWNoZXMgPyAgKGUudG91Y2hlcy5sZW5ndGggPyBlLnRvdWNoZXMuaXRlbSgwKSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0pIDogZTtcblxuXHRcdFx0Ly8gR2V0IG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRpZiAoIWNoYXJ0UG9zaXRpb24pIHtcblx0XHRcdFx0dGhpcy5jaGFydFBvc2l0aW9uID0gY2hhcnRQb3NpdGlvbiA9IG9mZnNldCh0aGlzLmNoYXJ0LmNvbnRhaW5lcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoYXJ0WCBhbmQgY2hhcnRZXG5cdFx0XHRpZiAoZVBvcy5wYWdlWCA9PT0gVU5ERUZJTkVEKSB7IC8vIElFIDwgOS4gIzg4Ni5cblx0XHRcdFx0Y2hhcnRYID0gbWF0aE1heChlLngsIGUuY2xpZW50WCAtIGNoYXJ0UG9zaXRpb24ubGVmdCk7IC8vICMyMDA1LCAjMjEyOTogdGhlIHNlY29uZCBjYXNlIGlzIFxuXHRcdFx0XHRcdC8vIGZvciBJRTEwIHF1aXJrcyBtb2RlIHdpdGhpbiBmcmFtZXNldHNcblx0XHRcdFx0Y2hhcnRZID0gZS55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhcnRYID0gZVBvcy5wYWdlWCAtIGNoYXJ0UG9zaXRpb24ubGVmdDtcblx0XHRcdFx0Y2hhcnRZID0gZVBvcy5wYWdlWSAtIGNoYXJ0UG9zaXRpb24udG9wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXh0ZW5kKGUsIHtcblx0XHRcdFx0Y2hhcnRYOiBtYXRoUm91bmQoY2hhcnRYKSxcblx0XHRcdFx0Y2hhcnRZOiBtYXRoUm91bmQoY2hhcnRZKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY2xpY2sgcG9zaXRpb24gaW4gdGVybXMgb2YgYXhpcyB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSBBIHBvaW50ZXIgZXZlbnRcblx0XHQgKi9cblx0XHRnZXRDb29yZGluYXRlczogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjb29yZGluYXRlcyA9IHtcblx0XHRcdFx0XHR4QXhpczogW10sXG5cdFx0XHRcdFx0eUF4aXM6IFtdXG5cdFx0XHRcdH07XG5cblx0XHRcdGVhY2godGhpcy5jaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRjb29yZGluYXRlc1theGlzLmlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ10ucHVzaCh7XG5cdFx0XHRcdFx0YXhpczogYXhpcyxcblx0XHRcdFx0XHR2YWx1ZTogYXhpcy50b1ZhbHVlKGVbYXhpcy5ob3JpeiA/ICdjaGFydFgnIDogJ2NoYXJ0WSddKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGNvb3JkaW5hdGVzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogV2l0aCBsaW5lIHR5cGUgY2hhcnRzIHdpdGggYSBzaW5nbGUgdHJhY2tlciwgZ2V0IHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBtb3VzZS5cblx0XHQgKiBSdW4gUG9pbnQub25Nb3VzZU92ZXIgYW5kIGRpc3BsYXkgdG9vbHRpcCBmb3IgdGhlIHBvaW50IG9yIHBvaW50cy5cblx0XHQgKi9cblx0XHRydW5Qb2ludEFjdGlvbnM6IGZ1bmN0aW9uIChlKSB7XG5cblx0XHRcdHZhciBwb2ludGVyID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBwb2ludGVyLmNoYXJ0LFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0XHRzaGFyZWQgPSB0b29sdGlwID8gdG9vbHRpcC5zaGFyZWQgOiBmYWxzZSxcblx0XHRcdFx0Zm9sbG93UG9pbnRlcixcblx0XHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQsXG5cdFx0XHRcdGhvdmVyU2VyaWVzID0gY2hhcnQuaG92ZXJTZXJpZXMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGRpc3RhbmNlID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0YW5jaG9yLFxuXHRcdFx0XHRub1NoYXJlZFRvb2x0aXAsXG5cdFx0XHRcdGRpcmVjdFRvdWNoLFxuXHRcdFx0XHRrZHBvaW50cyA9IFtdLFxuXHRcdFx0XHRrZHBvaW50LFxuXHRcdFx0XHRrZHBvaW50VDtcblxuXHRcdFx0Ly8gRm9yIGhvdmVyaW5nIG92ZXIgdGhlIGVtcHR5IHBhcnRzIG9mIHRoZSBwbG90IGFyZWEgKGhvdmVyU2VyaWVzIGlzIHVuZGVmaW5lZCkuIFxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgb25lIHNlcmllcyB3aXRoIHBvaW50IHRyYWNraW5nIChjb21ibyBjaGFydCksIGRvbid0IGdvIHRvIG5lYXJlc3QgbmVpZ2hib3VyLlxuXHRcdFx0aWYgKCFzaGFyZWQgJiYgIWhvdmVyU2VyaWVzKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoc2VyaWVzW2ldLmRpcmVjdFRvdWNoIHx8ICFzZXJpZXNbaV0ub3B0aW9ucy5zdGlja3lUcmFja2luZykge1xuXHRcdFx0XHRcdFx0c2VyaWVzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGl0IGhhcyBhIGhvdmVyUG9pbnQgYW5kIHRoYXQgc2VyaWVzIHJlcXVpcmVzIGRpcmVjdCB0b3VjaCAobGlrZSBjb2x1bW5zKSwgXG5cdFx0XHQvLyB1c2UgdGhlIGhvdmVyUG9pbnQgKCMzODk5KS4gT3RoZXJ3aXNlLCBzZWFyY2ggdGhlIGstZCB0cmVlLlxuXHRcdFx0aWYgKCFzaGFyZWQgJiYgaG92ZXJTZXJpZXMgJiYgaG92ZXJTZXJpZXMuZGlyZWN0VG91Y2ggJiYgaG92ZXJQb2ludCkge1xuXHRcdFx0XHRrZHBvaW50ID0gaG92ZXJQb2ludDtcblxuXHRcdFx0Ly8gSGFuZGxlIHNoYXJlZCB0b29sdGlwIG9yIGNhc2VzIHdoZXJlIGEgc2VyaWVzIGlzIG5vdCB5ZXQgaG92ZXJlZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRmluZCBuZWFyZXN0IHBvaW50cyBvbiBhbGwgc2VyaWVzXG5cdFx0XHRcdGVhY2goc2VyaWVzLCBmdW5jdGlvbiAocykge1xuXHRcdFx0XHRcdC8vIFNraXAgaGlkZGVuIHNlcmllc1xuXHRcdFx0XHRcdG5vU2hhcmVkVG9vbHRpcCA9IHMubm9TaGFyZWRUb29sdGlwICYmIHNoYXJlZDtcblx0XHRcdFx0XHRkaXJlY3RUb3VjaCA9ICFzaGFyZWQgJiYgcy5kaXJlY3RUb3VjaDtcblx0XHRcdFx0XHRpZiAocy52aXNpYmxlICYmICFub1NoYXJlZFRvb2x0aXAgJiYgIWRpcmVjdFRvdWNoICYmIHBpY2socy5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsIHRydWUpKSB7IC8vICMzODIxXG5cdFx0XHRcdFx0XHRrZHBvaW50VCA9IHMuc2VhcmNoUG9pbnQoZSwgIW5vU2hhcmVkVG9vbHRpcCAmJiBzLmtkRGltZW5zaW9ucyA9PT0gMSk7IC8vICMzODI4XG5cdFx0XHRcdFx0XHRpZiAoa2Rwb2ludFQpIHtcblx0XHRcdFx0XHRcdFx0a2Rwb2ludHMucHVzaChrZHBvaW50VCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gRmluZCBhYnNvbHV0ZSBuZWFyZXN0IHBvaW50XG5cdFx0XHRcdGVhY2goa2Rwb2ludHMsIGZ1bmN0aW9uIChwKSB7XG5cdFx0XHRcdFx0aWYgKHAgJiYgdHlwZW9mIHAuZGlzdCA9PT0gJ251bWJlcicgJiYgcC5kaXN0IDwgZGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gcC5kaXN0O1xuXHRcdFx0XHRcdFx0a2Rwb2ludCA9IHA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVmcmVzaCB0b29sdGlwIGZvciBrZHBvaW50IGlmIG5ldyBob3ZlciBwb2ludCBvciB0b29sdGlwIHdhcyBoaWRkZW4gLy8gIzM5MjYsICM0MjAwXG5cdFx0XHRpZiAoa2Rwb2ludCAmJiAoa2Rwb2ludCAhPT0gdGhpcy5wcmV2S0RQb2ludCB8fCAodG9vbHRpcCAmJiB0b29sdGlwLmlzSGlkZGVuKSkpIHtcblx0XHRcdFx0Ly8gRHJhdyB0b29sdGlwIGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRpZiAoc2hhcmVkICYmICFrZHBvaW50LnNlcmllcy5ub1NoYXJlZFRvb2x0aXApIHtcblx0XHRcdFx0XHRpID0ga2Rwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChrZHBvaW50c1tpXS5jbGllbnRYICE9PSBrZHBvaW50LmNsaWVudFggfHwga2Rwb2ludHNbaV0uc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkge1xuXHRcdFx0XHRcdFx0XHRrZHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChrZHBvaW50cy5sZW5ndGggJiYgdG9vbHRpcCkge1xuXHRcdFx0XHRcdFx0dG9vbHRpcC5yZWZyZXNoKGtkcG9pbnRzLCBlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBkbyBtb3VzZW92ZXIgb24gYWxsIHBvaW50cyBleGNlcHQgdGhlIGNsb3Nlc3Rcblx0XHRcdFx0XHRlYWNoKGtkcG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRcdGlmIChwb2ludCAhPT0ga2Rwb2ludCkgeyBcblx0XHRcdFx0XHRcdFx0cG9pbnQub25Nb3VzZU92ZXIoZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XHRcblx0XHRcdFx0XHQvLyAjMzkxOSwgIzM5ODUgZG8gbW91c2VvdmVyIG9uIHRoZSBjbG9zZXN0IHBvaW50IGxhc3QgdG8gZW5zdXJlIGl0IGlzIHRoZSBob3ZlcnBvaW50XG5cdFx0XHRcdFx0KChob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcy5kaXJlY3RUb3VjaCAmJiBob3ZlclBvaW50KSB8fCBrZHBvaW50KS5vbk1vdXNlT3ZlcihlKTsgXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRvb2x0aXApIHsgXG5cdFx0XHRcdFx0XHR0b29sdGlwLnJlZnJlc2goa2Rwb2ludCwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtkcG9pbnQub25Nb3VzZU92ZXIoZSk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucHJldktEUG9pbnQgPSBrZHBvaW50O1xuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgcG9zaXRpb25zIChyZWdhcmRsZXNzIG9mIGtkcG9pbnQgb3IgaG92ZXJQb2ludClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvbGxvd1BvaW50ZXIgPSBob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcy50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO1xuXHRcdFx0XHRpZiAodG9vbHRpcCAmJiBmb2xsb3dQb2ludGVyICYmICF0b29sdGlwLmlzSGlkZGVuKSB7XG5cdFx0XHRcdFx0YW5jaG9yID0gdG9vbHRpcC5nZXRBbmNob3IoW3t9XSwgZSk7XG5cdFx0XHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IHBsb3RYOiBhbmNob3JbMF0sIHBsb3RZOiBhbmNob3JbMV0gfSk7XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIHBpY2sgdXAgdGhlIHRvb2x0aXAgXG5cdFx0XHRpZiAodG9vbHRpcCAmJiAhcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSkge1xuXHRcdFx0XHRwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZiAoY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0XHRcdGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIub25Eb2N1bWVudE1vdXNlTW92ZShlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGFkZEV2ZW50KGRvYywgJ21vdXNlbW92ZScsIHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBDcm9zc2hhaXJcblx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0YXhpcy5kcmF3Q3Jvc3NoYWlyKGUsIHBpY2soa2Rwb2ludCwgaG92ZXJQb2ludCkpO1xuXHRcdFx0fSk7XHRcblx0XHRcdFxuXG5cdFx0fSxcblxuXG5cblx0XHQvKipcblx0XHQgKiBSZXNldCB0aGUgdHJhY2tpbmcgYnkgaGlkaW5nIHRoZSB0b29sdGlwLCB0aGUgaG92ZXIgc2VyaWVzIHN0YXRlIGFuZCB0aGUgaG92ZXIgcG9pbnRcblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gYWxsb3dNb3ZlIHtCb29sZWFufSBJbnN0ZWFkIG9mIGRlc3Ryb3lpbmcgdGhlIHRvb2x0aXAgYWx0b2dldGhlciwgYWxsb3cgbW92aW5nIGl0IGlmIHBvc3NpYmxlXG5cdFx0ICovXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uIChhbGxvd01vdmUsIGRlbGF5KSB7XG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gcG9pbnRlci5jaGFydCxcblx0XHRcdFx0aG92ZXJTZXJpZXMgPSBjaGFydC5ob3ZlclNlcmllcyxcblx0XHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQsXG5cdFx0XHRcdGhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludHMsXG5cdFx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0XHR0b29sdGlwUG9pbnRzID0gdG9vbHRpcCAmJiB0b29sdGlwLnNoYXJlZCA/IGhvdmVyUG9pbnRzIDogaG92ZXJQb2ludDtcblx0XHRcdFx0XG5cdFx0XHQvLyBOYXJyb3cgaW4gYWxsb3dNb3ZlXG5cdFx0XHRhbGxvd01vdmUgPSBhbGxvd01vdmUgJiYgdG9vbHRpcCAmJiB0b29sdGlwUG9pbnRzO1xuXHRcdFx0XHRcblx0XHRcdC8vIENoZWNrIGlmIHRoZSBwb2ludHMgaGF2ZSBtb3ZlZCBvdXRzaWRlIHRoZSBwbG90IGFyZWEsICMxMDAzXHRcdFxuXHRcdFx0aWYgKGFsbG93TW92ZSAgJiYgc3BsYXQodG9vbHRpcFBvaW50cylbMF0ucGxvdFggPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRhbGxvd01vdmUgPSBmYWxzZTtcblx0XHRcdH1cdFxuXHRcdFx0Ly8gSnVzdCBtb3ZlIHRoZSB0b29sdGlwLCAjMzQ5XG5cdFx0XHRpZiAoYWxsb3dNb3ZlKSB7XG5cdFx0XHRcdHRvb2x0aXAucmVmcmVzaCh0b29sdGlwUG9pbnRzKTtcblx0XHRcdFx0aWYgKGhvdmVyUG9pbnQpIHsgLy8gIzI1MDBcblx0XHRcdFx0XHRob3ZlclBvaW50LnNldFN0YXRlKGhvdmVyUG9pbnQuc3RhdGUsIHRydWUpO1xuXHRcdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRcdGlmIChwaWNrKGF4aXMub3B0aW9ucy5jcm9zc2hhaXIgJiYgYXhpcy5vcHRpb25zLmNyb3NzaGFpci5zbmFwLCB0cnVlKSkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRyYXdDcm9zc2hhaXIobnVsbCwgaG92ZXJQb2ludCk7XG5cdFx0XHRcdFx0XHR9ICBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gRnVsbCByZXNldFxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoaG92ZXJQb2ludCkge1xuXHRcdFx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdFx0ZWFjaChob3ZlclBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhvdmVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0aG92ZXJTZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0XHR0b29sdGlwLmhpZGUoZGVsYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpIHtcblx0XHRcdFx0XHRyZW1vdmVFdmVudChkb2MsICdtb3VzZW1vdmUnLCBwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlKTtcblx0XHRcdFx0XHRwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbW92ZSBjcm9zc2hhaXJzXG5cdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRheGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRwb2ludGVyLmhvdmVyWCA9IGNoYXJ0LmhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludCA9IG51bGw7XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2NhbGUgc2VyaWVzIGdyb3VwcyB0byBhIGNlcnRhaW4gc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG5cdFx0ICovXG5cdFx0c2NhbGVHcm91cHM6IGZ1bmN0aW9uIChhdHRyaWJzLCBjbGlwKSB7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHNlcmllc0F0dHJpYnM7XG5cblx0XHRcdC8vIFNjYWxlIGVhY2ggc2VyaWVzXG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXNBdHRyaWJzID0gYXR0cmlicyB8fCBzZXJpZXMuZ2V0UGxvdEJveCgpOyAvLyAjMTcwMVxuXHRcdFx0XHRpZiAoc2VyaWVzLnhBeGlzICYmIHNlcmllcy54QXhpcy56b29tRW5hYmxlZCkge1xuXHRcdFx0XHRcdHNlcmllcy5ncm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdGlmIChzZXJpZXMubWFya2VyR3JvdXApIHtcblx0XHRcdFx0XHRcdHNlcmllcy5tYXJrZXJHcm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwLmNsaXAoY2xpcCA/IGNoYXJ0LmNsaXBSZWN0IDogbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZXJpZXMuZGF0YUxhYmVsc0dyb3VwKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuZGF0YUxhYmVsc0dyb3VwLmF0dHIoc2VyaWVzQXR0cmlicyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2xpcFxuXHRcdFx0Y2hhcnQuY2xpcFJlY3QuYXR0cihjbGlwIHx8IGNoYXJ0LmNsaXBCb3gpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTdGFydCBhIGRyYWcgb3BlcmF0aW9uXG5cdFx0ICovXG5cdFx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBzdGFydCBwb3NpdGlvblxuXHRcdFx0Y2hhcnQubW91c2VJc0Rvd24gPSBlLnR5cGU7XG5cdFx0XHRjaGFydC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2hhcnQubW91c2VEb3duWCA9IHRoaXMubW91c2VEb3duWCA9IGUuY2hhcnRYO1xuXHRcdFx0Y2hhcnQubW91c2VEb3duWSA9IHRoaXMubW91c2VEb3duWSA9IGUuY2hhcnRZO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQZXJmb3JtIGEgZHJhZyBvcGVyYXRpb24gaW4gcmVzcG9uc2UgdG8gYSBtb3VzZW1vdmUgZXZlbnQgd2hpbGUgdGhlIG1vdXNlIGlzIGRvd25cblx0XHQgKi9cblx0XHRkcmFnOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0XHRjaGFydFggPSBlLmNoYXJ0WCxcblx0XHRcdFx0Y2hhcnRZID0gZS5jaGFydFksXG5cdFx0XHRcdHpvb21Ib3IgPSB0aGlzLnpvb21Ib3IsXG5cdFx0XHRcdHpvb21WZXJ0ID0gdGhpcy56b29tVmVydCxcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRcdGNsaWNrZWRJbnNpZGUsXG5cdFx0XHRcdHNpemUsXG5cdFx0XHRcdG1vdXNlRG93blggPSB0aGlzLm1vdXNlRG93blgsXG5cdFx0XHRcdG1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blksXG5cdFx0XHRcdHBhbktleSA9IGNoYXJ0T3B0aW9ucy5wYW5LZXkgJiYgZVtjaGFydE9wdGlvbnMucGFuS2V5ICsgJ0tleSddO1xuXG5cdFx0XHQvLyBJZiB0aGUgbW91c2UgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhZGp1c3QgdG8gY29vb3JkaW5hdGVzXG5cdFx0XHQvLyBpbnNpZGUgdG8gcHJldmVudCB0aGUgc2VsZWN0aW9uIG1hcmtlciBmcm9tIGdvaW5nIG91dHNpZGVcblx0XHRcdGlmIChjaGFydFggPCBwbG90TGVmdCkge1xuXHRcdFx0XHRjaGFydFggPSBwbG90TGVmdDtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcnRYID4gcGxvdExlZnQgKyBwbG90V2lkdGgpIHtcblx0XHRcdFx0Y2hhcnRYID0gcGxvdExlZnQgKyBwbG90V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGFydFkgPCBwbG90VG9wKSB7XG5cdFx0XHRcdGNoYXJ0WSA9IHBsb3RUb3A7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJ0WSA+IHBsb3RUb3AgKyBwbG90SGVpZ2h0KSB7XG5cdFx0XHRcdGNoYXJ0WSA9IHBsb3RUb3AgKyBwbG90SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBkZXRlcm1pbmUgaWYgdGhlIG1vdXNlIGhhcyBtb3ZlZCBtb3JlIHRoYW4gMTBweFxuXHRcdFx0dGhpcy5oYXNEcmFnZ2VkID0gTWF0aC5zcXJ0KFxuXHRcdFx0XHRNYXRoLnBvdyhtb3VzZURvd25YIC0gY2hhcnRYLCAyKSArXG5cdFx0XHRcdE1hdGgucG93KG1vdXNlRG93blkgLSBjaGFydFksIDIpXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEcmFnZ2VkID4gMTApIHtcblx0XHRcdFx0Y2xpY2tlZEluc2lkZSA9IGNoYXJ0LmlzSW5zaWRlUGxvdChtb3VzZURvd25YIC0gcGxvdExlZnQsIG1vdXNlRG93blkgLSBwbG90VG9wKTtcblxuXHRcdFx0XHQvLyBtYWtlIGEgc2VsZWN0aW9uXG5cdFx0XHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMgJiYgKHRoaXMuem9vbVggfHwgdGhpcy56b29tWSkgJiYgY2xpY2tlZEluc2lkZSAmJiAhcGFuS2V5KSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIgPSBjaGFydC5yZW5kZXJlci5yZWN0KFxuXHRcdFx0XHRcdFx0XHRwbG90TGVmdCxcblx0XHRcdFx0XHRcdFx0cGxvdFRvcCxcblx0XHRcdFx0XHRcdFx0em9vbUhvciA/IDEgOiBwbG90V2lkdGgsXG5cdFx0XHRcdFx0XHRcdHpvb21WZXJ0ID8gMSA6IHBsb3RIZWlnaHQsXG5cdFx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogY2hhcnRPcHRpb25zLnNlbGVjdGlvbk1hcmtlckZpbGwgfHwgJ3JnYmEoNjksMTE0LDE2NywwLjI1KScsXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogN1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gbWFya2VyXG5cdFx0XHRcdGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlciAmJiB6b29tSG9yKSB7XG5cdFx0XHRcdFx0c2l6ZSA9IGNoYXJ0WCAtIG1vdXNlRG93blg7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIuYXR0cih7XG5cdFx0XHRcdFx0XHR3aWR0aDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHRcdHg6IChzaXplID4gMCA/IDAgOiBzaXplKSArIG1vdXNlRG93blhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgc2VsZWN0aW9uIG1hcmtlclxuXHRcdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgem9vbVZlcnQpIHtcblx0XHRcdFx0XHRzaXplID0gY2hhcnRZIC0gbW91c2VEb3duWTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGlvbk1hcmtlci5hdHRyKHtcblx0XHRcdFx0XHRcdGhlaWdodDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHRcdHk6IChzaXplID4gMCA/IDAgOiBzaXplKSArIG1vdXNlRG93bllcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhbm5pbmdcblx0XHRcdFx0aWYgKGNsaWNrZWRJbnNpZGUgJiYgIXRoaXMuc2VsZWN0aW9uTWFya2VyICYmIGNoYXJ0T3B0aW9ucy5wYW5uaW5nKSB7XG5cdFx0XHRcdFx0Y2hhcnQucGFuKGUsIGNoYXJ0T3B0aW9ucy5wYW5uaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBPbiBtb3VzZSB1cCBvciB0b3VjaCBlbmQgYWNyb3NzIHRoZSBlbnRpcmUgZG9jdW1lbnQsIGRyb3AgdGhlIHNlbGVjdGlvbi5cblx0XHQgKi9cblx0XHRkcm9wOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGhhc1BpbmNoZWQgPSB0aGlzLmhhc1BpbmNoZWQ7XG5cblx0XHRcdGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHR2YXIgc2VsZWN0aW9uRGF0YSA9IHtcblx0XHRcdFx0XHRcdHhBeGlzOiBbXSxcblx0XHRcdFx0XHRcdHlBeGlzOiBbXSxcblx0XHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUub3JpZ2luYWxFdmVudCB8fCBlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZWxlY3Rpb25Cb3ggPSB0aGlzLnNlbGVjdGlvbk1hcmtlcixcblx0XHRcdFx0XHRzZWxlY3Rpb25MZWZ0ID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cigneCcpIDogc2VsZWN0aW9uQm94LngsXG5cdFx0XHRcdFx0c2VsZWN0aW9uVG9wID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cigneScpIDogc2VsZWN0aW9uQm94LnksXG5cdFx0XHRcdFx0c2VsZWN0aW9uV2lkdGggPSBzZWxlY3Rpb25Cb3guYXR0ciA/IHNlbGVjdGlvbkJveC5hdHRyKCd3aWR0aCcpIDogc2VsZWN0aW9uQm94LndpZHRoLFxuXHRcdFx0XHRcdHNlbGVjdGlvbkhlaWdodCA9IHNlbGVjdGlvbkJveC5hdHRyID8gc2VsZWN0aW9uQm94LmF0dHIoJ2hlaWdodCcpIDogc2VsZWN0aW9uQm94LmhlaWdodCxcblx0XHRcdFx0XHRydW5ab29tO1xuXG5cdFx0XHRcdC8vIGEgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGVcblx0XHRcdFx0aWYgKHRoaXMuaGFzRHJhZ2dlZCB8fCBoYXNQaW5jaGVkKSB7XG5cblx0XHRcdFx0XHQvLyByZWNvcmQgZWFjaCBheGlzJyBtaW4gYW5kIG1heFxuXHRcdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRcdGlmIChheGlzLnpvb21FbmFibGVkICYmIGRlZmluZWQoYXhpcy5taW4pICYmIChoYXNQaW5jaGVkIHx8IHBvaW50ZXJbeyB4QXhpczogJ3pvb21YJywgeUF4aXM6ICd6b29tWScgfVtheGlzLmNvbGxdXSkpIHsgLy8gIzg1OSwgIzM1Njlcblx0XHRcdFx0XHRcdFx0dmFyIGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0XHRcdFx0XHRtaW5QaXhlbFBhZGRpbmcgPSBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBheGlzLm1pblBpeGVsUGFkZGluZzogMCwgLy8gIzEyMDcsICMzMDc1XG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uTWluID0gYXhpcy50b1ZhbHVlKChob3JpeiA/IHNlbGVjdGlvbkxlZnQgOiBzZWxlY3Rpb25Ub3ApICsgbWluUGl4ZWxQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25NYXggPSBheGlzLnRvVmFsdWUoKGhvcml6ID8gc2VsZWN0aW9uTGVmdCArIHNlbGVjdGlvbldpZHRoIDogc2VsZWN0aW9uVG9wICsgc2VsZWN0aW9uSGVpZ2h0KSAtIG1pblBpeGVsUGFkZGluZyk7XG5cblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YVtheGlzLmNvbGxdLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGF4aXM6IGF4aXMsXG5cdFx0XHRcdFx0XHRcdFx0bWluOiBtYXRoTWluKHNlbGVjdGlvbk1pbiwgc2VsZWN0aW9uTWF4KSwgLy8gZm9yIHJldmVyc2VkIGF4ZXNcblx0XHRcdFx0XHRcdFx0XHRtYXg6IG1hdGhNYXgoc2VsZWN0aW9uTWluLCBzZWxlY3Rpb25NYXgpXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRydW5ab29tID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAocnVuWm9vbSkge1xuXHRcdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnc2VsZWN0aW9uJywgc2VsZWN0aW9uRGF0YSwgZnVuY3Rpb24gKGFyZ3MpIHsgXG5cdFx0XHRcdFx0XHRcdGNoYXJ0Lnpvb20oZXh0ZW5kKGFyZ3MsIGhhc1BpbmNoZWQgPyB7IGFuaW1hdGlvbjogZmFsc2UgfSA6IG51bGwpKTsgXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNlbGVjdGlvbk1hcmtlciA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKTtcblxuXHRcdFx0XHQvLyBSZXNldCBzY2FsaW5nIHByZXZpZXdcblx0XHRcdFx0aWYgKGhhc1BpbmNoZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNjYWxlR3JvdXBzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgYWxsXG5cdFx0XHRpZiAoY2hhcnQpIHsgLy8gaXQgbWF5IGJlIGRlc3Ryb3llZCBvbiBtb3VzZSB1cCAtICM4Nzdcblx0XHRcdFx0Y3NzKGNoYXJ0LmNvbnRhaW5lciwgeyBjdXJzb3I6IGNoYXJ0Ll9jdXJzb3IgfSk7XG5cdFx0XHRcdGNoYXJ0LmNhbmNlbENsaWNrID0gdGhpcy5oYXNEcmFnZ2VkID4gMTA7IC8vICMzNzBcblx0XHRcdFx0Y2hhcnQubW91c2VJc0Rvd24gPSB0aGlzLmhhc0RyYWdnZWQgPSB0aGlzLmhhc1BpbmNoZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5waW5jaERvd24gPSBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdFx0Ly8gaXNzdWUgIzI5NSwgZHJhZ2dpbmcgbm90IGFsd2F5cyB3b3JraW5nIGluIEZpcmVmb3hcblx0XHRcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5kcmFnU3RhcnQoZSk7XG5cdFx0fSxcblxuXHRcdFxuXG5cdFx0b25Eb2N1bWVudE1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0Y2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWFsIGhhbmRsZXIgZm9yIG1vdXNlIG1vdmUgdGhhdCB3aWxsIGhpZGUgdGhlIHRvb2x0aXAgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBwbG90YXJlYS5cblx0XHQgKiBJc3N1ZSAjMTQ5IHdvcmthcm91bmQuIFRoZSBtb3VzZWxlYXZlIGV2ZW50IGRvZXMgbm90IGFsd2F5cyBmaXJlLiBcblx0XHQgKi9cblx0XHRvbkRvY3VtZW50TW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0Y2hhcnRQb3NpdGlvbiA9IHRoaXMuY2hhcnRQb3NpdGlvbjtcblxuXHRcdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUsIGNoYXJ0UG9zaXRpb24pO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBvdXRzaWRlLCBoaWRlIHRoZSB0b29sdGlwXG5cdFx0XHRpZiAoY2hhcnRQb3NpdGlvbiAmJiAhdGhpcy5pbkNsYXNzKGUudGFyZ2V0LCAnaGlnaGNoYXJ0cy10cmFja2VyJykgJiZcblx0XHRcdFx0XHQhY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkpIHtcblx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBXaGVuIG1vdXNlIGxlYXZlcyB0aGUgY29udGFpbmVyLCBoaWRlIHRoZSB0b29sdGlwLlxuXHRcdCAqL1xuXHRcdG9uQ29udGFpbmVyTW91c2VMZWF2ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF07XG5cdFx0XHRpZiAoY2hhcnQpIHtcblx0XHRcdFx0Y2hhcnQucG9pbnRlci5yZXNldCgpO1xuXHRcdFx0XHRjaGFydC5wb2ludGVyLmNoYXJ0UG9zaXRpb24gPSBudWxsOyAvLyBhbHNvIHJlc2V0IHRoZSBjaGFydCBwb3NpdGlvbiwgdXNlZCBpbiAjMTQ5IGZpeFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBUaGUgbW91c2Vtb3ZlLCB0b3VjaG1vdmUgYW5kIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlclxuXHRcdG9uQ29udGFpbmVyTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG5cdFx0XHRob3ZlckNoYXJ0SW5kZXggPSBjaGFydC5pbmRleDtcblxuXHRcdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1x0XHRcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTsgLy8gIzIyNTEsICMzMjI0XG5cdFx0XHRcblx0XHRcdGlmIChjaGFydC5tb3VzZUlzRG93biA9PT0gJ21vdXNlZG93bicpIHtcblx0XHRcdFx0dGhpcy5kcmFnKGUpO1xuXHRcdFx0fSBcblx0XHRcdFxuXHRcdFx0Ly8gU2hvdyB0aGUgdG9vbHRpcCBhbmQgcnVuIG1vdXNlIG92ZXIgZXZlbnRzICgjOTc3KVxuXHRcdFx0aWYgKCh0aGlzLmluQ2xhc3MoZS50YXJnZXQsICdoaWdoY2hhcnRzLXRyYWNrZXInKSB8fCBcblx0XHRcdFx0XHRjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cdFx0XHRcdHRoaXMucnVuUG9pbnRBY3Rpb25zKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVdGlsaXR5IHRvIGRldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzLCBvciBoYXMgYSBwYXJlbnQgd2l0aCwgYSBzcGVjaWZpY1xuXHRcdCAqIGNsYXNzIG5hbWUuIFVzZWQgb24gZGV0ZWN0aW9uIG9mIHRyYWNrZXIgb2JqZWN0cyBhbmQgb24gZGVjaWRpbmcgd2hldGhlclxuXHRcdCAqIGhvdmVyaW5nIHRoZSB0b29sdGlwIHNob3VsZCBjYXVzZSB0aGUgYWN0aXZlIHNlcmllcyB0byBtb3VzZSBvdXQuXG5cdFx0ICovXG5cdFx0aW5DbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdFx0dmFyIGVsZW1DbGFzc05hbWU7XG5cdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRlbGVtQ2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKTtcblx0XHRcdFx0aWYgKGVsZW1DbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbUNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1DbGFzc05hbWUuaW5kZXhPZihQUkVGSVggKyAnY29udGFpbmVyJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblx0XHRvblRyYWNrZXJNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0XHRyZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGUudG9FbGVtZW50LFxuXHRcdFx0XHRyZWxhdGVkU2VyaWVzID0gcmVsYXRlZFRhcmdldCAmJiByZWxhdGVkVGFyZ2V0LnBvaW50ICYmIHJlbGF0ZWRUYXJnZXQucG9pbnQuc2VyaWVzOyAvLyAjMjQ5OVxuXHRcdFx0XG5cdFx0XHRpZiAoc2VyaWVzICYmICFzZXJpZXMub3B0aW9ucy5zdGlja3lUcmFja2luZyAmJiAhdGhpcy5pbkNsYXNzKHJlbGF0ZWRUYXJnZXQsIFBSRUZJWCArICd0b29sdGlwJykgJiZcblx0XHRcdFx0XHRyZWxhdGVkU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50LCBcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3A7XG5cdFx0XHRcblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblx0XHRcdGUub3JpZ2luYWxFdmVudCA9IGU7IC8vICMzOTEzXG5cblx0XHRcdGlmICghY2hhcnQuY2FuY2VsQ2xpY2spIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE9uIHRyYWNrZXIgY2xpY2ssIGZpcmUgdGhlIHNlcmllcyBhbmQgcG9pbnQgZXZlbnRzLiAjNzgzLCAjMTU4M1xuXHRcdFx0XHRpZiAoaG92ZXJQb2ludCAmJiB0aGlzLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykpIHtcblxuXHRcdFx0XHRcdC8vIHRoZSBzZXJpZXMgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRmaXJlRXZlbnQoaG92ZXJQb2ludC5zZXJpZXMsICdjbGljaycsIGV4dGVuZChlLCB7XG5cdFx0XHRcdFx0XHRwb2ludDogaG92ZXJQb2ludFxuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdC8vIHRoZSBwb2ludCBjbGljayBldmVudFxuXHRcdFx0XHRcdGlmIChjaGFydC5ob3ZlclBvaW50KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgKCMxODQ0KVxuXHRcdFx0XHRcdFx0aG92ZXJQb2ludC5maXJlUG9pbnRFdmVudCgnY2xpY2snLCBlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2hlbiBjbGlja2luZyBvdXRzaWRlIGEgdHJhY2tlciwgZmlyZSBhIGNoYXJ0IGV2ZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXh0ZW5kKGUsIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoZSkpO1xuXG5cdFx0XHRcdFx0Ly8gZmlyZSBhIGNsaWNrIGV2ZW50IGluIHRoZSBjaGFydFxuXHRcdFx0XHRcdGlmIChjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBwbG90TGVmdCwgZS5jaGFydFkgLSBwbG90VG9wKSkge1xuXHRcdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnY2xpY2snLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgSlMgRE9NIGV2ZW50cyBvbiB0aGUgY29udGFpbmVyIGFuZCBkb2N1bWVudC4gVGhpcyBtZXRob2Qgc2hvdWxkIGNvbnRhaW5cblx0XHQgKiBhIG9uZS10by1vbmUgYXNzaWdubWVudCBiZXR3ZWVuIG1ldGhvZHMgYW5kIHRoZWlyIGhhbmRsZXJzLiBBbnkgYWR2YW5jZWQgbG9naWMgc2hvdWxkXG5cdFx0ICogYmUgbW92ZWQgdG8gdGhlIGhhbmRsZXIgcmVmbGVjdGluZyB0aGUgZXZlbnQncyBuYW1lLlxuXHRcdCAqL1xuXHRcdHNldERPTUV2ZW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRcdGNvbnRhaW5lciA9IHBvaW50ZXIuY2hhcnQuY29udGFpbmVyO1xuXG5cdFx0XHRjb250YWluZXIub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyTW91c2VEb3duKGUpO1xuXHRcdFx0fTtcblx0XHRcdGNvbnRhaW5lci5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHBvaW50ZXIub25Db250YWluZXJNb3VzZU1vdmUoZSk7XG5cdFx0XHR9O1xuXHRcdFx0Y29udGFpbmVyLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyQ2xpY2soZSk7XG5cdFx0XHR9O1xuXHRcdFx0YWRkRXZlbnQoY29udGFpbmVyLCAnbW91c2VsZWF2ZScsIHBvaW50ZXIub25Db250YWluZXJNb3VzZUxlYXZlKTtcblx0XHRcdGlmIChjaGFydENvdW50ID09PSAxKSB7XG5cdFx0XHRcdGFkZEV2ZW50KGRvYywgJ21vdXNldXAnLCBwb2ludGVyLm9uRG9jdW1lbnRNb3VzZVVwKTtcblx0XHRcdH1cblx0XHRcdGlmIChoYXNUb3VjaCkge1xuXHRcdFx0XHRjb250YWluZXIub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hTdGFydChlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Y29udGFpbmVyLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoY2hhcnRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdGFkZEV2ZW50KGRvYywgJ3RvdWNoZW5kJywgcG9pbnRlci5vbkRvY3VtZW50VG91Y2hFbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveXMgdGhlIFBvaW50ZXIgb2JqZWN0IGFuZCBkaXNjb25uZWN0cyBET00gZXZlbnRzLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRyZW1vdmVFdmVudCh0aGlzLmNoYXJ0LmNvbnRhaW5lciwgJ21vdXNlbGVhdmUnLCB0aGlzLm9uQ29udGFpbmVyTW91c2VMZWF2ZSk7XG5cdFx0XHRpZiAoIWNoYXJ0Q291bnQpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAnbW91c2V1cCcsIHRoaXMub25Eb2N1bWVudE1vdXNlVXApO1xuXHRcdFx0XHRyZW1vdmVFdmVudChkb2MsICd0b3VjaGVuZCcsIHRoaXMub25Eb2N1bWVudFRvdWNoRW5kKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWVtb3J5IGFuZCBDUFUgbGVha1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblxuXHRcdFx0Zm9yIChwcm9wIGluIHRoaXMpIHtcblx0XHRcdFx0dGhpc1twcm9wXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0LyogU3VwcG9ydCBmb3IgdG91Y2ggZGV2aWNlcyAqL1xuXHRleHRlbmQoSGlnaGNoYXJ0cy5Qb2ludGVyLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRyYW5zbGF0aW9uIG9wZXJhdGlvbnNcblx0XHQgKi9cblx0XHRwaW5jaFRyYW5zbGF0ZTogZnVuY3Rpb24gKHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKSB7XG5cdFx0XHRpZiAodGhpcy56b29tSG9yIHx8IHRoaXMucGluY2hIb3IpIHtcblx0XHRcdFx0dGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbih0cnVlLCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy56b29tVmVydCB8fCB0aGlzLnBpbmNoVmVydCkge1xuXHRcdFx0XHR0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKGZhbHNlLCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biB0cmFuc2xhdGlvbiBvcGVyYXRpb25zIGZvciBlYWNoIGRpcmVjdGlvbiAoaG9yaXpvbnRhbCBhbmQgdmVydGljYWwpIGluZGVwZW5kZW50bHlcblx0XHQgKi9cblx0XHRwaW5jaFRyYW5zbGF0ZURpcmVjdGlvbjogZnVuY3Rpb24gKGhvcml6LCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCwgZm9yY2VkU2NhbGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHh5ID0gaG9yaXogPyAneCcgOiAneScsXG5cdFx0XHRcdFhZID0gaG9yaXogPyAnWCcgOiAnWScsXG5cdFx0XHRcdHNDaGFydFhZID0gJ2NoYXJ0JyArIFhZLFxuXHRcdFx0XHR3aCA9IGhvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnLFxuXHRcdFx0XHRwbG90TGVmdFRvcCA9IGNoYXJ0WydwbG90JyArIChob3JpeiA/ICdMZWZ0JyA6ICdUb3AnKV0sXG5cdFx0XHRcdHNlbGVjdGlvbldILFxuXHRcdFx0XHRzZWxlY3Rpb25YWSxcblx0XHRcdFx0Y2xpcFhZLFxuXHRcdFx0XHRzY2FsZSA9IGZvcmNlZFNjYWxlIHx8IDEsXG5cdFx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdGJvdW5kcyA9IGNoYXJ0LmJvdW5kc1tob3JpeiA/ICdoJyA6ICd2J10sXG5cdFx0XHRcdHNpbmdsZVRvdWNoID0gcGluY2hEb3duLmxlbmd0aCA9PT0gMSxcblx0XHRcdFx0dG91Y2gwU3RhcnQgPSBwaW5jaERvd25bMF1bc0NoYXJ0WFldLFxuXHRcdFx0XHR0b3VjaDBOb3cgPSB0b3VjaGVzWzBdW3NDaGFydFhZXSxcblx0XHRcdFx0dG91Y2gxU3RhcnQgPSAhc2luZ2xlVG91Y2ggJiYgcGluY2hEb3duWzFdW3NDaGFydFhZXSxcblx0XHRcdFx0dG91Y2gxTm93ID0gIXNpbmdsZVRvdWNoICYmIHRvdWNoZXNbMV1bc0NoYXJ0WFldLFxuXHRcdFx0XHRvdXRPZkJvdW5kcyxcblx0XHRcdFx0dHJhbnNmb3JtU2NhbGUsXG5cdFx0XHRcdHNjYWxlS2V5LFxuXHRcdFx0XHRzZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIXNpbmdsZVRvdWNoICYmIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCkgPiAyMCkgeyAvLyBEb24ndCB6b29tIGlmIGZpbmdlcnMgYXJlIHRvbyBjbG9zZSBvbiB0aGlzIGF4aXNcblx0XHRcdFx0XHRcdHNjYWxlID0gZm9yY2VkU2NhbGUgfHwgbWF0aEFicyh0b3VjaDBOb3cgLSB0b3VjaDFOb3cpIC8gbWF0aEFicyh0b3VjaDBTdGFydCAtIHRvdWNoMVN0YXJ0KTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNsaXBYWSA9ICgocGxvdExlZnRUb3AgLSB0b3VjaDBOb3cpIC8gc2NhbGUpICsgdG91Y2gwU3RhcnQ7XG5cdFx0XHRcdFx0c2VsZWN0aW9uV0ggPSBjaGFydFsncGxvdCcgKyAoaG9yaXogPyAnV2lkdGgnIDogJ0hlaWdodCcpXSAvIHNjYWxlO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBTZXQgdGhlIHNjYWxlLCBmaXJzdCBwYXNzXG5cdFx0XHRzZXRTY2FsZSgpO1xuXG5cdFx0XHRzZWxlY3Rpb25YWSA9IGNsaXBYWTsgLy8gdGhlIGNsaXAgcG9zaXRpb24gKHggb3IgeSkgaXMgYWx0ZXJlZCBpZiBvdXQgb2YgYm91bmRzLCB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uIGlzIG5vdFxuXG5cdFx0XHQvLyBPdXQgb2YgYm91bmRzXG5cdFx0XHRpZiAoc2VsZWN0aW9uWFkgPCBib3VuZHMubWluKSB7XG5cdFx0XHRcdHNlbGVjdGlvblhZID0gYm91bmRzLm1pbjtcblx0XHRcdFx0b3V0T2ZCb3VuZHMgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChzZWxlY3Rpb25YWSArIHNlbGVjdGlvbldIID4gYm91bmRzLm1heCkge1xuXHRcdFx0XHRzZWxlY3Rpb25YWSA9IGJvdW5kcy5tYXggLSBzZWxlY3Rpb25XSDtcblx0XHRcdFx0b3V0T2ZCb3VuZHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJcyB0aGUgY2hhcnQgZHJhZ2dlZCBvZmYgaXRzIGJvdW5kcywgZGV0ZXJtaW5lZCBieSBkYXRhTWluIGFuZCBkYXRhTWF4P1xuXHRcdFx0aWYgKG91dE9mQm91bmRzKSB7XG5cblx0XHRcdFx0Ly8gTW9kaWZ5IHRoZSB0b3VjaE5vdyBwb3NpdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgYW4gZWxhc3RpYyBkcmFnIG1vdmVtZW50LiBUaGlzIGluZGljYXRlc1xuXHRcdFx0XHQvLyB0byB0aGUgdXNlciB0aGF0IHRoZSBjaGFydCBpcyByZXNwb25zaXZlIGJ1dCBjYW4ndCBiZSBkcmFnZ2VkIGZ1cnRoZXIuXG5cdFx0XHRcdHRvdWNoME5vdyAtPSAwLjggKiAodG91Y2gwTm93IC0gbGFzdFZhbGlkVG91Y2hbeHldWzBdKTtcblx0XHRcdFx0aWYgKCFzaW5nbGVUb3VjaCkge1xuXHRcdFx0XHRcdHRvdWNoMU5vdyAtPSAwLjggKiAodG91Y2gxTm93IC0gbGFzdFZhbGlkVG91Y2hbeHldWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgc2NhbGUsIHNlY29uZCBwYXNzIHRvIGFkYXB0IHRvIHRoZSBtb2RpZmllZCB0b3VjaE5vdyBwb3NpdGlvbnNcblx0XHRcdFx0c2V0U2NhbGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2hbeHldID0gW3RvdWNoME5vdywgdG91Y2gxTm93XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGdlb21ldHJ5IGZvciBjbGlwcGluZywgc2VsZWN0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvblxuXHRcdFx0aWYgKCFpbnZlcnRlZCkgeyAvLyBUT0RPOiBpbXBsZW1lbnQgY2xpcHBpbmcgZm9yIGludmVydGVkIGNoYXJ0c1xuXHRcdFx0XHRjbGlwW3h5XSA9IGNsaXBYWSAtIHBsb3RMZWZ0VG9wO1xuXHRcdFx0XHRjbGlwW3doXSA9IHNlbGVjdGlvbldIO1xuXHRcdFx0fVxuXHRcdFx0c2NhbGVLZXkgPSBpbnZlcnRlZCA/IChob3JpeiA/ICdzY2FsZVknIDogJ3NjYWxlWCcpIDogJ3NjYWxlJyArIFhZO1xuXHRcdFx0dHJhbnNmb3JtU2NhbGUgPSBpbnZlcnRlZCA/IDEgLyBzY2FsZSA6IHNjYWxlO1xuXG5cdFx0XHRzZWxlY3Rpb25NYXJrZXJbd2hdID0gc2VsZWN0aW9uV0g7XG5cdFx0XHRzZWxlY3Rpb25NYXJrZXJbeHldID0gc2VsZWN0aW9uWFk7XG5cdFx0XHR0cmFuc2Zvcm1bc2NhbGVLZXldID0gc2NhbGU7XG5cdFx0XHR0cmFuc2Zvcm1bJ3RyYW5zbGF0ZScgKyBYWV0gPSAodHJhbnNmb3JtU2NhbGUgKiBwbG90TGVmdFRvcCkgKyAodG91Y2gwTm93IC0gKHRyYW5zZm9ybVNjYWxlICogdG91Y2gwU3RhcnQpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSB0b3VjaCBldmVudHMgd2l0aCB0d28gdG91Y2hlc1xuXHRcdCAqL1xuXHRcdHBpbmNoOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VsZi5jaGFydCxcblx0XHRcdFx0cGluY2hEb3duID0gc2VsZi5waW5jaERvd24sXG5cdFx0XHRcdHRvdWNoZXMgPSBlLnRvdWNoZXMsXG5cdFx0XHRcdHRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aCxcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2ggPSBzZWxmLmxhc3RWYWxpZFRvdWNoLFxuXHRcdFx0XHRoYXNab29tID0gc2VsZi5oYXNab29tLFxuXHRcdFx0XHRzZWxlY3Rpb25NYXJrZXIgPSBzZWxmLnNlbGVjdGlvbk1hcmtlcixcblx0XHRcdFx0dHJhbnNmb3JtID0ge30sXG5cdFx0XHRcdGZpcmVDbGlja0V2ZW50ID0gdG91Y2hlc0xlbmd0aCA9PT0gMSAmJiAoKHNlbGYuaW5DbGFzcyhlLnRhcmdldCwgUFJFRklYICsgJ3RyYWNrZXInKSAmJiBcblx0XHRcdFx0XHRjaGFydC5ydW5UcmFja2VyQ2xpY2spIHx8IHNlbGYucnVuQ2hhcnRDbGljayksXG5cdFx0XHRcdGNsaXAgPSB7fTtcblxuXHRcdFx0Ly8gRG9uJ3QgaW5pdGlhdGUgcGFubmluZyB1bnRpbCB0aGUgdXNlciBoYXMgcGluY2hlZC4gVGhpcyBwcmV2ZW50cyB1cyBmcm9tIFxuXHRcdFx0Ly8gYmxvY2tpbmcgcGFnZSBzY3JvbGxpbmcgYXMgdXNlcnMgc2Nyb2xsIGRvd24gYSBsb25nIHBhZ2UgKCM0MjEwKS5cblx0XHRcdGlmICh0b3VjaGVzTGVuZ3RoID4gMSkge1xuXHRcdFx0XHRzZWxmLmluaXRpYXRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9uIHRvdWNoIGRldmljZXMsIG9ubHkgcHJvY2VlZCB0byB0cmlnZ2VyIGNsaWNrIGlmIGEgaGFuZGxlciBpcyBkZWZpbmVkXG5cdFx0XHRpZiAoaGFzWm9vbSAmJiBzZWxmLmluaXRpYXRlZCAmJiAhZmlyZUNsaWNrRXZlbnQpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBOb3JtYWxpemUgZWFjaCB0b3VjaFxuXHRcdFx0bWFwKHRvdWNoZXMsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLm5vcm1hbGl6ZShlKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBSZWdpc3RlciB0aGUgdG91Y2ggc3RhcnQgcG9zaXRpb25cblx0XHRcdGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0XHRlYWNoKHRvdWNoZXMsIGZ1bmN0aW9uIChlLCBpKSB7XG5cdFx0XHRcdFx0cGluY2hEb3duW2ldID0geyBjaGFydFg6IGUuY2hhcnRYLCBjaGFydFk6IGUuY2hhcnRZIH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRsYXN0VmFsaWRUb3VjaC54ID0gW3BpbmNoRG93blswXS5jaGFydFgsIHBpbmNoRG93blsxXSAmJiBwaW5jaERvd25bMV0uY2hhcnRYXTtcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2gueSA9IFtwaW5jaERvd25bMF0uY2hhcnRZLCBwaW5jaERvd25bMV0gJiYgcGluY2hEb3duWzFdLmNoYXJ0WV07XG5cblx0XHRcdFx0Ly8gSWRlbnRpZnkgdGhlIGRhdGEgYm91bmRzIGluIHBpeGVsc1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0aWYgKGF4aXMuem9vbUVuYWJsZWQpIHtcblx0XHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGFydC5ib3VuZHNbYXhpcy5ob3JpeiA/ICdoJyA6ICd2J10sXG5cdFx0XHRcdFx0XHRcdG1pblBpeGVsUGFkZGluZyA9IGF4aXMubWluUGl4ZWxQYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHRtaW4gPSBheGlzLnRvUGl4ZWxzKHBpY2soYXhpcy5vcHRpb25zLm1pbiwgYXhpcy5kYXRhTWluKSksXG5cdFx0XHRcdFx0XHRcdG1heCA9IGF4aXMudG9QaXhlbHMocGljayhheGlzLm9wdGlvbnMubWF4LCBheGlzLmRhdGFNYXgpKSxcblx0XHRcdFx0XHRcdFx0YWJzTWluID0gbWF0aE1pbihtaW4sIG1heCksXG5cdFx0XHRcdFx0XHRcdGFic01heCA9IG1hdGhNYXgobWluLCBtYXgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgYm91bmRzIGZvciB1c2UgaW4gdGhlIHRvdWNobW92ZSBoYW5kbGVyXG5cdFx0XHRcdFx0XHRib3VuZHMubWluID0gbWF0aE1pbihheGlzLnBvcywgYWJzTWluIC0gbWluUGl4ZWxQYWRkaW5nKTtcblx0XHRcdFx0XHRcdGJvdW5kcy5tYXggPSBtYXRoTWF4KGF4aXMucG9zICsgYXhpcy5sZW4sIGFic01heCArIG1pblBpeGVsUGFkZGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2VsZi5yZXMgPSB0cnVlOyAvLyByZXNldCBvbiBuZXh0IG1vdmVcblx0XHRcdFxuXHRcdFx0Ly8gRXZlbnQgdHlwZSBpcyB0b3VjaG1vdmUsIGhhbmRsZSBwYW5uaW5nIGFuZCBwaW5jaGluZ1xuXHRcdFx0fSBlbHNlIGlmIChwaW5jaERvd24ubGVuZ3RoKSB7IC8vIGNhbiBiZSAwIHdoZW4gcmVsZWFzaW5nLCBpZiB0b3VjaGVuZCBmaXJlcyBmaXJzdFxuXHRcdFx0XHRcblxuXHRcdFx0XHQvLyBTZXQgdGhlIG1hcmtlclxuXHRcdFx0XHRpZiAoIXNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdHNlbGYuc2VsZWN0aW9uTWFya2VyID0gc2VsZWN0aW9uTWFya2VyID0gZXh0ZW5kKHtcblx0XHRcdFx0XHRcdGRlc3Ryb3k6IG5vb3Bcblx0XHRcdFx0XHR9LCBjaGFydC5wbG90Qm94KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5waW5jaFRyYW5zbGF0ZShwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cblx0XHRcdFx0c2VsZi5oYXNQaW5jaGVkID0gaGFzWm9vbTtcblxuXHRcdFx0XHQvLyBTY2FsZSBhbmQgdHJhbnNsYXRlIHRoZSBncm91cHMgdG8gcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2sgZHVyaW5nIHBpbmNoaW5nXG5cdFx0XHRcdHNlbGYuc2NhbGVHcm91cHModHJhbnNmb3JtLCBjbGlwKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE9wdGlvbmFsbHkgbW92ZSB0aGUgdG9vbHRpcCBvbiB0b3VjaG1vdmVcblx0XHRcdFx0aWYgKCFoYXNab29tICYmIHNlbGYuZm9sbG93VG91Y2hNb3ZlICYmIHRvdWNoZXNMZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhzZWxmLm5vcm1hbGl6ZShlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5yZXMpIHtcblx0XHRcdFx0XHRzZWxmLnJlcyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVzZXQoZmFsc2UsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYWwgdG91Y2ggaGFuZGxlciBzaGFyZWQgYnkgdG91Y2hzdGFydCBhbmQgdG91Y2htb3ZlLlxuXHRcdCAqL1xuXHRcdHRvdWNoOiBmdW5jdGlvbiAoZSwgc3RhcnQpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHRcdGhvdmVyQ2hhcnRJbmRleCA9IGNoYXJ0LmluZGV4O1xuXG5cdFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuXG5cdFx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gbW91c2UgZXZlbnRzIGFuZCBkaXNwbGF5IHRvb2x0aXAgZXRjXG5cdFx0XHRcdFx0aWYgKHN0YXJ0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLnBpbmNoKGUpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnQpIHtcblx0XHRcdFx0XHQvLyBIaWRlIHRoZSB0b29sdGlwIG9uIHRvdWNoaW5nIG91dHNpZGUgdGhlIHBsb3QgYXJlYSAoIzEyMDMpXG5cdFx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHR0aGlzLnBpbmNoKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNvbnRhaW5lclRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0aGlzLnRvdWNoKGUsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRvbkNvbnRhaW5lclRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHRoaXMudG91Y2goZSk7XG5cdFx0fSxcblxuXHRcdG9uRG9jdW1lbnRUb3VjaEVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRjaGFydHNbaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pO1xuXHRpZiAod2luLlBvaW50ZXJFdmVudCB8fCB3aW4uTVNQb2ludGVyRXZlbnQpIHtcblx0XHRcblx0XHQvLyBUaGUgdG91Y2hlcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIHBvaW50cyBiZWluZyB0b3VjaGVkIGF0IGFsbCB0aW1lc1xuXHRcdHZhciB0b3VjaGVzID0ge30sXG5cdFx0XHRoYXNQb2ludGVyRXZlbnQgPSAhIXdpbi5Qb2ludGVyRXZlbnQsXG5cdFx0XHRnZXRXZWJraXRUb3VjaGVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIga2V5LCBmYWtlID0gW107XG5cdFx0XHRcdGZha2UuaXRlbSA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzW2ldOyB9O1xuXHRcdFx0XHRmb3IgKGtleSBpbiB0b3VjaGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRvdWNoZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0ZmFrZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0cGFnZVg6IHRvdWNoZXNba2V5XS5wYWdlWCxcblx0XHRcdFx0XHRcdFx0cGFnZVk6IHRvdWNoZXNba2V5XS5wYWdlWSxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0OiB0b3VjaGVzW2tleV0udGFyZ2V0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZha2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNsYXRlTVNQb2ludGVyID0gZnVuY3Rpb24gKGUsIG1ldGhvZCwgd2t0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcDtcblx0XHRcdFx0ZSA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuXHRcdFx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkgJiYgY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlKTtcblx0XHRcdFx0XHRwID0gY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0ucG9pbnRlcjtcblx0XHRcdFx0XHRwW21ldGhvZF0oe1xuXHRcdFx0XHRcdFx0dHlwZTogd2t0eXBlLFxuXHRcdFx0XHRcdFx0dGFyZ2V0OiBlLmN1cnJlbnRUYXJnZXQsXG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdDogbm9vcCxcblx0XHRcdFx0XHRcdHRvdWNoZXM6IGdldFdlYmtpdFRvdWNoZXMoKVxuXHRcdFx0XHRcdH0pO1x0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmQgdGhlIFBvaW50ZXIgcHJvdG90eXBlIHdpdGggbWV0aG9kcyBmb3IgZWFjaCBldmVudCBoYW5kbGVyIGFuZCBtb3JlXG5cdFx0ICovXG5cdFx0ZXh0ZW5kKFBvaW50ZXIucHJvdG90eXBlLCB7XG5cdFx0XHRvbkNvbnRhaW5lclBvaW50ZXJEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hTdGFydCcsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR0b3VjaGVzW2UucG9pbnRlcklkXSA9IHsgcGFnZVg6IGUucGFnZVgsIHBhZ2VZOiBlLnBhZ2VZLCB0YXJnZXQ6IGUuY3VycmVudFRhcmdldCB9O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRvbkNvbnRhaW5lclBvaW50ZXJNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hNb3ZlJywgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0dG91Y2hlc1tlLnBvaW50ZXJJZF0gPSB7IHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSB9O1xuXHRcdFx0XHRcdGlmICghdG91Y2hlc1tlLnBvaW50ZXJJZF0udGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHR0b3VjaGVzW2UucG9pbnRlcklkXS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRvbkRvY3VtZW50UG9pbnRlclVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uRG9jdW1lbnRUb3VjaEVuZCcsICd0b3VjaGVuZCcsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRvdWNoZXNbZS5wb2ludGVySWRdO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIG9yIHJlbW92ZSB0aGUgTVMgUG9pbnRlciBzcGVjaWZpYyBldmVudHNcblx0XHRcdCAqL1xuXHRcdFx0YmF0Y2hNU0V2ZW50czogZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdGZuKHRoaXMuY2hhcnQuY29udGFpbmVyLCBoYXNQb2ludGVyRXZlbnQgPyAncG9pbnRlcmRvd24nIDogJ01TUG9pbnRlckRvd24nLCB0aGlzLm9uQ29udGFpbmVyUG9pbnRlckRvd24pO1xuXHRcdFx0XHRmbih0aGlzLmNoYXJ0LmNvbnRhaW5lciwgaGFzUG9pbnRlckV2ZW50ID8gJ3BvaW50ZXJtb3ZlJyA6ICdNU1BvaW50ZXJNb3ZlJywgdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlKTtcblx0XHRcdFx0Zm4oZG9jLCBoYXNQb2ludGVyRXZlbnQgPyAncG9pbnRlcnVwJyA6ICdNU1BvaW50ZXJVcCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBEaXNhYmxlIGRlZmF1bHQgSUUgYWN0aW9ucyBmb3IgcGluY2ggYW5kIHN1Y2ggb24gY2hhcnQgZWxlbWVudFxuXHRcdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdpbml0JywgZnVuY3Rpb24gKHByb2NlZWQsIGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHRwcm9jZWVkLmNhbGwodGhpcywgY2hhcnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuaGFzWm9vbSkgeyAvLyAjNDAxNFxuXHRcdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7XG5cdFx0XHRcdFx0Jy1tcy10b3VjaC1hY3Rpb24nOiBOT05FLFxuXHRcdFx0XHRcdCd0b3VjaC1hY3Rpb24nOiBOT05FXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQWRkIElFIHNwZWNpZmljIHRvdWNoIGV2ZW50cyB0byBjaGFydFxuXHRcdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdzZXRET01FdmVudHMnLCBmdW5jdGlvbiAocHJvY2VlZCkge1xuXHRcdFx0cHJvY2VlZC5hcHBseSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLmhhc1pvb20gfHwgdGhpcy5mb2xsb3dUb3VjaE1vdmUpIHtcblx0XHRcdFx0dGhpcy5iYXRjaE1TRXZlbnRzKGFkZEV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBEZXN0cm95IE1TIGV2ZW50cyBhbHNvXG5cdFx0d3JhcChQb2ludGVyLnByb3RvdHlwZSwgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAocHJvY2VlZCkge1xuXHRcdFx0dGhpcy5iYXRjaE1TRXZlbnRzKHJlbW92ZUV2ZW50KTtcblx0XHRcdHByb2NlZWQuY2FsbCh0aGlzKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0ICogVGhlIG92ZXJ2aWV3IG9mIHRoZSBjaGFydCdzIHNlcmllc1xuXHQgKi9cblx0dmFyIExlZ2VuZCA9IEhpZ2hjaGFydHMuTGVnZW5kID0gZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcblx0fTtcblxuXHRMZWdlbmQucHJvdG90eXBlID0ge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGxlZ2VuZFxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFx0XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0aXRlbVN0eWxlID0gb3B0aW9ucy5pdGVtU3R5bGUsXG5cdFx0XHRcdHBhZGRpbmcsXG5cdFx0XHRcdGl0ZW1NYXJnaW5Ub3AgPSBvcHRpb25zLml0ZW1NYXJnaW5Ub3AgfHwgMDtcblx0XHRcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRcdGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcblx0XHRcdGxlZ2VuZC5pdGVtU3R5bGUgPSBpdGVtU3R5bGU7XG5cdFx0XHRsZWdlbmQuaXRlbUhpZGRlblN0eWxlID0gbWVyZ2UoaXRlbVN0eWxlLCBvcHRpb25zLml0ZW1IaWRkZW5TdHlsZSk7XG5cdFx0XHRsZWdlbmQuaXRlbU1hcmdpblRvcCA9IGl0ZW1NYXJnaW5Ub3A7XG5cdFx0XHRsZWdlbmQucGFkZGluZyA9IHBhZGRpbmcgPSBwaWNrKG9wdGlvbnMucGFkZGluZywgOCk7XG5cdFx0XHRsZWdlbmQuaW5pdGlhbEl0ZW1YID0gcGFkZGluZztcblx0XHRcdGxlZ2VuZC5pbml0aWFsSXRlbVkgPSBwYWRkaW5nIC0gNTsgLy8gNSBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBhYm92ZSB0aGUgdGV4dFxuXHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0XHRsZWdlbmQuY2hhcnQgPSBjaGFydDtcblx0XHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gMDtcblx0XHRcdGxlZ2VuZC5zeW1ib2xXaWR0aCA9IHBpY2sob3B0aW9ucy5zeW1ib2xXaWR0aCwgMTYpO1xuXHRcdFx0bGVnZW5kLnBhZ2VzID0gW107XG5cblxuXHRcdFx0Ly8gUmVuZGVyIGl0XG5cdFx0XHRsZWdlbmQucmVuZGVyKCk7XG5cblx0XHRcdC8vIG1vdmUgY2hlY2tib3hlc1xuXHRcdFx0YWRkRXZlbnQobGVnZW5kLmNoYXJ0LCAnZW5kUmVzaXplJywgZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0bGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjb2xvcnMgZm9yIHRoZSBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgU2VyaWVzIG9yIFBvaW50IGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZpc2libGUgRGltbWVkIG9yIGNvbG9yZWRcblx0XHQgKi9cblx0XHRjb2xvcml6ZUl0ZW06IGZ1bmN0aW9uIChpdGVtLCB2aXNpYmxlKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRsZWdlbmRJdGVtID0gaXRlbS5sZWdlbmRJdGVtLFxuXHRcdFx0XHRsZWdlbmRMaW5lID0gaXRlbS5sZWdlbmRMaW5lLFxuXHRcdFx0XHRsZWdlbmRTeW1ib2wgPSBpdGVtLmxlZ2VuZFN5bWJvbCxcblx0XHRcdFx0aGlkZGVuQ29sb3IgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLmNvbG9yLFxuXHRcdFx0XHR0ZXh0Q29sb3IgPSB2aXNpYmxlID8gb3B0aW9ucy5pdGVtU3R5bGUuY29sb3IgOiBoaWRkZW5Db2xvcixcblx0XHRcdFx0c3ltYm9sQ29sb3IgPSB2aXNpYmxlID8gKGl0ZW0ubGVnZW5kQ29sb3IgfHwgaXRlbS5jb2xvciB8fCAnI0NDQycpIDogaGlkZGVuQ29sb3IsXG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBpdGVtLm9wdGlvbnMgJiYgaXRlbS5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0c3ltYm9sQXR0ciA9IHsgZmlsbDogc3ltYm9sQ29sb3IgfSxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHR2YWw7XG5cdFx0XHRcblx0XHRcdGlmIChsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGxlZ2VuZEl0ZW0uY3NzKHsgZmlsbDogdGV4dENvbG9yLCBjb2xvcjogdGV4dENvbG9yIH0pOyAvLyBjb2xvciBmb3IgIzE1NTMsIG9sZElFXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVnZW5kTGluZSkge1xuXHRcdFx0XHRsZWdlbmRMaW5lLmF0dHIoeyBzdHJva2U6IHN5bWJvbENvbG9yIH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobGVnZW5kU3ltYm9sKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBcHBseSBtYXJrZXIgb3B0aW9uc1xuXHRcdFx0XHRpZiAobWFya2VyT3B0aW9ucyAmJiBsZWdlbmRTeW1ib2wuaXNNYXJrZXIpIHsgLy8gIzU4NVxuXHRcdFx0XHRcdHN5bWJvbEF0dHIuc3Ryb2tlID0gc3ltYm9sQ29sb3I7XG5cdFx0XHRcdFx0bWFya2VyT3B0aW9ucyA9IGl0ZW0uY29udmVydEF0dHJpYnMobWFya2VyT3B0aW9ucyk7XG5cdFx0XHRcdFx0Zm9yIChrZXkgaW4gbWFya2VyT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0dmFsID0gbWFya2VyT3B0aW9uc1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdHN5bWJvbEF0dHJba2V5XSA9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZWdlbmRTeW1ib2wuYXR0cihzeW1ib2xBdHRyKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gdGhlIGxlZ2VuZCBpdGVtXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBTZXJpZXMgb3IgUG9pbnQgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRwb3NpdGlvbkl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRzeW1ib2xQYWRkaW5nID0gb3B0aW9ucy5zeW1ib2xQYWRkaW5nLFxuXHRcdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRcdGxlZ2VuZEl0ZW1Qb3MgPSBpdGVtLl9sZWdlbmRJdGVtUG9zLFxuXHRcdFx0XHRpdGVtWCA9IGxlZ2VuZEl0ZW1Qb3NbMF0sXG5cdFx0XHRcdGl0ZW1ZID0gbGVnZW5kSXRlbVBvc1sxXSxcblx0XHRcdFx0Y2hlY2tib3ggPSBpdGVtLmNoZWNrYm94LFxuXHRcdFx0XHRsZWdlbmRHcm91cCA9IGl0ZW0ubGVnZW5kR3JvdXA7XG5cblx0XHRcdGlmIChsZWdlbmRHcm91cCAmJiBsZWdlbmRHcm91cC5lbGVtZW50KSB7XG5cdFx0XHRcdGxlZ2VuZEdyb3VwLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRsdHIgPyBpdGVtWCA6IGxlZ2VuZC5sZWdlbmRXaWR0aCAtIGl0ZW1YIC0gMiAqIHN5bWJvbFBhZGRpbmcgLSA0LFxuXHRcdFx0XHRcdGl0ZW1ZXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0XHRjaGVja2JveC54ID0gaXRlbVg7XG5cdFx0XHRcdGNoZWNrYm94LnkgPSBpdGVtWTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBhIHNpbmdsZSBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBzZXJpZXMgb3IgcG9pbnRcblx0XHQgKi9cblx0XHRkZXN0cm95SXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjaGVja2JveCA9IGl0ZW0uY2hlY2tib3g7XG5cblx0XHRcdC8vIGRlc3Ryb3kgU1ZHIGVsZW1lbnRzXG5cdFx0XHRlYWNoKFsnbGVnZW5kSXRlbScsICdsZWdlbmRMaW5lJywgJ2xlZ2VuZFN5bWJvbCcsICdsZWdlbmRHcm91cCddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChpdGVtW2tleV0pIHtcblx0XHRcdFx0XHRpdGVtW2tleV0gPSBpdGVtW2tleV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRcdGRpc2NhcmRFbGVtZW50KGl0ZW0uY2hlY2tib3gpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95cyB0aGUgbGVnZW5kLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0XHRsZWdlbmRHcm91cCA9IGxlZ2VuZC5ncm91cCxcblx0XHRcdFx0Ym94ID0gbGVnZW5kLmJveDtcblxuXHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRsZWdlbmQuYm94ID0gYm94LmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGxlZ2VuZEdyb3VwKSB7XG5cdFx0XHRcdGxlZ2VuZC5ncm91cCA9IGxlZ2VuZEdyb3VwLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gdGhlIGNoZWNrYm94ZXMgYWZ0ZXIgdGhlIHdpZHRoIGlzIGRldGVybWluZWRcblx0XHQgKi9cblx0XHRwb3NpdGlvbkNoZWNrYm94ZXM6IGZ1bmN0aW9uIChzY3JvbGxPZmZzZXQpIHtcblx0XHRcdHZhciBhbGlnbkF0dHIgPSB0aGlzLmdyb3VwLmFsaWduQXR0cixcblx0XHRcdFx0dHJhbnNsYXRlWSxcblx0XHRcdFx0Y2xpcEhlaWdodCA9IHRoaXMuY2xpcEhlaWdodCB8fCB0aGlzLmxlZ2VuZEhlaWdodDtcblxuXHRcdFx0aWYgKGFsaWduQXR0cikge1xuXHRcdFx0XHR0cmFuc2xhdGVZID0gYWxpZ25BdHRyLnRyYW5zbGF0ZVk7XG5cdFx0XHRcdGVhY2godGhpcy5hbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0XHR2YXIgY2hlY2tib3ggPSBpdGVtLmNoZWNrYm94LFxuXHRcdFx0XHRcdFx0dG9wO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0XHRcdFx0dG9wID0gKHRyYW5zbGF0ZVkgKyBjaGVja2JveC55ICsgKHNjcm9sbE9mZnNldCB8fCAwKSArIDMpO1xuXHRcdFx0XHRcdFx0Y3NzKGNoZWNrYm94LCB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IChhbGlnbkF0dHIudHJhbnNsYXRlWCArIGl0ZW0uY2hlY2tib3hPZmZzZXQgKyBjaGVja2JveC54IC0gMjApICsgUFgsXG5cdFx0XHRcdFx0XHRcdHRvcDogdG9wICsgUFgsXG5cdFx0XHRcdFx0XHRcdGRpc3BsYXk6IHRvcCA+IHRyYW5zbGF0ZVkgLSA2ICYmIHRvcCA8IHRyYW5zbGF0ZVkgKyBjbGlwSGVpZ2h0IC0gNiA/ICcnIDogTk9ORVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgbGVnZW5kIHRpdGxlIG9uIHRvcCBvZiB0aGUgbGVnZW5kXG5cdFx0ICovXG5cdFx0cmVuZGVyVGl0bGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRwYWRkaW5nID0gdGhpcy5wYWRkaW5nLFxuXHRcdFx0XHR0aXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlLFxuXHRcdFx0XHR0aXRsZUhlaWdodCA9IDAsXG5cdFx0XHRcdGJCb3g7XG5cdFx0XHRcblx0XHRcdGlmICh0aXRsZU9wdGlvbnMudGV4dCkge1xuXHRcdFx0XHRpZiAoIXRoaXMudGl0bGUpIHtcblx0XHRcdFx0XHR0aGlzLnRpdGxlID0gdGhpcy5jaGFydC5yZW5kZXJlci5sYWJlbCh0aXRsZU9wdGlvbnMudGV4dCwgcGFkZGluZyAtIDMsIHBhZGRpbmcgLSA0LCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAnbGVnZW5kLXRpdGxlJylcblx0XHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdFx0XHQuY3NzKHRpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0XHRcdC5hZGQodGhpcy5ncm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YkJveCA9IHRoaXMudGl0bGUuZ2V0QkJveCgpO1xuXHRcdFx0XHR0aXRsZUhlaWdodCA9IGJCb3guaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLm9mZnNldFdpZHRoID0gYkJveC53aWR0aDsgLy8gIzE3MTdcblx0XHRcdFx0dGhpcy5jb250ZW50R3JvdXAuYXR0cih7IHRyYW5zbGF0ZVk6IHRpdGxlSGVpZ2h0IH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50aXRsZUhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGxlZ2VuZCBpdGVtIHRleHRcblx0XHQgKi9cblx0XHRzZXRUZXh0OiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0XHRpdGVtLmxlZ2VuZEl0ZW0uYXR0cih7XG5cdFx0XHRcdHRleHQ6IG9wdGlvbnMubGFiZWxGb3JtYXQgPyBmb3JtYXQob3B0aW9ucy5sYWJlbEZvcm1hdCwgaXRlbSkgOiBvcHRpb25zLmxhYmVsRm9ybWF0dGVyLmNhbGwoaXRlbSlcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgYSBzaW5nbGUgc3BlY2lmaWMgbGVnZW5kIGl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIHNlcmllcyBvciBwb2ludFxuXHRcdCAqL1xuXHRcdHJlbmRlckl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBsZWdlbmQuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0aG9yaXpvbnRhbCA9IG9wdGlvbnMubGF5b3V0ID09PSAnaG9yaXpvbnRhbCcsXG5cdFx0XHRcdHN5bWJvbFdpZHRoID0gbGVnZW5kLnN5bWJvbFdpZHRoLFxuXHRcdFx0XHRzeW1ib2xQYWRkaW5nID0gb3B0aW9ucy5zeW1ib2xQYWRkaW5nLFxuXHRcdFx0XHRpdGVtU3R5bGUgPSBsZWdlbmQuaXRlbVN0eWxlLFxuXHRcdFx0XHRpdGVtSGlkZGVuU3R5bGUgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLFxuXHRcdFx0XHRwYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcsXG5cdFx0XHRcdGl0ZW1EaXN0YW5jZSA9IGhvcml6b250YWwgPyBwaWNrKG9wdGlvbnMuaXRlbURpc3RhbmNlLCAyMCkgOiAwLFxuXHRcdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRcdGl0ZW1IZWlnaHQsXG5cdFx0XHRcdHdpZHRoT3B0aW9uID0gb3B0aW9ucy53aWR0aCxcblx0XHRcdFx0aXRlbU1hcmdpbkJvdHRvbSA9IG9wdGlvbnMuaXRlbU1hcmdpbkJvdHRvbSB8fCAwLFxuXHRcdFx0XHRpdGVtTWFyZ2luVG9wID0gbGVnZW5kLml0ZW1NYXJnaW5Ub3AsXG5cdFx0XHRcdGluaXRpYWxJdGVtWCA9IGxlZ2VuZC5pbml0aWFsSXRlbVgsXG5cdFx0XHRcdGJCb3gsXG5cdFx0XHRcdGl0ZW1XaWR0aCxcblx0XHRcdFx0bGkgPSBpdGVtLmxlZ2VuZEl0ZW0sXG5cdFx0XHRcdHNlcmllcyA9IGl0ZW0uc2VyaWVzICYmIGl0ZW0uc2VyaWVzLmRyYXdMZWdlbmRTeW1ib2wgPyBpdGVtLnNlcmllcyA6IGl0ZW0sXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c2hvd0NoZWNrYm94ID0gbGVnZW5kLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSAmJiBzZXJpZXNPcHRpb25zICYmIHNlcmllc09wdGlvbnMuc2hvd0NoZWNrYm94LFxuXHRcdFx0XHR1c2VIVE1MID0gb3B0aW9ucy51c2VIVE1MO1xuXG5cdFx0XHRpZiAoIWxpKSB7IC8vIGdlbmVyYXRlIGl0IG9uY2UsIGxhdGVyIG1vdmUgaXRcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSB0aGUgZ3JvdXAgYm94XG5cdFx0XHRcdC8vIEEgZ3JvdXAgdG8gaG9sZCB0aGUgc3ltYm9sIGFuZCB0ZXh0LiBUZXh0IGlzIHRvIGJlIGFwcGVuZGVkIGluIExlZ2VuZCBjbGFzcy5cblx0XHRcdFx0aXRlbS5sZWdlbmRHcm91cCA9IHJlbmRlcmVyLmcoJ2xlZ2VuZC1pdGVtJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KVxuXHRcdFx0XHRcdC5hZGQobGVnZW5kLnNjcm9sbEdyb3VwKTtcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSB0aGUgbGlzdCBpdGVtIHRleHQgYW5kIGFkZCBpdCB0byB0aGUgZ3JvdXBcblx0XHRcdFx0aXRlbS5sZWdlbmRJdGVtID0gbGkgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0JycsXG5cdFx0XHRcdFx0XHRsdHIgPyBzeW1ib2xXaWR0aCArIHN5bWJvbFBhZGRpbmcgOiAtc3ltYm9sUGFkZGluZyxcblx0XHRcdFx0XHRcdGxlZ2VuZC5iYXNlbGluZSB8fCAwLFxuXHRcdFx0XHRcdFx0dXNlSFRNTFxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuY3NzKG1lcmdlKGl0ZW0udmlzaWJsZSA/IGl0ZW1TdHlsZSA6IGl0ZW1IaWRkZW5TdHlsZSkpIC8vIG1lcmdlIHRvIHByZXZlbnQgbW9kaWZ5aW5nIG9yaWdpbmFsICgjMTAyMSlcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRhbGlnbjogbHRyID8gJ2xlZnQnIDogJ3JpZ2h0Jyxcblx0XHRcdFx0XHRcdHpJbmRleDogMlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChpdGVtLmxlZ2VuZEdyb3VwKTtcblxuXHRcdFx0XHQvLyBHZXQgdGhlIGJhc2VsaW5lIGZvciB0aGUgZmlyc3QgaXRlbSAtIHRoZSBmb250IHNpemUgaXMgZXF1YWwgZm9yIGFsbFxuXHRcdFx0XHRpZiAoIWxlZ2VuZC5iYXNlbGluZSkge1xuXHRcdFx0XHRcdGxlZ2VuZC5mb250TWV0cmljcyA9IHJlbmRlcmVyLmZvbnRNZXRyaWNzKGl0ZW1TdHlsZS5mb250U2l6ZSwgbGkpO1xuXHRcdFx0XHRcdGxlZ2VuZC5iYXNlbGluZSA9IGxlZ2VuZC5mb250TWV0cmljcy5mICsgMyArIGl0ZW1NYXJnaW5Ub3A7XG5cdFx0XHRcdFx0bGkuYXR0cigneScsIGxlZ2VuZC5iYXNlbGluZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHRoZSBsZWdlbmQgc3ltYm9sIGluc2lkZSB0aGUgZ3JvdXAgYm94XG5cdFx0XHRcdHNlcmllcy5kcmF3TGVnZW5kU3ltYm9sKGxlZ2VuZCwgaXRlbSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZC5zZXRJdGVtRXZlbnRzKSB7XG5cdFx0XHRcdFx0bGVnZW5kLnNldEl0ZW1FdmVudHMoaXRlbSwgbGksIHVzZUhUTUwsIGl0ZW1TdHlsZSwgaXRlbUhpZGRlblN0eWxlKTtcblx0XHRcdFx0fVx0XHRcdFxuXG5cdFx0XHRcdC8vIENvbG9yaXplIHRoZSBpdGVtc1xuXHRcdFx0XHRsZWdlbmQuY29sb3JpemVJdGVtKGl0ZW0sIGl0ZW0udmlzaWJsZSk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBIVE1MIGNoZWNrYm94IG9uIHRvcFxuXHRcdFx0XHRpZiAoc2hvd0NoZWNrYm94KSB7XG5cdFx0XHRcdFx0bGVnZW5kLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbShpdGVtKTtcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsd2F5cyB1cGRhdGUgdGhlIHRleHRcblx0XHRcdGxlZ2VuZC5zZXRUZXh0KGl0ZW0pO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIG5leHQgbGluZVxuXHRcdFx0YkJveCA9IGxpLmdldEJCb3goKTtcblxuXHRcdFx0aXRlbVdpZHRoID0gaXRlbS5jaGVja2JveE9mZnNldCA9IFxuXHRcdFx0XHRvcHRpb25zLml0ZW1XaWR0aCB8fCBcblx0XHRcdFx0aXRlbS5sZWdlbmRJdGVtV2lkdGggfHwgXG5cdFx0XHRcdHN5bWJvbFdpZHRoICsgc3ltYm9sUGFkZGluZyArIGJCb3gud2lkdGggKyBpdGVtRGlzdGFuY2UgKyAoc2hvd0NoZWNrYm94ID8gMjAgOiAwKTtcblx0XHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gaXRlbUhlaWdodCA9IG1hdGhSb3VuZChpdGVtLmxlZ2VuZEl0ZW1IZWlnaHQgfHwgYkJveC5oZWlnaHQpO1xuXG5cdFx0XHQvLyBpZiB0aGUgaXRlbSBleGNlZWRzIHRoZSB3aWR0aCwgc3RhcnQgYSBuZXcgbGluZVxuXHRcdFx0aWYgKGhvcml6b250YWwgJiYgbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YICsgaXRlbVdpZHRoID5cblx0XHRcdFx0XHQod2lkdGhPcHRpb24gfHwgKGNoYXJ0LmNoYXJ0V2lkdGggLSAyICogcGFkZGluZyAtIGluaXRpYWxJdGVtWCAtIG9wdGlvbnMueCkpKSB7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWCA9IGluaXRpYWxJdGVtWDtcblx0XHRcdFx0bGVnZW5kLml0ZW1ZICs9IGl0ZW1NYXJnaW5Ub3AgKyBsZWdlbmQubGFzdExpbmVIZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSAwOyAvLyByZXNldCBmb3IgbmV4dCBsaW5lICgjOTE1LCAjMzk3Nilcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGl0ZW0gZXhjZWVkcyB0aGUgaGVpZ2h0LCBzdGFydCBhIG5ldyBjb2x1bW5cblx0XHRcdC8qaWYgKCFob3Jpem9udGFsICYmIGxlZ2VuZC5pdGVtWSArIG9wdGlvbnMueSArIGl0ZW1IZWlnaHQgPiBjaGFydC5jaGFydEhlaWdodCAtIHNwYWNpbmdUb3AgLSBzcGFjaW5nQm90dG9tKSB7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWSA9IGxlZ2VuZC5pbml0aWFsSXRlbVk7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWCArPSBsZWdlbmQubWF4SXRlbVdpZHRoO1xuXHRcdFx0XHRsZWdlbmQubWF4SXRlbVdpZHRoID0gMDtcblx0XHRcdH0qL1xuXG5cdFx0XHQvLyBTZXQgdGhlIGVkZ2UgcG9zaXRpb25zXG5cdFx0XHRsZWdlbmQubWF4SXRlbVdpZHRoID0gbWF0aE1heChsZWdlbmQubWF4SXRlbVdpZHRoLCBpdGVtV2lkdGgpO1xuXHRcdFx0bGVnZW5kLmxhc3RJdGVtWSA9IGl0ZW1NYXJnaW5Ub3AgKyBsZWdlbmQuaXRlbVkgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gbWF0aE1heChpdGVtSGVpZ2h0LCBsZWdlbmQubGFzdExpbmVIZWlnaHQpOyAvLyAjOTE1XG5cblx0XHRcdC8vIGNhY2hlIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV3bHkgZ2VuZXJhdGVkIG9yIHJlb3JkZXJlZCBpdGVtc1xuXHRcdFx0aXRlbS5fbGVnZW5kSXRlbVBvcyA9IFtsZWdlbmQuaXRlbVgsIGxlZ2VuZC5pdGVtWV07XG5cblx0XHRcdC8vIGFkdmFuY2Vcblx0XHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWCArPSBpdGVtV2lkdGg7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWSArPSBpdGVtTWFyZ2luVG9wICsgaXRlbUhlaWdodCArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0XHRcdGxlZ2VuZC5sYXN0TGluZUhlaWdodCA9IGl0ZW1IZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZSB3aWR0aCBvZiB0aGUgd2lkZXN0IGl0ZW1cblx0XHRcdGxlZ2VuZC5vZmZzZXRXaWR0aCA9IHdpZHRoT3B0aW9uIHx8IG1hdGhNYXgoXG5cdFx0XHRcdChob3Jpem9udGFsID8gbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YIC0gaXRlbURpc3RhbmNlIDogaXRlbVdpZHRoKSArIHBhZGRpbmcsXG5cdFx0XHRcdGxlZ2VuZC5vZmZzZXRXaWR0aFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFsbCBpdGVtcywgd2hpY2ggaXMgb25lIGl0ZW0gcGVyIHNlcmllcyBmb3Igbm9ybWFsIHNlcmllcyBhbmQgb25lIGl0ZW0gcGVyIHBvaW50XG5cdFx0ICogZm9yIHBpZSBzZXJpZXMuXG5cdFx0ICovXG5cdFx0Z2V0QWxsSXRlbXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBhbGxJdGVtcyA9IFtdO1xuXHRcdFx0ZWFjaCh0aGlzLmNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHR2YXIgc2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBzaG93SW5MZWdlbmQuIElmIHRoZSBzZXJpZXMgaXMgbGlua2VkIHRvIGFub3RoZXIgc2VyaWVzLCBkZWZhdWx0cyB0byBmYWxzZS5cblx0XHRcdFx0aWYgKCFwaWNrKHNlcmllc09wdGlvbnMuc2hvd0luTGVnZW5kLCAhZGVmaW5lZChzZXJpZXNPcHRpb25zLmxpbmtlZFRvKSA/IFVOREVGSU5FRCA6IGZhbHNlLCB0cnVlKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVzZSBwb2ludHMgb3Igc2VyaWVzIGZvciB0aGUgbGVnZW5kIGl0ZW0gZGVwZW5kaW5nIG9uIGxlZ2VuZFR5cGVcblx0XHRcdFx0YWxsSXRlbXMgPSBhbGxJdGVtcy5jb25jYXQoXG5cdFx0XHRcdFx0XHRzZXJpZXMubGVnZW5kSXRlbXMgfHxcblx0XHRcdFx0XHRcdChzZXJpZXNPcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcgP1xuXHRcdFx0XHRcdFx0XHRcdHNlcmllcy5kYXRhIDpcblx0XHRcdFx0XHRcdFx0XHRzZXJpZXMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhbGxJdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRqdXN0IHRoZSBjaGFydCBtYXJnaW5zIGJ5IHJlc2VydmluZyBzcGFjZSBmb3IgdGhlIGxlZ2VuZCBvbiBvbmx5IG9uZSBzaWRlXG5cdFx0ICogb2YgdGhlIGNoYXJ0LiBJZiB0aGUgcG9zaXRpb24gaXMgc2V0IHRvIGEgY29ybmVyLCB0b3Agb3IgYm90dG9tIGlzIHJlc2VydmVkXG5cdFx0ICogZm9yIGhvcml6b250YWwgbGVnZW5kcyBhbmQgbGVmdCBvciByaWdodCBmb3IgdmVydGljYWwgb25lcy5cblx0XHQgKi9cblx0XHRhZGp1c3RNYXJnaW5zOiBmdW5jdGlvbiAobWFyZ2luLCBzcGFjaW5nKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LCBcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0Ly8gVXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCBhbGlnbm1lbnQgb3B0aW9uIGluIG9yZGVyIHRvIGRldGVjdCB0aGUgc2lkZSBcblx0XHRcdFx0YWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnblswXSArIG9wdGlvbnMudmVydGljYWxBbGlnblswXSArIG9wdGlvbnMubGF5b3V0WzBdO1xuXHRcdFx0XHRcblx0XHRcdGlmICh0aGlzLmRpc3BsYXkgJiYgIW9wdGlvbnMuZmxvYXRpbmcpIHtcblxuXHRcdFx0XHRlYWNoKFtcblx0XHRcdFx0XHQvKGx0aHxjdHxydGgpLyxcblx0XHRcdFx0XHQvKHJ0dnxybXxyYnYpLyxcblx0XHRcdFx0XHQvKHJiaHxjYnxsYmgpLyxcblx0XHRcdFx0XHQvKGxidnxsbXxsdHYpL1xuXHRcdFx0XHRdLCBmdW5jdGlvbiAoYWxpZ25tZW50cywgc2lkZSkge1xuXHRcdFx0XHRcdGlmIChhbGlnbm1lbnRzLnRlc3QoYWxpZ25tZW50KSAmJiAhZGVmaW5lZChtYXJnaW5bc2lkZV0pKSB7XG5cdFx0XHRcdFx0XHQvLyBOb3cgd2UgaGF2ZSBkZXRlY3RlZCBvbiB3aGljaCBzaWRlIG9mIHRoZSBjaGFydCB3ZSBzaG91bGQgcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIGxlZ2VuZFxuXHRcdFx0XHRcdFx0Y2hhcnRbbWFyZ2luTmFtZXNbc2lkZV1dID0gbWF0aE1heChcblx0XHRcdFx0XHRcdFx0Y2hhcnRbbWFyZ2luTmFtZXNbc2lkZV1dLFxuXHRcdFx0XHRcdFx0XHRjaGFydC5sZWdlbmRbKHNpZGUgKyAxKSAlIDIgPyAnbGVnZW5kSGVpZ2h0JyA6ICdsZWdlbmRXaWR0aCddICsgXG5cdFx0XHRcdFx0XHRcdFx0WzEsIC0xLCAtMSwgMV1bc2lkZV0gKiBvcHRpb25zWyhzaWRlICUgMikgPyAneCcgOiAneSddICsgXG5cdFx0XHRcdFx0XHRcdFx0cGljayhvcHRpb25zLm1hcmdpbiwgMTIpICtcblx0XHRcdFx0XHRcdFx0XHRzcGFjaW5nW3NpZGVdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgbGVnZW5kLiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGJvdGggYmVmb3JlIGFuZCBhZnRlclxuXHRcdCAqIGNoYXJ0LnJlbmRlci4gSWYgY2FsbGVkIGFmdGVyLCBpdCB3aWxsIG9ubHkgcmVhcnJhbmdlIGl0ZW1zIGluc3RlYWRcblx0XHQgKiBvZiBjcmVhdGluZyBuZXcgb25lcy5cblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGxlZ2VuZC5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0bGVnZW5kR3JvdXAgPSBsZWdlbmQuZ3JvdXAsXG5cdFx0XHRcdGFsbEl0ZW1zLFxuXHRcdFx0XHRkaXNwbGF5LFxuXHRcdFx0XHRsZWdlbmRXaWR0aCxcblx0XHRcdFx0bGVnZW5kSGVpZ2h0LFxuXHRcdFx0XHRib3ggPSBsZWdlbmQuYm94LFxuXHRcdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRcdHBhZGRpbmcgPSBsZWdlbmQucGFkZGluZyxcblx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRsZWdlbmRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcblxuXHRcdFx0bGVnZW5kLml0ZW1YID0gbGVnZW5kLmluaXRpYWxJdGVtWDtcblx0XHRcdGxlZ2VuZC5pdGVtWSA9IGxlZ2VuZC5pbml0aWFsSXRlbVk7XG5cdFx0XHRsZWdlbmQub2Zmc2V0V2lkdGggPSAwO1xuXHRcdFx0bGVnZW5kLmxhc3RJdGVtWSA9IDA7XG5cblx0XHRcdGlmICghbGVnZW5kR3JvdXApIHtcblx0XHRcdFx0bGVnZW5kLmdyb3VwID0gbGVnZW5kR3JvdXAgPSByZW5kZXJlci5nKCdsZWdlbmQnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiA3IH0pIFxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cCA9IHJlbmRlcmVyLmcoKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pIC8vIGFib3ZlIGJhY2tncm91bmRcblx0XHRcdFx0XHQuYWRkKGxlZ2VuZEdyb3VwKTtcblx0XHRcdFx0bGVnZW5kLnNjcm9sbEdyb3VwID0gcmVuZGVyZXIuZygpXG5cdFx0XHRcdFx0LmFkZChsZWdlbmQuY29udGVudEdyb3VwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bGVnZW5kLnJlbmRlclRpdGxlKCk7XG5cblx0XHRcdC8vIGFkZCBlYWNoIHNlcmllcyBvciBwb2ludFxuXHRcdFx0YWxsSXRlbXMgPSBsZWdlbmQuZ2V0QWxsSXRlbXMoKTtcblxuXHRcdFx0Ly8gc29ydCBieSBsZWdlbmRJbmRleFxuXHRcdFx0c3RhYmxlU29ydChhbGxJdGVtcywgZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuICgoYS5vcHRpb25zICYmIGEub3B0aW9ucy5sZWdlbmRJbmRleCkgfHwgMCkgLSAoKGIub3B0aW9ucyAmJiBiLm9wdGlvbnMubGVnZW5kSW5kZXgpIHx8IDApO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJldmVyc2VkIGxlZ2VuZFxuXHRcdFx0aWYgKG9wdGlvbnMucmV2ZXJzZWQpIHtcblx0XHRcdFx0YWxsSXRlbXMucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZWdlbmQuYWxsSXRlbXMgPSBhbGxJdGVtcztcblx0XHRcdGxlZ2VuZC5kaXNwbGF5ID0gZGlzcGxheSA9ICEhYWxsSXRlbXMubGVuZ3RoO1xuXG5cdFx0XHQvLyByZW5kZXIgdGhlIGl0ZW1zXG5cdFx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSAwO1xuXHRcdFx0ZWFjaChhbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0bGVnZW5kLnJlbmRlckl0ZW0oaXRlbSk7IFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEdldCB0aGUgYm94XG5cdFx0XHRsZWdlbmRXaWR0aCA9IChvcHRpb25zLndpZHRoIHx8IGxlZ2VuZC5vZmZzZXRXaWR0aCkgKyBwYWRkaW5nO1xuXHRcdFx0bGVnZW5kSGVpZ2h0ID0gbGVnZW5kLmxhc3RJdGVtWSArIGxlZ2VuZC5sYXN0TGluZUhlaWdodCArIGxlZ2VuZC50aXRsZUhlaWdodDtcblx0XHRcdGxlZ2VuZEhlaWdodCA9IGxlZ2VuZC5oYW5kbGVPdmVyZmxvdyhsZWdlbmRIZWlnaHQpO1xuXHRcdFx0bGVnZW5kSGVpZ2h0ICs9IHBhZGRpbmc7XG5cblx0XHRcdC8vIERyYXcgdGhlIGJvcmRlciBhbmQvb3IgYmFja2dyb3VuZFxuXHRcdFx0aWYgKGxlZ2VuZEJvcmRlcldpZHRoIHx8IGxlZ2VuZEJhY2tncm91bmRDb2xvcikge1xuXG5cdFx0XHRcdGlmICghYm94KSB7XG5cdFx0XHRcdFx0bGVnZW5kLmJveCA9IGJveCA9IHJlbmRlcmVyLnJlY3QoXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRcdFx0bGVnZW5kSGVpZ2h0LFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5ib3JkZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCB8fCAwXG5cdFx0XHRcdFx0KS5hdHRyKHtcblx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsZWdlbmRCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0XHRcdFx0ZmlsbDogbGVnZW5kQmFja2dyb3VuZENvbG9yIHx8IE5PTkVcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApXG5cdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zLnNoYWRvdyk7XG5cdFx0XHRcdFx0Ym94LmlzTmV3ID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKGxlZ2VuZFdpZHRoID4gMCAmJiBsZWdlbmRIZWlnaHQgPiAwKSB7XG5cdFx0XHRcdFx0Ym94W2JveC5pc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10oXG5cdFx0XHRcdFx0XHRib3guY3Jpc3AoeyB3aWR0aDogbGVnZW5kV2lkdGgsIGhlaWdodDogbGVnZW5kSGVpZ2h0IH0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRib3guaXNOZXcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGhpZGUgdGhlIGJvcmRlciBpZiBubyBpdGVtc1xuXHRcdFx0XHRib3hbZGlzcGxheSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bGVnZW5kLmxlZ2VuZFdpZHRoID0gbGVnZW5kV2lkdGg7XG5cdFx0XHRsZWdlbmQubGVnZW5kSGVpZ2h0ID0gbGVnZW5kSGVpZ2h0O1xuXG5cdFx0XHQvLyBOb3cgdGhhdCB0aGUgbGVnZW5kIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVzdGFibGlzaGVkLCBwdXQgdGhlIGl0ZW1zIGluIHRoZSBcblx0XHRcdC8vIGZpbmFsIHBvc2l0aW9uXG5cdFx0XHRlYWNoKGFsbEl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRsZWdlbmQucG9zaXRpb25JdGVtKGl0ZW0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIDEueCBjb21wYXRpYmlsaXR5OiBwb3NpdGlvbmluZyBiYXNlZCBvbiBzdHlsZVxuXHRcdFx0Lyp2YXIgcHJvcHMgPSBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuXHRcdFx0XHRwcm9wLFxuXHRcdFx0XHRpID0gNDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5zdHlsZVtwcm9wXSAmJiBvcHRpb25zLnN0eWxlW3Byb3BdICE9PSAnYXV0bycpIHtcblx0XHRcdFx0XHRvcHRpb25zW2kgPCAyID8gJ2FsaWduJyA6ICd2ZXJ0aWNhbEFsaWduJ10gPSBwcm9wO1xuXHRcdFx0XHRcdG9wdGlvbnNbaSA8IDIgPyAneCcgOiAneSddID0gcEludChvcHRpb25zLnN0eWxlW3Byb3BdKSAqIChpICUgMiA/IC0xIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0qL1xuXG5cdFx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0XHRsZWdlbmRHcm91cC5hbGlnbihleHRlbmQoe1xuXHRcdFx0XHRcdHdpZHRoOiBsZWdlbmRXaWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGxlZ2VuZEhlaWdodFxuXHRcdFx0XHR9LCBvcHRpb25zKSwgdHJ1ZSwgJ3NwYWNpbmdCb3gnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFjaGFydC5pc1Jlc2l6aW5nKSB7XG5cdFx0XHRcdHRoaXMucG9zaXRpb25DaGVja2JveGVzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXQgdXAgdGhlIG92ZXJmbG93IGhhbmRsaW5nIGJ5IGFkZGluZyBuYXZpZ2F0aW9uIHdpdGggdXAgYW5kIGRvd24gYXJyb3dzIGJlbG93IHRoZVxuXHRcdCAqIGxlZ2VuZC5cblx0XHQgKi9cblx0XHRoYW5kbGVPdmVyZmxvdzogZnVuY3Rpb24gKGxlZ2VuZEhlaWdodCkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0b3B0aW9uc1kgPSBvcHRpb25zLnksXG5cdFx0XHRcdGFsaWduVG9wID0gb3B0aW9ucy52ZXJ0aWNhbEFsaWduID09PSAndG9wJyxcblx0XHRcdFx0c3BhY2VIZWlnaHQgPSBjaGFydC5zcGFjaW5nQm94LmhlaWdodCArIChhbGlnblRvcCA/IC1vcHRpb25zWSA6IG9wdGlvbnNZKSAtIHRoaXMucGFkZGluZyxcblx0XHRcdFx0bWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQsXG5cdFx0XHRcdGNsaXBIZWlnaHQsXG5cdFx0XHRcdGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdCxcblx0XHRcdFx0bmF2T3B0aW9ucyA9IG9wdGlvbnMubmF2aWdhdGlvbixcblx0XHRcdFx0YW5pbWF0aW9uID0gcGljayhuYXZPcHRpb25zLmFuaW1hdGlvbiwgdHJ1ZSksXG5cdFx0XHRcdGFycm93U2l6ZSA9IG5hdk9wdGlvbnMuYXJyb3dTaXplIHx8IDEyLFxuXHRcdFx0XHRuYXYgPSB0aGlzLm5hdixcblx0XHRcdFx0cGFnZXMgPSB0aGlzLnBhZ2VzLFxuXHRcdFx0XHRwYWRkaW5nID0gdGhpcy5wYWRkaW5nLFxuXHRcdFx0XHRsYXN0WSxcblx0XHRcdFx0YWxsSXRlbXMgPSB0aGlzLmFsbEl0ZW1zLFxuXHRcdFx0XHRjbGlwVG9IZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG5cdFx0XHRcdFx0Y2xpcFJlY3QuYXR0cih7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gdXNlSFRNTFxuXHRcdFx0XHRcdGlmIChsZWdlbmQuY29udGVudEdyb3VwLmRpdikge1xuXHRcdFx0XHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcCA9ICdyZWN0KCcgKyBwYWRkaW5nICsgJ3B4LDk5OTlweCwnICsgKHBhZGRpbmcgKyBoZWlnaHQpICsgJ3B4LDApJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0XG5cdFx0XHQvLyBBZGp1c3QgdGhlIGhlaWdodFxuXHRcdFx0aWYgKG9wdGlvbnMubGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcblx0XHRcdFx0c3BhY2VIZWlnaHQgLz0gMjtcblx0XHRcdH1cblx0XHRcdGlmIChtYXhIZWlnaHQpIHtcblx0XHRcdFx0c3BhY2VIZWlnaHQgPSBtYXRoTWluKHNwYWNlSGVpZ2h0LCBtYXhIZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBSZXNldCB0aGUgbGVnZW5kIGhlaWdodCBhbmQgYWRqdXN0IHRoZSBjbGlwcGluZyByZWN0YW5nbGVcblx0XHRcdHBhZ2VzLmxlbmd0aCA9IDA7XG5cdFx0XHRpZiAobGVnZW5kSGVpZ2h0ID4gc3BhY2VIZWlnaHQpIHtcblxuXHRcdFx0XHR0aGlzLmNsaXBIZWlnaHQgPSBjbGlwSGVpZ2h0ID0gbWF0aE1heChzcGFjZUhlaWdodCAtIDIwIC0gdGhpcy50aXRsZUhlaWdodCAtIHBhZGRpbmcsIDApO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gcGljayh0aGlzLmN1cnJlbnRQYWdlLCAxKTtcblx0XHRcdFx0dGhpcy5mdWxsSGVpZ2h0ID0gbGVnZW5kSGVpZ2h0O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRmlsbCBwYWdlcyB3aXRoIFkgcG9zaXRpb25zIHNvIHRoYXQgdGhlIHRvcCBvZiBlYWNoIGEgbGVnZW5kIGl0ZW0gZGVmaW5lc1xuXHRcdFx0XHQvLyB0aGUgc2Nyb2xsIHRvcCBmb3IgZWFjaCBwYWdlICgjMjA5OClcblx0XHRcdFx0ZWFjaChhbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgeSA9IGl0ZW0uX2xlZ2VuZEl0ZW1Qb3NbMV0sXG5cdFx0XHRcdFx0XHRoID0gbWF0aFJvdW5kKGl0ZW0ubGVnZW5kSXRlbS5nZXRCQm94KCkuaGVpZ2h0KSxcblx0XHRcdFx0XHRcdGxlbiA9IHBhZ2VzLmxlbmd0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWxlbiB8fCAoeSAtIHBhZ2VzW2xlbiAtIDFdID4gY2xpcEhlaWdodCAmJiAobGFzdFkgfHwgeSkgIT09IHBhZ2VzW2xlbiAtIDFdKSkge1xuXHRcdFx0XHRcdFx0cGFnZXMucHVzaChsYXN0WSB8fCB5KTtcblx0XHRcdFx0XHRcdGxlbisrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaSA9PT0gYWxsSXRlbXMubGVuZ3RoIC0gMSAmJiB5ICsgaCAtIHBhZ2VzW2xlbiAtIDFdID4gY2xpcEhlaWdodCkge1xuXHRcdFx0XHRcdFx0cGFnZXMucHVzaCh5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgIT09IGxhc3RZKSB7XG5cdFx0XHRcdFx0XHRsYXN0WSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBPbmx5IGFwcGx5IGNsaXBwaW5nIGlmIG5lZWRlZC4gQ2xpcHBpbmcgY2F1c2VzIGJsdXJyZWQgbGVnZW5kIGluIFBERiBleHBvcnQgKCMxNzg3KVxuXHRcdFx0XHRpZiAoIWNsaXBSZWN0KSB7XG5cdFx0XHRcdFx0Y2xpcFJlY3QgPSBsZWdlbmQuY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdCgwLCBwYWRkaW5nLCA5OTk5LCAwKTtcblx0XHRcdFx0XHRsZWdlbmQuY29udGVudEdyb3VwLmNsaXAoY2xpcFJlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNsaXBUb0hlaWdodChjbGlwSGVpZ2h0KTtcblxuXHRcdFx0XHQvLyBBZGQgbmF2aWdhdGlvbiBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIW5hdikge1xuXHRcdFx0XHRcdHRoaXMubmF2ID0gbmF2ID0gcmVuZGVyZXIuZygpLmF0dHIoeyB6SW5kZXg6IDEgfSkuYWRkKHRoaXMuZ3JvdXApO1xuXHRcdFx0XHRcdHRoaXMudXAgPSByZW5kZXJlci5zeW1ib2woJ3RyaWFuZ2xlJywgMCwgMCwgYXJyb3dTaXplLCBhcnJvd1NpemUpXG5cdFx0XHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRsZWdlbmQuc2Nyb2xsKC0xLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQobmF2KTtcblx0XHRcdFx0XHR0aGlzLnBhZ2VyID0gcmVuZGVyZXIudGV4dCgnJywgMTUsIDEwKVxuXHRcdFx0XHRcdFx0LmNzcyhuYXZPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHRcdHRoaXMuZG93biA9IHJlbmRlcmVyLnN5bWJvbCgndHJpYW5nbGUtZG93bicsIDAsIDAsIGFycm93U2l6ZSwgYXJyb3dTaXplKVxuXHRcdFx0XHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0bGVnZW5kLnNjcm9sbCgxLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQobmF2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU2V0IGluaXRpYWwgcG9zaXRpb25cblx0XHRcdFx0bGVnZW5kLnNjcm9sbCgwKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxlZ2VuZEhlaWdodCA9IHNwYWNlSGVpZ2h0O1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAobmF2KSB7XG5cdFx0XHRcdGNsaXBUb0hlaWdodChjaGFydC5jaGFydEhlaWdodCk7XG5cdFx0XHRcdG5hdi5oaWRlKCk7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogMVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5jbGlwSGVpZ2h0ID0gMDsgLy8gIzEzNzlcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxlZ2VuZEhlaWdodDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbCB0aGUgbGVnZW5kIGJ5IGEgbnVtYmVyIG9mIHBhZ2VzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNjcm9sbEJ5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdHNjcm9sbDogZnVuY3Rpb24gKHNjcm9sbEJ5LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBwYWdlcyA9IHRoaXMucGFnZXMsXG5cdFx0XHRcdHBhZ2VDb3VudCA9IHBhZ2VzLmxlbmd0aCxcblx0XHRcdFx0Y3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlICsgc2Nyb2xsQnksXG5cdFx0XHRcdGNsaXBIZWlnaHQgPSB0aGlzLmNsaXBIZWlnaHQsXG5cdFx0XHRcdG5hdk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbixcblx0XHRcdFx0YWN0aXZlQ29sb3IgPSBuYXZPcHRpb25zLmFjdGl2ZUNvbG9yLFxuXHRcdFx0XHRpbmFjdGl2ZUNvbG9yID0gbmF2T3B0aW9ucy5pbmFjdGl2ZUNvbG9yLFxuXHRcdFx0XHRwYWdlciA9IHRoaXMucGFnZXIsXG5cdFx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRcdHNjcm9sbE9mZnNldDtcblx0XHRcdFxuXHRcdFx0Ly8gV2hlbiByZXNpemluZyB3aGlsZSBsb29raW5nIGF0IHRoZSBsYXN0IHBhZ2Vcblx0XHRcdGlmIChjdXJyZW50UGFnZSA+IHBhZ2VDb3VudCkge1xuXHRcdFx0XHRjdXJyZW50UGFnZSA9IHBhZ2VDb3VudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGN1cnJlbnRQYWdlID4gMCkge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFuaW1hdGlvbiAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgdGhpcy5jaGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMubmF2LmF0dHIoe1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVg6IHBhZGRpbmcsXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogY2xpcEhlaWdodCArIHRoaXMucGFkZGluZyArIDcgKyB0aGlzLnRpdGxlSGVpZ2h0LFxuXHRcdFx0XHRcdHZpc2liaWxpdHk6IFZJU0lCTEVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMudXAuYXR0cih7XG5cdFx0XHRcdFx0XHRmaWxsOiBjdXJyZW50UGFnZSA9PT0gMSA/IGluYWN0aXZlQ29sb3IgOiBhY3RpdmVDb2xvclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IGN1cnJlbnRQYWdlID09PSAxID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdHBhZ2VyLmF0dHIoe1xuXHRcdFx0XHRcdHRleHQ6IGN1cnJlbnRQYWdlICsgJy8nICsgcGFnZUNvdW50XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmRvd24uYXR0cih7XG5cdFx0XHRcdFx0XHR4OiAxOCArIHRoaXMucGFnZXIuZ2V0QkJveCgpLndpZHRoLCAvLyBhZGp1c3QgdG8gdGV4dCB3aWR0aFxuXHRcdFx0XHRcdFx0ZmlsbDogY3VycmVudFBhZ2UgPT09IHBhZ2VDb3VudCA/IGluYWN0aXZlQ29sb3IgOiBhY3RpdmVDb2xvclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IGN1cnJlbnRQYWdlID09PSBwYWdlQ291bnQgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHNjcm9sbE9mZnNldCA9IC1wYWdlc1tjdXJyZW50UGFnZSAtIDFdICsgdGhpcy5pbml0aWFsSXRlbVk7XG5cblx0XHRcdFx0dGhpcy5zY3JvbGxHcm91cC5hbmltYXRlKHtcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBzY3JvbGxPZmZzZXRcblx0XHRcdFx0fSk7XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gY3VycmVudFBhZ2U7XG5cdFx0XHRcdHRoaXMucG9zaXRpb25DaGVja2JveGVzKHNjcm9sbE9mZnNldCk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdH1cblx0XHRcblx0fTtcblxuXHQvKlxuXHQgKiBMZWdlbmRTeW1ib2xNaXhpblxuXHQgKi8gXG5cblx0dmFyIExlZ2VuZFN5bWJvbE1peGluID0gSGlnaGNoYXJ0cy5MZWdlbmRTeW1ib2xNaXhpbiA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc2VyaWVzJyBzeW1ib2wgaW4gdGhlIGxlZ2VuZFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmQgVGhlIGxlZ2VuZCBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgc2VyaWVzICh0aGlzKSBvciBwb2ludFxuXHRcdCAqL1xuXHRcdGRyYXdSZWN0YW5nbGU6IGZ1bmN0aW9uIChsZWdlbmQsIGl0ZW0pIHtcblx0XHRcdHZhciBzeW1ib2xIZWlnaHQgPSBsZWdlbmQub3B0aW9ucy5zeW1ib2xIZWlnaHQgfHwgbGVnZW5kLmZvbnRNZXRyaWNzLmY7XG5cblx0XHRcdGl0ZW0ubGVnZW5kU3ltYm9sID0gdGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KFxuXHRcdFx0XHQwLFxuXHRcdFx0XHRsZWdlbmQuYmFzZWxpbmUgLSBzeW1ib2xIZWlnaHQgKyAxLCAvLyAjMzk4OFxuXHRcdFx0XHRsZWdlbmQuc3ltYm9sV2lkdGgsXG5cdFx0XHRcdHN5bWJvbEhlaWdodCxcblx0XHRcdFx0bGVnZW5kLm9wdGlvbnMuc3ltYm9sUmFkaXVzIHx8IDBcblx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdHpJbmRleDogM1xuXHRcdFx0fSkuYWRkKGl0ZW0ubGVnZW5kR3JvdXApO1x0XHRcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sIGluIHRoZSBsZWdlbmQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkYWJsZSB0byBjcmVhdGUgY3VzdG9tIFxuXHRcdCAqIHN5bWJvbHMgdGhyb3VnaCBIaWdoY2hhcnRzLnNlcmllc1R5cGVzW3R5cGVdLnByb3RvdHlwZS5kcmF3TGVnZW5kU3ltYm9scy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kIFRoZSBsZWdlbmQgb2JqZWN0XG5cdFx0ICovXG5cdFx0ZHJhd0xpbmVNYXJrZXI6IGZ1bmN0aW9uIChsZWdlbmQpIHtcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBvcHRpb25zLm1hcmtlcixcblx0XHRcdFx0cmFkaXVzLFxuXHRcdFx0XHRsZWdlbmRTeW1ib2wsXG5cdFx0XHRcdHN5bWJvbFdpZHRoID0gbGVnZW5kLnN5bWJvbFdpZHRoLFxuXHRcdFx0XHRyZW5kZXJlciA9IHRoaXMuY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGxlZ2VuZEl0ZW1Hcm91cCA9IHRoaXMubGVnZW5kR3JvdXAsXG5cdFx0XHRcdHZlcnRpY2FsQ2VudGVyID0gbGVnZW5kLmJhc2VsaW5lIC0gbWF0aFJvdW5kKGxlZ2VuZC5mb250TWV0cmljcy5iICogMC4zKSxcblx0XHRcdFx0YXR0cjtcblxuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZVxuXHRcdFx0aWYgKG9wdGlvbnMubGluZVdpZHRoKSB7XG5cdFx0XHRcdGF0dHIgPSB7XG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMubGluZVdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvcHRpb25zLmRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdGF0dHIuZGFzaHN0eWxlID0gb3B0aW9ucy5kYXNoU3R5bGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sZWdlbmRMaW5lID0gcmVuZGVyZXIucGF0aChbXG5cdFx0XHRcdFx0TSxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHZlcnRpY2FsQ2VudGVyLFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0c3ltYm9sV2lkdGgsXG5cdFx0XHRcdFx0dmVydGljYWxDZW50ZXJcblx0XHRcdFx0XSlcblx0XHRcdFx0LmF0dHIoYXR0cilcblx0XHRcdFx0LmFkZChsZWdlbmRJdGVtR3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBEcmF3IHRoZSBtYXJrZXJcblx0XHRcdGlmIChtYXJrZXJPcHRpb25zICYmIG1hcmtlck9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0cmFkaXVzID0gbWFya2VyT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHRcdHRoaXMubGVnZW5kU3ltYm9sID0gbGVnZW5kU3ltYm9sID0gcmVuZGVyZXIuc3ltYm9sKFxuXHRcdFx0XHRcdHRoaXMuc3ltYm9sLFxuXHRcdFx0XHRcdChzeW1ib2xXaWR0aCAvIDIpIC0gcmFkaXVzLFxuXHRcdFx0XHRcdHZlcnRpY2FsQ2VudGVyIC0gcmFkaXVzLFxuXHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0MiAqIHJhZGl1c1xuXHRcdFx0XHQpXG5cdFx0XHRcdC5hZGQobGVnZW5kSXRlbUdyb3VwKTtcblx0XHRcdFx0bGVnZW5kU3ltYm9sLmlzTWFya2VyID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gV29ya2Fyb3VuZCBmb3IgIzIwMzAsIGhvcml6b250YWwgbGVnZW5kIGl0ZW1zIG5vdCBkaXNwbGF5aW5nIGluIElFMTEgUHJldmlldyxcblx0Ly8gYW5kIGZvciAjMjU4MCwgYSBzaW1pbGFyIGRyYXdpbmcgZmxhdyBpbiBGaXJlZm94IDI2LlxuXHQvLyBUT0RPOiBFeHBsb3JlIGlmIHRoZXJlJ3MgYSBnZW5lcmFsIGNhdXNlIGZvciB0aGlzLiBUaGUgcHJvYmxlbSBtYXkgYmUgcmVsYXRlZCBcblx0Ly8gdG8gbmVzdGVkIGdyb3VwIGVsZW1lbnRzLCBhcyB0aGUgbGVnZW5kIGl0ZW0gdGV4dHMgYXJlIHdpdGhpbiA0IGdyb3VwIGVsZW1lbnRzLlxuXHRpZiAoL1RyaWRlbnRcXC83XFwuMC8udGVzdCh1c2VyQWdlbnQpIHx8IGlzRmlyZWZveCkge1xuXHRcdHdyYXAoTGVnZW5kLnByb3RvdHlwZSwgJ3Bvc2l0aW9uSXRlbScsIGZ1bmN0aW9uIChwcm9jZWVkLCBpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0cnVuUG9zaXRpb25JdGVtID0gZnVuY3Rpb24gKCkgeyAvLyBJZiBjaGFydCBkZXN0cm95ZWQgaW4gc3luYywgdGhpcyBpcyB1bmRlZmluZWQgKCMyMDMwKVxuXHRcdFx0XHRcdGlmIChpdGVtLl9sZWdlbmRJdGVtUG9zKSB7XG5cdFx0XHRcdFx0XHRwcm9jZWVkLmNhbGwobGVnZW5kLCBpdGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIERvIGl0IG5vdywgZm9yIGV4cG9ydCBhbmQgdG8gZ2V0IGNoZWNrYm94IHBsYWNlbWVudFxuXHRcdFx0cnVuUG9zaXRpb25JdGVtKCk7XG5cdFx0XHRcblx0XHRcdC8vIERvIGl0IGFmdGVyIHRvIHdvcmsgYXJvdW5kIHRoZSBjb3JlIGlzc3VlXG5cdFx0XHRzZXRUaW1lb3V0KHJ1blBvc2l0aW9uSXRlbSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCAqIFRoZSBjaGFydCBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgY2hhcnQgaGFzIGxvYWRlZFxuXHQgKi9cblx0dmFyIENoYXJ0ID0gSGlnaGNoYXJ0cy5DaGFydCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRDaGFydC5wcm90b3R5cGUgPSB7XG5cblx0XHQvKipcblx0XHQgKiBIb29rIGZvciBtb2R1bGVzXG5cdFx0ICovXG5cdFx0Y2FsbGJhY2tzOiBbXSxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHVzZXJPcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdFx0XHQvLyBIYW5kbGUgcmVndWxhciBvcHRpb25zXG5cdFx0XHR2YXIgb3B0aW9ucyxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHVzZXJPcHRpb25zLnNlcmllczsgLy8gc2tpcCBtZXJnaW5nIGRhdGEgcG9pbnRzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG5cblx0XHRcdHVzZXJPcHRpb25zLnNlcmllcyA9IG51bGw7XG5cdFx0XHRvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKTsgLy8gZG8gdGhlIG1lcmdlXG5cdFx0XHRvcHRpb25zLnNlcmllcyA9IHVzZXJPcHRpb25zLnNlcmllcyA9IHNlcmllc09wdGlvbnM7IC8vIHNldCBiYWNrIHRoZSBzZXJpZXMgZGF0YVxuXHRcdFx0dGhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuXG5cdFx0XHR2YXIgb3B0aW9uc0NoYXJ0ID0gb3B0aW9ucy5jaGFydDtcblx0XHRcdFxuXHRcdFx0Ly8gQ3JlYXRlIG1hcmdpbiAmIHNwYWNpbmcgYXJyYXlcblx0XHRcdHRoaXMubWFyZ2luID0gdGhpcy5zcGxhc2hBcnJheSgnbWFyZ2luJywgb3B0aW9uc0NoYXJ0KTtcblx0XHRcdHRoaXMuc3BhY2luZyA9IHRoaXMuc3BsYXNoQXJyYXkoJ3NwYWNpbmcnLCBvcHRpb25zQ2hhcnQpO1xuXG5cdFx0XHR2YXIgY2hhcnRFdmVudHMgPSBvcHRpb25zQ2hhcnQuZXZlbnRzO1xuXG5cdFx0XHQvL3RoaXMucnVuQ2hhcnRDbGljayA9IGNoYXJ0RXZlbnRzICYmICEhY2hhcnRFdmVudHMuY2xpY2s7XG5cdFx0XHR0aGlzLmJvdW5kcyA9IHsgaDoge30sIHY6IHt9IH07IC8vIFBpeGVsIGRhdGEgYm91bmRzIGZvciB0b3VjaCB6b29tXG5cblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuaXNSZXNpemluZyA9IDA7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0Ly9jaGFydFRpdGxlT3B0aW9ucyA9IFVOREVGSU5FRDtcblx0XHRcdC8vY2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBVTkRFRklORUQ7XG5cblx0XHRcdHRoaXMuYXhlcyA9IFtdO1xuXHRcdFx0dGhpcy5zZXJpZXMgPSBbXTtcblx0XHRcdHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID0gb3B0aW9uc0NoYXJ0LnNob3dBeGVzO1xuXHRcdFx0Ly90aGlzLmF4aXNPZmZzZXQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubWF4VGlja3MgPSBVTkRFRklORUQ7IC8vIGhhbmRsZSB0aGUgZ3JlYXRlc3QgYW1vdW50IG9mIHRpY2tzIG9uIGdyb3VwZWQgYXhlc1xuXHRcdFx0Ly90aGlzLmludmVydGVkID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmxvYWRpbmdTaG93biA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5jb250YWluZXIgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY2hhcnRXaWR0aCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5jaGFydEhlaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5tYXJnaW5SaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5tYXJnaW5Cb3R0b20gPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY29udGFpbmVyV2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY29udGFpbmVySGVpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLm9sZENoYXJ0V2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMub2xkQ2hhcnRIZWlnaHQgPSBVTkRFRklORUQ7XG5cblx0XHRcdC8vdGhpcy5yZW5kZXJUbyA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5yZW5kZXJUb0Nsb25lID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvL3RoaXMuc3BhY2luZ0JveCA9IFVOREVGSU5FRFxuXG5cdFx0XHQvL3RoaXMubGVnZW5kID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBFbGVtZW50c1xuXHRcdFx0Ly90aGlzLmNoYXJ0QmFja2dyb3VuZCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90QmFja2dyb3VuZCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90QkdJbWFnZSA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90Qm9yZGVyID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmxvYWRpbmdEaXYgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubG9hZGluZ1NwYW4gPSBVTkRFRklORUQ7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGV2ZW50VHlwZTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBjaGFydCB0byB0aGUgZ2xvYmFsIGxvb2t1cFxuXHRcdFx0Y2hhcnQuaW5kZXggPSBjaGFydHMubGVuZ3RoO1xuXHRcdFx0Y2hhcnRzLnB1c2goY2hhcnQpO1xuXHRcdFx0Y2hhcnRDb3VudCsrO1xuXG5cdFx0XHQvLyBTZXQgdXAgYXV0byByZXNpemVcblx0XHRcdGlmIChvcHRpb25zQ2hhcnQucmVmbG93ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRhZGRFdmVudChjaGFydCwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y2hhcnQuaW5pdFJlZmxvdygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhcnQgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmIChjaGFydEV2ZW50cykge1xuXHRcdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBjaGFydEV2ZW50cykge1xuXHRcdFx0XHRcdGFkZEV2ZW50KGNoYXJ0LCBldmVudFR5cGUsIGNoYXJ0RXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnhBeGlzID0gW107XG5cdFx0XHRjaGFydC55QXhpcyA9IFtdO1xuXG5cdFx0XHQvLyBFeHBvc2UgbWV0aG9kcyBhbmQgdmFyaWFibGVzXG5cdFx0XHRjaGFydC5hbmltYXRpb24gPSB1c2VDYW5WRyA/IGZhbHNlIDogcGljayhvcHRpb25zQ2hhcnQuYW5pbWF0aW9uLCB0cnVlKTtcblx0XHRcdGNoYXJ0LnBvaW50Q291bnQgPSBjaGFydC5jb2xvckNvdW50ZXIgPSBjaGFydC5zeW1ib2xDb3VudGVyID0gMDtcblxuXHRcdFx0Y2hhcnQuZmlyc3RSZW5kZXIoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSBhbiBpbmRpdmlkdWFsIHNlcmllcywgY2FsbGVkIGludGVybmFsbHkgYmVmb3JlIHJlbmRlciB0aW1lXG5cdFx0ICovXG5cdFx0aW5pdFNlcmllczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgb3B0aW9uc0NoYXJ0LnR5cGUgfHwgb3B0aW9uc0NoYXJ0LmRlZmF1bHRTZXJpZXNUeXBlLFxuXHRcdFx0XHRzZXJpZXMsXG5cdFx0XHRcdGNvbnN0ciA9IHNlcmllc1R5cGVzW3R5cGVdO1xuXG5cdFx0XHQvLyBObyBzdWNoIHNlcmllcyB0eXBlXG5cdFx0XHRpZiAoIWNvbnN0cikge1xuXHRcdFx0XHRlcnJvcigxNywgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcyA9IG5ldyBjb25zdHIoKTtcblx0XHRcdHNlcmllcy5pbml0KHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHNlcmllcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHBvaW50IGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGxvdFggUGl4ZWwgeCByZWxhdGl2ZSB0byB0aGUgcGxvdCBhcmVhXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBsb3RZIFBpeGVsIHkgcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0ZWQgV2hldGhlciB0aGUgY2hhcnQgaXMgaW52ZXJ0ZWRcblx0XHQgKi9cblx0XHRpc0luc2lkZVBsb3Q6IGZ1bmN0aW9uIChwbG90WCwgcGxvdFksIGludmVydGVkKSB7XG5cdFx0XHR2YXIgeCA9IGludmVydGVkID8gcGxvdFkgOiBwbG90WCxcblx0XHRcdFx0eSA9IGludmVydGVkID8gcGxvdFggOiBwbG90WTtcblx0XHRcdFx0XG5cdFx0XHRyZXR1cm4geCA+PSAwICYmXG5cdFx0XHRcdHggPD0gdGhpcy5wbG90V2lkdGggJiZcblx0XHRcdFx0eSA+PSAwICYmXG5cdFx0XHRcdHkgPD0gdGhpcy5wbG90SGVpZ2h0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWRyYXcgbGVnZW5kLCBheGVzIG9yIHNlcmllcyBiYXNlZCBvbiB1cGRhdGVkIGRhdGFcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqL1xuXHRcdHJlZHJhdzogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0YXhlcyA9IGNoYXJ0LmF4ZXMsXG5cdFx0XHRcdHNlcmllcyA9IGNoYXJ0LnNlcmllcyxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCxcblx0XHRcdFx0cmVkcmF3TGVnZW5kID0gY2hhcnQuaXNEaXJ0eUxlZ2VuZCxcblx0XHRcdFx0aGFzU3RhY2tlZFNlcmllcyxcblx0XHRcdFx0aGFzRGlydHlTdGFja3MsXG5cdFx0XHRcdGhhc0NhcnRlc2lhblNlcmllcyA9IGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcyxcblx0XHRcdFx0aXNEaXJ0eUJveCA9IGNoYXJ0LmlzRGlydHlCb3gsIC8vIHRvZG86IGNoZWNrIGlmIGl0IGhhcyBhY3R1YWxseSBjaGFuZ2VkP1xuXHRcdFx0XHRzZXJpZXNMZW5ndGggPSBzZXJpZXMubGVuZ3RoLFxuXHRcdFx0XHRpID0gc2VyaWVzTGVuZ3RoLFxuXHRcdFx0XHRzZXJpZSxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0aXNIaWRkZW5DaGFydCA9IHJlbmRlcmVyLmlzSGlkZGVuKCksXG5cdFx0XHRcdGFmdGVyUmVkcmF3ID0gW107XG5cdFx0XHRcdFxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNIaWRkZW5DaGFydCkge1xuXHRcdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkanVzdCB0aXRsZSBsYXlvdXQgKHJlZmxvdyBtdWx0aWxpbmUgdGV4dClcblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcygpO1xuXG5cdFx0XHQvLyBsaW5rIHN0YWNrZWQgc2VyaWVzXG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHNlcmllID0gc2VyaWVzW2ldO1xuXG5cdFx0XHRcdGlmIChzZXJpZS5vcHRpb25zLnN0YWNraW5nKSB7XG5cdFx0XHRcdFx0aGFzU3RhY2tlZFNlcmllcyA9IHRydWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNlcmllLmlzRGlydHkpIHtcblx0XHRcdFx0XHRcdGhhc0RpcnR5U3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0RpcnR5U3RhY2tzKSB7IC8vIG1hcmsgb3RoZXJzIGFzIGRpcnR5XG5cdFx0XHRcdGkgPSBzZXJpZXNMZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRzZXJpZSA9IHNlcmllc1tpXTtcblx0XHRcdFx0XHRpZiAoc2VyaWUub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdFx0c2VyaWUuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB1cGRhdGVkIGRhdGEgaW4gdGhlIHNlcmllc1xuXHRcdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRpZiAoc2VyaWUuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGlmIChzZXJpZS5vcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHtcblx0XHRcdFx0XHRcdGlmIChzZXJpZS51cGRhdGVUb3RhbHMpIHtcblx0XHRcdFx0XHRcdFx0c2VyaWUudXBkYXRlVG90YWxzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZWRyYXdMZWdlbmQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGhhbmRsZSBhZGRlZCBvciByZW1vdmVkIHNlcmllc1xuXHRcdFx0aWYgKHJlZHJhd0xlZ2VuZCAmJiBsZWdlbmQub3B0aW9ucy5lbmFibGVkKSB7IC8vIHNlcmllcyBvciBwaWUgcG9pbnRzIGFyZSBhZGRlZCBvciByZW1vdmVkXG5cdFx0XHRcdC8vIGRyYXcgbGVnZW5kIGdyYXBoaWNzXG5cdFx0XHRcdGxlZ2VuZC5yZW5kZXIoKTtcblxuXHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc2V0IHN0YWNrc1xuXHRcdFx0aWYgKGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdFx0Y2hhcnQuZ2V0U3RhY2tzKCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKGhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHRpZiAoIWNoYXJ0LmlzUmVzaXppbmcpIHtcblxuXHRcdFx0XHRcdC8vIHJlc2V0IG1heFRpY2tzXG5cdFx0XHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IGF4ZXMgc2NhbGVzXG5cdFx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdFx0YXhpcy5zZXRTY2FsZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LmdldE1hcmdpbnMoKTsgLy8gIzMwOThcblxuXHRcdFx0aWYgKGhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHQvLyBJZiBvbmUgYXhpcyBpcyBkaXJ0eSwgYWxsIGF4ZXMgbXVzdCBiZSByZWRyYXduICgjNzkyLCAjMjE2OSlcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGlmIChheGlzLmlzRGlydHkpIHtcblx0XHRcdFx0XHRcdGlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcmVkcmF3IGF4ZXNcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEZpcmUgJ2FmdGVyU2V0RXh0cmVtZXMnIG9ubHkgaWYgZXh0cmVtZXMgYXJlIHNldFxuXHRcdFx0XHRcdGlmIChheGlzLmlzRGlydHlFeHRyZW1lcykgeyAvLyAjODIxXG5cdFx0XHRcdFx0XHRheGlzLmlzRGlydHlFeHRyZW1lcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YWZ0ZXJSZWRyYXcucHVzaChmdW5jdGlvbiAoKSB7IC8vIHByZXZlbnQgYSByZWN1cnNpdmUgY2FsbCB0byBjaGFydC5yZWRyYXcoKSAoIzExMTkpXG5cdFx0XHRcdFx0XHRcdGZpcmVFdmVudChheGlzLCAnYWZ0ZXJTZXRFeHRyZW1lcycsIGV4dGVuZChheGlzLmV2ZW50QXJncywgYXhpcy5nZXRFeHRyZW1lcygpKSk7IC8vICM3NDcsICM3NTFcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGF4aXMuZXZlbnRBcmdzO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc0RpcnR5Qm94IHx8IGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdFx0XHRcdGF4aXMucmVkcmF3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gdGhlIHBsb3QgYXJlYXMgc2l6ZSBoYXMgY2hhbmdlZFxuXHRcdFx0aWYgKGlzRGlydHlCb3gpIHtcblx0XHRcdFx0Y2hhcnQuZHJhd0NoYXJ0Qm94KCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmVkcmF3IGFmZmVjdGVkIHNlcmllc1xuXHRcdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRpZiAoc2VyaWUuaXNEaXJ0eSAmJiBzZXJpZS52aXNpYmxlICYmXG5cdFx0XHRcdFx0XHQoIXNlcmllLmlzQ2FydGVzaWFuIHx8IHNlcmllLnhBeGlzKSkgeyAvLyBpc3N1ZSAjMTUzXG5cdFx0XHRcdFx0c2VyaWUucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBtb3ZlIHRvb2x0aXAgb3IgcmVzZXRcblx0XHRcdGlmIChwb2ludGVyKSB7XG5cdFx0XHRcdHBvaW50ZXIucmVzZXQodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZHJhdyBpZiBjYW52YXNcblx0XHRcdHJlbmRlcmVyLmRyYXcoKTtcblxuXHRcdFx0Ly8gZmlyZSB0aGUgZXZlbnRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3JlZHJhdycpOyAvLyBqUXVlcnkgYnJlYWtzIHRoaXMgd2hlbiBjYWxsaW5nIGl0IGZyb20gYWRkRXZlbnQuIE92ZXJ3cml0ZXMgY2hhcnQucmVkcmF3XG5cdFx0XHRcblx0XHRcdGlmIChpc0hpZGRlbkNoYXJ0KSB7XG5cdFx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8odHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEZpcmUgY2FsbGJhY2tzIHRoYXQgYXJlIHB1dCBvbiBob2xkIHVudGlsIGFmdGVyIHRoZSByZWRyYXdcblx0XHRcdGVhY2goYWZ0ZXJSZWRyYXcsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGF4aXMsIHNlcmllcyBvciBwb2ludCBvYmplY3QgYnkgaWQuXG5cdFx0ICogQHBhcmFtIGlkIHtTdHJpbmd9IFRoZSBpZCBhcyBnaXZlbiBpbiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG5cdFx0ICovXG5cdFx0Z2V0OiBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXM7XG5cblx0XHRcdHZhciBpLFxuXHRcdFx0XHRqLFxuXHRcdFx0XHRwb2ludHM7XG5cblx0XHRcdC8vIHNlYXJjaCBheGVzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXhlc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBheGVzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNlYXJjaCBzZXJpZXNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHNlcmllc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBzZXJpZXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2VhcmNoIHBvaW50c1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXNbaV0ucG9pbnRzIHx8IFtdO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50c1tqXS5pZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwb2ludHNbal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBBeGlzIGluc3RhbmNlcyBiYXNlZCBvbiB0aGUgY29uZmlnIG9wdGlvbnNcblx0XHQgKi9cblx0XHRnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR4QXhpc09wdGlvbnMgPSBvcHRpb25zLnhBeGlzID0gc3BsYXQob3B0aW9ucy54QXhpcyB8fCB7fSksXG5cdFx0XHRcdHlBeGlzT3B0aW9ucyA9IG9wdGlvbnMueUF4aXMgPSBzcGxhdChvcHRpb25zLnlBeGlzIHx8IHt9KSxcblx0XHRcdFx0b3B0aW9uc0FycmF5LFxuXHRcdFx0XHRheGlzO1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYXJlIGFycmF5cyBhbmQgYWRkIHNvbWUgbWVtYmVyc1xuXHRcdFx0ZWFjaCh4QXhpc09wdGlvbnMsIGZ1bmN0aW9uIChheGlzLCBpKSB7XG5cdFx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdFx0XHRheGlzLmlzWCA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWFjaCh5QXhpc09wdGlvbnMsIGZ1bmN0aW9uIChheGlzLCBpKSB7XG5cdFx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGNvbmNhdGVuYXRlIGFsbCBheGlzIG9wdGlvbnMgaW50byBvbmUgYXJyYXlcblx0XHRcdG9wdGlvbnNBcnJheSA9IHhBeGlzT3B0aW9ucy5jb25jYXQoeUF4aXNPcHRpb25zKTtcblxuXHRcdFx0ZWFjaChvcHRpb25zQXJyYXksIGZ1bmN0aW9uIChheGlzT3B0aW9ucykge1xuXHRcdFx0XHRheGlzID0gbmV3IEF4aXMoY2hhcnQsIGF4aXNPcHRpb25zKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvaW50cyBmcm9tIGFsbCBzZXJpZXNcblx0XHQgKi9cblx0XHRnZXRTZWxlY3RlZFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50cyA9IFtdO1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdHBvaW50cyA9IHBvaW50cy5jb25jYXQoZ3JlcChzZXJpZS5wb2ludHMgfHwgW10sIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHJldHVybiBwb2ludC5zZWxlY3RlZDtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzZXJpZXNcblx0XHQgKi9cblx0XHRnZXRTZWxlY3RlZFNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdyZXAodGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRyZXR1cm4gc2VyaWUuc2VsZWN0ZWQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvdyB0aGUgdGl0bGUgYW5kIHN1YnRpdGxlIG9mIHRoZSBjaGFydFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHRpdGxlT3B0aW9ucyB7T2JqZWN0fSBOZXcgdGl0bGUgb3B0aW9uc1xuXHRcdCAqIEBwYXJhbSBzdWJ0aXRsZU9wdGlvbnMge09iamVjdH0gTmV3IHN1YnRpdGxlIG9wdGlvbnNcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHNldFRpdGxlOiBmdW5jdGlvbiAodGl0bGVPcHRpb25zLCBzdWJ0aXRsZU9wdGlvbnMsIHJlZHJhdykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0VGl0bGVPcHRpb25zLFxuXHRcdFx0XHRjaGFydFN1YnRpdGxlT3B0aW9ucztcblxuXHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlID0gbWVyZ2Uob3B0aW9ucy50aXRsZSwgdGl0bGVPcHRpb25zKTtcblx0XHRcdGNoYXJ0U3VidGl0bGVPcHRpb25zID0gb3B0aW9ucy5zdWJ0aXRsZSA9IG1lcmdlKG9wdGlvbnMuc3VidGl0bGUsIHN1YnRpdGxlT3B0aW9ucyk7XG5cblx0XHRcdC8vIGFkZCB0aXRsZSBhbmQgc3VidGl0bGVcblx0XHRcdGVhY2goW1xuXHRcdFx0XHRbJ3RpdGxlJywgdGl0bGVPcHRpb25zLCBjaGFydFRpdGxlT3B0aW9uc10sXG5cdFx0XHRcdFsnc3VidGl0bGUnLCBzdWJ0aXRsZU9wdGlvbnMsIGNoYXJ0U3VidGl0bGVPcHRpb25zXVxuXHRcdFx0XSwgZnVuY3Rpb24gKGFycikge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGFyclswXSxcblx0XHRcdFx0XHR0aXRsZSA9IGNoYXJ0W25hbWVdLFxuXHRcdFx0XHRcdHRpdGxlT3B0aW9ucyA9IGFyclsxXSxcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucyA9IGFyclsyXTtcblxuXHRcdFx0XHRpZiAodGl0bGUgJiYgdGl0bGVPcHRpb25zKSB7XG5cdFx0XHRcdFx0Y2hhcnRbbmFtZV0gPSB0aXRsZSA9IHRpdGxlLmRlc3Ryb3koKTsgLy8gcmVtb3ZlIG9sZFxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2hhcnRUaXRsZU9wdGlvbnMgJiYgY2hhcnRUaXRsZU9wdGlvbnMudGV4dCAmJiAhdGl0bGUpIHtcblx0XHRcdFx0XHRjaGFydFtuYW1lXSA9IGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGFsaWduOiBjaGFydFRpdGxlT3B0aW9ucy5hbGlnbixcblx0XHRcdFx0XHRcdCdjbGFzcyc6IFBSRUZJWCArIG5hbWUsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IGNoYXJ0VGl0bGVPcHRpb25zLnpJbmRleCB8fCA0XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY3NzKGNoYXJ0VGl0bGVPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fVx0XG5cdFx0XHR9KTtcblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcyhyZWRyYXcpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMYXkgb3V0IHRoZSBjaGFydCB0aXRsZXMgYW5kIGNhY2hlIHRoZSBmdWxsIG9mZnNldCBoZWlnaHQgZm9yIHVzZSBpbiBnZXRNYXJnaW5zXG5cdFx0ICovXG5cdFx0bGF5T3V0VGl0bGVzOiBmdW5jdGlvbiAocmVkcmF3KSB7XG5cdFx0XHR2YXIgdGl0bGVPZmZzZXQgPSAwLFxuXHRcdFx0XHR0aXRsZSA9IHRoaXMudGl0bGUsXG5cdFx0XHRcdHN1YnRpdGxlID0gdGhpcy5zdWJ0aXRsZSxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSxcblx0XHRcdFx0c3VidGl0bGVPcHRpb25zID0gb3B0aW9ucy5zdWJ0aXRsZSxcblx0XHRcdFx0cmVxdWlyZXNEaXJ0eUJveCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRhdXRvV2lkdGggPSB0aGlzLnNwYWNpbmdCb3gud2lkdGggLSA0NDsgLy8gNDQgbWFrZXMgcm9vbSBmb3IgZGVmYXVsdCBjb250ZXh0IGJ1dHRvblxuXG5cdFx0XHRpZiAodGl0bGUpIHtcblx0XHRcdFx0dGl0bGVcblx0XHRcdFx0XHQuY3NzKHsgd2lkdGg6ICh0aXRsZU9wdGlvbnMud2lkdGggfHwgYXV0b1dpZHRoKSArIFBYIH0pXG5cdFx0XHRcdFx0LmFsaWduKGV4dGVuZCh7IFxuXHRcdFx0XHRcdFx0eTogcmVuZGVyZXIuZm9udE1ldHJpY3ModGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplLCB0aXRsZSkuYiAtIDNcblx0XHRcdFx0XHR9LCB0aXRsZU9wdGlvbnMpLCBmYWxzZSwgJ3NwYWNpbmdCb3gnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghdGl0bGVPcHRpb25zLmZsb2F0aW5nICYmICF0aXRsZU9wdGlvbnMudmVydGljYWxBbGlnbikge1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0ID0gdGl0bGUuZ2V0QkJveCgpLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHN1YnRpdGxlKSB7XG5cdFx0XHRcdHN1YnRpdGxlXG5cdFx0XHRcdFx0LmNzcyh7IHdpZHRoOiAoc3VidGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHRcdC5hbGlnbihleHRlbmQoeyBcblx0XHRcdFx0XHRcdHk6IHRpdGxlT2Zmc2V0ICsgKHRpdGxlT3B0aW9ucy5tYXJnaW4gLSAxMykgKyByZW5kZXJlci5mb250TWV0cmljcyh0aXRsZU9wdGlvbnMuc3R5bGUuZm9udFNpemUsIHN1YnRpdGxlKS5iIFxuXHRcdFx0XHRcdH0sIHN1YnRpdGxlT3B0aW9ucyksIGZhbHNlLCAnc3BhY2luZ0JveCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFzdWJ0aXRsZU9wdGlvbnMuZmxvYXRpbmcgJiYgIXN1YnRpdGxlT3B0aW9ucy52ZXJ0aWNhbEFsaWduKSB7XG5cdFx0XHRcdFx0dGl0bGVPZmZzZXQgPSBtYXRoQ2VpbCh0aXRsZU9mZnNldCArIHN1YnRpdGxlLmdldEJCb3goKS5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlcXVpcmVzRGlydHlCb3ggPSB0aGlzLnRpdGxlT2Zmc2V0ICE9PSB0aXRsZU9mZnNldDtcdFx0XHRcdFxuXHRcdFx0dGhpcy50aXRsZU9mZnNldCA9IHRpdGxlT2Zmc2V0OyAvLyB1c2VkIGluIGdldE1hcmdpbnNcblxuXHRcdFx0aWYgKCF0aGlzLmlzRGlydHlCb3ggJiYgcmVxdWlyZXNEaXJ0eUJveCkge1xuXHRcdFx0XHR0aGlzLmlzRGlydHlCb3ggPSByZXF1aXJlc0RpcnR5Qm94O1xuXHRcdFx0XHQvLyBSZWRyYXcgaWYgbmVjZXNzYXJ5ICgjMjcxOSwgIzI3NDQpXHRcdFxuXHRcdFx0XHRpZiAodGhpcy5oYXNSZW5kZXJlZCAmJiBwaWNrKHJlZHJhdywgdHJ1ZSkgJiYgdGhpcy5pc0RpcnR5Qm94KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgY2hhcnQgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gb3B0aW9ucyBhbmQgY29udGFpbmVyIHNpemVcblx0XHQgKi9cblx0XHRnZXRDaGFydFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHdpZHRoT3B0aW9uID0gb3B0aW9uc0NoYXJ0LndpZHRoLFxuXHRcdFx0XHRoZWlnaHRPcHRpb24gPSBvcHRpb25zQ2hhcnQuaGVpZ2h0LFxuXHRcdFx0XHRyZW5kZXJUbyA9IGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgY2hhcnQucmVuZGVyVG87XG5cblx0XHRcdC8vIGdldCBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0IGZyb20galF1ZXJ5ICgjODI0KVxuXHRcdFx0aWYgKCFkZWZpbmVkKHdpZHRoT3B0aW9uKSkge1xuXHRcdFx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICd3aWR0aCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFkZWZpbmVkKGhlaWdodE9wdGlvbikpIHtcblx0XHRcdFx0Y2hhcnQuY29udGFpbmVySGVpZ2h0ID0gYWRhcHRlclJ1bihyZW5kZXJUbywgJ2hlaWdodCcpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjaGFydC5jaGFydFdpZHRoID0gbWF0aE1heCgwLCB3aWR0aE9wdGlvbiB8fCBjaGFydC5jb250YWluZXJXaWR0aCB8fCA2MDApOyAvLyAjMTM5MywgMTQ2MFxuXHRcdFx0Y2hhcnQuY2hhcnRIZWlnaHQgPSBtYXRoTWF4KDAsIHBpY2soaGVpZ2h0T3B0aW9uLFxuXHRcdFx0XHQvLyB0aGUgb2Zmc2V0SGVpZ2h0IG9mIGFuIGVtcHR5IGNvbnRhaW5lciBpcyAwIGluIHN0YW5kYXJkIGJyb3dzZXJzLCBidXQgMTkgaW4gSUU3OlxuXHRcdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPiAxOSA/IGNoYXJ0LmNvbnRhaW5lckhlaWdodCA6IDQwMCkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY2hhcnQncyByZW5kZXJUbyBkaXYgYW5kIHBsYWNlIGl0IG91dHNpZGUgdGhlIHZpZXdwb3J0IHRvIGFsbG93XG5cdFx0ICogc2l6ZSBjb21wdXRhdGlvbiBvbiBjaGFydC5yZW5kZXIgYW5kIGNoYXJ0LnJlZHJhd1xuXHRcdCAqL1xuXHRcdGNsb25lUmVuZGVyVG86IGZ1bmN0aW9uIChyZXZlcnQpIHtcblx0XHRcdHZhciBjbG9uZSA9IHRoaXMucmVuZGVyVG9DbG9uZSxcblx0XHRcdFx0Y29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG5cdFx0XHRcblx0XHRcdC8vIERlc3Ryb3kgdGhlIGNsb25lIGFuZCBicmluZyB0aGUgY29udGFpbmVyIGJhY2sgdG8gdGhlIHJlYWwgcmVuZGVyVG8gZGl2XG5cdFx0XHRpZiAocmV2ZXJ0KSB7XG5cdFx0XHRcdGlmIChjbG9uZSkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyVG8uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdFx0XHRkaXNjYXJkRWxlbWVudChjbG9uZSk7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucmVuZGVyVG9DbG9uZTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTZXQgdXAgdGhlIGNsb25lXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLnJlbmRlclRvKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJUby5yZW1vdmVDaGlsZChjb250YWluZXIpOyAvLyBkbyBub3QgY2xvbmUgdGhpc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVuZGVyVG9DbG9uZSA9IGNsb25lID0gdGhpcy5yZW5kZXJUby5jbG9uZU5vZGUoMCk7XG5cdFx0XHRcdGNzcyhjbG9uZSwge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHR0b3A6ICctOTk5OXB4Jyxcblx0XHRcdFx0XHRkaXNwbGF5OiAnYmxvY2snIC8vICM4MzNcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSkgeyAvLyAjMjYzMVxuXHRcdFx0XHRcdGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvYy5ib2R5LmFwcGVuZENoaWxkKGNsb25lKTtcblx0XHRcdFx0aWYgKGNvbnRhaW5lcikge1xuXHRcdFx0XHRcdGNsb25lLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBjb250YWluaW5nIGVsZW1lbnQsIGRldGVybWluZSB0aGUgc2l6ZSBhbmQgY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHQgKiBkaXYgdG8gaG9sZCB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGNvbnRhaW5lcixcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQsXG5cdFx0XHRcdHJlbmRlclRvLFxuXHRcdFx0XHRpbmRleEF0dHJOYW1lID0gJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcsXG5cdFx0XHRcdG9sZENoYXJ0SW5kZXgsXG5cdFx0XHRcdGNvbnRhaW5lcklkO1xuXG5cdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gb3B0aW9uc0NoYXJ0LnJlbmRlclRvO1xuXHRcdFx0Y29udGFpbmVySWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKztcblxuXHRcdFx0aWYgKGlzU3RyaW5nKHJlbmRlclRvKSkge1xuXHRcdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gZG9jLmdldEVsZW1lbnRCeUlkKHJlbmRlclRvKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRGlzcGxheSBhbiBlcnJvciBpZiB0aGUgcmVuZGVyVG8gaXMgd3Jvbmdcblx0XHRcdGlmICghcmVuZGVyVG8pIHtcblx0XHRcdFx0ZXJyb3IoMTMsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIGFscmVhZHkgaG9sZHMgYSBjaGFydCwgZGVzdHJveSBpdC4gVGhlIGNoZWNrIGZvciBoYXNSZW5kZXJlZCBpcyB0aGVyZVxuXHRcdFx0Ly8gYmVjYXVzZSB3ZWIgcGFnZXMgdGhhdCBhcmUgc2F2ZWQgdG8gZGlzayBmcm9tIHRoZSBicm93c2VyLCB3aWxsIHByZXNlcnZlIHRoZSBkYXRhLWhpZ2hjaGFydHMtY2hhcnRcblx0XHRcdC8vIGF0dHJpYnV0ZSBhbmQgdGhlIFNWRyBjb250ZW50cywgYnV0IG5vdCBhbiBpbnRlcmFjdGl2ZSBjaGFydC4gU28gaW4gdGhpcyBjYXNlLFxuXHRcdFx0Ly8gY2hhcnRzW29sZENoYXJ0SW5kZXhdIHdpbGwgcG9pbnQgdG8gdGhlIHdyb25nIGNoYXJ0IGlmIGFueSAoIzI2MDkpLlxuXHRcdFx0b2xkQ2hhcnRJbmRleCA9IHBJbnQoYXR0cihyZW5kZXJUbywgaW5kZXhBdHRyTmFtZSkpO1xuXHRcdFx0aWYgKCFpc05hTihvbGRDaGFydEluZGV4KSAmJiBjaGFydHNbb2xkQ2hhcnRJbmRleF0gJiYgY2hhcnRzW29sZENoYXJ0SW5kZXhdLmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGNoYXJ0c1tvbGRDaGFydEluZGV4XS5kZXN0cm95KCk7XG5cdFx0XHR9XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBNYWtlIGEgcmVmZXJlbmNlIHRvIHRoZSBjaGFydCBmcm9tIHRoZSBkaXZcblx0XHRcdGF0dHIocmVuZGVyVG8sIGluZGV4QXR0ck5hbWUsIGNoYXJ0LmluZGV4KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIHByZXZpb3VzIGNoYXJ0XG5cdFx0XHRyZW5kZXJUby5pbm5lckhUTUwgPSAnJztcblxuXHRcdFx0Ly8gSWYgdGhlIGNvbnRhaW5lciBkb2Vzbid0IGhhdmUgYW4gb2Zmc2V0V2lkdGgsIGl0IGhhcyBvciBpcyBhIGNoaWxkIG9mIGEgbm9kZVxuXHRcdFx0Ly8gdGhhdCBoYXMgZGlzcGxheTpub25lLiBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IG1vdmUgaXQgb3V0IHRvIGEgdmlzaWJsZVxuXHRcdFx0Ly8gc3RhdGUgdG8gZGV0ZXJtaW5lIHRoZSBzaXplLCBlbHNlIHRoZSBsZWdlbmQgYW5kIHRvb2x0aXBzIHdvbid0IHJlbmRlclxuXHRcdFx0Ly8gcHJvcGVybHkuIFRoZSBhbGxvd0Nsb25lIG9wdGlvbiBpcyB1c2VkIGluIHNwYXJrbGluZXMgYXMgYSBtaWNybyBvcHRpbWl6YXRpb24sXG5cdFx0XHQvLyBzYXZpbmcgYWJvdXQgMS0yIG1zIGVhY2ggY2hhcnQuXG5cdFx0XHRpZiAoIW9wdGlvbnNDaGFydC5za2lwQ2xvbmUgJiYgIXJlbmRlclRvLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0XHRjaGFydC5nZXRDaGFydFNpemUoKTtcblx0XHRcdGNoYXJ0V2lkdGggPSBjaGFydC5jaGFydFdpZHRoO1xuXHRcdFx0Y2hhcnRIZWlnaHQgPSBjaGFydC5jaGFydEhlaWdodDtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHRcdGNoYXJ0LmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoRElWLCB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lOiBQUkVGSVggKyAnY29udGFpbmVyJyArXG5cdFx0XHRcdFx0XHQob3B0aW9uc0NoYXJ0LmNsYXNzTmFtZSA/ICcgJyArIG9wdGlvbnNDaGFydC5jbGFzc05hbWUgOiAnJyksXG5cdFx0XHRcdFx0aWQ6IGNvbnRhaW5lcklkXG5cdFx0XHRcdH0sIGV4dGVuZCh7XG5cdFx0XHRcdFx0cG9zaXRpb246IFJFTEFUSVZFLFxuXHRcdFx0XHRcdG92ZXJmbG93OiBISURERU4sIC8vIG5lZWRlZCBmb3IgY29udGV4dCBtZW51IChhdm9pZCBzY3JvbGxiYXJzKSBhbmRcblx0XHRcdFx0XHRcdC8vIGNvbnRlbnQgb3ZlcmZsb3cgaW4gSUVcblx0XHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCArIFBYLFxuXHRcdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgKyBQWCxcblx0XHRcdFx0XHR0ZXh0QWxpZ246ICdsZWZ0Jyxcblx0XHRcdFx0XHRsaW5lSGVpZ2h0OiAnbm9ybWFsJywgLy8gIzQyN1xuXHRcdFx0XHRcdHpJbmRleDogMCwgLy8gIzEwNzJcblx0XHRcdFx0XHQnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknXG5cdFx0XHRcdH0sIG9wdGlvbnNDaGFydC5zdHlsZSksXG5cdFx0XHRcdGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgcmVuZGVyVG9cblx0XHRcdCk7XG5cblx0XHRcdC8vIGNhY2hlIHRoZSBjdXJzb3IgKCMxNjUwKVxuXHRcdFx0Y2hhcnQuX2N1cnNvciA9IGNvbnRhaW5lci5zdHlsZS5jdXJzb3I7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGhlIHJlbmRlcmVyXG5cdFx0XHRjaGFydC5yZW5kZXJlciA9XG5cdFx0XHRcdG9wdGlvbnNDaGFydC5mb3JFeHBvcnQgPyAvLyBmb3JjZSBTVkcsIHVzZWQgZm9yIFNWRyBleHBvcnRcblx0XHRcdFx0XHRuZXcgU1ZHUmVuZGVyZXIoY29udGFpbmVyLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgb3B0aW9uc0NoYXJ0LnN0eWxlLCB0cnVlKSA6XG5cdFx0XHRcdFx0bmV3IFJlbmRlcmVyKGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG9wdGlvbnNDaGFydC5zdHlsZSk7XG5cblx0XHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0XHQvLyBJZiB3ZSBuZWVkIGNhbnZnIGxpYnJhcnksIGV4dGVuZCBhbmQgY29uZmlndXJlIHRoZSByZW5kZXJlclxuXHRcdFx0XHQvLyB0byBnZXQgdGhlIHRyYWNrZXIgZm9yIHRyYW5zbGF0aW5nIG1vdXNlIGV2ZW50c1xuXHRcdFx0XHRjaGFydC5yZW5kZXJlci5jcmVhdGUoY2hhcnQsIGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIGEgcmVmZXJlbmNlIHRvIHRoZSBjaGFydHMgaW5kZXhcblx0XHRcdGNoYXJ0LnJlbmRlcmVyLmNoYXJ0SW5kZXggPSBjaGFydC5pbmRleDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlIG1hcmdpbnMgYnkgcmVuZGVyaW5nIGF4aXMgbGFiZWxzIGluIGEgcHJlbGltaW5hcnkgcG9zaXRpb24uIFRpdGxlLFxuXHRcdCAqIHN1YnRpdGxlIGFuZCBsZWdlbmQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgYXQgdGhpcyBzdGFnZSwgYnV0IHdpbGwgYmVcblx0XHQgKiBtb3ZlZCBpbnRvIHRoZWlyIGZpbmFsIHBvc2l0aW9uc1xuXHRcdCAqL1xuXHRcdGdldE1hcmdpbnM6IGZ1bmN0aW9uIChza2lwQXhlcykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRcdG1hcmdpbiA9IGNoYXJ0Lm1hcmdpbixcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSBjaGFydC50aXRsZU9mZnNldDtcblxuXHRcdFx0Y2hhcnQucmVzZXRNYXJnaW5zKCk7XG5cblx0XHRcdC8vIEFkanVzdCBmb3IgdGl0bGUgYW5kIHN1YnRpdGxlXG5cdFx0XHRpZiAodGl0bGVPZmZzZXQgJiYgIWRlZmluZWQobWFyZ2luWzBdKSkge1xuXHRcdFx0XHRjaGFydC5wbG90VG9wID0gbWF0aE1heChjaGFydC5wbG90VG9wLCB0aXRsZU9mZnNldCArIGNoYXJ0Lm9wdGlvbnMudGl0bGUubWFyZ2luICsgc3BhY2luZ1swXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEFkanVzdCBmb3IgbGVnZW5kXG5cdFx0XHRjaGFydC5sZWdlbmQuYWRqdXN0TWFyZ2lucyhtYXJnaW4sIHNwYWNpbmcpO1xuXG5cdFx0XHQvLyBhZGp1c3QgZm9yIHNjcm9sbGVyXG5cdFx0XHRpZiAoY2hhcnQuZXh0cmFCb3R0b21NYXJnaW4pIHtcblx0XHRcdFx0Y2hhcnQubWFyZ2luQm90dG9tICs9IGNoYXJ0LmV4dHJhQm90dG9tTWFyZ2luO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYXJ0LmV4dHJhVG9wTWFyZ2luKSB7XG5cdFx0XHRcdGNoYXJ0LnBsb3RUb3AgKz0gY2hhcnQuZXh0cmFUb3BNYXJnaW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXNraXBBeGVzKSB7XG5cdFx0XHRcdHRoaXMuZ2V0QXhpc01hcmdpbnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0QXhpc01hcmdpbnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0YXhpc09mZnNldCA9IGNoYXJ0LmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF0sIC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW47XG5cdFx0XHRcblx0XHRcdC8vIHByZS1yZW5kZXIgYXhlcyB0byBnZXQgbGFiZWxzIG9mZnNldCB3aWR0aFxuXHRcdFx0aWYgKGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5nZXRPZmZzZXQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgYXhpcyBvZmZzZXRzXG5cdFx0XHRlYWNoKG1hcmdpbk5hbWVzLCBmdW5jdGlvbiAobSwgc2lkZSkge1xuXHRcdFx0XHRpZiAoIWRlZmluZWQobWFyZ2luW3NpZGVdKSkge1xuXHRcdFx0XHRcdGNoYXJ0W21dICs9IGF4aXNPZmZzZXRbc2lkZV07XG5cdFx0XHRcdH1cdFx0XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIGlmIHNpemUgaXMgbm90IGV4cGxpY2l0bHkgc2V0XG5cdFx0ICovXG5cdFx0cmVmbG93OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0cmVuZGVyVG8gPSBjaGFydC5yZW5kZXJUbyxcblx0XHRcdFx0d2lkdGggPSBvcHRpb25zQ2hhcnQud2lkdGggfHwgYWRhcHRlclJ1bihyZW5kZXJUbywgJ3dpZHRoJyksXG5cdFx0XHRcdGhlaWdodCA9IG9wdGlvbnNDaGFydC5oZWlnaHQgfHwgYWRhcHRlclJ1bihyZW5kZXJUbywgJ2hlaWdodCcpLFxuXHRcdFx0XHR0YXJnZXQgPSBlID8gZS50YXJnZXQgOiB3aW4sIC8vICM4MDUgLSBNb29Ub29scyBkb2Vzbid0IHN1cHBseSBlXG5cdFx0XHRcdGRvUmVmbG93ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChjaGFydC5jb250YWluZXIpIHsgLy8gSXQgbWF5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaW4gdGhlIG1lYW50aW1lICgjMTI1Nylcblx0XHRcdFx0XHRcdGNoYXJ0LnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0Y2hhcnQuaGFzVXNlclNpemUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IGNoZWNrcyBmb3IgZGlzcGxheTpub25lLiBUYXJnZXQgaXMgZG9jIGluIElFOCBhbmQgT3BlcmEsXG5cdFx0XHQvLyB3aW4gaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBJRTkuXG5cdFx0XHRpZiAoIWNoYXJ0Lmhhc1VzZXJTaXplICYmICFjaGFydC5pc1ByaW50aW5nICYmIHdpZHRoICYmIGhlaWdodCAmJiAodGFyZ2V0ID09PSB3aW4gfHwgdGFyZ2V0ID09PSBkb2MpKSB7IC8vICMxMDkzXG5cdFx0XHRcdGlmICh3aWR0aCAhPT0gY2hhcnQuY29udGFpbmVyV2lkdGggfHwgaGVpZ2h0ICE9PSBjaGFydC5jb250YWluZXJIZWlnaHQpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoY2hhcnQucmVmbG93VGltZW91dCk7XG5cdFx0XHRcdFx0aWYgKGUpIHsgLy8gQ2FsbGVkIGZyb20gd2luZG93LnJlc2l6ZVxuXHRcdFx0XHRcdFx0Y2hhcnQucmVmbG93VGltZW91dCA9IHNldFRpbWVvdXQoZG9SZWZsb3csIDEwMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy8gQ2FsbGVkIGRpcmVjdGx5ICgjMjIyNClcblx0XHRcdFx0XHRcdGRvUmVmbG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYXJ0LmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG5cdFx0XHRcdGNoYXJ0LmNvbnRhaW5lckhlaWdodCA9IGhlaWdodDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBldmVudCBoYW5kbGVycyBuZWNlc3NhcnkgZm9yIGF1dG8gcmVzaXppbmdcblx0XHQgKi9cblx0XHRpbml0UmVmbG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRyZWZsb3cgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZmxvdyhlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcblx0XHRcdGFkZEV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlZmxvdyk7XG5cdFx0XHRhZGRFdmVudChjaGFydCwgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlZmxvdyk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBjaGFydCB0byBhIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R8Qm9vbGVhbn0gYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQsXG5cdFx0XHRcdGZpcmVFbmRSZXNpemU7XG5cblx0XHRcdC8vIEhhbmRsZSB0aGUgaXNSZXNpemluZyBjb3VudGVyXG5cdFx0XHRjaGFydC5pc1Jlc2l6aW5nICs9IDE7XG5cdFx0XHRmaXJlRW5kUmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY2hhcnQpIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdlbmRSZXNpemUnLCBudWxsLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRjaGFydC5pc1Jlc2l6aW5nIC09IDE7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHNldCB0aGUgYW5pbWF0aW9uIGZvciB0aGUgY3VycmVudCBwcm9jZXNzXG5cdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHRcdGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQ7XG5cdFx0XHRjaGFydC5vbGRDaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aDtcblx0XHRcdGlmIChkZWZpbmVkKHdpZHRoKSkge1xuXHRcdFx0XHRjaGFydC5jaGFydFdpZHRoID0gY2hhcnRXaWR0aCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKHdpZHRoKSk7XG5cdFx0XHRcdGNoYXJ0Lmhhc1VzZXJTaXplID0gISFjaGFydFdpZHRoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlZmluZWQoaGVpZ2h0KSkge1xuXHRcdFx0XHRjaGFydC5jaGFydEhlaWdodCA9IGNoYXJ0SGVpZ2h0ID0gbWF0aE1heCgwLCBtYXRoUm91bmQoaGVpZ2h0KSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2l6ZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIGdsb2JhbCBhbmltYXRpb24gYXBwbGllZCBpZiBlbmFibGVkICgjMjUwMylcblx0XHRcdChnbG9iYWxBbmltYXRpb24gPyBhbmltYXRlIDogY3NzKShjaGFydC5jb250YWluZXIsIHtcblx0XHRcdFx0d2lkdGg6IGNoYXJ0V2lkdGggKyBQWCxcblx0XHRcdFx0aGVpZ2h0OiBjaGFydEhlaWdodCArIFBYXG5cdFx0XHR9LCBnbG9iYWxBbmltYXRpb24pO1xuXG5cdFx0XHRjaGFydC5zZXRDaGFydFNpemUodHJ1ZSk7XG5cdFx0XHRjaGFydC5yZW5kZXJlci5zZXRTaXplKGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBhbmltYXRpb24pO1xuXG5cdFx0XHQvLyBoYW5kbGUgYXhlc1xuXHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIG5vbi1jYXJ0ZXNpYW4gc2VyaWVzIGFyZSBhbHNvIGhhbmRsZWRcblx0XHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0c2VyaWUuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IHRydWU7IC8vIGZvcmNlIGxlZ2VuZCByZWRyYXdcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlOyAvLyBmb3JjZSByZWRyYXcgb2YgcGxvdCBhbmQgY2hhcnQgYm9yZGVyXG5cblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcygpOyAvLyAjMjg1N1xuXHRcdFx0Y2hhcnQuZ2V0TWFyZ2lucygpO1xuXG5cdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblxuXG5cdFx0XHRjaGFydC5vbGRDaGFydEhlaWdodCA9IG51bGw7XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdyZXNpemUnKTtcblxuXHRcdFx0Ly8gZmlyZSBlbmRSZXNpemUgYW5kIHNldCBpc1Jlc2l6aW5nIGJhY2tcblx0XHRcdC8vIElmIGFuaW1hdGlvbiBpcyBkaXNhYmxlZCwgZmlyZSB3aXRob3V0IGRlbGF5XG5cdFx0XHRpZiAoZ2xvYmFsQW5pbWF0aW9uID09PSBmYWxzZSkge1xuXHRcdFx0XHRmaXJlRW5kUmVzaXplKCk7XG5cdFx0XHR9IGVsc2UgeyAvLyBlbHNlIHNldCBhIHRpbWVvdXQgd2l0aCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0XHRcdHNldFRpbWVvdXQoZmlyZUVuZFJlc2l6ZSwgKGdsb2JhbEFuaW1hdGlvbiAmJiBnbG9iYWxBbmltYXRpb24uZHVyYXRpb24pIHx8IDUwMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcHVibGljIGNoYXJ0IHByb3BlcnRpZXMuIFRoaXMgaXMgZG9uZSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBwcmUtcmVuZGVyXG5cdFx0ICogdG8gZGV0ZXJtaW5lIG1hcmdpbiBzaXplc1xuXHRcdCAqL1xuXHRcdHNldENoYXJ0U2l6ZTogZnVuY3Rpb24gKHNraXBBeGVzKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQgPSBjaGFydC5jaGFydEhlaWdodCxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRcdGNsaXBPZmZzZXQgPSBjaGFydC5jbGlwT2Zmc2V0LFxuXHRcdFx0XHRjbGlwWCxcblx0XHRcdFx0Y2xpcFksXG5cdFx0XHRcdHBsb3RMZWZ0LFxuXHRcdFx0XHRwbG90VG9wLFxuXHRcdFx0XHRwbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQsXG5cdFx0XHRcdHBsb3RCb3JkZXJXaWR0aDtcblxuXHRcdFx0Y2hhcnQucGxvdExlZnQgPSBwbG90TGVmdCA9IG1hdGhSb3VuZChjaGFydC5wbG90TGVmdCk7XG5cdFx0XHRjaGFydC5wbG90VG9wID0gcGxvdFRvcCA9IG1hdGhSb3VuZChjaGFydC5wbG90VG9wKTtcblx0XHRcdGNoYXJ0LnBsb3RXaWR0aCA9IHBsb3RXaWR0aCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGNoYXJ0V2lkdGggLSBwbG90TGVmdCAtIGNoYXJ0Lm1hcmdpblJpZ2h0KSk7XG5cdFx0XHRjaGFydC5wbG90SGVpZ2h0ID0gcGxvdEhlaWdodCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGNoYXJ0SGVpZ2h0IC0gcGxvdFRvcCAtIGNoYXJ0Lm1hcmdpbkJvdHRvbSkpO1xuXG5cdFx0XHRjaGFydC5wbG90U2l6ZVggPSBpbnZlcnRlZCA/IHBsb3RIZWlnaHQgOiBwbG90V2lkdGg7XG5cdFx0XHRjaGFydC5wbG90U2l6ZVkgPSBpbnZlcnRlZCA/IHBsb3RXaWR0aCA6IHBsb3RIZWlnaHQ7XG5cdFx0XHRcblx0XHRcdGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyV2lkdGggfHwgMDtcblxuXHRcdFx0Ly8gU2V0IGJveGVzIHVzZWQgZm9yIGFsaWdubWVudFxuXHRcdFx0Y2hhcnQuc3BhY2luZ0JveCA9IHJlbmRlcmVyLnNwYWNpbmdCb3ggPSB7XG5cdFx0XHRcdHg6IHNwYWNpbmdbM10sXG5cdFx0XHRcdHk6IHNwYWNpbmdbMF0sXG5cdFx0XHRcdHdpZHRoOiBjaGFydFdpZHRoIC0gc3BhY2luZ1szXSAtIHNwYWNpbmdbMV0sXG5cdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgLSBzcGFjaW5nWzBdIC0gc3BhY2luZ1syXVxuXHRcdFx0fTtcblx0XHRcdGNoYXJ0LnBsb3RCb3ggPSByZW5kZXJlci5wbG90Qm94ID0ge1xuXHRcdFx0XHR4OiBwbG90TGVmdCxcblx0XHRcdFx0eTogcGxvdFRvcCxcblx0XHRcdFx0d2lkdGg6IHBsb3RXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBwbG90SGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0XHRwbG90Qm9yZGVyV2lkdGggPSAyICogbWF0aEZsb29yKGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCAvIDIpO1xuXHRcdFx0Y2xpcFggPSBtYXRoQ2VpbChtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFszXSkgLyAyKTtcblx0XHRcdGNsaXBZID0gbWF0aENlaWwobWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbMF0pIC8gMik7XG5cdFx0XHRjaGFydC5jbGlwQm94ID0ge1xuXHRcdFx0XHR4OiBjbGlwWCwgXG5cdFx0XHRcdHk6IGNsaXBZLCBcblx0XHRcdFx0d2lkdGg6IG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVggLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsxXSkgLyAyIC0gY2xpcFgpLCBcblx0XHRcdFx0aGVpZ2h0OiBtYXRoTWF4KDAsIG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVkgLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsyXSkgLyAyIC0gY2xpcFkpKVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFza2lwQXhlcykge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5zZXRBeGlzU2l6ZSgpO1xuXHRcdFx0XHRcdGF4aXMuc2V0QXhpc1RyYW5zbGF0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsIG1hcmdpbnMgYmVmb3JlIGF1dG8gc2l6ZSBtYXJnaW5zIGFyZSBhcHBsaWVkXG5cdFx0ICovXG5cdFx0cmVzZXRNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdFx0XHRlYWNoKG1hcmdpbk5hbWVzLCBmdW5jdGlvbiAobSwgc2lkZSkge1xuXHRcdFx0XHRjaGFydFttXSA9IHBpY2soY2hhcnQubWFyZ2luW3NpZGVdLCBjaGFydC5zcGFjaW5nW3NpZGVdKTtcblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQuYXhpc09mZnNldCA9IFswLCAwLCAwLCAwXTsgLy8gdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XG5cdFx0XHRjaGFydC5jbGlwT2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBib3JkZXJzIGFuZCBiYWNrZ3JvdW5kcyBmb3IgY2hhcnQgYW5kIHBsb3QgYXJlYVxuXHRcdCAqL1xuXHRcdGRyYXdDaGFydEJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0Y2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRcdGNoYXJ0QmFja2dyb3VuZCA9IGNoYXJ0LmNoYXJ0QmFja2dyb3VuZCxcblx0XHRcdFx0cGxvdEJhY2tncm91bmQgPSBjaGFydC5wbG90QmFja2dyb3VuZCxcblx0XHRcdFx0cGxvdEJvcmRlciA9IGNoYXJ0LnBsb3RCb3JkZXIsXG5cdFx0XHRcdHBsb3RCR0ltYWdlID0gY2hhcnQucGxvdEJHSW1hZ2UsXG5cdFx0XHRcdGNoYXJ0Qm9yZGVyV2lkdGggPSBvcHRpb25zQ2hhcnQuYm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zQ2hhcnQuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRwbG90QmFja2dyb3VuZENvbG9yID0gb3B0aW9uc0NoYXJ0LnBsb3RCYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdHBsb3RCYWNrZ3JvdW5kSW1hZ2UgPSBvcHRpb25zQ2hhcnQucGxvdEJhY2tncm91bmRJbWFnZSxcblx0XHRcdFx0cGxvdEJvcmRlcldpZHRoID0gb3B0aW9uc0NoYXJ0LnBsb3RCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0XHRtZ24sXG5cdFx0XHRcdGJnQXR0cixcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRcdHBsb3RCb3ggPSBjaGFydC5wbG90Qm94LFxuXHRcdFx0XHRjbGlwUmVjdCA9IGNoYXJ0LmNsaXBSZWN0LFxuXHRcdFx0XHRjbGlwQm94ID0gY2hhcnQuY2xpcEJveDtcblxuXHRcdFx0Ly8gQ2hhcnQgYXJlYVxuXHRcdFx0bWduID0gY2hhcnRCb3JkZXJXaWR0aCArIChvcHRpb25zQ2hhcnQuc2hhZG93ID8gOCA6IDApO1xuXG5cdFx0XHRpZiAoY2hhcnRCb3JkZXJXaWR0aCB8fCBjaGFydEJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRpZiAoIWNoYXJ0QmFja2dyb3VuZCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGJnQXR0ciA9IHtcblx0XHRcdFx0XHRcdGZpbGw6IGNoYXJ0QmFja2dyb3VuZENvbG9yIHx8IE5PTkVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChjaGFydEJvcmRlcldpZHRoKSB7IC8vICM5ODBcblx0XHRcdFx0XHRcdGJnQXR0ci5zdHJva2UgPSBvcHRpb25zQ2hhcnQuYm9yZGVyQ29sb3I7XG5cdFx0XHRcdFx0XHRiZ0F0dHJbJ3N0cm9rZS13aWR0aCddID0gY2hhcnRCb3JkZXJXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hhcnQuY2hhcnRCYWNrZ3JvdW5kID0gcmVuZGVyZXIucmVjdChtZ24gLyAyLCBtZ24gLyAyLCBjaGFydFdpZHRoIC0gbWduLCBjaGFydEhlaWdodCAtIG1nbixcblx0XHRcdFx0XHRcdFx0b3B0aW9uc0NoYXJ0LmJvcmRlclJhZGl1cywgY2hhcnRCb3JkZXJXaWR0aClcblx0XHRcdFx0XHRcdC5hdHRyKGJnQXR0cilcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyAnYmFja2dyb3VuZCcpXG5cdFx0XHRcdFx0XHQuYWRkKClcblx0XHRcdFx0XHRcdC5zaGFkb3cob3B0aW9uc0NoYXJ0LnNoYWRvdyk7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gcmVzaXplXG5cdFx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmFuaW1hdGUoXG5cdFx0XHRcdFx0XHRjaGFydEJhY2tncm91bmQuY3Jpc3AoeyB3aWR0aDogY2hhcnRXaWR0aCAtIG1nbiwgaGVpZ2h0OiBjaGFydEhlaWdodCAtIG1nbiB9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBQbG90IGJhY2tncm91bmRcblx0XHRcdGlmIChwbG90QmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRcdGlmICghcGxvdEJhY2tncm91bmQpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90QmFja2dyb3VuZCA9IHJlbmRlcmVyLnJlY3QocGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodCwgMClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogcGxvdEJhY2tncm91bmRDb2xvclxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zQ2hhcnQucGxvdFNoYWRvdyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGxvdEJhY2tncm91bmQuYW5pbWF0ZShwbG90Qm94KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBsb3RCYWNrZ3JvdW5kSW1hZ2UpIHtcblx0XHRcdFx0aWYgKCFwbG90QkdJbWFnZSkge1xuXHRcdFx0XHRcdGNoYXJ0LnBsb3RCR0ltYWdlID0gcmVuZGVyZXIuaW1hZ2UocGxvdEJhY2tncm91bmRJbWFnZSwgcGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodClcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbG90QkdJbWFnZS5hbmltYXRlKHBsb3RCb3gpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFBsb3QgY2xpcFxuXHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXHRcdFx0XHRjaGFydC5jbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KGNsaXBCb3gpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xpcFJlY3QuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0d2lkdGg6IGNsaXBCb3gud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBjbGlwQm94LmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGxvdCBhcmVhIGJvcmRlclxuXHRcdFx0aWYgKHBsb3RCb3JkZXJXaWR0aCkge1xuXHRcdFx0XHRpZiAoIXBsb3RCb3JkZXIpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90Qm9yZGVyID0gcmVuZGVyZXIucmVjdChwbG90TGVmdCwgcGxvdFRvcCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCAwLCAtcGxvdEJvcmRlcldpZHRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBwbG90Qm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGZpbGw6IE5PTkUsXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogMVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbG90Qm9yZGVyLmFuaW1hdGUoXG5cdFx0XHRcdFx0XHRwbG90Qm9yZGVyLmNyaXNwKHsgeDogcGxvdExlZnQsIHk6IHBsb3RUb3AsIHdpZHRoOiBwbG90V2lkdGgsIGhlaWdodDogcGxvdEhlaWdodCwgc3Ryb2tlV2lkdGg6IC1wbG90Qm9yZGVyV2lkdGggfSkgLy8jMzI4MiBwbG90Qm9yZGVyIHNob3VsZCBiZSBuZWdhdGl2ZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzZXRcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZWN0IHdoZXRoZXIgYSBjZXJ0YWluIGNoYXJ0IHByb3BlcnR5IGlzIG5lZWRlZCBiYXNlZCBvbiBpbnNwZWN0aW5nIGl0cyBvcHRpb25zXG5cdFx0ICogYW5kIHNlcmllcy4gVGhpcyBtYWlubHkgYXBwbGllcyB0byB0aGUgY2hhcnQuaW52ZXJ0IHByb3BlcnR5LCBhbmQgaW4gZXh0ZW5zaW9ucyB0byBcblx0XHQgKiB0aGUgY2hhcnQuYW5ndWxhciBhbmQgY2hhcnQucG9sYXIgcHJvcGVydGllcy5cblx0XHQgKi9cblx0XHRwcm9wRnJvbVNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0a2xhc3MsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBjaGFydC5vcHRpb25zLnNlcmllcyxcblx0XHRcdFx0aSxcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdGVhY2goWydpbnZlcnRlZCcsICdhbmd1bGFyJywgJ3BvbGFyJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBkZWZhdWx0IHNlcmllcyB0eXBlJ3MgY2xhc3Ncblx0XHRcdFx0a2xhc3MgPSBzZXJpZXNUeXBlc1tvcHRpb25zQ2hhcnQudHlwZSB8fCBvcHRpb25zQ2hhcnQuZGVmYXVsdFNlcmllc1R5cGVdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gR2V0IHRoZSB2YWx1ZSBmcm9tIGF2YWlsYWJsZSBjaGFydC13aWRlIHByb3BlcnRpZXNcblx0XHRcdFx0dmFsdWUgPSAoXG5cdFx0XHRcdFx0Y2hhcnRba2V5XSB8fCAvLyAxLiBpdCBpcyBzZXQgYmVmb3JlXG5cdFx0XHRcdFx0b3B0aW9uc0NoYXJ0W2tleV0gfHwgLy8gMi4gaXQgaXMgc2V0IGluIHRoZSBvcHRpb25zXG5cdFx0XHRcdFx0KGtsYXNzICYmIGtsYXNzLnByb3RvdHlwZVtrZXldKSAvLyAzLiBpdCdzIGRlZmF1bHQgc2VyaWVzIGNsYXNzIHJlcXVpcmVzIGl0XG5cdFx0XHRcdCk7XG5cdFx0XG5cdFx0XHRcdC8vIDQuIENoZWNrIGlmIGFueSB0aGUgY2hhcnQncyBzZXJpZXMgcmVxdWlyZSBpdFxuXHRcdFx0XHRpID0gc2VyaWVzT3B0aW9ucyAmJiBzZXJpZXNPcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCF2YWx1ZSAmJiBpLS0pIHtcblx0XHRcdFx0XHRrbGFzcyA9IHNlcmllc1R5cGVzW3Nlcmllc09wdGlvbnNbaV0udHlwZV07XG5cdFx0XHRcdFx0aWYgKGtsYXNzICYmIGtsYXNzLnByb3RvdHlwZVtrZXldKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdC8vIFNldCB0aGUgY2hhcnQgcHJvcGVydHlcblx0XHRcdFx0Y2hhcnRba2V5XSA9IHZhbHVlO1x0XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMaW5rIHR3byBvciBtb3JlIHNlcmllcyB0b2dldGhlci4gVGhpcyBpcyBkb25lIGluaXRpYWxseSBmcm9tIENoYXJ0LnJlbmRlcixcblx0XHQgKiBhbmQgYWZ0ZXIgQ2hhcnQuYWRkU2VyaWVzIGFuZCBTZXJpZXMucmVtb3ZlLlxuXHRcdCAqL1xuXHRcdGxpbmtTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzO1xuXG5cdFx0XHQvLyBSZXNldCBsaW5rc1xuXHRcdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMubGlua2VkU2VyaWVzLmxlbmd0aCA9IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgbmV3IGxpbmtzXG5cdFx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdHZhciBsaW5rZWRUbyA9IHNlcmllcy5vcHRpb25zLmxpbmtlZFRvO1xuXHRcdFx0XHRpZiAoaXNTdHJpbmcobGlua2VkVG8pKSB7XG5cdFx0XHRcdFx0aWYgKGxpbmtlZFRvID09PSAnOnByZXZpb3VzJykge1xuXHRcdFx0XHRcdFx0bGlua2VkVG8gPSBjaGFydC5zZXJpZXNbc2VyaWVzLmluZGV4IC0gMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuZ2V0KGxpbmtlZFRvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxpbmtlZFRvKSB7XG5cdFx0XHRcdFx0XHRsaW5rZWRUby5saW5rZWRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdFx0XHRcdFx0c2VyaWVzLmxpbmtlZFBhcmVudCA9IGxpbmtlZFRvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciBzZXJpZXMgZm9yIHRoZSBjaGFydFxuXHRcdCAqL1xuXHRcdHJlbmRlclNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdHNlcmllLnRyYW5zbGF0ZSgpO1xuXHRcdFx0XHRzZXJpZS5yZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XHRcblx0XHQvKipcblx0XHQgKiBSZW5kZXIgbGFiZWxzIGZvciB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRyZW5kZXJMYWJlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGxhYmVscyA9IGNoYXJ0Lm9wdGlvbnMubGFiZWxzO1xuXHRcdFx0aWYgKGxhYmVscy5pdGVtcykge1xuXHRcdFx0XHRlYWNoKGxhYmVscy5pdGVtcywgZnVuY3Rpb24gKGxhYmVsKSB7XG5cdFx0XHRcdFx0dmFyIHN0eWxlID0gZXh0ZW5kKGxhYmVscy5zdHlsZSwgbGFiZWwuc3R5bGUpLFxuXHRcdFx0XHRcdFx0eCA9IHBJbnQoc3R5bGUubGVmdCkgKyBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHRcdHkgPSBwSW50KHN0eWxlLnRvcCkgKyBjaGFydC5wbG90VG9wICsgMTI7XG5cblx0XHRcdFx0XHQvLyBkZWxldGUgdG8gcHJldmVudCByZXdyaXRpbmcgaW4gSUVcblx0XHRcdFx0XHRkZWxldGUgc3R5bGUubGVmdDtcblx0XHRcdFx0XHRkZWxldGUgc3R5bGUudG9wO1xuXG5cdFx0XHRcdFx0Y2hhcnQucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRcdGxhYmVsLmh0bWwsXG5cdFx0XHRcdFx0XHR4LFxuXHRcdFx0XHRcdFx0eVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMiB9KVxuXHRcdFx0XHRcdC5jc3Moc3R5bGUpXG5cdFx0XHRcdFx0LmFkZCgpO1xuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgYWxsIGdyYXBoaWNzIGZvciB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0dGVtcFdpZHRoLFxuXHRcdFx0XHR0ZW1wSGVpZ2h0LFxuXHRcdFx0XHRyZWRvSG9yaXpvbnRhbCxcblx0XHRcdFx0cmVkb1ZlcnRpY2FsO1xuXG5cdFx0XHQvLyBUaXRsZVxuXHRcdFx0Y2hhcnQuc2V0VGl0bGUoKTtcblxuXG5cdFx0XHQvLyBMZWdlbmRcblx0XHRcdGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoY2hhcnQsIG9wdGlvbnMubGVnZW5kKTtcblxuXHRcdFx0Ly8gR2V0IHN0YWNrc1xuXHRcdFx0aWYgKGNoYXJ0LmdldFN0YWNrcykge1xuXHRcdFx0XHRjaGFydC5nZXRTdGFja3MoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGNoYXJ0IG1hcmdpbnNcblx0XHRcdGNoYXJ0LmdldE1hcmdpbnModHJ1ZSk7XG5cdFx0XHRjaGFydC5zZXRDaGFydFNpemUoKTtcblxuXHRcdFx0Ly8gUmVjb3JkIHByZWxpbWluYXJ5IGRpbWVuc2lvbnMgZm9yIGxhdGVyIGNvbXBhcmlzb25cblx0XHRcdHRlbXBXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aDtcblx0XHRcdHRlbXBIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCAtIDEzOyAvLyAxMyBpcyB0aGUgbW9zdCBjb21tb24gaGVpZ2h0IG9mIFggYXhpcyBsYWJlbHNcblxuXHRcdFx0Ly8gR2V0IG1hcmdpbnMgYnkgcHJlLXJlbmRlcmluZyBheGVzXG5cdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGF4aXMuc2V0U2NhbGUoKTtcblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQuZ2V0QXhpc01hcmdpbnMoKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHBsb3QgYXJlYSBzaXplIGhhcyBjaGFuZ2VkIHNpZ25pZmljYW50bHksIGNhbGN1bGF0ZSB0aWNrIHBvc2l0aW9ucyBhZ2FpblxuXHRcdFx0cmVkb0hvcml6b250YWwgPSB0ZW1wV2lkdGggLyBjaGFydC5wbG90V2lkdGggPiAxLjE7XG5cdFx0XHRyZWRvVmVydGljYWwgPSB0ZW1wSGVpZ2h0IC8gY2hhcnQucGxvdEhlaWdodCA+IDEuMTtcblxuXHRcdFx0aWYgKHJlZG9Ib3Jpem9udGFsIHx8IHJlZG9WZXJ0aWNhbCkge1xuXG5cdFx0XHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDsgLy8gcmVzZXQgZm9yIHNlY29uZCBwYXNzXG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRpZiAoKGF4aXMuaG9yaXogJiYgcmVkb0hvcml6b250YWwpIHx8ICghYXhpcy5ob3JpeiAmJiByZWRvVmVydGljYWwpKSB7XG5cdFx0XHRcdFx0XHRheGlzLnNldFRpY2tJbnRlcnZhbCh0cnVlKTsgLy8gdXBkYXRlIHRvIHJlZmxlY3QgdGhlIG5ldyBtYXJnaW5zXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2hhcnQuZ2V0TWFyZ2lucygpOyAvLyBzZWNvbmQgcGFzcyB0byBjaGVjayBmb3IgbmV3IGxhYmVsc1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IHRoZSBib3JkZXJzIGFuZCBiYWNrZ3JvdW5kc1xuXHRcdFx0Y2hhcnQuZHJhd0NoYXJ0Qm94KCk7XHRcdFxuXG5cblx0XHRcdC8vIEF4ZXNcblx0XHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGF4aXMucmVuZGVyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgc2VyaWVzXG5cdFx0XHRpZiAoIWNoYXJ0LnNlcmllc0dyb3VwKSB7XG5cdFx0XHRcdGNoYXJ0LnNlcmllc0dyb3VwID0gcmVuZGVyZXIuZygnc2VyaWVzLWdyb3VwJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMyB9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdH1cblx0XHRcdGNoYXJ0LnJlbmRlclNlcmllcygpO1xuXG5cdFx0XHQvLyBMYWJlbHNcblx0XHRcdGNoYXJ0LnJlbmRlckxhYmVscygpO1xuXG5cdFx0XHQvLyBDcmVkaXRzXG5cdFx0XHRjaGFydC5zaG93Q3JlZGl0cyhvcHRpb25zLmNyZWRpdHMpO1xuXG5cdFx0XHQvLyBTZXQgZmxhZ1xuXHRcdFx0Y2hhcnQuaGFzUmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgY2hhcnQgY3JlZGl0cyBiYXNlZCBvbiBjb25maWcgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNob3dDcmVkaXRzOiBmdW5jdGlvbiAoY3JlZGl0cykge1xuXHRcdFx0aWYgKGNyZWRpdHMuZW5hYmxlZCAmJiAhdGhpcy5jcmVkaXRzKSB7XG5cdFx0XHRcdHRoaXMuY3JlZGl0cyA9IHRoaXMucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRjcmVkaXRzLnRleHQsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwXG5cdFx0XHRcdClcblx0XHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoY3JlZGl0cy5ocmVmKSB7XG5cdFx0XHRcdFx0XHRsb2NhdGlvbi5ocmVmID0gY3JlZGl0cy5ocmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBjcmVkaXRzLnBvc2l0aW9uLmFsaWduLFxuXHRcdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKGNyZWRpdHMuc3R5bGUpXG5cdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHQuYWxpZ24oY3JlZGl0cy5wb3NpdGlvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFuIHVwIG1lbW9yeSB1c2FnZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRcdGNvbnRhaW5lciA9IGNoYXJ0LmNvbnRhaW5lcixcblx0XHRcdFx0aSxcblx0XHRcdFx0cGFyZW50Tm9kZSA9IGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZTtcblx0XHRcdFx0XG5cdFx0XHQvLyBmaXJlIHRoZSBjaGFydC5kZXN0b3kgZXZlbnRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2Rlc3Ryb3knKTtcblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIHRoZSBjaGFydCBmcm9tIGNoYXJ0cyBsb29rdXAgYXJyYXlcblx0XHRcdGNoYXJ0c1tjaGFydC5pbmRleF0gPSBVTkRFRklORUQ7XG5cdFx0XHRjaGFydENvdW50LS07XG5cdFx0XHRjaGFydC5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpO1xuXG5cdFx0XHQvLyByZW1vdmUgZXZlbnRzXG5cdFx0XHRyZW1vdmVFdmVudChjaGFydCk7XG5cblx0XHRcdC8vID09PT0gRGVzdHJveSBjb2xsZWN0aW9uczpcblx0XHRcdC8vIERlc3Ryb3kgYXhlc1xuXHRcdFx0aSA9IGF4ZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRheGVzW2ldID0gYXhlc1tpXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlc3Ryb3kgZWFjaCBzZXJpZXNcblx0XHRcdGkgPSBzZXJpZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZXNbaV0gPSBzZXJpZXNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyA9PT09IERlc3Ryb3kgY2hhcnQgcHJvcGVydGllczpcblx0XHRcdGVhY2goWyd0aXRsZScsICdzdWJ0aXRsZScsICdjaGFydEJhY2tncm91bmQnLCAncGxvdEJhY2tncm91bmQnLCAncGxvdEJHSW1hZ2UnLCBcblx0XHRcdFx0XHQncGxvdEJvcmRlcicsICdzZXJpZXNHcm91cCcsICdjbGlwUmVjdCcsICdjcmVkaXRzJywgJ3BvaW50ZXInLCAnc2Nyb2xsZXInLCBcblx0XHRcdFx0XHQncmFuZ2VTZWxlY3RvcicsICdsZWdlbmQnLCAncmVzZXRab29tQnV0dG9uJywgJ3Rvb2x0aXAnLCAncmVuZGVyZXInXSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0dmFyIHByb3AgPSBjaGFydFtuYW1lXTtcblxuXHRcdFx0XHRpZiAocHJvcCAmJiBwcm9wLmRlc3Ryb3kpIHtcblx0XHRcdFx0XHRjaGFydFtuYW1lXSA9IHByb3AuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGNvbnRhaW5lciBhbmQgYWxsIFNWR1xuXHRcdFx0aWYgKGNvbnRhaW5lcikgeyAvLyBjYW4gYnJlYWsgaW4gSUUgd2hlbiBkZXN0cm95ZWQgYmVmb3JlIGZpbmlzaGVkIGxvYWRpbmdcblx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRyZW1vdmVFdmVudChjb250YWluZXIpO1xuXHRcdFx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGRpc2NhcmRFbGVtZW50KGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGVhbiBpdCBhbGwgdXBcblx0XHRcdGZvciAoaSBpbiBjaGFydCkge1xuXHRcdFx0XHRkZWxldGUgY2hhcnRbaV07XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBWTUwgbmFtZXNwYWNlcyBjYW4ndCBiZSBhZGRlZCB1bnRpbCBhZnRlciBjb21wbGV0ZS4gTGlzdGVuaW5nXG5cdFx0ICogZm9yIFBlcmluaSdzIGRvU2Nyb2xsIGhhY2sgaXMgbm90IGVub3VnaC5cblx0XHQgKi9cblx0XHRpc1JlYWR5VG9SZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXM7XG5cblx0XHRcdC8vIE5vdGU6IGluIHNwaXRlIG9mIEpTTGludCdzIGNvbXBsYWludHMsIHdpbiA9PSB3aW4udG9wIGlzIHJlcXVpcmVkXG5cdFx0XHQvKmpzbGludCBlcWVxOiB0cnVlKi9cblx0XHRcdGlmICgoIWhhc1NWRyAmJiAod2luID09IHdpbi50b3AgJiYgZG9jLnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpKSB8fCAodXNlQ2FuVkcgJiYgIXdpbi5jYW52ZykpIHtcblx0XHRcdC8qanNsaW50IGVxZXE6IGZhbHNlKi9cblx0XHRcdFx0aWYgKHVzZUNhblZHKSB7XG5cdFx0XHRcdFx0Ly8gRGVsYXkgcmVuZGVyaW5nIHVudGlsIGNhbnZnIGxpYnJhcnkgaXMgZG93bmxvYWRlZCBhbmQgcmVhZHlcblx0XHRcdFx0XHRDYW5WR0NvbnRyb2xsZXIucHVzaChmdW5jdGlvbiAoKSB7IGNoYXJ0LmZpcnN0UmVuZGVyKCk7IH0sIGNoYXJ0Lm9wdGlvbnMuZ2xvYmFsLmNhbnZhc1Rvb2xzVVJMKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGRvYy5kZXRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgY2hhcnQuZmlyc3RSZW5kZXIpO1xuXHRcdFx0XHRcdFx0aWYgKGRvYy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG5cdFx0XHRcdFx0XHRcdGNoYXJ0LmZpcnN0UmVuZGVyKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXBhcmUgZm9yIGZpcnN0IHJlbmRlcmluZyBhZnRlciBhbGwgZGF0YSBhcmUgbG9hZGVkXG5cdFx0ICovXG5cdFx0Zmlyc3RSZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRjYWxsYmFjayA9IGNoYXJ0LmNhbGxiYWNrO1xuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIHRoZSBjaGFydCBpcyByZWFkeSB0byByZW5kZXJcblx0XHRcdGlmICghY2hhcnQuaXNSZWFkeVRvUmVuZGVyKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGNvbnRhaW5lclxuXHRcdFx0Y2hhcnQuZ2V0Q29udGFpbmVyKCk7XG5cblx0XHRcdC8vIFJ1biBhbiBlYXJseSBldmVudCBhZnRlciB0aGUgY29udGFpbmVyIGFuZCByZW5kZXJlciBhcmUgZXN0YWJsaXNoZWRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2luaXQnKTtcblxuXHRcdFx0XG5cdFx0XHRjaGFydC5yZXNldE1hcmdpbnMoKTtcblx0XHRcdGNoYXJ0LnNldENoYXJ0U2l6ZSgpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGNvbW1vbiBjaGFydCBwcm9wZXJ0aWVzIChtYWlubHkgaW52ZXJ0KSBmcm9tIHRoZSBnaXZlbiBzZXJpZXNcblx0XHRcdGNoYXJ0LnByb3BGcm9tU2VyaWVzKCk7XG5cblx0XHRcdC8vIGdldCBheGVzXG5cdFx0XHRjaGFydC5nZXRBeGVzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGhlIHNlcmllc1xuXHRcdFx0ZWFjaChvcHRpb25zLnNlcmllcyB8fCBbXSwgZnVuY3Rpb24gKHNlcmllT3B0aW9ucykge1xuXHRcdFx0XHRjaGFydC5pbml0U2VyaWVzKHNlcmllT3B0aW9ucyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0XHQvLyBSdW4gYW4gZXZlbnQgYWZ0ZXIgYXhlcyBhbmQgc2VyaWVzIGFyZSBpbml0aWFsaXplZCwgYnV0IGJlZm9yZSByZW5kZXIuIEF0IHRoaXMgc3RhZ2UsXG5cdFx0XHQvLyB0aGUgc2VyaWVzIGRhdGEgaXMgaW5kZXhlZCBhbmQgY2FjaGVkIGluIHRoZSB4RGF0YSBhbmQgeURhdGEgYXJyYXlzLCBzbyB3ZSBjYW4gYWNjZXNzXG5cdFx0XHQvLyB0aG9zZSBiZWZvcmUgcmVuZGVyaW5nLiBVc2VkIGluIEhpZ2hzdG9jay4gXG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdiZWZvcmVSZW5kZXInKTsgXG5cblx0XHRcdC8vIGRlcGVuZHMgb24gaW52ZXJ0ZWQgYW5kIG9uIG1hcmdpbnMgYmVpbmcgc2V0XG5cdFx0XHRpZiAoSGlnaGNoYXJ0cy5Qb2ludGVyKSB7XG5cdFx0XHRcdGNoYXJ0LnBvaW50ZXIgPSBuZXcgUG9pbnRlcihjaGFydCwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnJlbmRlcigpO1xuXG5cdFx0XHQvLyBhZGQgY2FudmFzXG5cdFx0XHRjaGFydC5yZW5kZXJlci5kcmF3KCk7XG5cdFx0XHQvLyBydW4gY2FsbGJhY2tzXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdFx0fVxuXHRcdFx0ZWFjaChjaGFydC5jYWxsYmFja3MsIGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRpZiAoY2hhcnQuaW5kZXggIT09IFVOREVGSU5FRCkgeyAvLyBDaGFydCBkZXN0cm95ZWQgaW4gaXRzIG93biBjYWxsYmFjayAoIzM2MDApXG5cdFx0XHRcdFx0Zm4uYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gRmlyZSB0aGUgbG9hZCBldmVudFxuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnbG9hZCcpO1x0XHRcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJ0IHdhcyByZW5kZXJlZCBvdXRzaWRlIHRoZSB0b3AgY29udGFpbmVyLCBwdXQgaXQgYmFjayBpbiAoIzM2NzkpXG5cdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKHRydWUpO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogQ3JlYXRlcyBhcnJheXMgZm9yIHNwYWNpbmcgYW5kIG1hcmdpbiBmcm9tIGdpdmVuIG9wdGlvbnMuXG5cdFx0Ki9cblx0XHRzcGxhc2hBcnJheTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIG9WYXIgPSBvcHRpb25zW3RhcmdldF0sXG5cdFx0XHRcdHRBcnJheSA9IGlzT2JqZWN0KG9WYXIpID8gb1ZhciA6IFtvVmFyLCBvVmFyLCBvVmFyLCBvVmFyXTtcblxuXHRcdFx0cmV0dXJuIFtwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ1RvcCddLCB0QXJyYXlbMF0pLFxuXHRcdFx0XHRcdHBpY2sob3B0aW9uc1t0YXJnZXQgKyAnUmlnaHQnXSwgdEFycmF5WzFdKSxcblx0XHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ0JvdHRvbSddLCB0QXJyYXlbMl0pLFxuXHRcdFx0XHRcdHBpY2sob3B0aW9uc1t0YXJnZXQgKyAnTGVmdCddLCB0QXJyYXlbM10pXTtcblx0XHR9XG5cdH07IC8vIGVuZCBDaGFydFxuXG5cdHZhciBDZW50ZXJlZFNlcmllc01peGluID0gSGlnaGNoYXJ0cy5DZW50ZXJlZFNlcmllc01peGluID0ge1xuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBwaWUgYmFzZWQgb24gdGhlIHNpemUgYW5kIGNlbnRlciBvcHRpb25zIHJlbGF0aXZlIHRvIHRoZSAgXG5cdFx0ICogcGxvdCBhcmVhLiBCb3Jyb3dlZCBieSB0aGUgcG9sYXIgYW5kIGdhdWdlIHNlcmllcyB0eXBlcy5cblx0XHQgKi9cblx0XHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0c2xpY2luZ1Jvb20gPSAyICogKG9wdGlvbnMuc2xpY2VkT2Zmc2V0IHx8IDApLFxuXHRcdFx0XHRoYW5kbGVTbGljaW5nUm9vbSxcblx0XHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoIC0gMiAqIHNsaWNpbmdSb29tLFxuXHRcdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCAtIDIgKiBzbGljaW5nUm9vbSxcblx0XHRcdFx0Y2VudGVyT3B0aW9uID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRcdHBvc2l0aW9ucyA9IFtwaWNrKGNlbnRlck9wdGlvblswXSwgJzUwJScpLCBwaWNrKGNlbnRlck9wdGlvblsxXSwgJzUwJScpLCBvcHRpb25zLnNpemUgfHwgJzEwMCUnLCBvcHRpb25zLmlubmVyU2l6ZSB8fCAwXSxcblx0XHRcdFx0c21hbGxlc3RTaXplID0gbWF0aE1pbihwbG90V2lkdGgsIHBsb3RIZWlnaHQpLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHR2YWx1ZTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuXHRcdFx0XHR2YWx1ZSA9IHBvc2l0aW9uc1tpXTtcblx0XHRcdFx0aGFuZGxlU2xpY2luZ1Jvb20gPSBpIDwgMiB8fCAoaSA9PT0gMiAmJiAvJSQvLnRlc3QodmFsdWUpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGkgPT0gMDogY2VudGVyWCwgcmVsYXRpdmUgdG8gd2lkdGhcblx0XHRcdFx0Ly8gaSA9PSAxOiBjZW50ZXJZLCByZWxhdGl2ZSB0byBoZWlnaHRcblx0XHRcdFx0Ly8gaSA9PSAyOiBzaXplLCByZWxhdGl2ZSB0byBzbWFsbGVzdFNpemVcblx0XHRcdFx0Ly8gaSA9PSAzOiBpbm5lclNpemUsIHJlbGF0aXZlIHRvIHNpemVcblx0XHRcdFx0cG9zaXRpb25zW2ldID0gcmVsYXRpdmVMZW5ndGgodmFsdWUsIFtwbG90V2lkdGgsIHBsb3RIZWlnaHQsIHNtYWxsZXN0U2l6ZSwgcG9zaXRpb25zWzJdXVtpXSkgK1xuXHRcdFx0XHRcdChoYW5kbGVTbGljaW5nUm9vbSA/IHNsaWNpbmdSb29tIDogMCk7XG5cblx0XHRcdH1cblx0XHRcdHJldHVybiBwb3NpdGlvbnM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgUG9pbnQgb2JqZWN0IGFuZCBwcm90b3R5cGUuIEluaGVyaXRhYmxlIGFuZCB1c2VkIGFzIGJhc2UgZm9yIFBpZVBvaW50XG5cdCAqL1xuXHR2YXIgUG9pbnQgPSBmdW5jdGlvbiAoKSB7fTtcblx0UG9pbnQucHJvdG90eXBlID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgcG9pbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzIFRoZSBzZXJpZXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhpcyBwb2ludFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBkYXRhIGluIGVpdGhlciBudW1iZXIsIGFycmF5IG9yIG9iamVjdCBmb3JtYXRcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoc2VyaWVzLCBvcHRpb25zLCB4KSB7XG5cblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdGNvbG9ycztcblx0XHRcdHBvaW50LnNlcmllcyA9IHNlcmllcztcblx0XHRcdHBvaW50LmNvbG9yID0gc2VyaWVzLmNvbG9yOyAvLyAjMzQ0NVxuXHRcdFx0cG9pbnQuYXBwbHlPcHRpb25zKG9wdGlvbnMsIHgpO1xuXHRcdFx0cG9pbnQucG9pbnRBdHRyID0ge307XG5cblx0XHRcdGlmIChzZXJpZXMub3B0aW9ucy5jb2xvckJ5UG9pbnQpIHtcblx0XHRcdFx0Y29sb3JzID0gc2VyaWVzLm9wdGlvbnMuY29sb3JzIHx8IHNlcmllcy5jaGFydC5vcHRpb25zLmNvbG9ycztcblx0XHRcdFx0cG9pbnQuY29sb3IgPSBwb2ludC5jb2xvciB8fCBjb2xvcnNbc2VyaWVzLmNvbG9yQ291bnRlcisrXTtcblx0XHRcdFx0Ly8gbG9vcCBiYWNrIHRvIHplcm9cblx0XHRcdFx0aWYgKHNlcmllcy5jb2xvckNvdW50ZXIgPT09IGNvbG9ycy5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZXJpZXMuY29sb3JDb3VudGVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuY2hhcnQucG9pbnRDb3VudCsrO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgdGhlIG9wdGlvbnMgY29udGFpbmluZyB0aGUgeCBhbmQgeSBkYXRhIGFuZCBwb3NzaWJsZSBzb21lIGV4dHJhIHByb3BlcnRpZXMuXG5cdFx0ICogVGhpcyBpcyBjYWxsZWQgb24gcG9pbnQgaW5pdCBvciBmcm9tIHBvaW50LnVwZGF0ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICovXG5cdFx0YXBwbHlPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgeCkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRwb2ludFZhbEtleSA9IHNlcmllcy5vcHRpb25zLnBvaW50VmFsS2V5IHx8IHNlcmllcy5wb2ludFZhbEtleTtcblxuXHRcdFx0b3B0aW9ucyA9IFBvaW50LnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0Ly8gY29weSBvcHRpb25zIGRpcmVjdGx5IHRvIHBvaW50XG5cdFx0XHRleHRlbmQocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0cG9pbnQub3B0aW9ucyA9IHBvaW50Lm9wdGlvbnMgPyBleHRlbmQocG9pbnQub3B0aW9ucywgb3B0aW9ucykgOiBvcHRpb25zO1xuXG5cdFx0XHQvLyBGb3IgaGlnaGVyIGRpbWVuc2lvbiBzZXJpZXMgdHlwZXMuIEZvciBpbnN0YW5jZSwgZm9yIHJhbmdlcywgcG9pbnQueSBpcyBtYXBwZWQgdG8gcG9pbnQubG93LlxuXHRcdFx0aWYgKHBvaW50VmFsS2V5KSB7XG5cdFx0XHRcdHBvaW50LnkgPSBwb2ludFtwb2ludFZhbEtleV07XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIHggaXMgc2V0IGJ5IG5vdywgZ2V0IGF1dG8gaW5jcmVtZW50ZWQgdmFsdWUuIEFsbCBwb2ludHMgbXVzdCBoYXZlIGFuXG5cdFx0XHQvLyB4IHZhbHVlLCBob3dldmVyIHRoZSB5IHZhbHVlIGNhbiBiZSBudWxsIHRvIGNyZWF0ZSBhIGdhcCBpbiB0aGUgc2VyaWVzXG5cdFx0XHRpZiAocG9pbnQueCA9PT0gVU5ERUZJTkVEICYmIHNlcmllcykge1xuXHRcdFx0XHRwb2ludC54ID0geCA9PT0gVU5ERUZJTkVEID8gc2VyaWVzLmF1dG9JbmNyZW1lbnQoKSA6IHg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNmb3JtIG51bWJlciBvciBhcnJheSBjb25maWdzIGludG8gb2JqZWN0c1xuXHRcdCAqL1xuXHRcdG9wdGlvbnNUb09iamVjdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdHZhciByZXQgPSB7fSxcblx0XHRcdFx0c2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRcdGtleXMgPSBzZXJpZXMub3B0aW9ucy5rZXlzLFxuXHRcdFx0XHRwb2ludEFycmF5TWFwID0ga2V5cyB8fCBzZXJpZXMucG9pbnRBcnJheU1hcCB8fCBbJ3knXSxcblx0XHRcdFx0dmFsdWVDb3VudCA9IHBvaW50QXJyYXlNYXAubGVuZ3RoLFxuXHRcdFx0XHRmaXJzdEl0ZW1UeXBlLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXRbcG9pbnRBcnJheU1hcFswXV0gPSBvcHRpb25zO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRcdFx0Ly8gd2l0aCBsZWFkaW5nIHggdmFsdWVcblx0XHRcdFx0aWYgKCFrZXlzICYmIG9wdGlvbnMubGVuZ3RoID4gdmFsdWVDb3VudCkge1xuXHRcdFx0XHRcdGZpcnN0SXRlbVR5cGUgPSB0eXBlb2Ygb3B0aW9uc1swXTtcblx0XHRcdFx0XHRpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHJldC5uYW1lID0gb3B0aW9uc1swXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGZpcnN0SXRlbVR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRyZXQueCA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoaiA8IHZhbHVlQ291bnQpIHtcblx0XHRcdFx0XHRyZXRbcG9pbnRBcnJheU1hcFtqKytdXSA9IG9wdGlvbnNbaSsrXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0cmV0ID0gb3B0aW9ucztcblxuXHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBmYXN0ZXN0IHdheSB0byBkZXRlY3QgaWYgdGhlcmUgYXJlIGluZGl2aWR1YWwgcG9pbnQgZGF0YUxhYmVscyB0aGF0IG5lZWRcblx0XHRcdFx0Ly8gdG8gYmUgY29uc2lkZXJlZCBpbiBkcmF3RGF0YUxhYmVscy4gVGhlc2UgY2FuIG9ubHkgb2NjdXIgaW4gb2JqZWN0IGNvbmZpZ3MuXG5cdFx0XHRcdGlmIChvcHRpb25zLmRhdGFMYWJlbHMpIHtcblx0XHRcdFx0XHRzZXJpZXMuX2hhc1BvaW50TGFiZWxzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNhbWUgYXBwcm9hY2ggYXMgYWJvdmUgZm9yIG1hcmtlcnNcblx0XHRcdFx0aWYgKG9wdGlvbnMubWFya2VyKSB7XG5cdFx0XHRcdFx0c2VyaWVzLl9oYXNQb2ludE1hcmtlcnMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IGEgcG9pbnQgdG8gY2xlYXIgbWVtb3J5LiBJdHMgcmVmZXJlbmNlIHN0aWxsIHN0YXlzIGluIHNlcmllcy5kYXRhLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdGhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludHMsXG5cdFx0XHRcdHByb3A7XG5cblx0XHRcdGNoYXJ0LnBvaW50Q291bnQtLTtcblxuXHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdGVyYXNlKGhvdmVyUG9pbnRzLCBwb2ludCk7XG5cdFx0XHRcdGlmICghaG92ZXJQb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdGlmIChwb2ludCA9PT0gY2hhcnQuaG92ZXJQb2ludCkge1xuXHRcdFx0XHRwb2ludC5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0XHRpZiAocG9pbnQuZ3JhcGhpYyB8fCBwb2ludC5kYXRhTGFiZWwpIHsgLy8gcmVtb3ZlRXZlbnQgYW5kIGRlc3Ryb3lFbGVtZW50cyBhcmUgcGVyZm9ybWFuY2UgZXhwZW5zaXZlXG5cdFx0XHRcdHJlbW92ZUV2ZW50KHBvaW50KTtcblx0XHRcdFx0cG9pbnQuZGVzdHJveUVsZW1lbnRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwb2ludC5sZWdlbmRJdGVtKSB7IC8vIHBpZXMgaGF2ZSBsZWdlbmQgaXRlbXNcblx0XHRcdFx0Y2hhcnQubGVnZW5kLmRlc3Ryb3lJdGVtKHBvaW50KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChwcm9wIGluIHBvaW50KSB7XG5cdFx0XHRcdHBvaW50W3Byb3BdID0gbnVsbDtcblx0XHRcdH1cblxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgU1ZHIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9pbnRcblx0XHQgKi9cblx0XHRkZXN0cm95RWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHByb3BzID0gWydncmFwaGljJywgJ2RhdGFMYWJlbCcsICdkYXRhTGFiZWxVcHBlcicsICdncm91cCcsICdjb25uZWN0b3InLCAnc2hhZG93R3JvdXAnXSxcblx0XHRcdFx0cHJvcCxcblx0XHRcdFx0aSA9IDY7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKHBvaW50W3Byb3BdKSB7XG5cdFx0XHRcdFx0cG9pbnRbcHJvcF0gPSBwb2ludFtwcm9wXS5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBjb25maWd1cmF0aW9uIGhhc2ggbmVlZGVkIGZvciB0aGUgZGF0YSBsYWJlbCBhbmQgdG9vbHRpcCBmb3JtYXR0ZXJzXG5cdFx0ICovXG5cdFx0Z2V0TGFiZWxDb25maWc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXM7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBwb2ludC5jYXRlZ29yeSxcblx0XHRcdFx0eTogcG9pbnQueSxcblx0XHRcdFx0a2V5OiBwb2ludC5uYW1lIHx8IHBvaW50LmNhdGVnb3J5LFxuXHRcdFx0XHRzZXJpZXM6IHBvaW50LnNlcmllcyxcblx0XHRcdFx0cG9pbnQ6IHBvaW50LFxuXHRcdFx0XHRwZXJjZW50YWdlOiBwb2ludC5wZXJjZW50YWdlLFxuXHRcdFx0XHR0b3RhbDogcG9pbnQudG90YWwgfHwgcG9pbnQuc3RhY2tUb3RhbFxuXHRcdFx0fTtcblx0XHR9LFx0XG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmRhYmxlIG1ldGhvZCBmb3IgZm9ybWF0dGluZyBlYWNoIHBvaW50J3MgdG9vbHRpcCBsaW5lXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHRvIGJlIGNvbmNhdGVuYXRlZCBpbiB0byB0aGUgY29tbW9uIHRvb2x0aXAgdGV4dFxuXHRcdCAqL1xuXHRcdHRvb2x0aXBGb3JtYXR0ZXI6IGZ1bmN0aW9uIChwb2ludEZvcm1hdCkge1xuXG5cdFx0XHQvLyBJbnNlcnQgb3B0aW9ucyBmb3IgdmFsdWVEZWNpbWFscywgdmFsdWVQcmVmaXgsIGFuZCB2YWx1ZVN1ZmZpeFxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0XHRzZXJpZXNUb29sdGlwT3B0aW9ucyA9IHNlcmllcy50b29sdGlwT3B0aW9ucyxcblx0XHRcdFx0dmFsdWVEZWNpbWFscyA9IHBpY2soc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVEZWNpbWFscywgJycpLFxuXHRcdFx0XHR2YWx1ZVByZWZpeCA9IHNlcmllc1Rvb2x0aXBPcHRpb25zLnZhbHVlUHJlZml4IHx8ICcnLFxuXHRcdFx0XHR2YWx1ZVN1ZmZpeCA9IHNlcmllc1Rvb2x0aXBPcHRpb25zLnZhbHVlU3VmZml4IHx8ICcnO1xuXG5cdFx0XHQvLyBMb29wIG92ZXIgdGhlIHBvaW50IGFycmF5IG1hcCBhbmQgcmVwbGFjZSB1bmZvcm1hdHRlZCB2YWx1ZXMgd2l0aCBzcHJpbnRmIGZvcm1hdHRpbmcgbWFya3VwXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludEFycmF5TWFwIHx8IFsneSddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGtleSA9ICd7cG9pbnQuJyArIGtleTsgLy8gd2l0aG91dCB0aGUgY2xvc2luZyBicmFja2V0XG5cdFx0XHRcdGlmICh2YWx1ZVByZWZpeCB8fCB2YWx1ZVN1ZmZpeCkge1xuXHRcdFx0XHRcdHBvaW50Rm9ybWF0ID0gcG9pbnRGb3JtYXQucmVwbGFjZShrZXkgKyAnfScsIHZhbHVlUHJlZml4ICsga2V5ICsgJ30nICsgdmFsdWVTdWZmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50Rm9ybWF0ID0gcG9pbnRGb3JtYXQucmVwbGFjZShrZXkgKyAnfScsIGtleSArICc6LC4nICsgdmFsdWVEZWNpbWFscyArICdmfScpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBmb3JtYXQocG9pbnRGb3JtYXQsIHtcblx0XHRcdFx0cG9pbnQ6IHRoaXMsXG5cdFx0XHRcdHNlcmllczogdGhpcy5zZXJpZXNcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGaXJlIGFuIGV2ZW50IG9uIHRoZSBQb2ludCBvYmplY3QuIE11c3Qgbm90IGJlIHJlbmFtZWQgdG8gZmlyZUV2ZW50LCBhcyB0aGlzXG5cdFx0ICogY2F1c2VzIGEgbmFtZSBjbGFzaCBpbiBNb29Ub29sc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmdzIEFkZGl0aW9uYWwgZXZlbnQgYXJndW1lbnRzXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdEZ1bmN0aW9uIERlZmF1bHQgZXZlbnQgaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZpcmVQb2ludEV2ZW50OiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudEFyZ3MsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucztcblxuXHRcdFx0Ly8gbG9hZCBldmVudCBoYW5kbGVycyBvbiBkZW1hbmQgdG8gc2F2ZSB0aW1lIG9uIG1vdXNlb3Zlci9vdXRcblx0XHRcdGlmIChzZXJpZXNPcHRpb25zLnBvaW50LmV2ZW50c1tldmVudFR5cGVdIHx8IChwb2ludC5vcHRpb25zICYmIHBvaW50Lm9wdGlvbnMuZXZlbnRzICYmIHBvaW50Lm9wdGlvbnMuZXZlbnRzW2V2ZW50VHlwZV0pKSB7XG5cdFx0XHRcdHRoaXMuaW1wb3J0RXZlbnRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBkZWZhdWx0IGhhbmRsZXIgaWYgaW4gc2VsZWN0aW9uIG1vZGVcblx0XHRcdGlmIChldmVudFR5cGUgPT09ICdjbGljaycgJiYgc2VyaWVzT3B0aW9ucy5hbGxvd1BvaW50U2VsZWN0KSB7XG5cdFx0XHRcdGRlZmF1bHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdC8vIENvbnRyb2wga2V5IGlzIGZvciBXaW5kb3dzLCBtZXRhICg9IENtZCBrZXkpIGZvciBNYWMsIFNoaWZ0IGZvciBPcGVyYVxuXHRcdFx0XHRcdGlmIChwb2ludC5zZWxlY3QpIHsgLy8gQ291bGQgYmUgZGVzdHJveWVkIGJ5IHByaW9yIGV2ZW50IGhhbmRsZXJzICgjMjkxMSlcblx0XHRcdFx0XHRcdHBvaW50LnNlbGVjdChudWxsLCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyZUV2ZW50KHRoaXMsIGV2ZW50VHlwZSwgZXZlbnRBcmdzLCBkZWZhdWx0RnVuY3Rpb24pO1xuXHRcdH1cblx0fTsvKipcblx0ICogQGNsYXNzRGVzY3JpcHRpb24gVGhlIGJhc2UgZnVuY3Rpb24gd2hpY2ggYWxsIG90aGVyIHNlcmllcyB0eXBlcyBpbmhlcml0IGZyb20uIFRoZSBkYXRhIGluIHRoZSBzZXJpZXMgaXMgc3RvcmVkXG5cdCAqIGluIHZhcmlvdXMgYXJyYXlzLlxuXHQgKlxuXHQgKiAtIEZpcnN0LCBzZXJpZXMub3B0aW9ucy5kYXRhIGNvbnRhaW5zIGFsbCB0aGUgb3JpZ2luYWwgY29uZmlnIG9wdGlvbnMgZm9yXG5cdCAqIGVhY2ggcG9pbnQgd2hldGhlciBhZGRlZCBieSBvcHRpb25zIG9yIG1ldGhvZHMgbGlrZSBzZXJpZXMuYWRkUG9pbnQuXG5cdCAqIC0gTmV4dCwgc2VyaWVzLmRhdGEgY29udGFpbnMgdGhvc2UgdmFsdWVzIGNvbnZlcnRlZCB0byBwb2ludHMsIGJ1dCBpbiBjYXNlIHRoZSBzZXJpZXMgZGF0YSBsZW5ndGhcblx0ICogZXhjZWVkcyB0aGUgY3JvcFRocmVzaG9sZCwgb3IgaWYgdGhlIGRhdGEgaXMgZ3JvdXBlZCwgc2VyaWVzLmRhdGEgZG9lc24ndCBjb250YWluIGFsbCB0aGUgcG9pbnRzLiBJdFxuXHQgKiBvbmx5IGNvbnRhaW5zIHRoZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCBvbiBkZW1hbmQuXG5cdCAqIC0gVGhlbiB0aGVyZSdzIHNlcmllcy5wb2ludHMgdGhhdCBjb250YWlucyBhbGwgY3VycmVudGx5IHZpc2libGUgcG9pbnQgb2JqZWN0cy4gSW4gY2FzZSBvZiBjcm9wcGluZyxcblx0ICogdGhlIGNyb3BwZWQtYXdheSBwb2ludHMgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgYXJyYXkuIFRoZSBzZXJpZXMucG9pbnRzIGFycmF5IHN0YXJ0cyBhdCBzZXJpZXMuY3JvcFN0YXJ0XG5cdCAqIGNvbXBhcmVkIHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMub3B0aW9ucy5kYXRhLiBJZiBob3dldmVyIHRoZSBzZXJpZXMgZGF0YSBpcyBncm91cGVkLCB0aGVzZSBjYW4ndFxuXHQgKiBiZSBjb3JyZWxhdGVkIG9uZSB0byBvbmUuXG5cdCAqIC0gc2VyaWVzLnhEYXRhIGFuZCBzZXJpZXMucHJvY2Vzc2VkWERhdGEgY29udGFpbiBjbGVhbiB4IHZhbHVlcywgZXF1aXZhbGVudCB0byBzZXJpZXMuZGF0YSBhbmQgc2VyaWVzLnBvaW50cy5cblx0ICogLSBzZXJpZXMueURhdGEgYW5kIHNlcmllcy5wcm9jZXNzZWRZRGF0YSBjb250YWluIGNsZWFuIHggdmFsdWVzLCBlcXVpdmFsZW50IHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMucG9pbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHZhciBTZXJpZXMgPSBIaWdoY2hhcnRzLlNlcmllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdFNlcmllcy5wcm90b3R5cGUgPSB7XG5cblx0XHRpc0NhcnRlc2lhbjogdHJ1ZSxcblx0XHR0eXBlOiAnbGluZScsXG5cdFx0cG9pbnRDbGFzczogUG9pbnQsXG5cdFx0c29ydGVkOiB0cnVlLCAvLyByZXF1aXJlcyB0aGUgZGF0YSB0byBiZSBzb3J0ZWRcblx0XHRyZXF1aXJlU29ydGluZzogdHJ1ZSxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdsaW5lQ29sb3InLFxuXHRcdFx0J3N0cm9rZS13aWR0aCc6ICdsaW5lV2lkdGgnLFxuXHRcdFx0ZmlsbDogJ2ZpbGxDb2xvcicsXG5cdFx0XHRyOiAncmFkaXVzJ1xuXHRcdH0sXG5cdFx0YXhpc1R5cGVzOiBbJ3hBeGlzJywgJ3lBeGlzJ10sXG5cdFx0Y29sb3JDb3VudGVyOiAwLFxuXHRcdHBhcmFsbGVsQXJyYXlzOiBbJ3gnLCAneSddLCAvLyBlYWNoIHBvaW50J3MgeCBhbmQgeSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGlzLnhEYXRhIGFuZCB0aGlzLnlEYXRhXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0XHRldmVudHMsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0XHRzb3J0QnlJbmRleCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBpY2soYS5vcHRpb25zLmluZGV4LCBhLl9pKSAtIHBpY2soYi5vcHRpb25zLmluZGV4LCBiLl9pKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0c2VyaWVzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRzZXJpZXMub3B0aW9ucyA9IG9wdGlvbnMgPSBzZXJpZXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gbWVyZ2Ugd2l0aCBwbG90T3B0aW9uc1xuXHRcdFx0c2VyaWVzLmxpbmtlZFNlcmllcyA9IFtdO1xuXG5cdFx0XHQvLyBiaW5kIHRoZSBheGVzXG5cdFx0XHRzZXJpZXMuYmluZEF4ZXMoKTtcblxuXHRcdFx0Ly8gc2V0IHNvbWUgdmFyaWFibGVzXG5cdFx0XHRleHRlbmQoc2VyaWVzLCB7XG5cdFx0XHRcdG5hbWU6IG9wdGlvbnMubmFtZSxcblx0XHRcdFx0c3RhdGU6IE5PUk1BTF9TVEFURSxcblx0XHRcdFx0cG9pbnRBdHRyOiB7fSxcblx0XHRcdFx0dmlzaWJsZTogb3B0aW9ucy52aXNpYmxlICE9PSBmYWxzZSwgLy8gdHJ1ZSBieSBkZWZhdWx0XG5cdFx0XHRcdHNlbGVjdGVkOiBvcHRpb25zLnNlbGVjdGVkID09PSB0cnVlIC8vIGZhbHNlIGJ5IGRlZmF1bHRcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBzcGVjaWFsXG5cdFx0XHRpZiAodXNlQ2FuVkcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cztcblx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudChzZXJpZXMsIGV2ZW50VHlwZSwgZXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQoZXZlbnRzICYmIGV2ZW50cy5jbGljaykgfHxcblx0XHRcdFx0KG9wdGlvbnMucG9pbnQgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMuY2xpY2spIHx8XG5cdFx0XHRcdG9wdGlvbnMuYWxsb3dQb2ludFNlbGVjdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoYXJ0LnJ1blRyYWNrZXJDbGljayA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5nZXRDb2xvcigpO1xuXHRcdFx0c2VyaWVzLmdldFN5bWJvbCgpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGFcblx0XHRcdGVhY2goc2VyaWVzLnBhcmFsbGVsQXJyYXlzLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdHNlcmllc1trZXkgKyAnRGF0YSddID0gW107XG5cdFx0XHR9KTtcblx0XHRcdHNlcmllcy5zZXREYXRhKG9wdGlvbnMuZGF0YSwgZmFsc2UpO1xuXG5cdFx0XHQvLyBNYXJrIGNhcnRlc2lhblxuXHRcdFx0aWYgKHNlcmllcy5pc0NhcnRlc2lhbikge1xuXHRcdFx0XHRjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWdpc3RlciBpdCBpbiB0aGUgY2hhcnRcblx0XHRcdGNoYXJ0U2VyaWVzLnB1c2goc2VyaWVzKTtcblx0XHRcdHNlcmllcy5faSA9IGNoYXJ0U2VyaWVzLmxlbmd0aCAtIDE7XG5cblx0XHRcdC8vIFNvcnQgc2VyaWVzIGFjY29yZGluZyB0byBpbmRleCBvcHRpb24gKCMyNDgsICMxMTIzLCAjMjQ1Nilcblx0XHRcdHN0YWJsZVNvcnQoY2hhcnRTZXJpZXMsIHNvcnRCeUluZGV4KTtcblx0XHRcdGlmICh0aGlzLnlBeGlzKSB7XG5cdFx0XHRcdHN0YWJsZVNvcnQodGhpcy55QXhpcy5zZXJpZXMsIHNvcnRCeUluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcywgaSkge1xuXHRcdFx0XHRzZXJpZXMuaW5kZXggPSBpO1xuXHRcdFx0XHRzZXJpZXMubmFtZSA9IHNlcmllcy5uYW1lIHx8ICdTZXJpZXMgJyArIChpICsgMSk7XG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHhBeGlzIGFuZCB5QXhpcyBwcm9wZXJ0aWVzIG9mIGNhcnRlc2lhbiBzZXJpZXMsIGFuZCByZWdpc3RlciB0aGUgc2VyaWVzXG5cdFx0ICogaW4gdGhlIGF4aXMuc2VyaWVzIGFycmF5XG5cdFx0ICovXG5cdFx0YmluZEF4ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRheGlzT3B0aW9ucztcblxuXHRcdFx0ZWFjaChzZXJpZXMuYXhpc1R5cGVzIHx8IFtdLCBmdW5jdGlvbiAoQVhJUykgeyAvLyByZXBlYXQgZm9yIHhBeGlzIGFuZCB5QXhpc1xuXG5cdFx0XHRcdGVhY2goY2hhcnRbQVhJU10sIGZ1bmN0aW9uIChheGlzKSB7IC8vIGxvb3AgdGhyb3VnaCB0aGUgY2hhcnQncyBheGlzIG9iamVjdHNcblx0XHRcdFx0XHRheGlzT3B0aW9ucyA9IGF4aXMub3B0aW9ucztcblxuXHRcdFx0XHRcdC8vIGFwcGx5IGlmIHRoZSBzZXJpZXMgeEF4aXMgb3IgeUF4aXMgb3B0aW9uIG1hdGhjaGVzIHRoZSBudW1iZXIgb2YgdGhlXG5cdFx0XHRcdFx0Ly8gYXhpcywgb3IgaWYgdW5kZWZpbmVkLCB1c2UgdGhlIGZpcnN0IGF4aXNcblx0XHRcdFx0XHRpZiAoKHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmluZGV4KSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSAhPT0gVU5ERUZJTkVEICYmIHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmlkKSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSA9PT0gVU5ERUZJTkVEICYmIGF4aXNPcHRpb25zLmluZGV4ID09PSAwKSkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHNlcmllcyBpbiB0aGUgYXhpcy5zZXJpZXMgbG9va3VwXG5cdFx0XHRcdFx0XHRheGlzLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cblx0XHRcdFx0XHRcdC8vIHNldCB0aGlzIHNlcmllcy54QXhpcyBvciBzZXJpZXMueUF4aXMgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRzZXJpZXNbQVhJU10gPSBheGlzO1xuXG5cdFx0XHRcdFx0XHQvLyBtYXJrIGRpcnR5IGZvciByZWRyYXdcblx0XHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBUaGUgc2VyaWVzIG5lZWRzIGFuIFggYW5kIGFuIFkgYXhpc1xuXHRcdFx0XHRpZiAoIXNlcmllc1tBWElTXSAmJiBzZXJpZXMub3B0aW9uYWxBeGlzICE9PSBBWElTKSB7XG5cdFx0XHRcdFx0ZXJyb3IoMTgsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3Igc2ltcGxlIHNlcmllcyB0eXBlcyBsaWtlIGxpbmUgYW5kIGNvbHVtbiwgdGhlIGRhdGEgdmFsdWVzIGFyZSBoZWxkIGluIGFycmF5cyBsaWtlXG5cdFx0ICogeERhdGEgYW5kIHlEYXRhIGZvciBxdWljayBsb29rdXAgdG8gZmluZCBleHRyZW1lcyBhbmQgbW9yZS4gRm9yIG11bHRpZGltZW5zaW9uYWwgc2VyaWVzXG5cdFx0ICogbGlrZSBidWJibGUgYW5kIG1hcCwgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBhcnJheXMgbGlrZSB6RGF0YSBhbmQgdmFsdWVEYXRhIGJ5XG5cdFx0ICogYWRkaW5nIHRvIHRoZSBzZXJpZXMucGFyYWxsZWxBcnJheXMgYXJyYXkuXG5cdFx0ICovXG5cdFx0dXBkYXRlUGFyYWxsZWxBcnJheXM6IGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0Zm4gPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHRcdCAvLyBJbnNlcnQgdGhlIHZhbHVlIGluIHRoZSBnaXZlbiBwb3NpdGlvblxuXHRcdFx0XHRcdGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdHZhciB2YWwgPSBrZXkgPT09ICd5JyAmJiBzZXJpZXMudG9ZRGF0YSA/IHNlcmllcy50b1lEYXRhKHBvaW50KSA6IHBvaW50W2tleV07XG5cdFx0XHRcdFx0XHRzZXJpZXNba2V5ICsgJ0RhdGEnXVtpXSA9IHZhbDtcblx0XHRcdFx0XHR9IDpcblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgbWV0aG9kIHNwZWNpZmllZCBpbiBpIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXMgYXJndW1lbnRzXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlW2ldLmFwcGx5KHNlcmllc1trZXkgKyAnRGF0YSddLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0ZWFjaChzZXJpZXMucGFyYWxsZWxBcnJheXMsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGFuIGF1dG8gaW5jcmVtZW50ZWQgeCB2YWx1ZSBiYXNlZCBvbiB0aGUgcG9pbnRTdGFydCBhbmQgcG9pbnRJbnRlcnZhbCBvcHRpb25zLlxuXHRcdCAqIFRoaXMgaXMgb25seSB1c2VkIGlmIGFuIHggdmFsdWUgaXMgbm90IGdpdmVuIGZvciB0aGUgcG9pbnQgdGhhdCBjYWxscyBhdXRvSW5jcmVtZW50LlxuXHRcdCAqL1xuXHRcdGF1dG9JbmNyZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHhJbmNyZW1lbnQgPSB0aGlzLnhJbmNyZW1lbnQsXG5cdFx0XHRcdGRhdGUsXG5cdFx0XHRcdHBvaW50SW50ZXJ2YWwsXG5cdFx0XHRcdHBvaW50SW50ZXJ2YWxVbml0ID0gb3B0aW9ucy5wb2ludEludGVydmFsVW5pdDtcblx0XHRcdFxuXHRcdFx0eEluY3JlbWVudCA9IHBpY2soeEluY3JlbWVudCwgb3B0aW9ucy5wb2ludFN0YXJ0LCAwKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wb2ludEludGVydmFsID0gcG9pbnRJbnRlcnZhbCA9IHBpY2sodGhpcy5wb2ludEludGVydmFsLCBvcHRpb25zLnBvaW50SW50ZXJ2YWwsIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyBBZGRlZCBjb2RlIGZvciBwb2ludEludGVydmFsIHN0cmluZ3Ncblx0XHRcdGlmIChwb2ludEludGVydmFsVW5pdCA9PT0gJ21vbnRoJyB8fCBwb2ludEludGVydmFsVW5pdCA9PT0gJ3llYXInKSB7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSh4SW5jcmVtZW50KTtcblx0XHRcdFx0ZGF0ZSA9IChwb2ludEludGVydmFsVW5pdCA9PT0gJ21vbnRoJykgP1xuXHRcdFx0XHRcdCtkYXRlW3NldE1vbnRoXShkYXRlW2dldE1vbnRoXSgpICsgcG9pbnRJbnRlcnZhbCkgOlxuXHRcdFx0XHRcdCtkYXRlW3NldEZ1bGxZZWFyXShkYXRlW2dldEZ1bGxZZWFyXSgpICsgcG9pbnRJbnRlcnZhbCk7XG5cdFx0XHRcdHBvaW50SW50ZXJ2YWwgPSBkYXRlIC0geEluY3JlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy54SW5jcmVtZW50ID0geEluY3JlbWVudCArIHBvaW50SW50ZXJ2YWw7XG5cdFx0XHRyZXR1cm4geEluY3JlbWVudDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGl2aWRlIHRoZSBzZXJpZXMgZGF0YSBpbnRvIHNlZ21lbnRzIGRpdmlkZWQgYnkgbnVsbCB2YWx1ZXMuXG5cdFx0ICovXG5cdFx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRsYXN0TnVsbCA9IC0xLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRwb2ludHNMZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRpZiAocG9pbnRzTGVuZ3RoKSB7IC8vIG5vIGFjdGlvbiByZXF1aXJlZCBmb3IgW11cblxuXHRcdFx0XHQvLyBpZiBjb25uZWN0IG51bGxzLCBqdXN0IHJlbW92ZSBudWxsIHBvaW50c1xuXHRcdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuY29ubmVjdE51bGxzKSB7XG5cdFx0XHRcdFx0aSA9IHBvaW50c0xlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAocG9pbnRzW2ldLnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNlZ21lbnRzID0gW3BvaW50c107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGVsc2UsIHNwbGl0IG9uIG51bGwgcG9pbnRzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdFx0XHRcdFx0aWYgKHBvaW50LnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGkgPiBsYXN0TnVsbCArIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHBvaW50cy5zbGljZShsYXN0TnVsbCArIDEsIGkpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0TnVsbCA9IGk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IHBvaW50c0xlbmd0aCAtIDEpIHsgLy8gbGFzdCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHBvaW50cy5zbGljZShsYXN0TnVsbCArIDEsIGkgKyAxKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVnaXN0ZXIgaXRcblx0XHRcdHNlcmllcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHNlcmllcyBvcHRpb25zIGJ5IG1lcmdpbmcgZnJvbSB0aGUgb3B0aW9ucyB0cmVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1PcHRpb25zXG5cdFx0ICovXG5cdFx0c2V0T3B0aW9uczogZnVuY3Rpb24gKGl0ZW1PcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRwbG90T3B0aW9ucyA9IGNoYXJ0T3B0aW9ucy5wbG90T3B0aW9ucyxcblx0XHRcdFx0dXNlck9wdGlvbnMgPSBjaGFydC51c2VyT3B0aW9ucyB8fCB7fSxcblx0XHRcdFx0dXNlclBsb3RPcHRpb25zID0gdXNlck9wdGlvbnMucGxvdE9wdGlvbnMgfHwge30sXG5cdFx0XHRcdHR5cGVPcHRpb25zID0gcGxvdE9wdGlvbnNbdGhpcy50eXBlXSxcblx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0em9uZXM7XG5cblx0XHRcdHRoaXMudXNlck9wdGlvbnMgPSBpdGVtT3B0aW9ucztcblxuXHRcdFx0Ly8gR2VuZXJhbCBzZXJpZXMgb3B0aW9ucyB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0eXBlIG9wdGlvbnMgYmVjYXVzZSBvdGhlcndpc2UsIGRlZmF1bHRcblx0XHRcdC8vIHR5cGUgb3B0aW9ucyBsaWtlIGNvbHVtbi5hbmltYXRpb24gd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGdlbmVyYWwgb3B0aW9uLlxuXHRcdFx0Ly8gQnV0IGlzc3VlcyBoYXZlIGJlZW4gcmFpc2VkIGhlcmUgKCMzODgxKSwgYW5kIHRoZSBzb2x1dGlvbiBtYXkgYmUgdG8gZGlzdGluZ3Vpc2ggXG5cdFx0XHQvLyBiZXR3ZWVuIGRlZmF1bHQgb3B0aW9uIGFuZCB1c2VyT3B0aW9ucyBsaWtlIGluIHRoZSB0b29sdGlwIGJlbG93LlxuXHRcdFx0b3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0XHR0eXBlT3B0aW9ucyxcblx0XHRcdFx0cGxvdE9wdGlvbnMuc2VyaWVzLFxuXHRcdFx0XHRpdGVtT3B0aW9uc1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gVGhlIHRvb2x0aXAgb3B0aW9ucyBhcmUgbWVyZ2VkIGJldHdlZW4gZ2xvYmFsIGFuZCBzZXJpZXMgc3BlY2lmaWMgb3B0aW9uc1xuXHRcdFx0dGhpcy50b29sdGlwT3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0XHRkZWZhdWx0T3B0aW9ucy50b29sdGlwLFxuXHRcdFx0XHRkZWZhdWx0T3B0aW9ucy5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsXG5cdFx0XHRcdHVzZXJPcHRpb25zLnRvb2x0aXAsXG5cdFx0XHRcdHVzZXJQbG90T3B0aW9ucy5zZXJpZXMgJiYgdXNlclBsb3RPcHRpb25zLnNlcmllcy50b29sdGlwLFxuXHRcdFx0XHR1c2VyUGxvdE9wdGlvbnNbdGhpcy50eXBlXSAmJiB1c2VyUGxvdE9wdGlvbnNbdGhpcy50eXBlXS50b29sdGlwLFxuXHRcdFx0XHRpdGVtT3B0aW9ucy50b29sdGlwXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBEZWxldGUgbWFya2VyIG9iamVjdCBpZiBub3QgYWxsb3dlZCAoIzExMjUpXG5cdFx0XHRpZiAodHlwZU9wdGlvbnMubWFya2VyID09PSBudWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zLm1hcmtlcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGNvbG9yIHpvbmVzXG5cdFx0XHR0aGlzLnpvbmVBeGlzID0gb3B0aW9ucy56b25lQXhpcztcblx0XHRcdHpvbmVzID0gdGhpcy56b25lcyA9IChvcHRpb25zLnpvbmVzIHx8IFtdKS5zbGljZSgpO1xuXHRcdFx0aWYgKChvcHRpb25zLm5lZ2F0aXZlQ29sb3IgfHwgb3B0aW9ucy5uZWdhdGl2ZUZpbGxDb2xvcikgJiYgIW9wdGlvbnMuem9uZXMpIHtcblx0XHRcdFx0em9uZXMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG9wdGlvbnNbdGhpcy56b25lQXhpcyArICdUaHJlc2hvbGQnXSB8fCBvcHRpb25zLnRocmVzaG9sZCB8fCAwLFxuXHRcdFx0XHRcdGNvbG9yOiBvcHRpb25zLm5lZ2F0aXZlQ29sb3IsXG5cdFx0XHRcdFx0ZmlsbENvbG9yOiBvcHRpb25zLm5lZ2F0aXZlRmlsbENvbG9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHpvbmVzLmxlbmd0aCkgeyAvLyBQdXNoIG9uZSBleHRyYSB6b25lIGZvciB0aGUgcmVzdFxuXHRcdFx0XHRpZiAoZGVmaW5lZCh6b25lc1t6b25lcy5sZW5ndGggLSAxXS52YWx1ZSkpIHtcblx0XHRcdFx0XHR6b25lcy5wdXNoKHtcblx0XHRcdFx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLFxuXHRcdFx0XHRcdFx0ZmlsbENvbG9yOiB0aGlzLmZpbGxDb2xvclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9LFxuXG5cdFx0Z2V0Q3ljbGljOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUsIGRlZmF1bHRzKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0dXNlck9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0XHRpbmRleE5hbWUgPSAnXycgKyBwcm9wICsgJ0luZGV4Jyxcblx0XHRcdFx0Y291bnRlck5hbWUgPSBwcm9wICsgJ0NvdW50ZXInO1xuXG5cdFx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdGlmIChkZWZpbmVkKHVzZXJPcHRpb25zW2luZGV4TmFtZV0pKSB7IC8vIGFmdGVyIFNlcmllcy51cGRhdGUoKVxuXHRcdFx0XHRcdGkgPSB1c2VyT3B0aW9uc1tpbmRleE5hbWVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVzZXJPcHRpb25zW2luZGV4TmFtZV0gPSBpID0gdGhpcy5jaGFydFtjb3VudGVyTmFtZV0gJSBkZWZhdWx0cy5sZW5ndGg7XG5cdFx0XHRcdFx0dGhpcy5jaGFydFtjb3VudGVyTmFtZV0gKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IGRlZmF1bHRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgY29sb3Jcblx0XHQgKi9cblx0XHRnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50KSB7XG5cdFx0XHRcdHRoaXMuZ2V0Q3ljbGljKCdjb2xvcicsIHRoaXMub3B0aW9ucy5jb2xvciB8fCBkZWZhdWx0UGxvdE9wdGlvbnNbdGhpcy50eXBlXS5jb2xvciwgdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sXG5cdFx0ICovXG5cdFx0Z2V0U3ltYm9sOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzTWFya2VyT3B0aW9uID0gdGhpcy5vcHRpb25zLm1hcmtlcjtcblxuXHRcdFx0dGhpcy5nZXRDeWNsaWMoJ3N5bWJvbCcsIHNlcmllc01hcmtlck9wdGlvbi5zeW1ib2wsIHRoaXMuY2hhcnQub3B0aW9ucy5zeW1ib2xzKTtcblxuXHRcdFx0Ly8gZG9uJ3Qgc3Vic3RyYWN0IHJhZGl1cyBpbiBpbWFnZSBzeW1ib2xzICgjNjA0KVxuXHRcdFx0aWYgKC9edXJsLy50ZXN0KHRoaXMuc3ltYm9sKSkge1xuXHRcdFx0XHRzZXJpZXNNYXJrZXJPcHRpb24ucmFkaXVzID0gMDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZHJhd0xlZ2VuZFN5bWJvbDogTGVnZW5kU3ltYm9sTWl4aW4uZHJhd0xpbmVNYXJrZXIsXG5cblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIHRoZSBzZXJpZXMgZGF0YSB3aXRoIGEgbmV3IHNldCBvZiBkYXRhXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcmVkcmF3XG5cdFx0ICovXG5cdFx0c2V0RGF0YTogZnVuY3Rpb24gKGRhdGEsIHJlZHJhdywgYW5pbWF0aW9uLCB1cGRhdGVQb2ludHMpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvbGREYXRhID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0b2xkRGF0YUxlbmd0aCA9IChvbGREYXRhICYmIG9sZERhdGEubGVuZ3RoKSB8fCAwLFxuXHRcdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRmaXJzdFBvaW50ID0gbnVsbCxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGhhc0NhdGVnb3JpZXMgPSB4QXhpcyAmJiAhIXhBeGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHR1cmJvVGhyZXNob2xkID0gb3B0aW9ucy50dXJib1RocmVzaG9sZCxcblx0XHRcdFx0cHQsXG5cdFx0XHRcdHhEYXRhID0gdGhpcy54RGF0YSxcblx0XHRcdFx0eURhdGEgPSB0aGlzLnlEYXRhLFxuXHRcdFx0XHRwb2ludEFycmF5TWFwID0gc2VyaWVzLnBvaW50QXJyYXlNYXAsXG5cdFx0XHRcdHZhbHVlQ291bnQgPSBwb2ludEFycmF5TWFwICYmIHBvaW50QXJyYXlNYXAubGVuZ3RoO1xuXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBbXTtcblx0XHRcdGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHBvaW50IGNvdW50IGlzIHRoZSBzYW1lIGFzIGlzIHdhcywganVzdCBydW4gUG9pbnQudXBkYXRlIHdoaWNoIGlzXG5cdFx0XHQvLyBjaGVhcGVyLCBhbGxvd3MgYW5pbWF0aW9uLCBhbmQga2VlcHMgcmVmZXJlbmNlcyB0byBwb2ludHMuXG5cdFx0XHRpZiAodXBkYXRlUG9pbnRzICE9PSBmYWxzZSAmJiBkYXRhTGVuZ3RoICYmIG9sZERhdGFMZW5ndGggPT09IGRhdGFMZW5ndGggJiYgIXNlcmllcy5jcm9wcGVkICYmICFzZXJpZXMuaGFzR3JvdXBlZERhdGEgJiYgc2VyaWVzLnZpc2libGUpIHtcblx0XHRcdFx0ZWFjaChkYXRhLCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdFx0XHRpZiAob2xkRGF0YVtpXS51cGRhdGUpIHsgLy8gTGlua2VkLCBwcmV2aW91c2x5IGhpZGRlbiBzZXJpZXMgKCMzNzA5KVxuXHRcdFx0XHRcdFx0b2xkRGF0YVtpXS51cGRhdGUocG9pbnQsIGZhbHNlLCBudWxsLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXNldCBwcm9wZXJ0aWVzXG5cdFx0XHRcdHNlcmllcy54SW5jcmVtZW50ID0gbnVsbDtcblx0XHRcdFx0c2VyaWVzLnBvaW50UmFuZ2UgPSBoYXNDYXRlZ29yaWVzID8gMSA6IG9wdGlvbnMucG9pbnRSYW5nZTtcblxuXHRcdFx0XHRzZXJpZXMuY29sb3JDb3VudGVyID0gMDsgLy8gZm9yIHNlcmllcyB3aXRoIGNvbG9yQnlQb2ludCAoIzE1NDcpXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBVcGRhdGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHRcdGVhY2godGhpcy5wYXJhbGxlbEFycmF5cywgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdHNlcmllc1trZXkgKyAnRGF0YSddLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEluIHR1cmJvIG1vZGUsIG9ubHkgb25lLSBvciB0d29kaW1lbnNpb25hbCBhcnJheXMgb2YgbnVtYmVycyBhcmUgYWxsb3dlZC4gVGhlXG5cdFx0XHRcdC8vIGZpcnN0IHZhbHVlIGlzIHRlc3RlZCwgYW5kIHdlIGFzc3VtZSB0aGF0IGFsbCB0aGUgcmVzdCBhcmUgZGVmaW5lZCB0aGUgc2FtZVxuXHRcdFx0XHQvLyB3YXkuIEFsdGhvdWdoIHRoZSAnZm9yJyBsb29wcyBhcmUgc2ltaWxhciwgdGhleSBhcmUgcmVwZWF0ZWQgaW5zaWRlIGVhY2hcblx0XHRcdFx0Ly8gaWYtZWxzZSBjb25kaXRpb25hbCBmb3IgbWF4IHBlcmZvcm1hbmNlLlxuXHRcdFx0XHRpZiAodHVyYm9UaHJlc2hvbGQgJiYgZGF0YUxlbmd0aCA+IHR1cmJvVGhyZXNob2xkKSB7XG5cblx0XHRcdFx0XHQvLyBmaW5kIHRoZSBmaXJzdCBub24tbnVsbCBwb2ludFxuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlIChmaXJzdFBvaW50ID09PSBudWxsICYmIGkgPCBkYXRhTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRmaXJzdFBvaW50ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmIChpc051bWJlcihmaXJzdFBvaW50KSkgeyAvLyBhc3N1bWUgYWxsIHBvaW50cyBhcmUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0dmFyIHggPSBwaWNrKG9wdGlvbnMucG9pbnRTdGFydCwgMCksXG5cdFx0XHRcdFx0XHRcdHBvaW50SW50ZXJ2YWwgPSBwaWNrKG9wdGlvbnMucG9pbnRJbnRlcnZhbCwgMSk7XG5cblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0eERhdGFbaV0gPSB4O1xuXHRcdFx0XHRcdFx0XHR5RGF0YVtpXSA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdHggKz0gcG9pbnRJbnRlcnZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlcmllcy54SW5jcmVtZW50ID0geDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZmlyc3RQb2ludCkpIHsgLy8gYXNzdW1lIGFsbCBwb2ludHMgYXJlIGFycmF5c1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlQ291bnQpIHsgLy8gW3gsIGxvdywgaGlnaF0gb3IgW3gsIG8sIGgsIGwsIGNdXG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRwdCA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdFx0eERhdGFbaV0gPSBwdFswXTtcblx0XHRcdFx0XHRcdFx0XHR5RGF0YVtpXSA9IHB0LnNsaWNlKDEsIHZhbHVlQ291bnQgKyAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gW3gsIHldXG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRwdCA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdFx0eERhdGFbaV0gPSBwdFswXTtcblx0XHRcdFx0XHRcdFx0XHR5RGF0YVtpXSA9IHB0WzFdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVycm9yKDEyKTsgLy8gSGlnaGNoYXJ0cyBleHBlY3RzIGNvbmZpZ3MgdG8gYmUgbnVtYmVycyBvciBhcnJheXMgaW4gdHVyYm8gbW9kZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YVtpXSAhPT0gVU5ERUZJTkVEKSB7IC8vIHN0cmF5IGNvbW1hcyBpbiBvbGRJRVxuXHRcdFx0XHRcdFx0XHRwdCA9IHsgc2VyaWVzOiBzZXJpZXMgfTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShwdCwgW2RhdGFbaV1dKTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHB0LCBpKTtcblx0XHRcdFx0XHRcdFx0aWYgKGhhc0NhdGVnb3JpZXMgJiYgcHQubmFtZSkge1xuXHRcdFx0XHRcdFx0XHRcdHhBeGlzLm5hbWVzW3B0LnhdID0gcHQubmFtZTsgLy8gIzIwNDZcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmdldHRpbmcgdG8gY2FzdCBzdHJpbmdzIHRvIG51bWJlcnMgaXMgYSBjb21tb24gY2F2ZWF0IHdoZW4gaGFuZGxpbmcgQ1NWIG9yIEpTT05cblx0XHRcdFx0aWYgKGlzU3RyaW5nKHlEYXRhWzBdKSkge1xuXHRcdFx0XHRcdGVycm9yKDE0LCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNlcmllcy5kYXRhID0gW107XG5cdFx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHQvL3Nlcmllcy56RGF0YSA9IHpEYXRhO1xuXG5cdFx0XHRcdC8vIGRlc3Ryb3kgb2xkIHBvaW50c1xuXHRcdFx0XHRpID0gb2xkRGF0YUxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChvbGREYXRhW2ldICYmIG9sZERhdGFbaV0uZGVzdHJveSkge1xuXHRcdFx0XHRcdFx0b2xkRGF0YVtpXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzZXQgbWluUmFuZ2UgKCM4NzgpXG5cdFx0XHRcdGlmICh4QXhpcykge1xuXHRcdFx0XHRcdHhBeGlzLm1pblJhbmdlID0geEF4aXMudXNlck1pblJhbmdlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRcdHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gY2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcm9jZXNzIHRoZSBkYXRhIGJ5IGNyb3BwaW5nIGF3YXkgdW51c2VkIGRhdGEgcG9pbnRzIGlmIHRoZSBzZXJpZXMgaXMgbG9uZ2VyXG5cdFx0ICogdGhhbiB0aGUgY3JvcCB0aHJlc2hvbGQuIFRoaXMgc2F2ZXMgY29tcHV0aW5nIHRpbWUgZm9yIGxhZ2Ugc2VyaWVzLlxuXHRcdCAqL1xuXHRcdHByb2Nlc3NEYXRhOiBmdW5jdGlvbiAoZm9yY2UpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRwcm9jZXNzZWRYRGF0YSA9IHNlcmllcy54RGF0YSwgLy8gY29waWVkIGR1cmluZyBzbGljZSBvcGVyYXRpb24gYmVsb3dcblx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBzZXJpZXMueURhdGEsXG5cdFx0XHRcdGRhdGFMZW5ndGggPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRcdGNyb3BwZWREYXRhLFxuXHRcdFx0XHRjcm9wU3RhcnQgPSAwLFxuXHRcdFx0XHRjcm9wcGVkLFxuXHRcdFx0XHRkaXN0YW5jZSxcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRpLCAvLyBsb29wIHZhcmlhYmxlXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0Y3JvcFRocmVzaG9sZCA9IG9wdGlvbnMuY3JvcFRocmVzaG9sZCxcblx0XHRcdFx0aXNDYXJ0ZXNpYW4gPSBzZXJpZXMuaXNDYXJ0ZXNpYW4sXG5cdFx0XHRcdHhFeHRyZW1lcyxcblx0XHRcdFx0bWluLFxuXHRcdFx0XHRtYXg7XG5cblx0XHRcdC8vIElmIHRoZSBzZXJpZXMgZGF0YSBvciBheGVzIGhhdmVuJ3QgY2hhbmdlZCwgZG9uJ3QgZ28gdGhyb3VnaCB0aGlzLiBSZXR1cm4gZmFsc2UgdG8gcGFzc1xuXHRcdFx0Ly8gdGhlIG1lc3NhZ2Ugb24gdG8gb3ZlcnJpZGUgbWV0aG9kcyBsaWtlIGluIGRhdGEgZ3JvdXBpbmcuXG5cdFx0XHRpZiAoaXNDYXJ0ZXNpYW4gJiYgIXNlcmllcy5pc0RpcnR5ICYmICF4QXhpcy5pc0RpcnR5ICYmICFzZXJpZXMueUF4aXMuaXNEaXJ0eSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeEF4aXMpIHtcblx0XHRcdFx0eEV4dHJlbWVzID0geEF4aXMuZ2V0RXh0cmVtZXMoKTsgLy8gY29ycmVjdGVkIGZvciBsb2cgYXhpcyAoIzMwNTMpXG5cdFx0XHRcdG1pbiA9IHhFeHRyZW1lcy5taW47XG5cdFx0XHRcdG1heCA9IHhFeHRyZW1lcy5tYXg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG9wdGlvbmFsbHkgZmlsdGVyIG91dCBwb2ludHMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhXG5cdFx0XHRpZiAoaXNDYXJ0ZXNpYW4gJiYgc2VyaWVzLnNvcnRlZCAmJiAoIWNyb3BUaHJlc2hvbGQgfHwgZGF0YUxlbmd0aCA+IGNyb3BUaHJlc2hvbGQgfHwgc2VyaWVzLmZvcmNlQ3JvcCkpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGl0J3Mgb3V0c2lkZSBjdXJyZW50IGV4dHJlbWVzXG5cdFx0XHRcdGlmIChwcm9jZXNzZWRYRGF0YVtkYXRhTGVuZ3RoIC0gMV0gPCBtaW4gfHwgcHJvY2Vzc2VkWERhdGFbMF0gPiBtYXgpIHtcblx0XHRcdFx0XHRwcm9jZXNzZWRYRGF0YSA9IFtdO1xuXHRcdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gW107XG5cblx0XHRcdFx0Ly8gb25seSBjcm9wIGlmIGl0J3MgYWN0dWFsbHkgc3BpbGxpbmcgb3V0XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvY2Vzc2VkWERhdGFbMF0gPCBtaW4gfHwgcHJvY2Vzc2VkWERhdGFbZGF0YUxlbmd0aCAtIDFdID4gbWF4KSB7XG5cdFx0XHRcdFx0Y3JvcHBlZERhdGEgPSB0aGlzLmNyb3BEYXRhKHNlcmllcy54RGF0YSwgc2VyaWVzLnlEYXRhLCBtaW4sIG1heCk7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBjcm9wcGVkRGF0YS54RGF0YTtcblx0XHRcdFx0XHRwcm9jZXNzZWRZRGF0YSA9IGNyb3BwZWREYXRhLnlEYXRhO1xuXHRcdFx0XHRcdGNyb3BTdGFydCA9IGNyb3BwZWREYXRhLnN0YXJ0O1xuXHRcdFx0XHRcdGNyb3BwZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHByb2Nlc3NlZCBwb2ludHNcblx0XHRcdGZvciAoaSA9IHByb2Nlc3NlZFhEYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gcHJvY2Vzc2VkWERhdGFbaV0gLSBwcm9jZXNzZWRYRGF0YVtpIC0gMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZGlzdGFuY2UgPiAwICYmIChjbG9zZXN0UG9pbnRSYW5nZSA9PT0gVU5ERUZJTkVEIHx8IGRpc3RhbmNlIDwgY2xvc2VzdFBvaW50UmFuZ2UpKSB7XG5cdFx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0XHQvLyBVbnNvcnRlZCBkYXRhIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGxpbmUgdG9vbHRpcCwgYXMgd2VsbCBhcyBkYXRhIGdyb3VwaW5nIGFuZFxuXHRcdFx0XHQvLyBuYXZpZ2F0aW9uIGluIFN0b2NrIGNoYXJ0cyAoIzcyNSkgYW5kIHdpZHRoIGNhbGN1bGF0aW9uIG9mIGNvbHVtbnMgKCMxOTAwKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRpc3RhbmNlIDwgMCAmJiBzZXJpZXMucmVxdWlyZVNvcnRpbmcpIHtcblx0XHRcdFx0XHRlcnJvcigxNSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBwcm9wZXJ0aWVzXG5cdFx0XHRzZXJpZXMuY3JvcHBlZCA9IGNyb3BwZWQ7IC8vIHVuZGVmaW5lZCBvciB0cnVlXG5cdFx0XHRzZXJpZXMuY3JvcFN0YXJ0ID0gY3JvcFN0YXJ0O1xuXHRcdFx0c2VyaWVzLnByb2Nlc3NlZFhEYXRhID0gcHJvY2Vzc2VkWERhdGE7XG5cdFx0XHRzZXJpZXMucHJvY2Vzc2VkWURhdGEgPSBwcm9jZXNzZWRZRGF0YTtcblxuXHRcdFx0aWYgKG9wdGlvbnMucG9pbnRSYW5nZSA9PT0gbnVsbCkgeyAvLyBudWxsIG1lYW5zIGF1dG8sIGFzIGZvciBjb2x1bW5zLCBjYW5kbGVzdGlja3MgYW5kIE9ITENcblx0XHRcdFx0c2VyaWVzLnBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZSB8fCAxO1xuXHRcdFx0fVxuXHRcdFx0c2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlID0gY2xvc2VzdFBvaW50UmFuZ2U7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSXRlcmF0ZSBvdmVyIHhEYXRhIGFuZCBjcm9wIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LiBSZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGNyb3Agc3RhcnQvZW5kXG5cdFx0ICogY3JvcHBlZCB4RGF0YSB3aXRoIGNvcnJlc3BvbmRpbmcgcGFydCBvZiB5RGF0YSwgZGF0YU1pbiBhbmQgZGF0YU1heCB3aXRoaW4gdGhlIGNyb3BwZWQgcmFuZ2Vcblx0XHQgKi9cblx0XHRjcm9wRGF0YTogZnVuY3Rpb24gKHhEYXRhLCB5RGF0YSwgbWluLCBtYXgpIHtcblx0XHRcdHZhciBkYXRhTGVuZ3RoID0geERhdGEubGVuZ3RoLFxuXHRcdFx0XHRjcm9wU3RhcnQgPSAwLFxuXHRcdFx0XHRjcm9wRW5kID0gZGF0YUxlbmd0aCxcblx0XHRcdFx0Y3JvcFNob3VsZGVyID0gcGljayh0aGlzLmNyb3BTaG91bGRlciwgMSksIC8vIGxpbmUtdHlwZSBzZXJpZXMgbmVlZCBvbmUgcG9pbnQgb3V0c2lkZVxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvLyBpdGVyYXRlIHVwIHRvIGZpbmQgc2xpY2Ugc3RhcnRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhEYXRhW2ldID49IG1pbikge1xuXHRcdFx0XHRcdGNyb3BTdGFydCA9IG1hdGhNYXgoMCwgaSAtIGNyb3BTaG91bGRlcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvY2VlZCB0byBmaW5kIHNsaWNlIGVuZFxuXHRcdFx0Zm9yICg7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhEYXRhW2ldID4gbWF4KSB7XG5cdFx0XHRcdFx0Y3JvcEVuZCA9IGkgKyBjcm9wU2hvdWxkZXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eERhdGE6IHhEYXRhLnNsaWNlKGNyb3BTdGFydCwgY3JvcEVuZCksXG5cdFx0XHRcdHlEYXRhOiB5RGF0YS5zbGljZShjcm9wU3RhcnQsIGNyb3BFbmQpLFxuXHRcdFx0XHRzdGFydDogY3JvcFN0YXJ0LFxuXHRcdFx0XHRlbmQ6IGNyb3BFbmRcblx0XHRcdH07XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgdGhlIGRhdGEgcG9pbnQgYWZ0ZXIgdGhlIGRhdGEgaGFzIGJlZW4gcHJvY2Vzc2VkIGJ5IGNyb3BwaW5nIGF3YXlcblx0XHQgKiB1bnVzZWQgcG9pbnRzIGFuZCBvcHRpb25hbGx5IGdyb3VwZWQgaW4gSGlnaGNoYXJ0cyBTdG9jay5cblx0XHQgKi9cblx0XHRnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0ZGF0YU9wdGlvbnMgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdFx0ZGF0YUxlbmd0aCxcblx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFlEYXRhLFxuXHRcdFx0XHRwb2ludENsYXNzID0gc2VyaWVzLnBvaW50Q2xhc3MsXG5cdFx0XHRcdHByb2Nlc3NlZERhdGFMZW5ndGggPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRcdGNyb3BTdGFydCA9IHNlcmllcy5jcm9wU3RhcnQgfHwgMCxcblx0XHRcdFx0Y3Vyc29yLFxuXHRcdFx0XHRoYXNHcm91cGVkRGF0YSA9IHNlcmllcy5oYXNHcm91cGVkRGF0YSxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHBvaW50cyA9IFtdLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHRpZiAoIWRhdGEgJiYgIWhhc0dyb3VwZWREYXRhKSB7XG5cdFx0XHRcdHZhciBhcnIgPSBbXTtcblx0XHRcdFx0YXJyLmxlbmd0aCA9IGRhdGFPcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhID0gYXJyO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvY2Vzc2VkRGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN1cnNvciA9IGNyb3BTdGFydCArIGk7XG5cdFx0XHRcdGlmICghaGFzR3JvdXBlZERhdGEpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtjdXJzb3JdKSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IGRhdGFbY3Vyc29yXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGFPcHRpb25zW2N1cnNvcl0gIT09IFVOREVGSU5FRCkgeyAvLyAjOTcwXG5cdFx0XHRcdFx0XHRkYXRhW2N1cnNvcl0gPSBwb2ludCA9IChuZXcgcG9pbnRDbGFzcygpKS5pbml0KHNlcmllcywgZGF0YU9wdGlvbnNbY3Vyc29yXSwgcHJvY2Vzc2VkWERhdGFbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb2ludHNbaV0gPSBwb2ludDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBzcGxhdCB0aGUgeSBkYXRhIGluIGNhc2Ugb2Ygb2hsYyBkYXRhIGFycmF5XG5cdFx0XHRcdFx0cG9pbnRzW2ldID0gKG5ldyBwb2ludENsYXNzKCkpLmluaXQoc2VyaWVzLCBbcHJvY2Vzc2VkWERhdGFbaV1dLmNvbmNhdChzcGxhdChwcm9jZXNzZWRZRGF0YVtpXSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwb2ludHNbaV0uaW5kZXggPSBjdXJzb3I7IC8vIEZvciBmYXN0ZXIgYWNjZXNzIGluIFBvaW50LnVwZGF0ZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIaWRlIGNyb3BwZWQtYXdheSBwb2ludHMgLSB0aGlzIG9ubHkgcnVucyB3aGVuIHRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIGFib3ZlIGNyb3BUaHJlc2hvbGQsIG9yIHdoZW5cblx0XHRcdC8vIHN3aXRoY2hpbmcgdmlldyBmcm9tIG5vbi1ncm91cGVkIGRhdGEgdG8gZ3JvdXBlZCBkYXRhICgjNjM3KVxuXHRcdFx0aWYgKGRhdGEgJiYgKHByb2Nlc3NlZERhdGFMZW5ndGggIT09IChkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgpIHx8IGhhc0dyb3VwZWREYXRhKSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGkgPT09IGNyb3BTdGFydCAmJiAhaGFzR3JvdXBlZERhdGEpIHsgLy8gd2hlbiBoYXMgZ3JvdXBlZCBkYXRhLCBjbGVhciBhbGwgcG9pbnRzXG5cdFx0XHRcdFx0XHRpICs9IHByb2Nlc3NlZERhdGFMZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkYXRhW2ldKSB7XG5cdFx0XHRcdFx0XHRkYXRhW2ldLmRlc3Ryb3lFbGVtZW50cygpO1xuXHRcdFx0XHRcdFx0ZGF0YVtpXS5wbG90WCA9IFVOREVGSU5FRDsgLy8gIzEwMDNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c2VyaWVzLmRhdGEgPSBkYXRhO1xuXHRcdFx0c2VyaWVzLnBvaW50cyA9IHBvaW50cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlIFkgZXh0cmVtZXMgZm9yIHZpc2libGUgZGF0YVxuXHRcdCAqL1xuXHRcdGdldEV4dHJlbWVzOiBmdW5jdGlvbiAoeURhdGEpIHtcblx0XHRcdHZhciB4QXhpcyA9IHRoaXMueEF4aXMsXG5cdFx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdFx0eERhdGEgPSB0aGlzLnByb2Nlc3NlZFhEYXRhLFxuXHRcdFx0XHR5RGF0YUxlbmd0aCxcblx0XHRcdFx0YWN0aXZlWURhdGEgPSBbXSxcblx0XHRcdFx0YWN0aXZlQ291bnRlciA9IDAsXG5cdFx0XHRcdHhFeHRyZW1lcyA9IHhBeGlzLmdldEV4dHJlbWVzKCksIC8vICMyMTE3LCBuZWVkIHRvIGNvbXBlbnNhdGUgZm9yIGxvZyBYIGF4aXNcblx0XHRcdFx0eE1pbiA9IHhFeHRyZW1lcy5taW4sXG5cdFx0XHRcdHhNYXggPSB4RXh0cmVtZXMubWF4LFxuXHRcdFx0XHR2YWxpZFZhbHVlLFxuXHRcdFx0XHR3aXRoaW5SYW5nZSxcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ajtcblxuXHRcdFx0eURhdGEgPSB5RGF0YSB8fCB0aGlzLnN0YWNrZWRZRGF0YSB8fCB0aGlzLnByb2Nlc3NlZFlEYXRhO1xuXHRcdFx0eURhdGFMZW5ndGggPSB5RGF0YS5sZW5ndGg7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB5RGF0YUxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdFx0eCA9IHhEYXRhW2ldO1xuXHRcdFx0XHR5ID0geURhdGFbaV07XG5cblx0XHRcdFx0Ly8gRm9yIHBvaW50cyB3aXRoaW4gdGhlIHZpc2libGUgcmFuZ2UsIGluY2x1ZGluZyB0aGUgZmlyc3QgcG9pbnQgb3V0c2lkZSB0aGVcblx0XHRcdFx0Ly8gdmlzaWJsZSByYW5nZSwgY29uc2lkZXIgeSBleHRyZW1lc1xuXHRcdFx0XHR2YWxpZFZhbHVlID0geSAhPT0gbnVsbCAmJiB5ICE9PSBVTkRFRklORUQgJiYgKCF5QXhpcy5pc0xvZyB8fCAoeS5sZW5ndGggfHwgeSA+IDApKTtcblx0XHRcdFx0d2l0aGluUmFuZ2UgPSB0aGlzLmdldEV4dHJlbWVzRnJvbUFsbCB8fCB0aGlzLm9wdGlvbnMuZ2V0RXh0cmVtZXNGcm9tQWxsIHx8IHRoaXMuY3JvcHBlZCB8fFxuXHRcdFx0XHRcdCgoeERhdGFbaSArIDFdIHx8IHgpID49IHhNaW4gJiZcdCh4RGF0YVtpIC0gMV0gfHwgeCkgPD0geE1heCk7XG5cblx0XHRcdFx0aWYgKHZhbGlkVmFsdWUgJiYgd2l0aGluUmFuZ2UpIHtcblxuXHRcdFx0XHRcdGogPSB5Lmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoaikgeyAvLyBhcnJheSwgbGlrZSBvaGxjIG9yIHJhbmdlIGRhdGFcblx0XHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdFx0aWYgKHlbal0gIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRhY3RpdmVZRGF0YVthY3RpdmVDb3VudGVyKytdID0geVtqXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhY3RpdmVZRGF0YVthY3RpdmVDb3VudGVyKytdID0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZGF0YU1pbiA9IGFycmF5TWluKGFjdGl2ZVlEYXRhKTtcblx0XHRcdHRoaXMuZGF0YU1heCA9IGFycmF5TWF4KGFjdGl2ZVlEYXRhKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNsYXRlIGRhdGEgcG9pbnRzIGZyb20gcmF3IGRhdGEgdmFsdWVzIHRvIGNoYXJ0IHNwZWNpZmljIHBvc2l0aW9uaW5nIGRhdGFcblx0XHQgKiBuZWVkZWQgbGF0ZXIgaW4gZHJhd1BvaW50cywgZHJhd0dyYXBoIGFuZCBkcmF3VHJhY2tlci5cblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5wcm9jZXNzZWRYRGF0YSkgeyAvLyBoaWRkZW4gc2VyaWVzXG5cdFx0XHRcdHRoaXMucHJvY2Vzc0RhdGEoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHN0YWNraW5nID0gb3B0aW9ucy5zdGFja2luZyxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGNhdGVnb3JpZXMgPSB4QXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0ZGF0YUxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRcdGhhc01vZGlmeVZhbHVlID0gISFzZXJpZXMubW9kaWZ5VmFsdWUsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBvaW50UGxhY2VtZW50ID0gb3B0aW9ucy5wb2ludFBsYWNlbWVudCxcblx0XHRcdFx0ZHluYW1pY2FsbHlQbGFjZWQgPSBwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nIHx8IGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSxcblx0XHRcdFx0dGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsXG5cdFx0XHRcdHN0YWNrVGhyZXNob2xkID0gb3B0aW9ucy5zdGFydEZyb21UaHJlc2hvbGQgPyB0aHJlc2hvbGQgOiAwLFxuXHRcdFx0XHRwbG90WCxcblx0XHRcdFx0cGxvdFksXG5cdFx0XHRcdGxhc3RQbG90WCxcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2VQeCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblx0XHRcdC8vIFRyYW5zbGF0ZSBlYWNoIHBvaW50XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1tpXSxcblx0XHRcdFx0XHR4VmFsdWUgPSBwb2ludC54LFxuXHRcdFx0XHRcdHlWYWx1ZSA9IHBvaW50LnksXG5cdFx0XHRcdFx0eUJvdHRvbSA9IHBvaW50Lmxvdyxcblx0XHRcdFx0XHRzdGFjayA9IHN0YWNraW5nICYmIHlBeGlzLnN0YWNrc1soc2VyaWVzLm5lZ1N0YWNrcyAmJiB5VmFsdWUgPCAoc3RhY2tUaHJlc2hvbGQgPyAwIDogdGhyZXNob2xkKSA/ICctJyA6ICcnKSArIHNlcmllcy5zdGFja0tleV0sXG5cdFx0XHRcdFx0cG9pbnRTdGFjayxcblx0XHRcdFx0XHRzdGFja1ZhbHVlcztcblxuXHRcdFx0XHQvLyBEaXNjYXJkIGRpc2FsbG93ZWQgeSB2YWx1ZXMgZm9yIGxvZyBheGVzICgjMzQzNClcblx0XHRcdFx0aWYgKHlBeGlzLmlzTG9nICYmIHlWYWx1ZSAhPT0gbnVsbCAmJiB5VmFsdWUgPD0gMCkge1xuXHRcdFx0XHRcdHBvaW50LnkgPSB5VmFsdWUgPSBudWxsO1xuXHRcdFx0XHRcdGVycm9yKDEwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCB0aGUgcGxvdFggdHJhbnNsYXRpb25cblx0XHRcdFx0cG9pbnQucGxvdFggPSBwbG90WCA9IG1hdGhNaW4obWF0aE1heCgtMWU1LCB4QXhpcy50cmFuc2xhdGUoeFZhbHVlLCAwLCAwLCAwLCAxLCBwb2ludFBsYWNlbWVudCwgdGhpcy50eXBlID09PSAnZmxhZ3MnKSksIDFlNSk7IC8vICMzOTIzXG5cblxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGJvdHRvbSB5IHZhbHVlIGZvciBzdGFja2VkIHNlcmllc1xuXHRcdFx0XHRpZiAoc3RhY2tpbmcgJiYgc2VyaWVzLnZpc2libGUgJiYgc3RhY2sgJiYgc3RhY2tbeFZhbHVlXSkge1xuXG5cdFx0XHRcdFx0cG9pbnRTdGFjayA9IHN0YWNrW3hWYWx1ZV07XG5cdFx0XHRcdFx0c3RhY2tWYWx1ZXMgPSBwb2ludFN0YWNrLnBvaW50c1tzZXJpZXMuaW5kZXggKyAnLCcgKyBpXTtcblx0XHRcdFx0XHR5Qm90dG9tID0gc3RhY2tWYWx1ZXNbMF07XG5cdFx0XHRcdFx0eVZhbHVlID0gc3RhY2tWYWx1ZXNbMV07XG5cblx0XHRcdFx0XHRpZiAoeUJvdHRvbSA9PT0gc3RhY2tUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdHlCb3R0b20gPSBwaWNrKHRocmVzaG9sZCwgeUF4aXMubWluKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHlBeGlzLmlzTG9nICYmIHlCb3R0b20gPD0gMCkgeyAvLyAjMTIwMCwgIzEyMzJcblx0XHRcdFx0XHRcdHlCb3R0b20gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBvaW50LnRvdGFsID0gcG9pbnQuc3RhY2tUb3RhbCA9IHBvaW50U3RhY2sudG90YWw7XG5cdFx0XHRcdFx0cG9pbnQucGVyY2VudGFnZSA9IHBvaW50U3RhY2sudG90YWwgJiYgKHBvaW50LnkgLyBwb2ludFN0YWNrLnRvdGFsICogMTAwKTtcblx0XHRcdFx0XHRwb2ludC5zdGFja1kgPSB5VmFsdWU7XG5cblx0XHRcdFx0XHQvLyBQbGFjZSB0aGUgc3RhY2sgbGFiZWxcblx0XHRcdFx0XHRwb2ludFN0YWNrLnNldE9mZnNldChzZXJpZXMucG9pbnRYT2Zmc2V0IHx8IDAsIHNlcmllcy5iYXJXIHx8IDApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdHJhbnNsYXRlZCB5Qm90dG9tIG9yIHJlbW92ZSBpdFxuXHRcdFx0XHRwb2ludC55Qm90dG9tID0gZGVmaW5lZCh5Qm90dG9tKSA/XG5cdFx0XHRcdFx0eUF4aXMudHJhbnNsYXRlKHlCb3R0b20sIDAsIDEsIDAsIDEpIDpcblx0XHRcdFx0XHRudWxsO1xuXG5cdFx0XHRcdC8vIGdlbmVyYWwgaG9vaywgdXNlZCBmb3IgSGlnaHN0b2NrIGNvbXBhcmUgbW9kZVxuXHRcdFx0XHRpZiAoaGFzTW9kaWZ5VmFsdWUpIHtcblx0XHRcdFx0XHR5VmFsdWUgPSBzZXJpZXMubW9kaWZ5VmFsdWUoeVZhbHVlLCBwb2ludCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIHRoZSBwbG90WSB2YWx1ZSwgcmVzZXQgaXQgZm9yIHJlZHJhd3Ncblx0XHRcdFx0cG9pbnQucGxvdFkgPSBwbG90WSA9ICh0eXBlb2YgeVZhbHVlID09PSAnbnVtYmVyJyAmJiB5VmFsdWUgIT09IEluZmluaXR5KSA/XG5cdFx0XHRcdFx0bWF0aE1pbihtYXRoTWF4KC0xZTUsIHlBeGlzLnRyYW5zbGF0ZSh5VmFsdWUsIDAsIDEsIDAsIDEpKSwgMWU1KSA6IC8vICMzMjAxXG5cdFx0XHRcdFx0VU5ERUZJTkVEO1xuXHRcdFx0XHRwb2ludC5pc0luc2lkZSA9IHBsb3RZICE9PSBVTkRFRklORUQgJiYgcGxvdFkgPj0gMCAmJiBwbG90WSA8PSB5QXhpcy5sZW4gJiYgLy8gIzM1MTlcblx0XHRcdFx0XHRwbG90WCA+PSAwICYmIHBsb3RYIDw9IHhBeGlzLmxlbjtcblxuXG5cdFx0XHRcdC8vIFNldCBjbGllbnQgcmVsYXRlZCBwb3NpdGlvbnMgZm9yIG1vdXNlIHRyYWNraW5nXG5cdFx0XHRcdHBvaW50LmNsaWVudFggPSBkeW5hbWljYWxseVBsYWNlZCA/IHhBeGlzLnRyYW5zbGF0ZSh4VmFsdWUsIDAsIDAsIDAsIDEpIDogcGxvdFg7IC8vICMxNTE0XG5cblx0XHRcdFx0cG9pbnQubmVnYXRpdmUgPSBwb2ludC55IDwgKHRocmVzaG9sZCB8fCAwKTtcblxuXHRcdFx0XHQvLyBzb21lIEFQSSBkYXRhXG5cdFx0XHRcdHBvaW50LmNhdGVnb3J5ID0gY2F0ZWdvcmllcyAmJiBjYXRlZ29yaWVzW3BvaW50LnhdICE9PSBVTkRFRklORUQgP1xuXHRcdFx0XHRcdGNhdGVnb3JpZXNbcG9pbnQueF0gOiBwb2ludC54O1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBhdXRvIGVuYWJsaW5nIG9mIG1hcmtlcnMgKCMzNjM1KVxuXHRcdFx0XHRpZiAoaSkge1xuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlUHggPSBtYXRoTWluKGNsb3Nlc3RQb2ludFJhbmdlUHgsIG1hdGhBYnMocGxvdFggLSBsYXN0UGxvdFgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UGxvdFggPSBwbG90WDtcblxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA9IGNsb3Nlc3RQb2ludFJhbmdlUHg7XG5cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIGNyb3BwZWQgZGF0YSwgYnVpbGQgdGhlIHNlZ21lbnRzXG5cdFx0XHRzZXJpZXMuZ2V0U2VnbWVudHMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjbGlwcGluZyBmb3IgdGhlIHNlcmllcy4gRm9yIGFuaW1hdGVkIHNlcmllcyBpdCBpcyBjYWxsZWQgdHdpY2UsIGZpcnN0IHRvIGluaXRpYXRlXG5cdFx0ICogYW5pbWF0aW5nIHRoZSBjbGlwIHRoZW4gdGhlIHNlY29uZCB0aW1lIHdpdGhvdXQgdGhlIGFuaW1hdGlvbiB0byBzZXQgdGhlIGZpbmFsIGNsaXAuXG5cdFx0ICovXG5cdFx0c2V0Q2xpcDogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0c2VyaWVzQ2xpcEJveCA9IHRoaXMuY2xpcEJveCxcblx0XHRcdFx0Y2xpcEJveCA9IHNlcmllc0NsaXBCb3ggfHwgY2hhcnQuY2xpcEJveCxcblx0XHRcdFx0c2hhcmVkQ2xpcEtleSA9IHRoaXMuc2hhcmVkQ2xpcEtleSB8fCBbJ19zaGFyZWRDbGlwJywgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5kdXJhdGlvbiwgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5lYXNpbmcsIGNsaXBCb3guaGVpZ2h0XS5qb2luKCcsJyksXG5cdFx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV0sXG5cdFx0XHRcdG1hcmtlckNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ107XG5cblx0XHRcdC8vIElmIGEgY2xpcHBpbmcgcmVjdGFuZ2xlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBpcyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgY2hhcnQsIHVzZSB0aGF0LlxuXHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXG5cdFx0XHRcdC8vIFdoZW4gYW5pbWF0aW9uIGlzIHNldCwgcHJlcGFyZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnNcblx0XHRcdFx0aWYgKGFuaW1hdGlvbikgeyBcblx0XHRcdFx0XHRjbGlwQm94LndpZHRoID0gMDtcblxuXHRcdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddID0gbWFya2VyQ2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChcblx0XHRcdFx0XHRcdC05OSwgLy8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIGZpcnN0IG1hcmtlclxuXHRcdFx0XHRcdFx0aW52ZXJ0ZWQgPyAtY2hhcnQucGxvdExlZnQgOiAtY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHRcdDk5LFxuXHRcdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5jaGFydFdpZHRoIDogY2hhcnQuY2hhcnRIZWlnaHRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXldID0gY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQm94KTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGNsaXBSZWN0LmNvdW50ICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpcCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5ncm91cC5jbGlwKGFuaW1hdGlvbiB8fCBzZXJpZXNDbGlwQm94ID8gY2xpcFJlY3QgOiBjaGFydC5jbGlwUmVjdCk7XG5cdFx0XHRcdHRoaXMubWFya2VyR3JvdXAuY2xpcChtYXJrZXJDbGlwUmVjdCk7XG5cdFx0XHRcdHRoaXMuc2hhcmVkQ2xpcEtleSA9IHNoYXJlZENsaXBLZXk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgc2hhcmVkIGNsaXBwaW5nIHJlY3RhbmdsZSB3aGVuIGFsbCBzZXJpZXMgYXJlIHNob3duXG5cdFx0XHRpZiAoIWFuaW1hdGlvbikge1xuXHRcdFx0XHRjbGlwUmVjdC5jb3VudCAtPSAxO1xuXHRcdFx0XHRpZiAoY2xpcFJlY3QuY291bnQgPD0gMCAmJiBzaGFyZWRDbGlwS2V5ICYmIGNoYXJ0W3NoYXJlZENsaXBLZXldKSB7XG5cdFx0XHRcdFx0aWYgKCFzZXJpZXNDbGlwQm94KSB7XG5cdFx0XHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5XSA9IGNoYXJ0W3NoYXJlZENsaXBLZXldLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddKSB7XG5cdFx0XHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXSA9IGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBpbiB0aGUgc2VyaWVzXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGluaXQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0Y2xpcFJlY3QsXG5cdFx0XHRcdGFuaW1hdGlvbiA9IHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbixcblx0XHRcdFx0c2hhcmVkQ2xpcEtleTtcblxuXHRcdFx0Ly8gQW5pbWF0aW9uIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZVxuXHRcdFx0aWYgKGFuaW1hdGlvbiAmJiAhaXNPYmplY3QoYW5pbWF0aW9uKSkge1xuXHRcdFx0XHRhbmltYXRpb24gPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLmFuaW1hdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgYW5pbWF0aW9uLiBTZXQgdXAgdGhlIGNsaXBwaW5nIHJlY3RhbmdsZS5cblx0XHRcdGlmIChpbml0KSB7XG5cblx0XHRcdFx0c2VyaWVzLnNldENsaXAoYW5pbWF0aW9uKTtcblxuXHRcdFx0Ly8gUnVuIHRoZSBhbmltYXRpb25cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNoYXJlZENsaXBLZXkgPSB0aGlzLnNoYXJlZENsaXBLZXk7XG5cdFx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV07XG5cdFx0XHRcdGlmIChjbGlwUmVjdCkge1xuXHRcdFx0XHRcdGNsaXBSZWN0LmFuaW1hdGUoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RTaXplWFxuXHRcdFx0XHRcdH0sIGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddKSB7XG5cdFx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10uYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFNpemVYICsgOTlcblx0XHRcdFx0XHR9LCBhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgaXQgb25seSBvbmNlXG5cdFx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0IFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHJ1bnMgYWZ0ZXIgYW5pbWF0aW9uIHRvIGxhbmQgb24gdGhlIGZpbmFsIHBsb3QgY2xpcHBpbmdcblx0XHQgKi9cblx0XHRhZnRlckFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2V0Q2xpcCgpO1xuXHRcdFx0ZmlyZUV2ZW50KHRoaXMsICdhZnRlckFuaW1hdGUnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgbWFya2Vyc1xuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRwbG90WCxcblx0XHRcdFx0cGxvdFksXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRyYWRpdXMsXG5cdFx0XHRcdHN5bWJvbCxcblx0XHRcdFx0aXNJbWFnZSxcblx0XHRcdFx0Z3JhcGhpYyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRzZXJpZXNNYXJrZXJPcHRpb25zID0gb3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRcdHNlcmllc1BvaW50QXR0ciA9IHNlcmllcy5wb2ludEF0dHJbJyddLFxuXHRcdFx0XHRwb2ludE1hcmtlck9wdGlvbnMsXG5cdFx0XHRcdGhhc1BvaW50TWFya2VyLFxuXHRcdFx0XHRlbmFibGVkLFxuXHRcdFx0XHRpc0luc2lkZSxcblx0XHRcdFx0bWFya2VyR3JvdXAgPSBzZXJpZXMubWFya2VyR3JvdXAsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRnbG9iYWxseUVuYWJsZWQgPSBwaWNrKFxuXHRcdFx0XHRcdHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCwgXG5cdFx0XHRcdFx0eEF4aXMuaXNSYWRpYWwsXG5cdFx0XHRcdFx0c2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlUHggPiAyICogc2VyaWVzTWFya2VyT3B0aW9ucy5yYWRpdXNcblx0XHRcdFx0KTtcblxuXHRcdFx0aWYgKHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UgfHwgc2VyaWVzLl9oYXNQb2ludE1hcmtlcnMpIHtcblxuXHRcdFx0XHRpID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRcdHBsb3RYID0gbWF0aEZsb29yKHBvaW50LnBsb3RYKTsgLy8gIzE4NDNcblx0XHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZO1xuXHRcdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljO1xuXHRcdFx0XHRcdHBvaW50TWFya2VyT3B0aW9ucyA9IHBvaW50Lm1hcmtlciB8fCB7fTtcblx0XHRcdFx0XHRoYXNQb2ludE1hcmtlciA9ICEhcG9pbnQubWFya2VyO1xuXHRcdFx0XHRcdGVuYWJsZWQgPSAoZ2xvYmFsbHlFbmFibGVkICYmIHBvaW50TWFya2VyT3B0aW9ucy5lbmFibGVkID09PSBVTkRFRklORUQpIHx8IHBvaW50TWFya2VyT3B0aW9ucy5lbmFibGVkO1xuXHRcdFx0XHRcdGlzSW5zaWRlID0gcG9pbnQuaXNJbnNpZGU7XG5cblx0XHRcdFx0XHQvLyBvbmx5IGRyYXcgdGhlIHBvaW50IGlmIHkgaXMgZGVmaW5lZFxuXHRcdFx0XHRcdGlmIChlbmFibGVkICYmIHBsb3RZICE9PSBVTkRFRklORUQgJiYgIWlzTmFOKHBsb3RZKSAmJiBwb2ludC55ICE9PSBudWxsKSB7XG5cblx0XHRcdFx0XHRcdC8vIHNob3J0Y3V0c1xuXHRcdFx0XHRcdFx0cG9pbnRBdHRyID0gcG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXSB8fCBzZXJpZXNQb2ludEF0dHI7XG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBwb2ludEF0dHIucjtcblx0XHRcdFx0XHRcdHN5bWJvbCA9IHBpY2socG9pbnRNYXJrZXJPcHRpb25zLnN5bWJvbCwgc2VyaWVzLnN5bWJvbCk7XG5cdFx0XHRcdFx0XHRpc0ltYWdlID0gc3ltYm9sLmluZGV4T2YoJ3VybCcpID09PSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAoZ3JhcGhpYykgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRcdFx0Z3JhcGhpY1tpc0luc2lkZSA/ICdzaG93JyA6ICdoaWRlJ10odHJ1ZSkgLy8gU2luY2UgdGhlIG1hcmtlciBncm91cCBpc24ndCBjbGlwcGVkLCBlYWNoIGluZGl2aWR1YWwgbWFya2VyIG11c3QgYmUgdG9nZ2xlZFxuXHRcdFx0XHRcdFx0XHRcdC5hbmltYXRlKGV4dGVuZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzXG5cdFx0XHRcdFx0XHRcdFx0fSwgZ3JhcGhpYy5zeW1ib2xOYW1lID8geyAvLyBkb24ndCBhcHBseSB0byBpbWFnZSBzeW1ib2xzICM1MDdcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAyICogcmFkaXVzXG5cdFx0XHRcdFx0XHRcdFx0fSA6IHt9KSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzSW5zaWRlICYmIChyYWRpdXMgPiAwIHx8IGlzSW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljID0gY2hhcnQucmVuZGVyZXIuc3ltYm9sKFxuXHRcdFx0XHRcdFx0XHRcdHN5bWJvbCxcblx0XHRcdFx0XHRcdFx0XHRwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRwbG90WSAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0aGFzUG9pbnRNYXJrZXIgPyBwb2ludE1hcmtlck9wdGlvbnMgOiBzZXJpZXNNYXJrZXJPcHRpb25zXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0LmF0dHIocG9pbnRBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYWRkKG1hcmtlckdyb3VwKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMuZGVzdHJveSgpOyAvLyAjMTI2OVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnQgc3RhdGUgcHJvcGVydGllcyBmcm9tIEFQSSBuYW1pbmcgY29udmVudGlvbnMgdG8gU1ZHIGF0dHJpYnV0ZXNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFQSSBvcHRpb25zIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBiYXNlMSBTVkcgYXR0cmlidXRlIG9iamVjdCB0byBpbmhlcml0IGZyb21cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYmFzZTIgU2Vjb25kIGxldmVsIFNWRyBhdHRyaWJ1dGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbVxuXHRcdCAqL1xuXHRcdGNvbnZlcnRBdHRyaWJzOiBmdW5jdGlvbiAob3B0aW9ucywgYmFzZTEsIGJhc2UyLCBiYXNlMykge1xuXHRcdFx0dmFyIGNvbnZlcnNpb24gPSB0aGlzLnBvaW50QXR0clRvT3B0aW9ucyxcblx0XHRcdFx0YXR0cixcblx0XHRcdFx0b3B0aW9uLFxuXHRcdFx0XHRvYmogPSB7fTtcblxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRiYXNlMSA9IGJhc2UxIHx8IHt9O1xuXHRcdFx0YmFzZTIgPSBiYXNlMiB8fCB7fTtcblx0XHRcdGJhc2UzID0gYmFzZTMgfHwge307XG5cblx0XHRcdGZvciAoYXR0ciBpbiBjb252ZXJzaW9uKSB7XG5cdFx0XHRcdG9wdGlvbiA9IGNvbnZlcnNpb25bYXR0cl07XG5cdFx0XHRcdG9ialthdHRyXSA9IHBpY2sob3B0aW9uc1tvcHRpb25dLCBiYXNlMVthdHRyXSwgYmFzZTJbYXR0cl0sIGJhc2UzW2F0dHJdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc3RhdGUgYXR0cmlidXRlcy4gRWFjaCBzZXJpZXMgdHlwZSBoYXMgaXRzIG93biBzZXQgb2YgYXR0cmlidXRlc1xuXHRcdCAqIHRoYXQgYXJlIGFsbG93ZWQgdG8gY2hhbmdlIG9uIGEgcG9pbnQncyBzdGF0ZSBjaGFuZ2UuIFNlcmllcyB3aWRlIGF0dHJpYnV0ZXMgYXJlIHN0b3JlZCBmb3Jcblx0XHQgKiBhbGwgc2VyaWVzLCBhbmQgYWRkaXRpb25hbGx5IHBvaW50IHNwZWNpZmljIGF0dHJpYnV0ZXMgYXJlIHN0b3JlZCBmb3IgYWxsXG5cdFx0ICogcG9pbnRzIHdpdGggaW5kaXZpZHVhbCBtYXJrZXIgb3B0aW9ucy4gSWYgc3VjaCBvcHRpb25zIGFyZSBub3QgZGVmaW5lZCBmb3IgdGhlIHBvaW50LFxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBzZXJpZXMgd2lkZSBhdHRyaWJ1dGVzIGlzIHN0b3JlZCBpbiBwb2ludC5wb2ludEF0dHIuXG5cdFx0ICovXG5cdFx0Z2V0QXR0cmliczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0bm9ybWFsT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9uc1tzZXJpZXMudHlwZV0ubWFya2VyID8gc2VyaWVzT3B0aW9ucy5tYXJrZXIgOiBzZXJpZXNPcHRpb25zLFxuXHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBub3JtYWxPcHRpb25zLnN0YXRlcyxcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIgPSBzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdLFxuXHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyLFxuXHRcdFx0XHRzZXJpZXNDb2xvciA9IHNlcmllcy5jb2xvcixcblx0XHRcdFx0c2VyaWVzTmVnYXRpdmVDb2xvciA9IHNlcmllcy5vcHRpb25zLm5lZ2F0aXZlQ29sb3IsXG5cdFx0XHRcdG5vcm1hbERlZmF1bHRzID0ge1xuXHRcdFx0XHRcdHN0cm9rZTogc2VyaWVzQ29sb3IsXG5cdFx0XHRcdFx0ZmlsbDogc2VyaWVzQ29sb3Jcblx0XHRcdFx0fSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyB8fCBbXSwgLy8gIzkyN1xuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyID0gW10sXG5cdFx0XHRcdHBvaW50QXR0cixcblx0XHRcdFx0cG9pbnRBdHRyVG9PcHRpb25zID0gc2VyaWVzLnBvaW50QXR0clRvT3B0aW9ucyxcblx0XHRcdFx0aGFzUG9pbnRTcGVjaWZpY09wdGlvbnMgPSBzZXJpZXMuaGFzUG9pbnRTcGVjaWZpY09wdGlvbnMsXG5cdFx0XHRcdGRlZmF1bHRMaW5lQ29sb3IgPSBub3JtYWxPcHRpb25zLmxpbmVDb2xvcixcblx0XHRcdFx0ZGVmYXVsdEZpbGxDb2xvciA9IG5vcm1hbE9wdGlvbnMuZmlsbENvbG9yLFxuXHRcdFx0XHR0dXJib1RocmVzaG9sZCA9IHNlcmllc09wdGlvbnMudHVyYm9UaHJlc2hvbGQsXG5cdFx0XHRcdHpvbmVzID0gc2VyaWVzLnpvbmVzLFxuXHRcdFx0XHR6b25lQXhpcyA9IHNlcmllcy56b25lQXhpcyB8fCAneScsXG5cdFx0XHRcdGF0dHIsXG5cdFx0XHRcdGtleTtcblxuXHRcdFx0Ly8gc2VyaWVzIHR5cGUgc3BlY2lmaWMgbW9kaWZpY2F0aW9uc1xuXHRcdFx0aWYgKHNlcmllc09wdGlvbnMubWFya2VyKSB7IC8vIGxpbmUsIHNwbGluZSwgYXJlYSwgYXJlYXNwbGluZSwgc2NhdHRlclxuXG5cdFx0XHRcdC8vIGlmIG5vIGhvdmVyIHJhZGl1cyBpcyBnaXZlbiwgZGVmYXVsdCB0byBub3JtYWwgcmFkaXVzICsgMlxuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgPSBzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgfHwgbm9ybWFsT3B0aW9ucy5yYWRpdXMgKyBzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXNQbHVzO1xuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGggPSBzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGggfHwgbm9ybWFsT3B0aW9ucy5saW5lV2lkdGggKyBzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGhQbHVzO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBjb2x1bW4sIGJhciwgcGllXG5cblx0XHRcdFx0Ly8gaWYgbm8gaG92ZXIgY29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgY29sb3Jcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIuY29sb3IgPSBzdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciB8fFxuXHRcdFx0XHRcdENvbG9yKHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8IHNlcmllc0NvbG9yKVxuXHRcdFx0XHRcdFx0LmJyaWdodGVuKHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpLmdldCgpO1xuXG5cdFx0XHRcdC8vIGlmIG5vIGhvdmVyIG5lZ2F0aXZlQ29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgbmVnYXRpdmVDb2xvclxuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5uZWdhdGl2ZUNvbG9yID0gc3RhdGVPcHRpb25zSG92ZXIubmVnYXRpdmVDb2xvciB8fFxuXHRcdFx0XHRcdENvbG9yKHN0YXRlT3B0aW9uc0hvdmVyLm5lZ2F0aXZlQ29sb3IgfHwgc2VyaWVzTmVnYXRpdmVDb2xvcilcblx0XHRcdFx0XHRcdC5icmlnaHRlbihzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKS5nZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhbCBwb2ludCBhdHRyaWJ1dGVzIGZvciB0aGUgc2VyaWVzIG5vcm1hbCBzdGF0ZVxuXHRcdFx0c2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMobm9ybWFsT3B0aW9ucywgbm9ybWFsRGVmYXVsdHMpO1xuXG5cdFx0XHQvLyBIT1ZFUl9TVEFURSBhbmQgU0VMRUNUX1NUQVRFIHN0YXRlcyBpbmhlcml0IGZyb20gbm9ybWFsIHN0YXRlIGV4Y2VwdCB0aGUgZGVmYXVsdCByYWRpdXNcblx0XHRcdGVhY2goW0hPVkVSX1NUQVRFLCBTRUxFQ1RfU1RBVEVdLCBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW3N0YXRlXSA9XG5cdFx0XHRcdFx0XHRzZXJpZXMuY29udmVydEF0dHJpYnMoc3RhdGVPcHRpb25zW3N0YXRlXSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNldCBpdFxuXHRcdFx0c2VyaWVzLnBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblxuXG5cdFx0XHQvLyBHZW5lcmF0ZSB0aGUgcG9pbnQtc3BlY2lmaWMgYXR0cmlidXRlIGNvbGxlY3Rpb25zIGlmIHNwZWNpZmljIHBvaW50XG5cdFx0XHQvLyBvcHRpb25zIGFyZSBnaXZlbi4gSWYgbm90LCBjcmVhdGUgYSByZWZlcmFuY2UgdG8gdGhlIHNlcmllcyB3aWRlIHBvaW50XG5cdFx0XHQvLyBhdHRyaWJ1dGVzXG5cdFx0XHRpID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdGlmICghdHVyYm9UaHJlc2hvbGQgfHwgaSA8IHR1cmJvVGhyZXNob2xkIHx8IGhhc1BvaW50U3BlY2lmaWNPcHRpb25zKSB7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0XHRub3JtYWxPcHRpb25zID0gKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5tYXJrZXIpIHx8IHBvaW50Lm9wdGlvbnM7XG5cdFx0XHRcdFx0aWYgKG5vcm1hbE9wdGlvbnMgJiYgbm9ybWFsT3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0bm9ybWFsT3B0aW9ucy5yYWRpdXMgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh6b25lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHZhciBqID0gMCxcblx0XHRcdFx0XHRcdFx0dGhyZXNob2xkID0gem9uZXNbal07XG5cdFx0XHRcdFx0XHR3aGlsZSAocG9pbnRbem9uZUF4aXNdID49IHRocmVzaG9sZC52YWx1ZSkge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHRocmVzaG9sZCA9IHpvbmVzWysral07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHBvaW50LmNvbG9yID0gcG9pbnQuZmlsbENvbG9yID0gdGhyZXNob2xkLmNvbG9yO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gc2VyaWVzT3B0aW9ucy5jb2xvckJ5UG9pbnQgfHwgcG9pbnQuY29sb3I7IC8vICM4NjhcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBwb2ludCBoYXMgc3BlY2lmaWMgdmlzdWFsIG9wdGlvbnNcblx0XHRcdFx0XHRpZiAocG9pbnQub3B0aW9ucykge1xuXHRcdFx0XHRcdFx0Zm9yIChrZXkgaW4gcG9pbnRBdHRyVG9PcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkZWZpbmVkKG5vcm1hbE9wdGlvbnNbcG9pbnRBdHRyVG9PcHRpb25zW2tleV1dKSkge1xuXHRcdFx0XHRcdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGEgc3BlY2lmaWMgbWFya2VyIGNvbmZpZyBvYmplY3QgaXMgZGVmaW5lZCBmb3IgdGhlIGluZGl2aWR1YWwgcG9pbnQ6XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGl0J3Mgb3duIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRcdFx0aWYgKGhhc1BvaW50U3BlY2lmaWNPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxPcHRpb25zID0gbm9ybWFsT3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0XHRcdHBvaW50QXR0ciA9IFtdO1xuXHRcdFx0XHRcdFx0c3RhdGVPcHRpb25zID0gbm9ybWFsT3B0aW9ucy5zdGF0ZXMgfHwge307IC8vIHJlYXNzaWduIGZvciBpbmRpdmlkdWFsIHBvaW50XG5cdFx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyID0gc3RhdGVPcHRpb25zW0hPVkVSX1NUQVRFXSA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBjb2xvcnMgZm9yIGNvbHVtbiBhbmQgcGllc1xuXHRcdFx0XHRcdFx0aWYgKCFzZXJpZXNPcHRpb25zLm1hcmtlcikgeyAvLyBjb2x1bW4sIGJhciwgcG9pbnRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgbm8gaG92ZXIgY29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgY29sb3IuICMxNjE5LCAjMjU3OVxuXHRcdFx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yID0gcG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciB8fCAoIXBvaW50Lm9wdGlvbnMuY29sb3IgJiYgc3RhdGVPcHRpb25zSG92ZXJbKHBvaW50Lm5lZ2F0aXZlICYmIHNlcmllc05lZ2F0aXZlQ29sb3IgPyAnbmVnYXRpdmVDb2xvcicgOiAnY29sb3InKV0pIHx8XG5cdFx0XHRcdFx0XHRcdFx0Q29sb3IocG9pbnQuY29sb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYnJpZ2h0ZW4ocG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzIHx8IHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpXG5cdFx0XHRcdFx0XHRcdFx0XHQuZ2V0KCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbCBwb2ludCBzdGF0ZSBpbmhlcml0cyBzZXJpZXMgd2lkZSBub3JtYWwgc3RhdGVcblx0XHRcdFx0XHRcdGF0dHIgPSB7IGNvbG9yOiBwb2ludC5jb2xvciB9OyAvLyAjODY4XG5cdFx0XHRcdFx0XHRpZiAoIWRlZmF1bHRGaWxsQ29sb3IpIHsgLy8gSW5kaXZpZHVhbCBwb2ludCBjb2xvciBvciBuZWdhdGl2ZSBjb2xvciBtYXJrZXJzICgjMjIxOSlcblx0XHRcdFx0XHRcdFx0YXR0ci5maWxsQ29sb3IgPSBwb2ludC5jb2xvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghZGVmYXVsdExpbmVDb2xvcikge1xuXHRcdFx0XHRcdFx0XHRhdHRyLmxpbmVDb2xvciA9IHBvaW50LmNvbG9yOyAvLyBCdWJibGVzIHRha2UgcG9pbnQgY29sb3IsIGxpbmUgbWFya2VycyB1c2Ugd2hpdGVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENvbG9yIGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkICgjMTI4OCwgIzQwNjgpXG5cdFx0XHRcdFx0XHRpZiAobm9ybWFsT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29sb3InKSAmJiAhbm9ybWFsT3B0aW9ucy5jb2xvcikge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgbm9ybWFsT3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKGV4dGVuZChhdHRyLCBub3JtYWxPcHRpb25zKSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXG5cdFx0XHRcdFx0XHQvLyBpbmhlcml0IGZyb20gcG9pbnQgbm9ybWFsIGFuZCBzZXJpZXMgaG92ZXJcblx0XHRcdFx0XHRcdHBvaW50QXR0cltIT1ZFUl9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMoXG5cdFx0XHRcdFx0XHRcdHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHNlcmllc1BvaW50QXR0cltIT1ZFUl9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBpbmhlcml0IGZyb20gcG9pbnQgbm9ybWFsIGFuZCBzZXJpZXMgaG92ZXJcblx0XHRcdFx0XHRcdHBvaW50QXR0cltTRUxFQ1RfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdFx0XHRzdGF0ZU9wdGlvbnNbU0VMRUNUX1NUQVRFXSxcblx0XHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW1NFTEVDVF9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0XHQpO1xuXG5cblx0XHRcdFx0XHQvLyBubyBtYXJrZXIgY29uZmlnIG9iamVjdCBpcyBjcmVhdGVkOiBjb3B5IGEgcmVmZXJlbmNlIHRvIHRoZSBzZXJpZXMtd2lkZVxuXHRcdFx0XHRcdC8vIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwb2ludC5wb2ludEF0dHIgPSBwb2ludEF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2xlYXIgRE9NIG9iamVjdHMgYW5kIGZyZWUgdXAgbWVtb3J5XG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRpc3N1ZTEzNCA9IC9BcHBsZVdlYktpdFxcLzUzMy8udGVzdCh1c2VyQWdlbnQpLFxuXHRcdFx0XHRkZXN0cm95LFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEgfHwgW10sXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwcm9wLFxuXHRcdFx0XHRheGlzO1xuXG5cdFx0XHQvLyBhZGQgZXZlbnQgaG9va1xuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ2Rlc3Ryb3knKTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCBldmVudHNcblx0XHRcdHJlbW92ZUV2ZW50KHNlcmllcyk7XG5cblx0XHRcdC8vIGVyYXNlIGZyb20gYXhlc1xuXHRcdFx0ZWFjaChzZXJpZXMuYXhpc1R5cGVzIHx8IFtdLCBmdW5jdGlvbiAoQVhJUykge1xuXHRcdFx0XHRheGlzID0gc2VyaWVzW0FYSVNdO1xuXHRcdFx0XHRpZiAoYXhpcykge1xuXHRcdFx0XHRcdGVyYXNlKGF4aXMuc2VyaWVzLCBzZXJpZXMpO1xuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGF4aXMuZm9yY2VSZWRyYXcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGxlZ2VuZCBpdGVtc1xuXHRcdFx0aWYgKHNlcmllcy5sZWdlbmRJdGVtKSB7XG5cdFx0XHRcdHNlcmllcy5jaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0oc2VyaWVzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVzdHJveSBhbGwgcG9pbnRzIHdpdGggdGhlaXIgZWxlbWVudHNcblx0XHRcdGkgPSBkYXRhLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cG9pbnQgPSBkYXRhW2ldO1xuXHRcdFx0XHRpZiAocG9pbnQgJiYgcG9pbnQuZGVzdHJveSkge1xuXHRcdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VyaWVzLnBvaW50cyA9IG51bGw7XG5cblx0XHRcdC8vIENsZWFyIHRoZSBhbmltYXRpb24gdGltZW91dCBpZiB3ZSBhcmUgZGVzdHJveWluZyB0aGUgc2VyaWVzIGR1cmluZyBpbml0aWFsIGFuaW1hdGlvblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHNlcmllcy5hbmltYXRpb25UaW1lb3V0KTtcblxuXHRcdFx0Ly8gRGVzdHJveSBhbGwgU1ZHRWxlbWVudHMgYXNzb2NpYXRlZCB0byB0aGUgc2VyaWVzXG5cdFx0XHRmb3IgKHByb3AgaW4gc2VyaWVzKSB7XG5cdFx0XHRcdGlmIChzZXJpZXNbcHJvcF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmICFzZXJpZXNbcHJvcF0uc3Vydml2ZSkgeyAvLyBTdXJ2aXZlIHByb3ZpZGVzIGEgaG9vayBmb3Igbm90IGRlc3Ryb3lpbmdcblxuXHRcdFx0XHRcdC8vIGlzc3VlIDEzNCB3b3JrYXJvdW5kXG5cdFx0XHRcdFx0ZGVzdHJveSA9IGlzc3VlMTM0ICYmIHByb3AgPT09ICdncm91cCcgP1xuXHRcdFx0XHRcdFx0J2hpZGUnIDpcblx0XHRcdFx0XHRcdCdkZXN0cm95JztcblxuXHRcdFx0XHRcdHNlcmllc1twcm9wXVtkZXN0cm95XSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBmcm9tIGhvdmVyU2VyaWVzXG5cdFx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgPT09IHNlcmllcykge1xuXHRcdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlcmFzZShjaGFydC5zZXJpZXMsIHNlcmllcyk7XG5cblx0XHRcdC8vIGNsZWFyIGFsbCBtZW1iZXJzXG5cdFx0XHRmb3IgKHByb3AgaW4gc2VyaWVzKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXJpZXNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgZ3JhcGggcGF0aCBvZiBhIHNlZ21lbnRcblx0XHQgKi9cblx0XHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZWdtZW50UGF0aCA9IFtdLFxuXHRcdFx0XHRzdGVwID0gc2VyaWVzLm9wdGlvbnMuc3RlcDtcblxuXHRcdFx0Ly8gYnVpbGQgdGhlIHNlZ21lbnQgbGluZVxuXHRcdFx0ZWFjaChzZWdtZW50LCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblxuXHRcdFx0XHR2YXIgcGxvdFggPSBwb2ludC5wbG90WCxcblx0XHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGxhc3RQb2ludDtcblxuXHRcdFx0XHRpZiAoc2VyaWVzLmdldFBvaW50U3BsaW5lKSB7IC8vIGdlbmVyYXRlIHRoZSBzcGxpbmUgYXMgZGVmaW5lZCBpbiB0aGUgU3BsaW5lU2VyaWVzIG9iamVjdFxuXHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2guYXBwbHkoc2VnbWVudFBhdGgsIHNlcmllcy5nZXRQb2ludFNwbGluZShzZWdtZW50LCBwb2ludCwgaSkpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBtb3ZlVG8gb3IgbGluZVRvXG5cdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChpID8gTCA6IE0pO1xuXG5cdFx0XHRcdFx0Ly8gc3RlcCBsaW5lP1xuXHRcdFx0XHRcdGlmIChzdGVwICYmIGkpIHtcblx0XHRcdFx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdO1xuXHRcdFx0XHRcdFx0aWYgKHN0ZXAgPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdGVwID09PSAnY2VudGVyJykge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdChsYXN0UG9pbnQucGxvdFggKyBwbG90WCkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0XHRcdFx0XHQobGFzdFBvaW50LnBsb3RYICsgcGxvdFgpIC8gMixcblx0XHRcdFx0XHRcdFx0XHRwbG90WVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG5vcm1hbCBsaW5lIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0cG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRwb2ludC5wbG90WVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gc2VnbWVudFBhdGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZ3JhcGggcGF0aFxuXHRcdCAqL1xuXHRcdGdldEdyYXBoUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGdyYXBoUGF0aCA9IFtdLFxuXHRcdFx0XHRzZWdtZW50UGF0aCxcblx0XHRcdFx0c2luZ2xlUG9pbnRzID0gW107IC8vIHVzZWQgaW4gZHJhd1RyYWNrZXJcblxuXHRcdFx0Ly8gRGl2aWRlIGludG8gc2VnbWVudHMgYW5kIGJ1aWxkIGdyYXBoIGFuZCBhcmVhIHBhdGhzXG5cdFx0XHRlYWNoKHNlcmllcy5zZWdtZW50cywgZnVuY3Rpb24gKHNlZ21lbnQpIHtcblxuXHRcdFx0XHRzZWdtZW50UGF0aCA9IHNlcmllcy5nZXRTZWdtZW50UGF0aChzZWdtZW50KTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIHNlZ21lbnQgdG8gdGhlIGdyYXBoLCBvciBhIHNpbmdsZSBwb2ludCBmb3IgdHJhY2tpbmdcblx0XHRcdFx0aWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGdyYXBoUGF0aCA9IGdyYXBoUGF0aC5jb25jYXQoc2VnbWVudFBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNpbmdsZVBvaW50cy5wdXNoKHNlZ21lbnRbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmVjb3JkIGl0IGZvciB1c2UgaW4gZHJhd0dyYXBoIGFuZCBkcmF3VHJhY2tlciwgYW5kIHJldHVybiBncmFwaFBhdGhcblx0XHRcdHNlcmllcy5zaW5nbGVQb2ludHMgPSBzaW5nbGVQb2ludHM7XG5cdFx0XHRzZXJpZXMuZ3JhcGhQYXRoID0gZ3JhcGhQYXRoO1xuXG5cdFx0XHRyZXR1cm4gZ3JhcGhQYXRoO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGFjdHVhbCBncmFwaFxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHByb3BzID0gW1snZ3JhcGgnLCBvcHRpb25zLmxpbmVDb2xvciB8fCB0aGlzLmNvbG9yLCBvcHRpb25zLmRhc2hTdHlsZV1dLFxuXHRcdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdFx0cm91bmRDYXAgPSBvcHRpb25zLmxpbmVjYXAgIT09ICdzcXVhcmUnLFxuXHRcdFx0XHRncmFwaFBhdGggPSB0aGlzLmdldEdyYXBoUGF0aCgpLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSAodGhpcy5maWxsR3JhcGggJiYgdGhpcy5jb2xvcikgfHwgTk9ORSwgLy8gcG9seWdvbiBzZXJpZXMgdXNlIGZpbGxlZCBncmFwaFxuXHRcdFx0XHR6b25lcyA9IHRoaXMuem9uZXM7XG5cblx0XHRcdGVhY2goem9uZXMsIGZ1bmN0aW9uICh0aHJlc2hvbGQsIGkpIHtcblx0XHRcdFx0cHJvcHMucHVzaChbJ3pvbmVHcmFwaCcgKyBpLCB0aHJlc2hvbGQuY29sb3IgfHwgc2VyaWVzLmNvbG9yLCB0aHJlc2hvbGQuZGFzaFN0eWxlIHx8IG9wdGlvbnMuZGFzaFN0eWxlXSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gRHJhdyB0aGUgZ3JhcGhcblx0XHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wLCBpKSB7XG5cdFx0XHRcdHZhciBncmFwaEtleSA9IHByb3BbMF0sXG5cdFx0XHRcdFx0Z3JhcGggPSBzZXJpZXNbZ3JhcGhLZXldLFxuXHRcdFx0XHRcdGF0dHJpYnM7XG5cblx0XHRcdFx0aWYgKGdyYXBoKSB7XG5cdFx0XHRcdFx0c3RvcChncmFwaCk7IC8vIGNhbmNlbCBydW5uaW5nIGFuaW1hdGlvbnMsICM0NTlcblx0XHRcdFx0XHRncmFwaC5hbmltYXRlKHsgZDogZ3JhcGhQYXRoIH0pO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoKGxpbmVXaWR0aCB8fCBmaWxsQ29sb3IpICYmIGdyYXBoUGF0aC5sZW5ndGgpIHsgLy8gIzE0ODdcblx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiBwcm9wWzFdLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRcdGZpbGw6IGZpbGxDb2xvcixcblx0XHRcdFx0XHRcdHpJbmRleDogMSAvLyAjMTA2OVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKHByb3BbMl0pIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gcHJvcFsyXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJvdW5kQ2FwKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzWydzdHJva2UtbGluZWNhcCddID0gYXR0cmlic1snc3Ryb2tlLWxpbmVqb2luJ10gPSAncm91bmQnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlcmllc1tncmFwaEtleV0gPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChncmFwaFBhdGgpXG5cdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKVxuXHRcdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KChpIDwgMikgJiYgb3B0aW9ucy5zaGFkb3cpOyAvLyBhZGQgc2hhZG93IHRvIG5vcm1hbCBzZXJpZXMgKDApIG9yIHRvIGZpcnN0IHpvbmUgKDEpICMzOTMyXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDbGlwIHRoZSBncmFwaHMgaW50byB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNvbG91cmVkIGdyYXBoc1xuXHRcdCAqL1xuXHRcdGFwcGx5Wm9uZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdHpvbmVzID0gdGhpcy56b25lcyxcblx0XHRcdFx0dHJhbnNsYXRlZEZyb20sXG5cdFx0XHRcdHRyYW5zbGF0ZWRUbyxcblx0XHRcdFx0Y2xpcHMgPSB0aGlzLmNsaXBzIHx8IFtdLFxuXHRcdFx0XHRjbGlwQXR0cixcblx0XHRcdFx0Z3JhcGggPSB0aGlzLmdyYXBoLFxuXHRcdFx0XHRhcmVhID0gdGhpcy5hcmVhLFxuXHRcdFx0XHRjaGFydFNpemVNYXggPSBtYXRoTWF4KGNoYXJ0LmNoYXJ0V2lkdGgsIGNoYXJ0LmNoYXJ0SGVpZ2h0KSxcblx0XHRcdFx0em9uZUF4aXMgPSB0aGlzLnpvbmVBeGlzIHx8ICd5Jyxcblx0XHRcdFx0YXhpcyA9IHRoaXNbem9uZUF4aXMgKyAnQXhpcyddLFxuXHRcdFx0XHRleHRyZW1lcyxcblx0XHRcdFx0cmV2ZXJzZWQgPSBheGlzLnJldmVyc2VkLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdHB4UmFuZ2UsXG5cdFx0XHRcdHB4UG9zTWluLFxuXHRcdFx0XHRweFBvc01heCxcblx0XHRcdFx0aWdub3JlWm9uZXMgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHpvbmVzLmxlbmd0aCAmJiAoZ3JhcGggfHwgYXJlYSkpIHtcblx0XHRcdFx0Ly8gVGhlIHVzZSBvZiB0aGUgQ29sb3IgVGhyZXNob2xkIGFzc3VtZXMgdGhlcmUgYXJlIG5vIGdhcHNcblx0XHRcdFx0Ly8gc28gaXQgaXMgc2FmZSB0byBoaWRlIHRoZSBvcmlnaW5hbCBncmFwaCBhbmQgYXJlYVxuXHRcdFx0XHRpZiAoZ3JhcGgpIHtcblx0XHRcdFx0XHRncmFwaC5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFyZWEpIHsgXG5cdFx0XHRcdFx0YXJlYS5oaWRlKCk7IFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbGlwc1xuXHRcdFx0XHRleHRyZW1lcyA9IGF4aXMuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0ZWFjaCh6b25lcywgZnVuY3Rpb24gKHRocmVzaG9sZCwgaSkge1xuXG5cdFx0XHRcdFx0dHJhbnNsYXRlZEZyb20gPSByZXZlcnNlZCA/IFxuXHRcdFx0XHRcdFx0KGhvcml6ID8gY2hhcnQucGxvdFdpZHRoIDogMCkgOiBcblx0XHRcdFx0XHRcdChob3JpeiA/IDAgOiBheGlzLnRvUGl4ZWxzKGV4dHJlbWVzLm1pbikpO1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRGcm9tID0gbWF0aE1pbihtYXRoTWF4KHBpY2sodHJhbnNsYXRlZFRvLCB0cmFuc2xhdGVkRnJvbSksIDApLCBjaGFydFNpemVNYXgpO1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRUbyA9IG1hdGhNaW4obWF0aE1heChtYXRoUm91bmQoYXhpcy50b1BpeGVscyhwaWNrKHRocmVzaG9sZC52YWx1ZSwgZXh0cmVtZXMubWF4KSwgdHJ1ZSkpLCAwKSwgY2hhcnRTaXplTWF4KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaWdub3JlWm9uZXMpIHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZWRGcm9tID0gdHJhbnNsYXRlZFRvID0gYXhpcy50b1BpeGVscyhleHRyZW1lcy5tYXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHB4UmFuZ2UgPSBNYXRoLmFicyh0cmFuc2xhdGVkRnJvbSAtIHRyYW5zbGF0ZWRUbyk7XG5cdFx0XHRcdFx0cHhQb3NNaW4gPSBtYXRoTWluKHRyYW5zbGF0ZWRGcm9tLCB0cmFuc2xhdGVkVG8pO1xuXHRcdFx0XHRcdHB4UG9zTWF4ID0gbWF0aE1heCh0cmFuc2xhdGVkRnJvbSwgdHJhbnNsYXRlZFRvKTtcblx0XHRcdFx0XHRpZiAoYXhpcy5pc1hBeGlzKSB7XG5cdFx0XHRcdFx0XHRjbGlwQXR0ciA9IHtcblx0XHRcdFx0XHRcdFx0eDogaW52ZXJ0ZWQgPyBweFBvc01heCA6IHB4UG9zTWluLFxuXHRcdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogcHhSYW5nZSwgXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnRTaXplTWF4XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0aWYgKCFob3Jpeikge1xuXHRcdFx0XHRcdFx0XHRjbGlwQXR0ci54ID0gY2hhcnQucGxvdEhlaWdodCAtIGNsaXBBdHRyLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsaXBBdHRyID0ge1xuXHRcdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0XHR5OiBpbnZlcnRlZCA/IHB4UG9zTWF4IDogcHhQb3NNaW4sXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBjaGFydFNpemVNYXgsIFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHB4UmFuZ2Vcblx0XHRcdFx0XHRcdH07XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGhvcml6KSB7XG5cdFx0XHRcdFx0XHRcdGNsaXBBdHRyLnkgPSBjaGFydC5wbG90V2lkdGggLSBjbGlwQXR0ci55O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vLyBWTUwgU1VQUFBPUlRcblx0XHRcdFx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQgJiYgcmVuZGVyZXIuaXNWTUwpIHtcblx0XHRcdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHRcdFx0XHR5OiByZXZlcnNlZCA/IHB4UG9zTWluIDogcHhQb3NNYXgsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjbGlwQXR0ci53aWR0aCxcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQuY2hhcnRXaWR0aFxuXHRcdFx0XHRcdFx0XHR9O1x0XHRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdFx0eDogY2xpcEF0dHIueSAtIGNoYXJ0LnBsb3RMZWZ0IC0gY2hhcnQuc3BhY2luZ0JveC54LFxuXHRcdFx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGNsaXBBdHRyLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGNoYXJ0LmNoYXJ0SGVpZ2h0XG5cdFx0XHRcdFx0XHRcdH07XHRcblx0XHRcdFx0XHRcdH1cdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLy8gRU5EIE9GIFZNTCBTVVBQT1JUXG5cblx0XHRcdFx0XHRpZiAoY2xpcHNbaV0pIHtcblx0XHRcdFx0XHRcdGNsaXBzW2ldLmFuaW1hdGUoY2xpcEF0dHIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbGlwc1tpXSA9IHJlbmRlcmVyLmNsaXBSZWN0KGNsaXBBdHRyKTtcblxuXHRcdFx0XHRcdFx0aWYgKGdyYXBoKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllc1snem9uZUdyYXBoJyArIGldLmNsaXAoY2xpcHNbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYXJlYSkge1xuXHRcdFx0XHRcdFx0XHRzZXJpZXNbJ3pvbmVBcmVhJyArIGldLmNsaXAoY2xpcHNbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBpZiB0aGlzIHpvbmUgZXh0ZW5kcyBvdXQgb2YgdGhlIGF4aXMsIGlnbm9yZSB0aGUgb3RoZXJzXG5cdFx0XHRcdFx0aWdub3JlWm9uZXMgPSB0aHJlc2hvbGQudmFsdWUgPiBleHRyZW1lcy5tYXg7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmNsaXBzID0gY2xpcHM7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgYW5kIHBlcmZvcm0gZ3JvdXAgaW52ZXJzaW9uIG9uIHNlcmllcy5ncm91cCBhbmQgc2VyaWVzLm1hcmtlckdyb3VwXG5cdFx0ICovXG5cdFx0aW52ZXJ0R3JvdXBzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRcdC8vIFBpZSwgZ28gYXdheSAoIzE3MzYpXG5cdFx0XHRpZiAoIXNlcmllcy54QXhpcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEEgZml4ZWQgc2l6ZSBpcyBuZWVkZWQgZm9yIGludmVyc2lvbiB0byB3b3JrXG5cdFx0XHRmdW5jdGlvbiBzZXRJbnZlcnQoKSB7XG5cdFx0XHRcdHZhciBzaXplID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBzZXJpZXMueUF4aXMubGVuLFxuXHRcdFx0XHRcdGhlaWdodDogc2VyaWVzLnhBeGlzLmxlblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVhY2goWydncm91cCcsICdtYXJrZXJHcm91cCddLCBmdW5jdGlvbiAoZ3JvdXBOYW1lKSB7XG5cdFx0XHRcdFx0aWYgKHNlcmllc1tncm91cE5hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXNbZ3JvdXBOYW1lXS5hdHRyKHNpemUpLmludmVydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAncmVzaXplJywgc2V0SW52ZXJ0KTsgLy8gZG8gaXQgb24gcmVzaXplXG5cdFx0XHRhZGRFdmVudChzZXJpZXMsICdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudChjaGFydCwgJ3Jlc2l6ZScsIHNldEludmVydCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRG8gaXQgbm93XG5cdFx0XHRzZXRJbnZlcnQoKTsgLy8gZG8gaXQgbm93XG5cblx0XHRcdC8vIE9uIHN1YnNlcXVlbnQgcmVuZGVyIGFuZCByZWRyYXcsIGp1c3QgZG8gc2V0SW52ZXJ0IHdpdGhvdXQgc2V0dGluZyB1cCBldmVudHMgYWdhaW5cblx0XHRcdHNlcmllcy5pbnZlcnRHcm91cHMgPSBzZXRJbnZlcnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYWwgYWJzdHJhY3Rpb24gZm9yIGNyZWF0aW5nIHBsb3QgZ3JvdXBzIGxpa2Ugc2VyaWVzLmdyb3VwLCBzZXJpZXMuZGF0YUxhYmVsc0dyb3VwIGFuZFxuXHRcdCAqIHNlcmllcy5tYXJrZXJHcm91cC4gT24gc3Vic2VxdWVudCBjYWxscywgdGhlIGdyb3VwIHdpbGwgb25seSBiZSBhZGp1c3RlZCB0byB0aGUgdXBkYXRlZCBwbG90IHNpemUuXG5cdFx0ICovXG5cdFx0cGxvdEdyb3VwOiBmdW5jdGlvbiAocHJvcCwgbmFtZSwgdmlzaWJpbGl0eSwgekluZGV4LCBwYXJlbnQpIHtcblx0XHRcdHZhciBncm91cCA9IHRoaXNbcHJvcF0sXG5cdFx0XHRcdGlzTmV3ID0gIWdyb3VwO1xuXG5cdFx0XHQvLyBHZW5lcmF0ZSBpdCBvbiBmaXJzdCBjYWxsXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0dGhpc1twcm9wXSA9IGdyb3VwID0gdGhpcy5jaGFydC5yZW5kZXJlci5nKG5hbWUpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRcdHpJbmRleDogekluZGV4IHx8IDAuMSAvLyBJRTggbmVlZHMgdGhpc1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChwYXJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUGxhY2UgaXQgb24gZmlyc3QgYW5kIHN1YnNlcXVlbnQgKHJlZHJhdykgY2FsbHNcblx0XHRcdGdyb3VwW2lzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh0aGlzLmdldFBsb3RCb3goKSk7XG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgdHJhbnNsYXRpb24gYW5kIHNjYWxlIGZvciB0aGUgcGxvdCBhcmVhIG9mIHRoaXMgc2VyaWVzXG5cdFx0ICovXG5cdFx0Z2V0UGxvdEJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0eEF4aXMgPSB0aGlzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHRoaXMueUF4aXM7XG5cblx0XHRcdC8vIFN3YXAgYXhlcyBmb3IgaW52ZXJ0ZWQgKCMyMzM5KVxuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdHhBeGlzID0geUF4aXM7XG5cdFx0XHRcdHlBeGlzID0gdGhpcy54QXhpcztcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IHhBeGlzID8geEF4aXMubGVmdCA6IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHR0cmFuc2xhdGVZOiB5QXhpcyA/IHlBeGlzLnRvcCA6IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHNjYWxlWDogMSwgLy8gIzE2MjNcblx0XHRcdFx0c2NhbGVZOiAxXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIGdyYXBoIGFuZCBtYXJrZXJzXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdGdyb3VwLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0XHQvLyBBbmltYXRpb24gZG9lc24ndCB3b3JrIGluIElFOCBxdWlya3Mgd2hlbiB0aGUgZ3JvdXAgZGl2IGlzIGhpZGRlbixcblx0XHRcdFx0Ly8gYW5kIGxvb2tzIGJhZCBpbiBvdGhlciBvbGRJRVxuXHRcdFx0XHRhbmltRHVyYXRpb24gPSAoYW5pbWF0aW9uICYmICEhc2VyaWVzLmFuaW1hdGUgJiYgY2hhcnQucmVuZGVyZXIuaXNTVkcgJiYgcGljayhhbmltYXRpb24uZHVyYXRpb24sIDUwMCkpIHx8IDAsXG5cdFx0XHRcdHZpc2liaWxpdHkgPSBzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sXG5cdFx0XHRcdHpJbmRleCA9IG9wdGlvbnMuekluZGV4LFxuXHRcdFx0XHRoYXNSZW5kZXJlZCA9IHNlcmllcy5oYXNSZW5kZXJlZCxcblx0XHRcdFx0Y2hhcnRTZXJpZXNHcm91cCA9IGNoYXJ0LnNlcmllc0dyb3VwO1xuXG5cdFx0XHQvLyB0aGUgZ3JvdXBcblx0XHRcdGdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdFx0J2dyb3VwJyxcblx0XHRcdFx0J3NlcmllcycsXG5cdFx0XHRcdHZpc2liaWxpdHksXG5cdFx0XHRcdHpJbmRleCxcblx0XHRcdFx0Y2hhcnRTZXJpZXNHcm91cFxuXHRcdFx0KTtcblxuXHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdFx0J21hcmtlckdyb3VwJyxcblx0XHRcdFx0J21hcmtlcnMnLFxuXHRcdFx0XHR2aXNpYmlsaXR5LFxuXHRcdFx0XHR6SW5kZXgsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzR3JvdXBcblx0XHRcdCk7XG5cblx0XHRcdC8vIGluaXRpYXRlIHRoZSBhbmltYXRpb25cblx0XHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdFx0c2VyaWVzLmFuaW1hdGUodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgZm9yIHNoYXBlc1xuXHRcdFx0c2VyaWVzLmdldEF0dHJpYnMoKTtcblxuXHRcdFx0Ly8gU1ZHUmVuZGVyZXIgbmVlZHMgdG8ga25vdyB0aGlzIGJlZm9yZSBkcmF3aW5nIGVsZW1lbnRzICgjMTA4OSwgIzE3OTUpXG5cdFx0XHRncm91cC5pbnZlcnRlZCA9IHNlcmllcy5pc0NhcnRlc2lhbiA/IGNoYXJ0LmludmVydGVkIDogZmFsc2U7XG5cblx0XHRcdC8vIGRyYXcgdGhlIGdyYXBoIGlmIGFueVxuXHRcdFx0aWYgKHNlcmllcy5kcmF3R3JhcGgpIHtcblx0XHRcdFx0c2VyaWVzLmRyYXdHcmFwaCgpO1xuXHRcdFx0XHRzZXJpZXMuYXBwbHlab25lcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRpZiAocG9pbnQucmVkcmF3KSB7XG5cdFx0XHRcdFx0cG9pbnQucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkcmF3IHRoZSBkYXRhIGxhYmVscyAoaW5uIHBpZXMgdGhleSBnbyBiZWZvcmUgdGhlIHBvaW50cylcblx0XHRcdGlmIChzZXJpZXMuZHJhd0RhdGFMYWJlbHMpIHtcblx0XHRcdFx0c2VyaWVzLmRyYXdEYXRhTGFiZWxzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRcdFx0aWYgKHNlcmllcy52aXNpYmxlKSB7XG5cdFx0XHRcdHNlcmllcy5kcmF3UG9pbnRzKCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gZHJhdyB0aGUgbW91c2UgdHJhY2tpbmcgYXJlYVxuXHRcdFx0aWYgKHNlcmllcy5kcmF3VHJhY2tlciAmJiBzZXJpZXMub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nICE9PSBmYWxzZSkge1xuXHRcdFx0XHRzZXJpZXMuZHJhd1RyYWNrZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGludmVydGVkIHNlcmllcyBhbmQgdHJhY2tlciBncm91cHNcblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0XHRzZXJpZXMuaW52ZXJ0R3JvdXBzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWwgY2xpcHBpbmcsIG11c3QgYmUgZGVmaW5lZCBhZnRlciBpbnZlcnRpbmcgZ3JvdXBzIGZvciBWTUwuIEFwcGxpZXMgdG8gY29sdW1ucyBldGMuICgjMzgzOSkuXG5cdFx0XHRpZiAob3B0aW9ucy5jbGlwICE9PSBmYWxzZSAmJiAhc2VyaWVzLnNoYXJlZENsaXBLZXkgJiYgIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGdyb3VwLmNsaXAoY2hhcnQuY2xpcFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSdW4gdGhlIGFuaW1hdGlvblxuXHRcdFx0aWYgKGFuaW1EdXJhdGlvbikge1xuXHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSgpO1xuXHRcdFx0fSBcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgYWZ0ZXJBbmltYXRlIGZ1bmN0aW9uIG9uIGFuaW1hdGlvbiBjb21wbGV0ZSAoYnV0IGRvbid0IG92ZXJ3cml0ZSB0aGUgYW5pbWF0aW9uLmNvbXBsZXRlIG9wdGlvblxuXHRcdFx0Ly8gd2hpY2ggc2hvdWxkIGJlIGF2YWlsYWJsZSB0byB0aGUgdXNlcikuXG5cdFx0XHRpZiAoIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdFx0XHRzZXJpZXMuYW5pbWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdFx0XHRcdH0sIGFuaW1EdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gZmFsc2U7IC8vIG1lYW5zIGRhdGEgaXMgaW4gYWNjb3JkYW5jZSB3aXRoIHdoYXQgeW91IHNlZVxuXHRcdFx0Ly8gKFNlZSAjMzIyKSBzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGZhbHNlOyAvLyBtZWFucyBkYXRhIGlzIGluIGFjY29yZGFuY2Ugd2l0aCB3aGF0IHlvdSBzZWVcblx0XHRcdHNlcmllcy5oYXNSZW5kZXJlZCA9IHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZHJhdyB0aGUgc2VyaWVzIGFmdGVyIGFuIHVwZGF0ZSBpbiB0aGUgYXhlcy5cblx0XHQgKi9cblx0XHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0d2FzRGlydHlEYXRhID0gc2VyaWVzLmlzRGlydHlEYXRhLCAvLyBjYWNoZSBpdCBoZXJlIGFzIGl0IGlzIHNldCB0byBmYWxzZSBpbiByZW5kZXIsIGJ1dCB1c2VkIGFmdGVyXG5cdFx0XHRcdHdhc0RpcnR5ID0gc2VyaWVzLmlzRGlydHksXG5cdFx0XHRcdGdyb3VwID0gc2VyaWVzLmdyb3VwLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXM7XG5cblx0XHRcdC8vIHJlcG9zaXRpb24gb24gcmVzaXplXG5cdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdFx0Z3JvdXAuYXR0cih7XG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5wbG90SGVpZ2h0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncm91cC5hbmltYXRlKHtcblx0XHRcdFx0XHR0cmFuc2xhdGVYOiBwaWNrKHhBeGlzICYmIHhBeGlzLmxlZnQsIGNoYXJ0LnBsb3RMZWZ0KSxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBwaWNrKHlBeGlzICYmIHlBeGlzLnRvcCwgY2hhcnQucGxvdFRvcClcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy50cmFuc2xhdGUoKTtcblx0XHRcdHNlcmllcy5yZW5kZXIoKTtcblx0XHRcdGlmICh3YXNEaXJ0eURhdGEpIHtcblx0XHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ3VwZGF0ZWREYXRhJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAod2FzRGlydHkgfHwgd2FzRGlydHlEYXRhKSB7XHRcdFx0Ly8gIzM5NDUgcmVjYWxjdWxhdGUgdGhlIGtkdHJlZSB3aGVuIGRpcnR5XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmtkVHJlZTsgLy8gIzM4NjggcmVjYWxjdWxhdGUgdGhlIGtkdHJlZSB3aXRoIGRpcnR5IGRhdGFcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogS0QgVHJlZSAmJiBQb2ludFNlYXJjaGluZyBJbXBsZW1lbnRhdGlvblxuXHRcdCAqL1xuXG5cdFx0a2REaW1lbnNpb25zOiAxLFxuXHRcdGtkQXhpc0FycmF5OiBbJ2NsaWVudFgnLCAncGxvdFknXSxcblxuXHRcdHNlYXJjaFBvaW50OiBmdW5jdGlvbiAoZSwgY29tcGFyZVgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRcdGludmVydGVkID0gc2VyaWVzLmNoYXJ0LmludmVydGVkO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe1xuXHRcdFx0XHRjbGllbnRYOiBpbnZlcnRlZCA/IHhBeGlzLmxlbiAtIGUuY2hhcnRZICsgeEF4aXMucG9zIDogZS5jaGFydFggLSB4QXhpcy5wb3MsXG5cdFx0XHRcdHBsb3RZOiBpbnZlcnRlZCA/IHlBeGlzLmxlbiAtIGUuY2hhcnRYICsgeUF4aXMucG9zIDogZS5jaGFydFkgLSB5QXhpcy5wb3Ncblx0XHRcdH0sIGNvbXBhcmVYKTtcblx0XHR9LFxuXG5cdFx0YnVpbGRLRFRyZWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRkaW1lbnNpb25zID0gc2VyaWVzLmtkRGltZW5zaW9ucztcblxuXHRcdFx0Ly8gSW50ZXJuYWwgZnVuY3Rpb25cblx0XHRcdGZ1bmN0aW9uIF9rZHRyZWUocG9pbnRzLCBkZXB0aCwgZGltZW5zaW9ucykge1xuXHRcdFx0XHR2YXIgYXhpcywgbWVkaWFuLCBsZW5ndGggPSBwb2ludHMgJiYgcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAobGVuZ3RoKSB7XG5cblx0XHRcdFx0XHQvLyBhbHRlcm5hdGUgYmV0d2VlbiB0aGUgYXhpc1xuXHRcdFx0XHRcdGF4aXMgPSBzZXJpZXMua2RBeGlzQXJyYXlbZGVwdGggJSBkaW1lbnNpb25zXTtcblxuXHRcdFx0XHRcdC8vIHNvcnQgcG9pbnQgYXJyYXlcblx0XHRcdFx0XHRwb2ludHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYVtheGlzXSAtIGJbYXhpc107XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdG1lZGlhbiA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gYnVpbGQgYW5kIHJldHVybiBub2Rcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0cG9pbnQ6IHBvaW50c1ttZWRpYW5dLFxuXHRcdFx0XHRcdFx0bGVmdDogX2tkdHJlZShwb2ludHMuc2xpY2UoMCwgbWVkaWFuKSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKSxcblx0XHRcdFx0XHRcdHJpZ2h0OiBfa2R0cmVlKHBvaW50cy5zbGljZShtZWRpYW4gKyAxKSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSByZWN1cnNpdmUgYnVpbGQgcHJvY2VzcyB3aXRoIGEgY2xvbmUgb2YgdGhlIHBvaW50cyBhcnJheSBhbmQgbnVsbCBwb2ludHMgZmlsdGVyZWQgb3V0ICgjMzg3Mylcblx0XHRcdGZ1bmN0aW9uIHN0YXJ0UmVjdXJzaXZlKCkge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gZ3JlcChzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcG9pbnQueSAhPT0gbnVsbDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2VyaWVzLmtkVHJlZSA9IF9rZHRyZWUocG9pbnRzLCBkaW1lbnNpb25zLCBkaW1lbnNpb25zKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBzZXJpZXMua2RUcmVlO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMua2RTeW5jKSB7ICAvLyBGb3IgdGVzdGluZyB0b29sdGlwcywgZG9uJ3QgYnVpbGQgYXN5bmNcblx0XHRcdFx0c3RhcnRSZWN1cnNpdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoc3RhcnRSZWN1cnNpdmUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZWFyY2hLRFRyZWU6IGZ1bmN0aW9uIChwb2ludCwgY29tcGFyZVgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRrZFggPSB0aGlzLmtkQXhpc0FycmF5WzBdLFxuXHRcdFx0XHRrZFkgPSB0aGlzLmtkQXhpc0FycmF5WzFdLFxuXHRcdFx0XHRrZENvbXBhcmVyID0gY29tcGFyZVggPyAnZGlzdFgnIDogJ2Rpc3QnO1xuXG5cdFx0XHQvLyBTZXQgdGhlIG9uZSBhbmQgdHdvIGRpbWVuc2lvbmFsIGRpc3RhbmNlIG9uIHRoZSBwb2ludCBvYmplY3Rcblx0XHRcdGZ1bmN0aW9uIHNldERpc3RhbmNlKHAxLCBwMikge1xuXHRcdFx0XHR2YXIgeCA9IChkZWZpbmVkKHAxW2tkWF0pICYmIGRlZmluZWQocDJba2RYXSkpID8gTWF0aC5wb3cocDFba2RYXSAtIHAyW2tkWF0sIDIpIDogbnVsbCxcblx0XHRcdFx0XHR5ID0gKGRlZmluZWQocDFba2RZXSkgJiYgZGVmaW5lZChwMltrZFldKSkgPyBNYXRoLnBvdyhwMVtrZFldIC0gcDJba2RZXSwgMikgOiBudWxsLFxuXHRcdFx0XHRcdHIgPSAoeCB8fCAwKSArICh5IHx8IDApO1xuXG5cdFx0XHRcdHAyLmRpc3QgPSBkZWZpbmVkKHIpID8gTWF0aC5zcXJ0KHIpIDogTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdFx0cDIuZGlzdFggPSBkZWZpbmVkKHgpID8gTWF0aC5zcXJ0KHgpIDogTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIF9zZWFyY2goc2VhcmNoLCB0cmVlLCBkZXB0aCwgZGltZW5zaW9ucykge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSB0cmVlLnBvaW50LFxuXHRcdFx0XHRcdGF4aXMgPSBzZXJpZXMua2RBeGlzQXJyYXlbZGVwdGggJSBkaW1lbnNpb25zXSxcblx0XHRcdFx0XHR0ZGlzdCxcblx0XHRcdFx0XHRzaWRlQSxcblx0XHRcdFx0XHRzaWRlQixcblx0XHRcdFx0XHRyZXQgPSBwb2ludCxcblx0XHRcdFx0XHRuUG9pbnQxLFxuXHRcdFx0XHRcdG5Qb2ludDI7XG5cdFx0XHRcdFxuXHRcdFx0XHRzZXREaXN0YW5jZShzZWFyY2gsIHBvaW50KTtcblxuXHRcdFx0XHQvLyBQaWNrIHNpZGUgYmFzZWQgb24gZGlzdGFuY2UgdG8gc3BsaXR0aW5nIHBvaW50XG5cdFx0XHRcdHRkaXN0ID0gc2VhcmNoW2F4aXNdIC0gcG9pbnRbYXhpc107XG5cdFx0XHRcdHNpZGVBID0gdGRpc3QgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdFx0c2lkZUIgPSB0ZGlzdCA8IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG5cdFx0XHRcdC8vIEVuZCBvZiB0cmVlXG5cdFx0XHRcdGlmICh0cmVlW3NpZGVBXSkge1xuXHRcdFx0XHRcdG5Qb2ludDEgPV9zZWFyY2goc2VhcmNoLCB0cmVlW3NpZGVBXSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKTtcblxuXHRcdFx0XHRcdHJldCA9IChuUG9pbnQxW2tkQ29tcGFyZXJdIDwgcmV0W2tkQ29tcGFyZXJdID8gblBvaW50MSA6IHBvaW50KTtcblx0XHRcdFx0fSBcblx0XHRcdFx0aWYgKHRyZWVbc2lkZUJdKSB7XG5cdFx0XHRcdFx0Ly8gY29tcGFyZSBkaXN0YW5jZSB0byBjdXJyZW50IGJlc3QgdG8gc3BsaXR0aW5nIHBvaW50IHRvIGRlY2lkZSB3ZXRoZXIgdG8gY2hlY2sgc2lkZSBCIG9yIG5vdFxuXHRcdFx0XHRcdGlmIChNYXRoLnNxcnQodGRpc3QgKiB0ZGlzdCkgPCByZXRba2RDb21wYXJlcl0pIHtcblx0XHRcdFx0XHRcdG5Qb2ludDIgPSBfc2VhcmNoKHNlYXJjaCwgdHJlZVtzaWRlQl0sIGRlcHRoICsgMSwgZGltZW5zaW9ucyk7XG5cdFx0XHRcdFx0XHRyZXQgPSAoblBvaW50MltrZENvbXBhcmVyXSA8IHJldFtrZENvbXBhcmVyXSA/IG5Qb2ludDIgOiByZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmtkVHJlZSkge1xuXHRcdFx0XHR0aGlzLmJ1aWxkS0RUcmVlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmtkVHJlZSkge1xuXHRcdFx0XHRyZXR1cm4gX3NlYXJjaChwb2ludCwgXG5cdFx0XHRcdFx0dGhpcy5rZFRyZWUsIHRoaXMua2REaW1lbnNpb25zLCB0aGlzLmtkRGltZW5zaW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH07IC8vIGVuZCBTZXJpZXMgcHJvdG90eXBlXG5cblx0LyoqXG5cdCAqIFRoZSBjbGFzcyBmb3Igc3RhY2sgaXRlbXNcblx0ICovXG5cdGZ1bmN0aW9uIFN0YWNrSXRlbShheGlzLCBvcHRpb25zLCBpc05lZ2F0aXZlLCB4LCBzdGFja09wdGlvbikge1xuXHRcdFxuXHRcdHZhciBpbnZlcnRlZCA9IGF4aXMuY2hhcnQuaW52ZXJ0ZWQ7XG5cblx0XHR0aGlzLmF4aXMgPSBheGlzO1xuXG5cdFx0Ly8gVGVsbHMgaWYgdGhlIHN0YWNrIGlzIG5lZ2F0aXZlXG5cdFx0dGhpcy5pc05lZ2F0aXZlID0gaXNOZWdhdGl2ZTtcblxuXHRcdC8vIFNhdmUgdGhlIG9wdGlvbnMgdG8gYmUgYWJsZSB0byBzdHlsZSB0aGUgbGFiZWxcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgeCB2YWx1ZSB0byBiZSBhYmxlIHRvIHBvc2l0aW9uIHRoZSBsYWJlbCBsYXRlclxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRvdGFsIHZhbHVlXG5cdFx0dGhpcy50b3RhbCA9IG51bGw7XG5cblx0XHQvLyBUaGlzIHdpbGwga2VlcCBlYWNoIHBvaW50cycgZXh0cmVtZXMgc3RvcmVkIGJ5IHNlcmllcy5pbmRleCBhbmQgcG9pbnQgaW5kZXhcblx0XHR0aGlzLnBvaW50cyA9IHt9O1xuXG5cdFx0Ly8gU2F2ZSB0aGUgc3RhY2sgb3B0aW9uIG9uIHRoZSBzZXJpZXMgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCB3aGV0aGVyIHRvIHRyZWF0IGl0IGFzIHBlcmNlbnRcblx0XHR0aGlzLnN0YWNrID0gc3RhY2tPcHRpb247XG5cblx0XHQvLyBUaGUgYWxpZ24gb3B0aW9ucyBhbmQgdGV4dCBhbGlnbiB2YXJpZXMgb24gd2hldGhlciB0aGUgc3RhY2sgaXMgbmVnYXRpdmUgYW5kXG5cdFx0Ly8gaWYgdGhlIGNoYXJ0IGlzIGludmVydGVkIG9yIG5vdC5cblx0XHQvLyBGaXJzdCB0ZXN0IHRoZSB1c2VyIHN1cHBsaWVkIHZhbHVlLCB0aGVuIHVzZSB0aGUgZHluYW1pYy5cblx0XHR0aGlzLmFsaWduT3B0aW9ucyA9IHtcblx0XHRcdGFsaWduOiBvcHRpb25zLmFsaWduIHx8IChpbnZlcnRlZCA/IChpc05lZ2F0aXZlID8gJ2xlZnQnIDogJ3JpZ2h0JykgOiAnY2VudGVyJyksXG5cdFx0XHR2ZXJ0aWNhbEFsaWduOiBvcHRpb25zLnZlcnRpY2FsQWxpZ24gfHwgKGludmVydGVkID8gJ21pZGRsZScgOiAoaXNOZWdhdGl2ZSA/ICdib3R0b20nIDogJ3RvcCcpKSxcblx0XHRcdHk6IHBpY2sob3B0aW9ucy55LCBpbnZlcnRlZCA/IDQgOiAoaXNOZWdhdGl2ZSA/IDE0IDogLTYpKSxcblx0XHRcdHg6IHBpY2sob3B0aW9ucy54LCBpbnZlcnRlZCA/IChpc05lZ2F0aXZlID8gLTYgOiA2KSA6IDApXG5cdFx0fTtcblxuXHRcdHRoaXMudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ24gfHwgKGludmVydGVkID8gKGlzTmVnYXRpdmUgPyAncmlnaHQnIDogJ2xlZnQnKSA6ICdjZW50ZXInKTtcblx0fVxuXG5cdFN0YWNrSXRlbS5wcm90b3R5cGUgPSB7XG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXModGhpcywgdGhpcy5heGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVycyB0aGUgc3RhY2sgdG90YWwgbGFiZWwgYW5kIGFkZHMgaXQgdG8gdGhlIHN0YWNrIGxhYmVsIGdyb3VwLlxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKGdyb3VwKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0Zm9ybWF0T3B0aW9uID0gb3B0aW9ucy5mb3JtYXQsXG5cdFx0XHRcdHN0ciA9IGZvcm1hdE9wdGlvbiA/XG5cdFx0XHRcdFx0Zm9ybWF0KGZvcm1hdE9wdGlvbiwgdGhpcykgOiBcblx0XHRcdFx0XHRvcHRpb25zLmZvcm1hdHRlci5jYWxsKHRoaXMpOyAgLy8gZm9ybWF0IHRoZSB0ZXh0IGluIHRoZSBsYWJlbFxuXG5cdFx0XHQvLyBDaGFuZ2UgdGhlIHRleHQgdG8gcmVmbGVjdCB0aGUgbmV3IHRvdGFsIGFuZCBzZXQgdmlzaWJpbGl0eSB0byBoaWRkZW4gaW4gY2FzZSB0aGUgc2VyaWUgaXMgaGlkZGVuXG5cdFx0XHRpZiAodGhpcy5sYWJlbCkge1xuXHRcdFx0XHR0aGlzLmxhYmVsLmF0dHIoe3RleHQ6IHN0ciwgdmlzaWJpbGl0eTogSElEREVOfSk7XG5cdFx0XHQvLyBDcmVhdGUgbmV3IGxhYmVsXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxhYmVsID1cblx0XHRcdFx0XHR0aGlzLmF4aXMuY2hhcnQucmVuZGVyZXIudGV4dChzdHIsIG51bGwsIG51bGwsIG9wdGlvbnMudXNlSFRNTClcdFx0Ly8gZHVtbXkgcG9zaXRpb25zLCBhY3R1YWwgcG9zaXRpb24gdXBkYXRlZCB3aXRoIHNldE9mZnNldCBtZXRob2QgaW4gY29sdW1uc2VyaWVzXG5cdFx0XHRcdFx0XHQuY3NzKG9wdGlvbnMuc3R5bGUpXHRcdFx0XHQvLyBhcHBseSBzdHlsZVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRhbGlnbjogdGhpcy50ZXh0QWxpZ24sXHRcdFx0XHQvLyBmaXggdGhlIHRleHQtYW5jaG9yXG5cdFx0XHRcdFx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFx0Ly8gcm90YXRpb25cblx0XHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogSElEREVOXHRcdFx0XHRcdC8vIGhpZGRlbiB1bnRpbCBzZXRPZmZzZXQgaXMgY2FsbGVkXG5cdFx0XHRcdFx0XHR9KVx0XHRcdFx0XG5cdFx0XHRcdFx0XHQuYWRkKGdyb3VwKTtcdFx0XHRcdFx0XHRcdC8vIGFkZCB0byB0aGUgbGFiZWxzLWdyb3VwXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIG9mZnNldCB0aGF0IHRoZSBzdGFjayBoYXMgZnJvbSB0aGUgeCB2YWx1ZSBhbmQgcmVwb3NpdGlvbnMgdGhlIGxhYmVsLlxuXHRcdCAqL1xuXHRcdHNldE9mZnNldDogZnVuY3Rpb24gKHhPZmZzZXQsIHhXaWR0aCkge1xuXHRcdFx0dmFyIHN0YWNrSXRlbSA9IHRoaXMsXG5cdFx0XHRcdGF4aXMgPSBzdGFja0l0ZW0uYXhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRcdG5lZyA9ICh0aGlzLmlzTmVnYXRpdmUgJiYgIXJldmVyc2VkKSB8fCAoIXRoaXMuaXNOZWdhdGl2ZSAmJiByZXZlcnNlZCksIC8vICM0MDU2XG5cdFx0XHRcdHkgPSBheGlzLnRyYW5zbGF0ZShheGlzLnVzZVBlcmNlbnRhZ2UgPyAxMDAgOiB0aGlzLnRvdGFsLCAwLCAwLCAwLCAxKSwgLy8gc3RhY2sgdmFsdWUgdHJhbnNsYXRlZCBtYXBwZWQgdG8gY2hhcnQgY29vcmRpbmF0ZXNcblx0XHRcdFx0eVplcm8gPSBheGlzLnRyYW5zbGF0ZSgwKSxcdFx0XHRcdFx0XHQvLyBzdGFjayBvcmlnaW5cblx0XHRcdFx0aCA9IG1hdGhBYnMoeSAtIHlaZXJvKSxcdFx0XHRcdFx0XHRcdC8vIHN0YWNrIGhlaWdodFxuXHRcdFx0XHR4ID0gY2hhcnQueEF4aXNbMF0udHJhbnNsYXRlKHRoaXMueCkgKyB4T2Zmc2V0LFx0Ly8gc3RhY2sgeCBwb3NpdGlvblxuXHRcdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCxcblx0XHRcdFx0c3RhY2tCb3ggPSB7XHQvLyB0aGlzIGlzIHRoZSBib3ggZm9yIHRoZSBjb21wbGV0ZSBzdGFja1xuXHRcdFx0XHRcdHg6IGludmVydGVkID8gKG5lZyA/IHkgOiB5IC0gaCkgOiB4LFxuXHRcdFx0XHRcdHk6IGludmVydGVkID8gcGxvdEhlaWdodCAtIHggLSB4V2lkdGggOiAobmVnID8gKHBsb3RIZWlnaHQgLSB5IC0gaCkgOiBwbG90SGVpZ2h0IC0geSksXG5cdFx0XHRcdFx0d2lkdGg6IGludmVydGVkID8gaCA6IHhXaWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGludmVydGVkID8geFdpZHRoIDogaFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsXG5cdFx0XHRcdGFsaWduQXR0cjtcblx0XHRcdFxuXHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLmFsaWduKHRoaXMuYWxpZ25PcHRpb25zLCBudWxsLCBzdGFja0JveCk7XHQvLyBhbGlnbiB0aGUgbGFiZWwgdG8gdGhlIGJveFxuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBTZXQgdmlzaWJpbGl0eSAoIzY3OClcblx0XHRcdFx0YWxpZ25BdHRyID0gbGFiZWwuYWxpZ25BdHRyO1xuXHRcdFx0XHRsYWJlbFt0aGlzLm9wdGlvbnMuY3JvcCA9PT0gZmFsc2UgfHwgY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54LCBhbGlnbkF0dHIueSkgPyAnc2hvdycgOiAnaGlkZSddKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgc3RhY2tzIGZvciBlYWNoIHNlcmllcyBhbmQgY2FsY3VsYXRlIHN0YWNrcyB0b3RhbCB2YWx1ZXNcblx0ICovXG5cdENoYXJ0LnByb3RvdHlwZS5nZXRTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblxuXHRcdC8vIHJlc2V0IHN0YWNrcyBmb3IgZWFjaCB5QXhpc1xuXHRcdGVhY2goY2hhcnQueUF4aXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRpZiAoYXhpcy5zdGFja3MgJiYgYXhpcy5oYXNWaXNpYmxlU2VyaWVzKSB7XG5cdFx0XHRcdGF4aXMub2xkU3RhY2tzID0gYXhpcy5zdGFja3M7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLnN0YWNraW5nICYmIChzZXJpZXMudmlzaWJsZSA9PT0gdHJ1ZSB8fCBjaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyA9PT0gZmFsc2UpKSB7XG5cdFx0XHRcdHNlcmllcy5zdGFja0tleSA9IHNlcmllcy50eXBlICsgcGljayhzZXJpZXMub3B0aW9ucy5zdGFjaywgJycpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cblx0Ly8gU3RhY2tpbmcgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBBeGlzIHByb3RvdHlwZVxuXG5cdC8qKlxuXHQgKiBCdWlsZCB0aGUgc3RhY2tzIGZyb20gdG9wIGRvd25cblx0ICovXG5cdEF4aXMucHJvdG90eXBlLmJ1aWxkU3RhY2tzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdHJldmVyc2VkU3RhY2tzID0gcGljayh0aGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsIHRydWUpLFxuXHRcdFx0aSA9IHNlcmllcy5sZW5ndGg7XG5cdFx0aWYgKCF0aGlzLmlzWEF4aXMpIHtcblx0XHRcdHRoaXMudXNlUGVyY2VudGFnZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZXNbcmV2ZXJzZWRTdGFja3MgPyBpIDogc2VyaWVzLmxlbmd0aCAtIGkgLSAxXS5zZXRTdGFja2VkUG9pbnRzKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb29wIHVwIGFnYWluIHRvIGNvbXB1dGUgcGVyY2VudCBzdGFja1xuXHRcdFx0aWYgKHRoaXMudXNlUGVyY2VudGFnZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VyaWVzW2ldLnNldFBlcmNlbnRTdGFja3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRBeGlzLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0c3RhY2tzID0gYXhpcy5zdGFja3MsXG5cdFx0XHRzdGFja0tleSwgXG5cdFx0XHRvbmVTdGFjaywgXG5cdFx0XHRzdGFja0NhdGVnb3J5LFxuXHRcdFx0c3RhY2tUb3RhbEdyb3VwID0gYXhpcy5zdGFja1RvdGFsR3JvdXA7XG5cblx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIHN0YWNrIHRvdGFsIGxhYmVsc1xuXHRcdGlmICghc3RhY2tUb3RhbEdyb3VwKSB7XG5cdFx0XHRheGlzLnN0YWNrVG90YWxHcm91cCA9IHN0YWNrVG90YWxHcm91cCA9XG5cdFx0XHRcdHJlbmRlcmVyLmcoJ3N0YWNrLWxhYmVscycpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogVklTSUJMRSxcblx0XHRcdFx0XHRcdHpJbmRleDogNlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdH1cblxuXHRcdC8vIHBsb3RMZWZ0L1RvcCB3aWxsIGNoYW5nZSB3aGVuIHkgYXhpcyBnZXRzIHdpZGVyIHNvIHdlIG5lZWQgdG8gdHJhbnNsYXRlIHRoZVxuXHRcdC8vIHN0YWNrVG90YWxHcm91cCBhdCBldmVyeSByZW5kZXIgY2FsbC4gU2VlIGJ1ZyAjNTA2IGFuZCAjNTE2XG5cdFx0c3RhY2tUb3RhbEdyb3VwLnRyYW5zbGF0ZShjaGFydC5wbG90TGVmdCwgY2hhcnQucGxvdFRvcCk7XG5cblx0XHQvLyBSZW5kZXIgZWFjaCBzdGFjayB0b3RhbFxuXHRcdGZvciAoc3RhY2tLZXkgaW4gc3RhY2tzKSB7XG5cdFx0XHRvbmVTdGFjayA9IHN0YWNrc1tzdGFja0tleV07XG5cdFx0XHRmb3IgKHN0YWNrQ2F0ZWdvcnkgaW4gb25lU3RhY2spIHtcblx0XHRcdFx0b25lU3RhY2tbc3RhY2tDYXRlZ29yeV0ucmVuZGVyKHN0YWNrVG90YWxHcm91cCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgYWxsIHRoZSBzdGFja3MgdG8gaW5pdGlhbCBzdGF0ZXMgYW5kIGRlc3Ryb3kgdW51c2VkIG9uZXMuXG5cdCAqL1xuXHRBeGlzLnByb3RvdHlwZS5yZXNldFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5zdGFja3MsXG5cdFx0XHR0eXBlLFxuXHRcdFx0aTtcblx0XHRpZiAoIXRoaXMuaXNYQXhpcykge1xuXHRcdFx0Zm9yICh0eXBlIGluIHN0YWNrcykge1xuXHRcdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cblx0XHRcdFx0XHQvLyBDbGVhbiB1cCBtZW1vcnkgYWZ0ZXIgcG9pbnQgZGVsZXRpb24gKCMxMDQ0LCAjNDMyMClcblx0XHRcdFx0XHRpZiAoc3RhY2tzW3R5cGVdW2ldLnRvdWNoZWQgPCB0aGlzLnN0YWNrc1RvdWNoZWQpIHtcblx0XHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRkZWxldGUgc3RhY2tzW3R5cGVdW2ldO1xuXG5cdFx0XHRcdFx0Ly8gUmVzZXQgc3RhY2tzXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS50b3RhbCA9IG51bGw7XG5cdFx0XHRcdFx0XHRzdGFja3NbdHlwZV1baV0uY3VtID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0QXhpcy5wcm90b3R5cGUuY2xlYW5TdGFja3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHN0YWNrcywgdHlwZSwgaTtcblxuXHRcdGlmICghdGhpcy5pc1hBeGlzKSB7XG5cdFx0XHRpZiAodGhpcy5vbGRTdGFja3MpIHtcblx0XHRcdFx0c3RhY2tzID0gdGhpcy5zdGFja3MgPSB0aGlzLm9sZFN0YWNrcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzZXQgc3RhY2tzXG5cdFx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBzdGFja3NbdHlwZV0pIHtcblx0XHRcdFx0XHRzdGFja3NbdHlwZV1baV0uY3VtID0gc3RhY2tzW3R5cGVdW2ldLnRvdGFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gU3RhY2tpbmcgbWV0aG9kcyBkZWZuaWVkIGZvciBTZXJpZXMgcHJvdG90eXBlXG5cblx0LyoqXG5cdCAqIEFkZHMgc2VyaWVzJyBwb2ludHMgdmFsdWUgdG8gY29ycmVzcG9uZGluZyBzdGFja1xuXHQgKi9cblx0U2VyaWVzLnByb3RvdHlwZS5zZXRTdGFja2VkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnN0YWNraW5nIHx8ICh0aGlzLnZpc2libGUgIT09IHRydWUgJiYgdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyAhPT0gZmFsc2UpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHR4RGF0YSA9IHNlcmllcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdHlEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFlEYXRhLFxuXHRcdFx0c3RhY2tlZFlEYXRhID0gW10sXG5cdFx0XHR5RGF0YUxlbmd0aCA9IHlEYXRhLmxlbmd0aCxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHRocmVzaG9sZCA9IHNlcmllc09wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0c3RhY2tUaHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnN0YXJ0RnJvbVRocmVzaG9sZCA/IHRocmVzaG9sZCA6IDAsXG5cdFx0XHRzdGFja09wdGlvbiA9IHNlcmllc09wdGlvbnMuc3RhY2ssXG5cdFx0XHRzdGFja2luZyA9IHNlcmllc09wdGlvbnMuc3RhY2tpbmcsXG5cdFx0XHRzdGFja0tleSA9IHNlcmllcy5zdGFja0tleSxcblx0XHRcdG5lZ0tleSA9ICctJyArIHN0YWNrS2V5LFxuXHRcdFx0bmVnU3RhY2tzID0gc2VyaWVzLm5lZ1N0YWNrcyxcblx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0c3RhY2tzID0geUF4aXMuc3RhY2tzLFxuXHRcdFx0b2xkU3RhY2tzID0geUF4aXMub2xkU3RhY2tzLFxuXHRcdFx0aXNOZWdhdGl2ZSxcblx0XHRcdHN0YWNrLFxuXHRcdFx0b3RoZXIsXG5cdFx0XHRrZXksXG5cdFx0XHRwb2ludEtleSxcblx0XHRcdGksXG5cdFx0XHR4LFxuXHRcdFx0eTtcblxuXG5cdFx0eUF4aXMuc3RhY2tzVG91Y2hlZCArPSAxO1xuXG5cdFx0Ly8gbG9vcCBvdmVyIHRoZSBub24tbnVsbCB5IHZhbHVlcyBhbmQgcmVhZCB0aGVtIGludG8gYSBsb2NhbCBhcnJheVxuXHRcdGZvciAoaSA9IDA7IGkgPCB5RGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHR4ID0geERhdGFbaV07XG5cdFx0XHR5ID0geURhdGFbaV07XG5cdFx0XHRwb2ludEtleSA9IHNlcmllcy5pbmRleCArICcsJyArIGk7XG5cblx0XHRcdC8vIFJlYWQgc3RhY2tlZCB2YWx1ZXMgaW50byBhIHN0YWNrIGJhc2VkIG9uIHRoZSB4IHZhbHVlLFxuXHRcdFx0Ly8gdGhlIHNpZ24gb2YgeSBhbmQgdGhlIHN0YWNrIGtleS4gU3RhY2tpbmcgaXMgYWxzbyBoYW5kbGVkIGZvciBudWxsIHZhbHVlcyAoIzczOSlcblx0XHRcdGlzTmVnYXRpdmUgPSBuZWdTdGFja3MgJiYgeSA8IChzdGFja1RocmVzaG9sZCA/IDAgOiB0aHJlc2hvbGQpO1xuXHRcdFx0a2V5ID0gaXNOZWdhdGl2ZSA/IG5lZ0tleSA6IHN0YWNrS2V5O1xuXG5cdFx0XHQvLyBDcmVhdGUgZW1wdHkgb2JqZWN0IGZvciB0aGlzIHN0YWNrIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG5cdFx0XHRpZiAoIXN0YWNrc1trZXldKSB7XG5cdFx0XHRcdHN0YWNrc1trZXldID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgU3RhY2tJdGVtIGZvciB0aGlzIHhcblx0XHRcdGlmICghc3RhY2tzW2tleV1beF0pIHtcblx0XHRcdFx0aWYgKG9sZFN0YWNrc1trZXldICYmIG9sZFN0YWNrc1trZXldW3hdKSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBvbGRTdGFja3Nba2V5XVt4XTtcblx0XHRcdFx0XHRzdGFja3Nba2V5XVt4XS50b3RhbCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBuZXcgU3RhY2tJdGVtKHlBeGlzLCB5QXhpcy5vcHRpb25zLnN0YWNrTGFiZWxzLCBpc05lZ2F0aXZlLCB4LCBzdGFja09wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIFN0YWNrSXRlbSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXQgZmlyc3Rcblx0XHRcdHN0YWNrID0gc3RhY2tzW2tleV1beF07XG5cdFx0XHQvL3N0YWNrLnBvaW50c1twb2ludEtleV0gPSBbc3RhY2suY3VtIHx8IHN0YWNrVGhyZXNob2xkXTtcblx0XHRcdHN0YWNrLnBvaW50c1twb2ludEtleV0gPSBbcGljayhzdGFjay5jdW0sIHN0YWNrVGhyZXNob2xkKV07XG5cdFx0XHRzdGFjay50b3VjaGVkID0geUF4aXMuc3RhY2tzVG91Y2hlZDtcblx0XHRcdFxuXG5cdFx0XHQvLyBBZGQgdmFsdWUgdG8gdGhlIHN0YWNrIHRvdGFsXG5cdFx0XHRpZiAoc3RhY2tpbmcgPT09ICdwZXJjZW50Jykge1xuXG5cdFx0XHRcdC8vIFBlcmNlbnQgc3RhY2tlZCBjb2x1bW4sIHRvdGFscyBhcmUgdGhlIHNhbWUgZm9yIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgc3RhY2tzXG5cdFx0XHRcdG90aGVyID0gaXNOZWdhdGl2ZSA/IHN0YWNrS2V5IDogbmVnS2V5O1xuXHRcdFx0XHRpZiAobmVnU3RhY2tzICYmIHN0YWNrc1tvdGhlcl0gJiYgc3RhY2tzW290aGVyXVt4XSkge1xuXHRcdFx0XHRcdG90aGVyID0gc3RhY2tzW290aGVyXVt4XTtcblx0XHRcdFx0XHRzdGFjay50b3RhbCA9IG90aGVyLnRvdGFsID0gbWF0aE1heChvdGhlci50b3RhbCwgc3RhY2sudG90YWwpICsgbWF0aEFicyh5KSB8fCAwO1xuXG5cdFx0XHRcdC8vIFBlcmNlbnQgc3RhY2tlZCBhcmVhc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YWNrLnRvdGFsID0gY29ycmVjdEZsb2F0KHN0YWNrLnRvdGFsICsgKG1hdGhBYnMoeSkgfHwgMCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFjay50b3RhbCA9IGNvcnJlY3RGbG9hdChzdGFjay50b3RhbCArICh5IHx8IDApKTtcblx0XHRcdH1cblxuXHRcdFx0c3RhY2suY3VtID0gcGljayhzdGFjay5jdW0sIHN0YWNrVGhyZXNob2xkKSArICh5IHx8IDApO1xuXG5cdFx0XHRzdGFjay5wb2ludHNbcG9pbnRLZXldLnB1c2goc3RhY2suY3VtKTtcblx0XHRcdHN0YWNrZWRZRGF0YVtpXSA9IHN0YWNrLmN1bTtcblxuXHRcdH1cblxuXHRcdGlmIChzdGFja2luZyA9PT0gJ3BlcmNlbnQnKSB7XG5cdFx0XHR5QXhpcy51c2VQZXJjZW50YWdlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YWNrZWRZRGF0YSA9IHN0YWNrZWRZRGF0YTsgLy8gVG8gYmUgdXNlZCBpbiBnZXRFeHRyZW1lc1xuXG5cdFx0Ly8gUmVzZXQgb2xkIHN0YWNrc1xuXHRcdHlBeGlzLm9sZFN0YWNrcyA9IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJdGVyYXRlIG92ZXIgYWxsIHN0YWNrcyBhbmQgY29tcHV0ZSB0aGUgYWJzb2x1dGUgdmFsdWVzIHRvIHBlcmNlbnRcblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuc2V0UGVyY2VudFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHN0YWNrS2V5ID0gc2VyaWVzLnN0YWNrS2V5LFxuXHRcdFx0c3RhY2tzID0gc2VyaWVzLnlBeGlzLnN0YWNrcyxcblx0XHRcdHByb2Nlc3NlZFhEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFhEYXRhO1xuXG5cdFx0ZWFjaChbc3RhY2tLZXksICctJyArIHN0YWNrS2V5XSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIGkgPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHN0YWNrLFxuXHRcdFx0XHRwb2ludEV4dHJlbWVzLFxuXHRcdFx0XHR0b3RhbEZhY3RvcjtcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR4ID0gcHJvY2Vzc2VkWERhdGFbaV07XG5cdFx0XHRcdHN0YWNrID0gc3RhY2tzW2tleV0gJiYgc3RhY2tzW2tleV1beF07XG5cdFx0XHRcdHBvaW50RXh0cmVtZXMgPSBzdGFjayAmJiBzdGFjay5wb2ludHNbc2VyaWVzLmluZGV4ICsgJywnICsgaV07XG5cdFx0XHRcdGlmIChwb2ludEV4dHJlbWVzKSB7XG5cdFx0XHRcdFx0dG90YWxGYWN0b3IgPSBzdGFjay50b3RhbCA/IDEwMCAvIHN0YWNrLnRvdGFsIDogMDtcblx0XHRcdFx0XHRwb2ludEV4dHJlbWVzWzBdID0gY29ycmVjdEZsb2F0KHBvaW50RXh0cmVtZXNbMF0gKiB0b3RhbEZhY3Rvcik7IC8vIFkgYm90dG9tIHZhbHVlXG5cdFx0XHRcdFx0cG9pbnRFeHRyZW1lc1sxXSA9IGNvcnJlY3RGbG9hdChwb2ludEV4dHJlbWVzWzFdICogdG90YWxGYWN0b3IpOyAvLyBZIHZhbHVlXG5cdFx0XHRcdFx0c2VyaWVzLnN0YWNrZWRZRGF0YVtpXSA9IHBvaW50RXh0cmVtZXNbMV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvLyBFeHRlbmQgdGhlIENoYXJ0IHByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5cdGV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNlcmllcyBkeW5hbWljYWxseSBhZnRlciAgdGltZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGNvbmZpZyBvcHRpb25zXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IGFmdGVyIGFkZGluZy4gRGVmYXVsdHMgdG8gdHJ1ZS5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gc2VyaWVzIFRoZSBuZXdseSBjcmVhdGVkIHNlcmllcyBvYmplY3Rcblx0XHQgKi9cblx0XHRhZGRTZXJpZXM6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNlcmllcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzO1xuXG5cdFx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7IC8vIGRlZmF1bHRzIHRvIHRydWVcblxuXHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdhZGRTZXJpZXMnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlcmllcyA9IGNoYXJ0LmluaXRTZXJpZXMob3B0aW9ucyk7XG5cblx0XHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gdHJ1ZTsgLy8gdGhlIHNlcmllcyBhcnJheSBpcyBvdXQgb2Ygc3luYyB3aXRoIHRoZSBkaXNwbGF5XG5cdFx0XHRcdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXHRcdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXJpZXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHQgICAgICogQWRkIGFuIGF4aXMgdG8gdGhlIGNoYXJ0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgYXhpcyBvcHRpb25cblx0ICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNYIFdoZXRoZXIgaXQgaXMgYW4gWCBheGlzIG9yIGEgdmFsdWUgYXhpc1xuXHQgICAgICovXG5cdFx0YWRkQXhpczogZnVuY3Rpb24gKG9wdGlvbnMsIGlzWCwgcmVkcmF3LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBrZXkgPSBpc1ggPyAneEF4aXMnIDogJ3lBeGlzJyxcblx0XHRcdFx0Y2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRheGlzO1xuXG5cdFx0XHQvKmpzbGludCB1bnVzZWQ6IGZhbHNlKi9cblx0XHRcdGF4aXMgPSBuZXcgQXhpcyh0aGlzLCBtZXJnZShvcHRpb25zLCB7XG5cdFx0XHRcdGluZGV4OiB0aGlzW2tleV0ubGVuZ3RoLFxuXHRcdFx0XHRpc1g6IGlzWFxuXHRcdFx0fSkpO1xuXHRcdFx0Lypqc2xpbnQgdW51c2VkOiB0cnVlKi9cblxuXHRcdFx0Ly8gUHVzaCB0aGUgbmV3IGF4aXMgb3B0aW9ucyB0byB0aGUgY2hhcnQgb3B0aW9uc1xuXHRcdFx0Y2hhcnRPcHRpb25zW2tleV0gPSBzcGxhdChjaGFydE9wdGlvbnNba2V5XSB8fCB7fSk7XG5cdFx0XHRjaGFydE9wdGlvbnNba2V5XS5wdXNoKG9wdGlvbnMpO1xuXG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdHRoaXMucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERpbSB0aGUgY2hhcnQgYW5kIHNob3cgYSBsb2FkaW5nIHRleHQgb3Igc3ltYm9sXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBbiBvcHRpb25hbCB0ZXh0IHRvIHNob3cgaW4gdGhlIGxvYWRpbmcgbGFiZWwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmVcblx0XHQgKi9cblx0XHRzaG93TG9hZGluZzogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRcdGxvYWRpbmdEaXYgPSBjaGFydC5sb2FkaW5nRGl2LFxuXHRcdFx0XHRsb2FkaW5nT3B0aW9ucyA9IG9wdGlvbnMubG9hZGluZyxcblx0XHRcdFx0c2V0TG9hZGluZ1NpemUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGxvYWRpbmdEaXYpIHtcblx0XHRcdFx0XHRcdGNzcyhsb2FkaW5nRGl2LCB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IGNoYXJ0LnBsb3RMZWZ0ICsgUFgsXG5cdFx0XHRcdFx0XHRcdHRvcDogY2hhcnQucGxvdFRvcCArIFBYLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFdpZHRoICsgUFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnQucGxvdEhlaWdodCArIFBYXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgbGF5ZXIgYXQgdGhlIGZpcnN0IGNhbGxcblx0XHRcdGlmICghbG9hZGluZ0Rpdikge1xuXHRcdFx0XHRjaGFydC5sb2FkaW5nRGl2ID0gbG9hZGluZ0RpdiA9IGNyZWF0ZUVsZW1lbnQoRElWLCB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lOiBQUkVGSVggKyAnbG9hZGluZydcblx0XHRcdFx0fSwgZXh0ZW5kKGxvYWRpbmdPcHRpb25zLnN0eWxlLCB7XG5cdFx0XHRcdFx0ekluZGV4OiAxMCxcblx0XHRcdFx0XHRkaXNwbGF5OiBOT05FXG5cdFx0XHRcdH0pLCBjaGFydC5jb250YWluZXIpO1xuXG5cdFx0XHRcdGNoYXJ0LmxvYWRpbmdTcGFuID0gY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQnc3BhbicsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRsb2FkaW5nT3B0aW9ucy5sYWJlbFN0eWxlLFxuXHRcdFx0XHRcdGxvYWRpbmdEaXZcblx0XHRcdFx0KTtcblx0XHRcdFx0YWRkRXZlbnQoY2hhcnQsICdyZWRyYXcnLCBzZXRMb2FkaW5nU2l6ZSk7IC8vICMxMDgwXG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSB0ZXh0XG5cdFx0XHRjaGFydC5sb2FkaW5nU3Bhbi5pbm5lckhUTUwgPSBzdHIgfHwgb3B0aW9ucy5sYW5nLmxvYWRpbmc7XG5cblx0XHRcdC8vIHNob3cgaXRcblx0XHRcdGlmICghY2hhcnQubG9hZGluZ1Nob3duKSB7XG5cdFx0XHRcdGNzcyhsb2FkaW5nRGl2LCB7XG5cdFx0XHRcdFx0b3BhY2l0eTogMCxcblx0XHRcdFx0XHRkaXNwbGF5OiAnJ1x0XHRcdFx0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRhbmltYXRlKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0XHRvcGFjaXR5OiBsb2FkaW5nT3B0aW9ucy5zdHlsZS5vcGFjaXR5XG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRkdXJhdGlvbjogbG9hZGluZ09wdGlvbnMuc2hvd0R1cmF0aW9uIHx8IDBcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNoYXJ0LmxvYWRpbmdTaG93biA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRzZXRMb2FkaW5nU2l6ZSgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWRlIHRoZSBsb2FkaW5nIGxheWVyXG5cdFx0ICovXG5cdFx0aGlkZUxvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRsb2FkaW5nRGl2ID0gdGhpcy5sb2FkaW5nRGl2O1xuXG5cdFx0XHRpZiAobG9hZGluZ0Rpdikge1xuXHRcdFx0XHRhbmltYXRlKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0XHRvcGFjaXR5OiAwXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5sb2FkaW5nLmhpZGVEdXJhdGlvbiB8fCAxMDAsXG5cdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGNzcyhsb2FkaW5nRGl2LCB7IGRpc3BsYXk6IE5PTkUgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMubG9hZGluZ1Nob3duID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBleHRlbmQgdGhlIFBvaW50IHByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5cdGV4dGVuZChQb2ludC5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHBvaW50IHdpdGggbmV3IG9wdGlvbnMgKHR5cGljYWxseSB4L3kgZGF0YSkgYW5kIG9wdGlvbmFsbHkgcmVkcmF3IHRoZSBzZXJpZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQb2ludCBvcHRpb25zIGFzIGRlZmluZWQgaW4gdGhlIHNlcmllcy5kYXRhIGFycmF5XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKlxuXHRcdCAqL1xuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHJlZHJhdywgYW5pbWF0aW9uLCBydW5FdmVudCkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYyxcblx0XHRcdFx0aSxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0bmFtZXMgPSBzZXJpZXMueEF4aXMgJiYgc2VyaWVzLnhBeGlzLm5hbWVzO1xuXG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0XHRwb2ludC5hcHBseU9wdGlvbnMob3B0aW9ucyk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHZpc3VhbHNcblx0XHRcdFx0aWYgKHBvaW50LnkgPT09IG51bGwgJiYgZ3JhcGhpYykgeyAvLyAjNDE0NlxuXHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgIWlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRcdFx0XHQvLyBEZWZlciB0aGUgYWN0dWFsIHJlZHJhdyB1bnRpbCBnZXRBdHRyaWJzIGhhcyBiZWVuIGNhbGxlZCAoIzMyNjApXG5cdFx0XHRcdFx0cG9pbnQucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGdyYXBoaWMgJiYgZ3JhcGhpYy5lbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubWFya2VyICYmIG9wdGlvbnMubWFya2VyLnN5bWJvbCkge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRncmFwaGljLmF0dHIocG9pbnQucG9pbnRBdHRyW3BvaW50LnN0YXRlIHx8ICcnXSlbcG9pbnQudmlzaWJsZSA9PT0gZmFsc2UgPyAnaGlkZScgOiAnc2hvdyddKHRydWUpOyAvLyAjMjQzMFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhdGFMYWJlbHMgJiYgcG9pbnQuZGF0YUxhYmVsKSB7IC8vICMyNDY4XG5cdFx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludC5yZWRyYXcgPSBudWxsO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY2hhbmdlcyBpbiB0aGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHRcdGkgPSBwb2ludC5pbmRleDtcblx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50LCBpKTtcblx0XHRcdFx0aWYgKG5hbWVzICYmIHBvaW50Lm5hbWUpIHtcblx0XHRcdFx0XHRuYW1lc1twb2ludC54XSA9IHBvaW50Lm5hbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXJpZXNPcHRpb25zLmRhdGFbaV0gPSBwb2ludC5vcHRpb25zO1xuXG5cdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdGlmICghc2VyaWVzLmZpeGVkQm94ICYmIHNlcmllcy5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHsgLy8gIzE5MDYsICMyMzIwXG5cdFx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnKSB7IC8vICMxODMxLCAjMTg4NVxuXHRcdFx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXJlIHRoZSBldmVudCB3aXRoIGEgZGVmYXVsdCBoYW5kbGVyIG9mIGRvaW5nIHRoZSB1cGRhdGVcblx0XHRcdGlmIChydW5FdmVudCA9PT0gZmFsc2UpIHsgLy8gV2hlbiBjYWxsZWQgZnJvbSBzZXREYXRhXG5cdFx0XHRcdHVwZGF0ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ3VwZGF0ZScsIHsgb3B0aW9uczogb3B0aW9ucyB9LCB1cGRhdGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBwb2ludCBhbmQgb3B0aW9uYWxseSByZWRyYXcgdGhlIHNlcmllcyBhbmQgaWYgbmVjZXNzYXJ5IHRoZSBheGVzXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uIChyZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQoaW5BcnJheSh0aGlzLCB0aGlzLnNlcmllcy5kYXRhKSwgcmVkcmF3LCBhbmltYXRpb24pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gRXh0ZW5kIHRoZSBzZXJpZXMgcHJvdG90eXBlIGZvciBkeW5hbWljIG1ldGhvZHNcblx0ZXh0ZW5kKFNlcmllcy5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBBZGQgYSBwb2ludCBkeW5hbWljYWxseSBhZnRlciBjaGFydCBsb2FkIHRpbWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQb2ludCBvcHRpb25zIGFzIGdpdmVuIGluIHNlcmllcy5kYXRhXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNoaWZ0IElmIHNoaWZ0IGlzIHRydWUsIGEgcG9pbnQgaXMgc2hpZnRlZCBvZmYgdGhlIHN0YXJ0XG5cdFx0ICogICAgb2YgdGhlIHNlcmllcyBhcyBvbmUgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZC5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKi9cblx0XHRhZGRQb2ludDogZnVuY3Rpb24gKG9wdGlvbnMsIHJlZHJhdywgc2hpZnQsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhLFxuXHRcdFx0XHRncmFwaCA9IHNlcmllcy5ncmFwaCxcblx0XHRcdFx0YXJlYSA9IHNlcmllcy5hcmVhLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0bmFtZXMgPSBzZXJpZXMueEF4aXMgJiYgc2VyaWVzLnhBeGlzLm5hbWVzLFxuXHRcdFx0XHRjdXJyZW50U2hpZnQgPSAoZ3JhcGggJiYgZ3JhcGguc2hpZnQpIHx8IDAsXG5cdFx0XHRcdHNoaWZ0U2hhcGVzID0gWydncmFwaCcsICdhcmVhJ10sXG5cdFx0XHRcdGRhdGFPcHRpb25zID0gc2VyaWVzT3B0aW9ucy5kYXRhLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0aXNJblRoZU1pZGRsZSxcblx0XHRcdFx0eERhdGEgPSBzZXJpZXMueERhdGEsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHg7XG5cblx0XHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblxuXHRcdFx0Ly8gTWFrZSBncmFwaCBhbmltYXRlIHNpZGV3YXlzXG5cdFx0XHRpZiAoc2hpZnQpIHtcblx0XHRcdFx0aSA9IHNlcmllcy56b25lcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRzaGlmdFNoYXBlcy5wdXNoKCd6b25lR3JhcGgnICsgaSwgJ3pvbmVBcmVhJyArIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVhY2goc2hpZnRTaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuXHRcdFx0XHRcdGlmIChzZXJpZXNbc2hhcGVdKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXNbc2hhcGVdLnNoaWZ0ID0gY3VycmVudFNoaWZ0ICsgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZWEpIHtcblx0XHRcdFx0YXJlYS5pc0FyZWEgPSB0cnVlOyAvLyBuZWVkZWQgaW4gYW5pbWF0aW9uLCBib3RoIHdpdGggYW5kIHdpdGhvdXQgc2hpZnRcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3B0aW9uYWwgcmVkcmF3LCBkZWZhdWx0cyB0byB0cnVlXG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdC8vIEdldCBvcHRpb25zIGFuZCBwdXNoIHRoZSBwb2ludCB0byB4RGF0YSwgeURhdGEgYW5kIHNlcmllcy5vcHRpb25zLiBJbiBzZXJpZXMuZ2VuZXJhdGVQb2ludHNcblx0XHRcdC8vIHRoZSBQb2ludCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQgb24gZGVtYW5kIGFuZCBwdXNoZWQgdG8gdGhlIHNlcmllcy5kYXRhIGFycmF5LlxuXHRcdFx0cG9pbnQgPSB7IHNlcmllczogc2VyaWVzIH07XG5cdFx0XHRzZXJpZXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHBvaW50LCBbb3B0aW9uc10pO1xuXHRcdFx0eCA9IHBvaW50Lng7XG5cblx0XHRcdC8vIEdldCB0aGUgaW5zZXJ0aW9uIHBvaW50XG5cdFx0XHRpID0geERhdGEubGVuZ3RoO1xuXHRcdFx0aWYgKHNlcmllcy5yZXF1aXJlU29ydGluZyAmJiB4IDwgeERhdGFbaSAtIDFdKSB7XG5cdFx0XHRcdGlzSW5UaGVNaWRkbGUgPSB0cnVlO1xuXHRcdFx0XHR3aGlsZSAoaSAmJiB4RGF0YVtpIC0gMV0gPiB4KSB7XG5cdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgJ3NwbGljZScsIGksIDAsIDApOyAvLyBpbnNlcnQgdW5kZWZpbmVkIGl0ZW1cblx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgaSk7IC8vIHVwZGF0ZSBpdFxuXG5cdFx0XHRpZiAobmFtZXMgJiYgcG9pbnQubmFtZSkge1xuXHRcdFx0XHRuYW1lc1t4XSA9IHBvaW50Lm5hbWU7XG5cdFx0XHR9XG5cdFx0XHRkYXRhT3B0aW9ucy5zcGxpY2UoaSwgMCwgb3B0aW9ucyk7XG5cblx0XHRcdGlmIChpc0luVGhlTWlkZGxlKSB7XG5cdFx0XHRcdHNlcmllcy5kYXRhLnNwbGljZShpLCAwLCBudWxsKTtcblx0XHRcdFx0c2VyaWVzLnByb2Nlc3NEYXRhKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdlbmVyYXRlIHBvaW50cyB0byBiZSBhZGRlZCB0byB0aGUgbGVnZW5kICgjMTMyOSlcblx0XHRcdGlmIChzZXJpZXNPcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHtcblx0XHRcdFx0c2VyaWVzLmdlbmVyYXRlUG9pbnRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNoaWZ0IHRoZSBmaXJzdCBwb2ludCBvZmYgdGhlIHBhcmFsbGVsIGFycmF5c1xuXHRcdFx0Ly8gdG9kbzogY29uc2lkZXIgc2VyaWVzLnJlbW92ZVBvaW50KGkpIG1ldGhvZFxuXHRcdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRcdGlmIChkYXRhWzBdICYmIGRhdGFbMF0ucmVtb3ZlKSB7XG5cdFx0XHRcdFx0ZGF0YVswXS5yZW1vdmUoZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGEuc2hpZnQoKTtcblx0XHRcdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQsICdzaGlmdCcpO1xuXG5cdFx0XHRcdFx0ZGF0YU9wdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWRyYXdcblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdHNlcmllcy5nZXRBdHRyaWJzKCk7IC8vICMxOTM3XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBwb2ludCAocmVuZGVyZWQgb3Igbm90KSwgYnkgaW5kZXhcblx0XHQgKi9cblx0XHRyZW1vdmVQb2ludDogZnVuY3Rpb24gKGksIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEsXG5cdFx0XHRcdHBvaW50ID0gZGF0YVtpXSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGlmIChkYXRhLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50IHx8IHsgc2VyaWVzOiBzZXJpZXMgfSwgJ3NwbGljZScsIGksIDEpO1xuXG5cdFx0XHRcdFx0aWYgKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdC8vIEZpcmUgdGhlIGV2ZW50IHdpdGggYSBkZWZhdWx0IGhhbmRsZXIgb2YgcmVtb3ZpbmcgdGhlIHBvaW50XG5cdFx0XHRpZiAocG9pbnQpIHtcblx0XHRcdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ3JlbW92ZScsIG51bGwsIHJlbW92ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgc2VyaWVzIGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgY2hhcnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICovXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uIChyZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0XHRpZiAoIXNlcmllcy5pc1JlbW92aW5nKSB7ICAvKiBwcmV2ZW50IHRyaWdnZXJpbmcgbmF0aXZlIGV2ZW50IGluIGpRdWVyeVxuXHRcdFx0XHRcdChjYWxsaW5nIHRoZSByZW1vdmUgZnVuY3Rpb24gZnJvbSB0aGUgcmVtb3ZlIGV2ZW50KSAqL1xuXHRcdFx0XHRzZXJpZXMuaXNSZW1vdmluZyA9IHRydWU7XG5cblx0XHRcdFx0Ly8gZmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiByZW1vdmluZyB0aGUgcG9pbnRcblx0XHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ3JlbW92ZScsIG51bGwsIGZ1bmN0aW9uICgpIHtcblxuXG5cdFx0XHRcdFx0Ly8gZGVzdHJveSBlbGVtZW50c1xuXHRcdFx0XHRcdHNlcmllcy5kZXN0cm95KCk7XG5cblxuXHRcdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSBjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdFx0XHRjaGFydC5saW5rU2VyaWVzKCk7XG5cblx0XHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9XG5cdFx0XHRzZXJpZXMuaXNSZW1vdmluZyA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHNlcmllcyB3aXRoIGEgbmV3IHNldCBvZiBvcHRpb25zXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAobmV3T3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHQvLyBtdXN0IHVzZSB1c2VyIG9wdGlvbnMgd2hlbiBjaGFuZ2luZyB0eXBlIGJlY2F1c2UgdGhpcy5vcHRpb25zIGlzIG1lcmdlZFxuXHRcdFx0XHQvLyBpbiB3aXRoIHR5cGUgc3BlY2lmaWMgcGxvdE9wdGlvbnNcblx0XHRcdFx0b2xkT3B0aW9ucyA9IHRoaXMudXNlck9wdGlvbnMsXG5cdFx0XHRcdG9sZFR5cGUgPSB0aGlzLnR5cGUsXG5cdFx0XHRcdHByb3RvID0gc2VyaWVzVHlwZXNbb2xkVHlwZV0ucHJvdG90eXBlLFxuXHRcdFx0XHRwcmVzZXJ2ZSA9IFsnZ3JvdXAnLCAnbWFya2VyR3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJ10sXG5cdFx0XHRcdG47XG5cblx0XHRcdC8vIElmIHdlJ3JlIGNoYW5naW5nIHR5cGUgb3IgekluZGV4LCBjcmVhdGUgbmV3IGdyb3VwcyAoIzMzODAsICMzNDA0KVxuXHRcdFx0aWYgKChuZXdPcHRpb25zLnR5cGUgJiYgbmV3T3B0aW9ucy50eXBlICE9PSBvbGRUeXBlKSB8fCBuZXdPcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByZXNlcnZlLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBncm91cHMgYXJlIG5vdCBkZXN0cm95ZWQgKCMzMDk0KVxuXHRcdFx0ZWFjaChwcmVzZXJ2ZSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0cHJlc2VydmVbcHJvcF0gPSBzZXJpZXNbcHJvcF07XG5cdFx0XHRcdGRlbGV0ZSBzZXJpZXNbcHJvcF07XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRG8gdGhlIG1lcmdlLCB3aXRoIHNvbWUgZm9yY2VkIG9wdGlvbnNcblx0XHRcdG5ld09wdGlvbnMgPSBtZXJnZShvbGRPcHRpb25zLCB7XG5cdFx0XHRcdGFuaW1hdGlvbjogZmFsc2UsXG5cdFx0XHRcdGluZGV4OiB0aGlzLmluZGV4LFxuXHRcdFx0XHRwb2ludFN0YXJ0OiB0aGlzLnhEYXRhWzBdIC8vIHdoZW4gdXBkYXRpbmcgYWZ0ZXIgYWRkUG9pbnRcblx0XHRcdH0sIHsgZGF0YTogdGhpcy5vcHRpb25zLmRhdGEgfSwgbmV3T3B0aW9ucyk7XG5cblx0XHRcdC8vIERlc3Ryb3kgdGhlIHNlcmllcyBhbmQgZGVsZXRlIGFsbCBwcm9wZXJ0aWVzLiBSZWluc2VydCBhbGwgbWV0aG9kcyBcblx0XHRcdC8vIGFuZCBwcm9wZXJ0aWVzIGZyb20gdGhlIG5ldyB0eXBlIHByb3RvdHlwZSAoIzIyNzAsICMzNzE5KVxuXHRcdFx0dGhpcy5yZW1vdmUoZmFsc2UpO1xuXHRcdFx0Zm9yIChuIGluIHByb3RvKSB7XG5cdFx0XHRcdHRoaXNbbl0gPSBVTkRFRklORUQ7XG5cdFx0XHR9XG5cdFx0XHRleHRlbmQodGhpcywgc2VyaWVzVHlwZXNbbmV3T3B0aW9ucy50eXBlIHx8IG9sZFR5cGVdLnByb3RvdHlwZSk7XG5cblx0XHRcdC8vIFJlLXJlZ2lzdGVyIGdyb3VwcyAoIzMwOTQpXG5cdFx0XHRlYWNoKHByZXNlcnZlLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRzZXJpZXNbcHJvcF0gPSBwcmVzZXJ2ZVtwcm9wXTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmluaXQoY2hhcnQsIG5ld09wdGlvbnMpO1xuXHRcdFx0Y2hhcnQubGlua1NlcmllcygpOyAvLyBMaW5rcyBhcmUgbG9zdCBpbiB0aGlzLnJlbW92ZSAoIzMwMjgpXG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBFeHRlbmQgdGhlIEF4aXMucHJvdG90eXBlIGZvciBkeW5hbWljIG1ldGhvZHNcblx0ZXh0ZW5kKEF4aXMucHJvdG90eXBlLCB7XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIGF4aXMgd2l0aCBhIG5ldyBvcHRpb25zIHN0cnVjdHVyZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKG5ld09wdGlvbnMsIHJlZHJhdykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdFx0bmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnNbdGhpcy5jb2xsXVt0aGlzLm9wdGlvbnMuaW5kZXhdID0gbWVyZ2UodGhpcy51c2VyT3B0aW9ucywgbmV3T3B0aW9ucyk7XG5cblx0XHRcdHRoaXMuZGVzdHJveSh0cnVlKTtcblx0XHRcdHRoaXMuX2FkZGVkUGxvdExCID0gdGhpcy5jaGFydC5fbGFiZWxQYW5lcyA9IFVOREVGSU5FRDsgLy8gIzE2MTEsICMyODg3LCAjNDMxNFxuXG5cdFx0XHR0aGlzLmluaXQoY2hhcnQsIGV4dGVuZChuZXdPcHRpb25zLCB7IGV2ZW50czogVU5ERUZJTkVEIH0pKTtcblxuXHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0ICAgICAqIFJlbW92ZSB0aGUgYXhpcyBmcm9tIHRoZSBjaGFydFxuXHQgICAgICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRrZXkgPSB0aGlzLmNvbGwsIC8vIHhBeGlzIG9yIHlBeGlzXG5cdFx0XHRcdGF4aXNTZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0aSA9IGF4aXNTZXJpZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBSZW1vdmUgYXNzb2NpYXRlZCBzZXJpZXMgKCMyNjg3KVxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAoYXhpc1Nlcmllc1tpXSkge1xuXHRcdFx0XHRcdGF4aXNTZXJpZXNbaV0ucmVtb3ZlKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIGF4aXNcblx0XHRcdGVyYXNlKGNoYXJ0LmF4ZXMsIHRoaXMpO1xuXHRcdFx0ZXJhc2UoY2hhcnRba2V5XSwgdGhpcyk7XG5cdFx0XHRjaGFydC5vcHRpb25zW2tleV0uc3BsaWNlKHRoaXMub3B0aW9ucy5pbmRleCwgMSk7XG5cdFx0XHRlYWNoKGNoYXJ0W2tleV0sIGZ1bmN0aW9uIChheGlzLCBpKSB7IC8vIFJlLWluZGV4LCAjMTcwNlxuXHRcdFx0XHRheGlzLm9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIGF4aXMgdGl0bGUgYnkgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNldFRpdGxlOiBmdW5jdGlvbiAobmV3VGl0bGVPcHRpb25zLCByZWRyYXcpIHtcblx0XHRcdHRoaXMudXBkYXRlKHsgdGl0bGU6IG5ld1RpdGxlT3B0aW9ucyB9LCByZWRyYXcpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgbmV3IGF4aXMgY2F0ZWdvcmllcyBhbmQgb3B0aW9uYWxseSByZWRyYXdcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBjYXRlZ29yaWVzXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXdcblx0XHQgKi9cblx0XHRzZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoY2F0ZWdvcmllcywgcmVkcmF3KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSh7IGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMgfSwgcmVkcmF3KTtcblx0XHR9XG5cblx0fSk7XG5cblxuXHQvKipcblx0ICogTGluZVNlcmllcyBvYmplY3Rcblx0ICovXG5cdHZhciBMaW5lU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzKTtcblx0c2VyaWVzVHlwZXMubGluZSA9IExpbmVTZXJpZXM7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBhcmVhXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0dGhyZXNob2xkOiAwXG5cdFx0Ly8gdHJhY2tCeUFyZWE6IGZhbHNlLFxuXHRcdC8vIGxpbmVDb2xvcjogbnVsbCwgLy8gb3ZlcnJpZGVzIGNvbG9yLCBidXQgbGV0cyBmaWxsQ29sb3IgYmUgdW5hbHRlcmVkXG5cdFx0Ly8gZmlsbE9wYWNpdHk6IDAuNzUsXG5cdFx0Ly8gZmlsbENvbG9yOiBudWxsXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBBcmVhU2VyaWVzIG9iamVjdFxuXHQgKi9cblx0dmFyIEFyZWFTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0XHR0eXBlOiAnYXJlYScsXG5cdFx0LyoqXG5cdFx0ICogRm9yIHN0YWNrcywgZG9uJ3Qgc3BsaXQgc2VnbWVudHMgb24gbnVsbCB2YWx1ZXMuIEluc3RlYWQsIGRyYXcgbnVsbCB2YWx1ZXMgd2l0aCBcblx0XHQgKiBubyBtYXJrZXIuIEFsc28gaW5zZXJ0IGR1bW15IHBvaW50cyBmb3IgYW55IFggcG9zaXRpb24gdGhhdCBleGlzdHMgaW4gb3RoZXIgc2VyaWVzXG5cdFx0ICogaW4gdGhlIHN0YWNrLlxuXHRcdCAqLyBcblx0XHRnZXRTZWdtZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdHNlZ21lbnQgPSBbXSxcblx0XHRcdFx0a2V5cyA9IFtdLFxuXHRcdFx0XHR4QXhpcyA9IHRoaXMueEF4aXMsXG5cdFx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdFx0c3RhY2sgPSB5QXhpcy5zdGFja3NbdGhpcy5zdGFja0tleV0sXG5cdFx0XHRcdHBvaW50TWFwID0ge30sXG5cdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRwbG90WSxcblx0XHRcdFx0cG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRcdGNvbm5lY3ROdWxscyA9IHRoaXMub3B0aW9ucy5jb25uZWN0TnVsbHMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHg7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3RhY2tpbmcgJiYgIXRoaXMuY3JvcHBlZCkgeyAvLyBjcm9wcGVkIGNhdXNlcyBhcnRlZmFjdHMgaW4gU3RvY2ssIGFuZCBwZXJmIGlzc3VlXG5cdFx0XHRcdC8vIENyZWF0ZSBhIG1hcCB3aGVyZSB3ZSBjYW4gcXVpY2tseSBsb29rIHVwIHRoZSBwb2ludHMgYnkgdGhlaXIgWCB2YWx1ZS5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBvaW50TWFwW3BvaW50c1tpXS54XSA9IHBvaW50c1tpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNvcnQgdGhlIGtleXMgKCMxNjUxKVxuXHRcdFx0XHRmb3IgKHggaW4gc3RhY2spIHtcblx0XHRcdFx0XHRpZiAoc3RhY2tbeF0udG90YWwgIT09IG51bGwpIHsgLy8gbnVsbGVkIGFmdGVyIHN3aXRjaGluZyBiZXR3ZWVuIGdyb3VwaW5nIGFuZCBub3QgKCMxNjUxLCAjMjMzNilcblx0XHRcdFx0XHRcdGtleXMucHVzaCgreCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBhIC0gYjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0ZWFjaChrZXlzLCBmdW5jdGlvbiAoeCkge1xuXHRcdFx0XHRcdHZhciB5ID0gMCxcblx0XHRcdFx0XHRcdHN0YWNrUG9pbnQ7XG5cblx0XHRcdFx0XHRpZiAoY29ubmVjdE51bGxzICYmICghcG9pbnRNYXBbeF0gfHwgcG9pbnRNYXBbeF0ueSA9PT0gbnVsbCkpIHsgLy8gIzE4MzZcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIFRoZSBwb2ludCBleGlzdHMsIHB1c2ggaXQgdG8gdGhlIHNlZ21lbnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvaW50TWFwW3hdKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50LnB1c2gocG9pbnRNYXBbeF0pO1xuXG5cdFx0XHRcdFx0Ly8gVGhlcmUgaXMgbm8gcG9pbnQgZm9yIHRoaXMgWCB2YWx1ZSBpbiB0aGlzIHNlcmllcywgc28gd2UgXG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IGEgZHVtbXkgcG9pbnQgaW4gb3JkZXIgZm9yIHRoZSBhcmVhcyB0byBiZSBkcmF3blxuXHRcdFx0XHRcdC8vIGNvcnJlY3RseS5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBMb29wIGRvd24gdGhlIHN0YWNrIHRvIGZpbmQgdGhlIHNlcmllcyBiZWxvdyB0aGlzIG9uZSB0aGF0IGhhc1xuXHRcdFx0XHRcdFx0Ly8gYSB2YWx1ZSAoIzE5OTEpXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSBzZXJpZXMuaW5kZXg7IGkgPD0geUF4aXMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrUG9pbnQgPSBzdGFja1t4XS5wb2ludHNbaSArICcsJyArIHhdO1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RhY2tQb2ludCkge1xuXHRcdFx0XHRcdFx0XHRcdHkgPSBzdGFja1BvaW50WzFdO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBsb3RYID0geEF4aXMudHJhbnNsYXRlKHgpO1xuXHRcdFx0XHRcdFx0cGxvdFkgPSB5QXhpcy50b1BpeGVscyh5LCB0cnVlKTtcblx0XHRcdFx0XHRcdHNlZ21lbnQucHVzaCh7IFxuXHRcdFx0XHRcdFx0XHR5OiBudWxsLCBcblx0XHRcdFx0XHRcdFx0cGxvdFg6IHBsb3RYLFxuXHRcdFx0XHRcdFx0XHRjbGllbnRYOiBwbG90WCwgXG5cdFx0XHRcdFx0XHRcdHBsb3RZOiBwbG90WSwgXG5cdFx0XHRcdFx0XHRcdHlCb3R0b206IHBsb3RZLFxuXHRcdFx0XHRcdFx0XHRvbk1vdXNlT3Zlcjogbm9vcFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoc2VnbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFNlcmllcy5wcm90b3R5cGUuZ2V0U2VnbWVudHMuY2FsbCh0aGlzKTtcblx0XHRcdFx0c2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRlbmQgdGhlIGJhc2UgU2VyaWVzIGdldFNlZ21lbnRQYXRoIG1ldGhvZCBieSBhZGRpbmcgdGhlIHBhdGggZm9yIHRoZSBhcmVhLlxuXHRcdCAqIFRoaXMgcGF0aCBpcyBwdXNoZWQgdG8gdGhlIHNlcmllcy5hcmVhUGF0aCBwcm9wZXJ0eS5cblx0XHQgKi9cblx0XHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHNlZ21lbnRQYXRoID0gU2VyaWVzLnByb3RvdHlwZS5nZXRTZWdtZW50UGF0aC5jYWxsKHRoaXMsIHNlZ21lbnQpLCAvLyBjYWxsIGJhc2UgbWV0aG9kXG5cdFx0XHRcdGFyZWFTZWdtZW50UGF0aCA9IFtdLmNvbmNhdChzZWdtZW50UGF0aCksIC8vIHdvcmsgb24gYSBjb3B5IGZvciB0aGUgYXJlYSBwYXRoXG5cdFx0XHRcdGksXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHNlZ0xlbmd0aCA9IHNlZ21lbnRQYXRoLmxlbmd0aCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHRoaXMueUF4aXMuZ2V0VGhyZXNob2xkKG9wdGlvbnMudGhyZXNob2xkKSwgLy8gIzIxODFcblx0XHRcdFx0eUJvdHRvbTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZ0xlbmd0aCA9PT0gMykgeyAvLyBmb3IgYW5pbWF0aW9uIGZyb20gMSB0byB0d28gcG9pbnRzXG5cdFx0XHRcdGFyZWFTZWdtZW50UGF0aC5wdXNoKEwsIHNlZ21lbnRQYXRoWzFdLCBzZWdtZW50UGF0aFsyXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdGFja2luZyAmJiAhdGhpcy5jbG9zZWRTdGFja3MpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEZvbGxvdyBzdGFjayBiYWNrLiBUb2RvOiBpbXBsZW1lbnQgYXJlYXNwbGluZS4gQSBnZW5lcmFsIHNvbHV0aW9uIGNvdWxkIGJlIHRvIFxuXHRcdFx0XHQvLyByZXZlcnNlIHRoZSBlbnRpcmUgZ3JhcGhQYXRoIG9mIHRoZSBwcmV2aW91cyBzZXJpZXMsIHRob3VnaCBtYXkgYmUgaGFyZCB3aXRoXG5cdFx0XHRcdC8vIHNwbGluZXMgYW5kIHdpdGggc2VyaWVzIHdpdGggZGlmZmVyZW50IGV4dHJlbWVzXG5cdFx0XHRcdGZvciAoaSA9IHNlZ21lbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0XHRcdHlCb3R0b20gPSBwaWNrKHNlZ21lbnRbaV0ueUJvdHRvbSwgdHJhbnNsYXRlZFRocmVzaG9sZCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHN0ZXAgbGluZT9cblx0XHRcdFx0XHRpZiAoaSA8IHNlZ21lbnQubGVuZ3RoIC0gMSAmJiBvcHRpb25zLnN0ZXApIHtcblx0XHRcdFx0XHRcdGFyZWFTZWdtZW50UGF0aC5wdXNoKHNlZ21lbnRbaSArIDFdLnBsb3RYLCB5Qm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goc2VnbWVudFtpXS5wbG90WCwgeUJvdHRvbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHsgLy8gZm9sbG93IHplcm8gbGluZSBiYWNrXG5cdFx0XHRcdHRoaXMuY2xvc2VTZWdtZW50KGFyZWFTZWdtZW50UGF0aCwgc2VnbWVudCwgdHJhbnNsYXRlZFRocmVzaG9sZCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFyZWFQYXRoID0gdGhpcy5hcmVhUGF0aC5jb25jYXQoYXJlYVNlZ21lbnRQYXRoKTtcblx0XHRcdHJldHVybiBzZWdtZW50UGF0aDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZGFibGUgbWV0aG9kIHRvIGNsb3NlIHRoZSBzZWdtZW50IHBhdGggb2YgYW4gYXJlYS4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHBvbGFyIFxuXHRcdCAqIGNoYXJ0cy5cblx0XHQgKi9cblx0XHRjbG9zZVNlZ21lbnQ6IGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50LCB0cmFuc2xhdGVkVGhyZXNob2xkKSB7XG5cdFx0XHRwYXRoLnB1c2goXG5cdFx0XHRcdEwsXG5cdFx0XHRcdHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAxXS5wbG90WCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCxcblx0XHRcdFx0TCxcblx0XHRcdFx0c2VnbWVudFswXS5wbG90WCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZFxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGdyYXBoIGFuZCB0aGUgdW5kZXJseWluZyBhcmVhLiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgU2VyaWVzIGJhc2Vcblx0XHQgKiBmdW5jdGlvbiBhbmQgYWRkcyB0aGUgYXJlYS4gVGhlIGFyZWFQYXRoIGlzIGNhbGN1bGF0ZWQgaW4gdGhlIGdldFNlZ21lbnRQYXRoXG5cdFx0ICogbWV0aG9kIGNhbGxlZCBmcm9tIFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLlxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XG5cdFx0XHQvLyBEZWZpbmUgb3IgcmVzZXQgYXJlYVBhdGhcblx0XHRcdHRoaXMuYXJlYVBhdGggPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2FsbCB0aGUgYmFzZSBtZXRob2Rcblx0XHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZWZpbmUgbG9jYWwgdmFyaWFibGVzXG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0YXJlYVBhdGggPSB0aGlzLmFyZWFQYXRoLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR6b25lcyA9IHRoaXMuem9uZXMsXG5cdFx0XHRcdHByb3BzID0gW1snYXJlYScsIHRoaXMuY29sb3IsIG9wdGlvbnMuZmlsbENvbG9yXV07IC8vIGFyZWEgbmFtZSwgbWFpbiBjb2xvciwgZmlsbCBjb2xvclxuXHRcdFx0XG5cdFx0XHRlYWNoKHpvbmVzLCBmdW5jdGlvbiAodGhyZXNob2xkLCBpKSB7XG5cdFx0XHRcdHByb3BzLnB1c2goWyd6b25lQXJlYScgKyBpLCB0aHJlc2hvbGQuY29sb3IgfHwgc2VyaWVzLmNvbG9yLCB0aHJlc2hvbGQuZmlsbENvbG9yIHx8IG9wdGlvbnMuZmlsbENvbG9yXSk7XG5cdFx0XHR9KTtcblx0XHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdHZhciBhcmVhS2V5ID0gcHJvcFswXSxcblx0XHRcdFx0XHRhcmVhID0gc2VyaWVzW2FyZWFLZXldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBDcmVhdGUgb3IgdXBkYXRlIHRoZSBhcmVhXG5cdFx0XHRcdGlmIChhcmVhKSB7IC8vIHVwZGF0ZVxuXHRcdFx0XHRcdGFyZWEuYW5pbWF0ZSh7IGQ6IGFyZWFQYXRoIH0pO1xuXHRcdFxuXHRcdFx0XHR9IGVsc2UgeyAvLyBjcmVhdGVcblx0XHRcdFx0XHRzZXJpZXNbYXJlYUtleV0gPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChhcmVhUGF0aClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogcGljayhcblx0XHRcdFx0XHRcdFx0XHRwcm9wWzJdLFxuXHRcdFx0XHRcdFx0XHRcdENvbG9yKHByb3BbMV0pLnNldE9wYWNpdHkocGljayhvcHRpb25zLmZpbGxPcGFjaXR5LCAwLjc1KSkuZ2V0KClcblx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0ekluZGV4OiAwIC8vICMxMDY5XG5cdFx0XHRcdFx0XHR9KS5hZGQoc2VyaWVzLmdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGVcblx0fSk7XG5cblx0c2VyaWVzVHlwZXMuYXJlYSA9IEFyZWFTZXJpZXM7XG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3Igc3BsaW5lXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuc3BsaW5lID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMpO1xuXG5cdC8qKlxuXHQgKiBTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgU3BsaW5lU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdFx0dHlwZTogJ3NwbGluZScsXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNwbGluZSBzZWdtZW50IGZyb20gYSBnaXZlbiBwb2ludCdzIHByZXZpb3VzIG5laWdoYm91ciB0byB0aGUgZ2l2ZW4gcG9pbnRcblx0XHQgKi9cblx0XHRnZXRQb2ludFNwbGluZTogZnVuY3Rpb24gKHNlZ21lbnQsIHBvaW50LCBpKSB7XG5cdFx0XHR2YXIgc21vb3RoaW5nID0gMS41LCAvLyAxIG1lYW5zIGNvbnRyb2wgcG9pbnRzIG1pZHdheSBiZXR3ZWVuIHBvaW50cywgMiBtZWFucyAxLzMgZnJvbSB0aGUgcG9pbnQsIDMgaXMgMS80IGV0Y1xuXHRcdFx0XHRkZW5vbSA9IHNtb290aGluZyArIDEsXG5cdFx0XHRcdHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdLFxuXHRcdFx0XHRuZXh0UG9pbnQgPSBzZWdtZW50W2kgKyAxXSxcblx0XHRcdFx0bGVmdENvbnRYLFxuXHRcdFx0XHRsZWZ0Q29udFksXG5cdFx0XHRcdHJpZ2h0Q29udFgsXG5cdFx0XHRcdHJpZ2h0Q29udFksXG5cdFx0XHRcdHJldDtcblxuXHRcdFx0Ly8gZmluZCBjb250cm9sIHBvaW50c1xuXHRcdFx0aWYgKGxhc3RQb2ludCAmJiBuZXh0UG9pbnQpIHtcblx0XHRcdFxuXHRcdFx0XHR2YXIgbGFzdFggPSBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bGFzdFkgPSBsYXN0UG9pbnQucGxvdFksXG5cdFx0XHRcdFx0bmV4dFggPSBuZXh0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bmV4dFkgPSBuZXh0UG9pbnQucGxvdFksXG5cdFx0XHRcdFx0Y29ycmVjdGlvbjtcblxuXHRcdFx0XHRsZWZ0Q29udFggPSAoc21vb3RoaW5nICogcGxvdFggKyBsYXN0WCkgLyBkZW5vbTtcblx0XHRcdFx0bGVmdENvbnRZID0gKHNtb290aGluZyAqIHBsb3RZICsgbGFzdFkpIC8gZGVub207XG5cdFx0XHRcdHJpZ2h0Q29udFggPSAoc21vb3RoaW5nICogcGxvdFggKyBuZXh0WCkgLyBkZW5vbTtcblx0XHRcdFx0cmlnaHRDb250WSA9IChzbW9vdGhpbmcgKiBwbG90WSArIG5leHRZKSAvIGRlbm9tO1xuXG5cdFx0XHRcdC8vIGhhdmUgdGhlIHR3byBjb250cm9sIHBvaW50cyBtYWtlIGEgc3RyYWlnaHQgbGluZSB0aHJvdWdoIG1haW4gcG9pbnRcblx0XHRcdFx0Y29ycmVjdGlvbiA9ICgocmlnaHRDb250WSAtIGxlZnRDb250WSkgKiAocmlnaHRDb250WCAtIHBsb3RYKSkgL1xuXHRcdFx0XHRcdChyaWdodENvbnRYIC0gbGVmdENvbnRYKSArIHBsb3RZIC0gcmlnaHRDb250WTtcblxuXHRcdFx0XHRsZWZ0Q29udFkgKz0gY29ycmVjdGlvbjtcblx0XHRcdFx0cmlnaHRDb250WSArPSBjb3JyZWN0aW9uO1xuXG5cdFx0XHRcdC8vIHRvIHByZXZlbnQgZmFsc2UgZXh0cmVtZXMsIGNoZWNrIHRoYXQgY29udHJvbCBwb2ludHMgYXJlIGJldHdlZW5cblx0XHRcdFx0Ly8gbmVpZ2hib3VyaW5nIHBvaW50cycgeSB2YWx1ZXNcblx0XHRcdFx0aWYgKGxlZnRDb250WSA+IGxhc3RZICYmIGxlZnRDb250WSA+IHBsb3RZKSB7XG5cdFx0XHRcdFx0bGVmdENvbnRZID0gbWF0aE1heChsYXN0WSwgcGxvdFkpO1xuXHRcdFx0XHRcdHJpZ2h0Q29udFkgPSAyICogcGxvdFkgLSBsZWZ0Q29udFk7IC8vIG1pcnJvciBvZiBsZWZ0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0fSBlbHNlIGlmIChsZWZ0Q29udFkgPCBsYXN0WSAmJiBsZWZ0Q29udFkgPCBwbG90WSkge1xuXHRcdFx0XHRcdGxlZnRDb250WSA9IG1hdGhNaW4obGFzdFksIHBsb3RZKTtcblx0XHRcdFx0XHRyaWdodENvbnRZID0gMiAqIHBsb3RZIC0gbGVmdENvbnRZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyaWdodENvbnRZID4gbmV4dFkgJiYgcmlnaHRDb250WSA+IHBsb3RZKSB7XG5cdFx0XHRcdFx0cmlnaHRDb250WSA9IG1hdGhNYXgobmV4dFksIHBsb3RZKTtcblx0XHRcdFx0XHRsZWZ0Q29udFkgPSAyICogcGxvdFkgLSByaWdodENvbnRZO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJpZ2h0Q29udFkgPCBuZXh0WSAmJiByaWdodENvbnRZIDwgcGxvdFkpIHtcblx0XHRcdFx0XHRyaWdodENvbnRZID0gbWF0aE1pbihuZXh0WSwgcGxvdFkpO1xuXHRcdFx0XHRcdGxlZnRDb250WSA9IDIgKiBwbG90WSAtIHJpZ2h0Q29udFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgZm9yIGRyYXdpbmcgaW4gbmV4dCBwb2ludFxuXHRcdFx0XHRwb2ludC5yaWdodENvbnRYID0gcmlnaHRDb250WDtcblx0XHRcdFx0cG9pbnQucmlnaHRDb250WSA9IHJpZ2h0Q29udFk7XG5cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVmlzdWFsaXplIGNvbnRyb2wgcG9pbnRzIGZvciBkZWJ1Z2dpbmdcblx0XHRcdC8qXG5cdFx0XHRpZiAobGVmdENvbnRYKSB7XG5cdFx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIuY2lyY2xlKGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCwgMilcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdyZWQnLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0XHRmaWxsOiAnbm9uZSdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKFsnTScsIGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHQnTCcsIHBsb3RYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgcGxvdFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3BdKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHN0cm9rZTogJ3JlZCcsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLmNpcmNsZShyaWdodENvbnRYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgcmlnaHRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCwgMilcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMSxcblx0XHRcdFx0XHRcdGZpbGw6ICdub25lJ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoWydNJywgcmlnaHRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHJpZ2h0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdFx0J0wnLCBwbG90WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHBsb3RZICsgdGhpcy5jaGFydC5wbG90VG9wXSlcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0Ly8gbW92ZVRvIG9yIGxpbmVUb1xuXHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdHJldCA9IFtNLCBwbG90WCwgcGxvdFldO1xuXHRcdFx0fSBlbHNlIHsgLy8gY3VydmUgZnJvbSBsYXN0IHBvaW50IHRvIHRoaXNcblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdCdDJyxcblx0XHRcdFx0XHRsYXN0UG9pbnQucmlnaHRDb250WCB8fCBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFkgfHwgbGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGxlZnRDb250WCB8fCBwbG90WCxcblx0XHRcdFx0XHRsZWZ0Q29udFkgfHwgcGxvdFksXG5cdFx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XTtcblx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFggPSBsYXN0UG9pbnQucmlnaHRDb250WSA9IG51bGw7IC8vIHJlc2V0IGZvciB1cGRhdGluZyBzZXJpZXMgbGF0ZXJcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9KTtcblx0c2VyaWVzVHlwZXMuc3BsaW5lID0gU3BsaW5lU2VyaWVzO1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYXJlYXNwbGluZVxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLmFyZWFzcGxpbmUgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSk7XG5cblx0LyoqXG5cdCAqIEFyZWFTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgYXJlYVByb3RvID0gQXJlYVNlcmllcy5wcm90b3R5cGUsXG5cdFx0QXJlYVNwbGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNwbGluZVNlcmllcywge1xuXHRcdFx0dHlwZTogJ2FyZWFzcGxpbmUnLFxuXHRcdFx0Y2xvc2VkU3RhY2tzOiB0cnVlLCAvLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgcHJldmlvdXMgZ3JhcGggYmFjaywgZm9sbG93IHRoZSB0aHJlc2hvbGQgYmFja1xuXHRcdFx0XG5cdFx0XHQvLyBNaXggaW4gbWV0aG9kcyBmcm9tIHRoZSBhcmVhIHNlcmllc1xuXHRcdFx0Z2V0U2VnbWVudFBhdGg6IGFyZWFQcm90by5nZXRTZWdtZW50UGF0aCxcblx0XHRcdGNsb3NlU2VnbWVudDogYXJlYVByb3RvLmNsb3NlU2VnbWVudCxcblx0XHRcdGRyYXdHcmFwaDogYXJlYVByb3RvLmRyYXdHcmFwaCxcblx0XHRcdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGVcblx0XHR9KTtcblxuXHRzZXJpZXNUeXBlcy5hcmVhc3BsaW5lID0gQXJlYVNwbGluZVNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGNvbHVtblxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLmNvbHVtbiA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0Ym9yZGVyQ29sb3I6ICcjRkZGRkZGJyxcblx0XHQvL2JvcmRlcldpZHRoOiAxLFxuXHRcdGJvcmRlclJhZGl1czogMCxcblx0XHQvL2NvbG9yQnlQb2ludDogdW5kZWZpbmVkLFxuXHRcdGdyb3VwUGFkZGluZzogMC4yLFxuXHRcdC8vZ3JvdXBpbmc6IHRydWUsXG5cdFx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRcdHBvaW50UGFkZGluZzogMC4xLFxuXHRcdC8vcG9pbnRXaWR0aDogbnVsbCxcblx0XHRtaW5Qb2ludExlbmd0aDogMCxcblx0XHRjcm9wVGhyZXNob2xkOiA1MCwgLy8gd2hlbiB0aGVyZSBhcmUgbW9yZSBwb2ludHMsIHRoZXkgd2lsbCBub3QgYW5pbWF0ZSBvdXQgb2YgdGhlIGNoYXJ0IG9uIHhBeGlzLnNldEV4dHJlbWVzXG5cdFx0cG9pbnRSYW5nZTogbnVsbCwgLy8gbnVsbCBtZWFucyBhdXRvLCBtZWFuaW5nIDEgaW4gYSBjYXRlZ29yaXplZCBheGlzIGFuZCBsZWFzdCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBpZiBub3QgY2F0ZWdvcmllc1xuXHRcdHN0YXRlczoge1xuXHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0YnJpZ2h0bmVzczogMC4xLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRoYWxvOiBmYWxzZVxuXHRcdFx0fSxcblx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRjb2xvcjogJyNDMEMwQzAnLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkYXRhTGFiZWxzOiB7XG5cdFx0XHRhbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdFx0dmVydGljYWxBbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdFx0eTogbnVsbFxuXHRcdH0sXG5cdFx0c3RhcnRGcm9tVGhyZXNob2xkOiB0cnVlLCAvLyBkb2NzOiBodHRwOi8vanNmaWRkbGUubmV0L2hpZ2hjaGFydHMvaHo4Zm9wYW4vMTQvXG5cdFx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdGRpc3RhbmNlOiA2XG5cdFx0fSxcblx0XHR0aHJlc2hvbGQ6IDBcblx0fSk7XG5cblx0LyoqXG5cdCAqIENvbHVtblNlcmllcyBvYmplY3Rcblx0ICovXG5cdHZhciBDb2x1bW5TZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0XHR0eXBlOiAnY29sdW1uJyxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0XHRmaWxsOiAnY29sb3InLFxuXHRcdFx0cjogJ2JvcmRlclJhZGl1cydcblx0XHR9LFxuXHRcdGNyb3BTaG91bGRlcjogMCxcblx0XHRkaXJlY3RUb3VjaDogdHJ1ZSwgLy8gV2hlbiB0b29sdGlwIGlzIG5vdCBzaGFyZWQsIHRoaXMgc2VyaWVzIChhbmQgZGVyaXZhdGl2ZXMpIHJlcXVpcmVzIGRpcmVjdCB0b3VjaC9ob3Zlci4gS0QtdHJlZSBkb2VzIG5vdCBhcHBseS5cblx0XHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdG5lZ1N0YWNrczogdHJ1ZSwgLy8gdXNlIHNlcGFyYXRlIG5lZ2F0aXZlIHN0YWNrcywgdW5saWtlIGFyZWEgc3RhY2tzIHdoZXJlIGEgbmVnYXRpdmUgXG5cdFx0XHQvLyBwb2ludCBpcyBzdWJzdHJhY3RlZCBmcm9tIHByZXZpb3VzICgjMTkxMClcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBzZXJpZXNcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXG5cdFx0XHQvLyBpZiB0aGUgc2VyaWVzIGlzIGFkZGVkIGR5bmFtaWNhbGx5LCBmb3JjZSByZWRyYXcgb2Ygb3RoZXJcblx0XHRcdC8vIHNlcmllcyBhZmZlY3RlZCBieSBhIG5ldyBjb2x1bW5cblx0XHRcdGlmIChjaGFydC5oYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLnR5cGUgPT09IHNlcmllcy50eXBlKSB7XG5cdFx0XHRcdFx0XHRvdGhlclNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIHdpZHRoIGFuZCB4IG9mZnNldCBvZiB0aGUgY29sdW1ucyBhZGp1c3RlZCBmb3IgZ3JvdXBpbmcsIGdyb3VwUGFkZGluZywgcG9pbnRQYWRkaW5nLFxuXHRcdCAqIHBvaW50V2lkdGggZXRjLiBcblx0XHQgKi9cblx0XHRnZXRDb2x1bW5NZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdFx0cmV2ZXJzZWRYQXhpcyA9IHhBeGlzLnJldmVyc2VkLFxuXHRcdFx0XHRzdGFja0tleSxcblx0XHRcdFx0c3RhY2tHcm91cHMgPSB7fSxcblx0XHRcdFx0Y29sdW1uSW5kZXgsXG5cdFx0XHRcdGNvbHVtbkNvdW50ID0gMDtcblxuXHRcdFx0Ly8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1uIHR5cGUgc2VyaWVzLlxuXHRcdFx0Ly8gVGhpcyBpcyBjYWxsZWQgb24gZXZlcnkgc2VyaWVzLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBsb2dpYyB0byBhXG5cdFx0XHQvLyBjaGFydC5vcmRlclN0YWNrcygpIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IG9uIGluaXQsIGFkZFNlcmllcyBhbmQgcmVtb3ZlU2VyaWVzXG5cdFx0XHRpZiAob3B0aW9ucy5ncm91cGluZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29sdW1uQ291bnQgPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFjaChzZXJpZXMuY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJPcHRpb25zID0gb3RoZXJTZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHRcdG90aGVyWUF4aXMgPSBvdGhlclNlcmllcy55QXhpcztcblx0XHRcdFx0XHRpZiAob3RoZXJTZXJpZXMudHlwZSA9PT0gc2VyaWVzLnR5cGUgJiYgb3RoZXJTZXJpZXMudmlzaWJsZSAmJlxuXHRcdFx0XHRcdFx0XHR5QXhpcy5sZW4gPT09IG90aGVyWUF4aXMubGVuICYmIHlBeGlzLnBvcyA9PT0gb3RoZXJZQXhpcy5wb3MpIHsgIC8vICM2NDIsICMyMDg2XG5cdFx0XHRcdFx0XHRpZiAob3RoZXJPcHRpb25zLnN0YWNraW5nKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrS2V5ID0gb3RoZXJTZXJpZXMuc3RhY2tLZXk7XG5cdFx0XHRcdFx0XHRcdGlmIChzdGFja0dyb3Vwc1tzdGFja0tleV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YWNrR3JvdXBzW3N0YWNrS2V5XSA9IGNvbHVtbkNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBzdGFja0dyb3Vwc1tzdGFja0tleV07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG90aGVyT3B0aW9ucy5ncm91cGluZyAhPT0gZmFsc2UpIHsgLy8gIzExNjJcblx0XHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBjb2x1bW5Db3VudCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuY29sdW1uSW5kZXggPSBjb2x1bW5JbmRleDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2F0ZWdvcnlXaWR0aCA9IG1hdGhNaW4oXG5cdFx0XHRcdFx0bWF0aEFicyh4QXhpcy50cmFuc0EpICogKHhBeGlzLm9yZGluYWxTbG9wZSB8fCBvcHRpb25zLnBvaW50UmFuZ2UgfHwgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgfHwgeEF4aXMudGlja0ludGVydmFsIHx8IDEpLCAvLyAjMjYxMFxuXHRcdFx0XHRcdHhBeGlzLmxlbiAvLyAjMTUzNVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRncm91cFBhZGRpbmcgPSBjYXRlZ29yeVdpZHRoICogb3B0aW9ucy5ncm91cFBhZGRpbmcsXG5cdFx0XHRcdGdyb3VwV2lkdGggPSBjYXRlZ29yeVdpZHRoIC0gMiAqIGdyb3VwUGFkZGluZyxcblx0XHRcdFx0cG9pbnRPZmZzZXRXaWR0aCA9IGdyb3VwV2lkdGggLyBjb2x1bW5Db3VudCxcblx0XHRcdFx0cG9pbnRXaWR0aCA9IG1hdGhNaW4oXG5cdFx0XHRcdFx0b3B0aW9ucy5tYXhQb2ludFdpZHRoIHx8IHhBeGlzLmxlbiwgLy8gZG9jczogU2FtcGxlIGNyZWF0ZWQuIEFkZCBcIlNlZSBhbHNvXCIgdG8gcG9pbnRXaWR0aC4gQ2xvc2UgVXNlclZvaWNlLlxuXHRcdFx0XHRcdHBpY2sob3B0aW9ucy5wb2ludFdpZHRoLCBwb2ludE9mZnNldFdpZHRoICogKDEgLSAyICogb3B0aW9ucy5wb2ludFBhZGRpbmcpKVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRwb2ludFBhZGRpbmcgPSAocG9pbnRPZmZzZXRXaWR0aCAtIHBvaW50V2lkdGgpIC8gMixcblx0XHRcdFx0Y29sSW5kZXggPSAocmV2ZXJzZWRYQXhpcyA/IFxuXHRcdFx0XHRcdGNvbHVtbkNvdW50IC0gKHNlcmllcy5jb2x1bW5JbmRleCB8fCAwKSA6IC8vICMxMjUxXG5cdFx0XHRcdFx0c2VyaWVzLmNvbHVtbkluZGV4KSB8fCAwLFxuXHRcdFx0XHRwb2ludFhPZmZzZXQgPSBwb2ludFBhZGRpbmcgKyAoZ3JvdXBQYWRkaW5nICsgY29sSW5kZXggKlxuXHRcdFx0XHRcdHBvaW50T2Zmc2V0V2lkdGggLSAoY2F0ZWdvcnlXaWR0aCAvIDIpKSAqXG5cdFx0XHRcdFx0KHJldmVyc2VkWEF4aXMgPyAtMSA6IDEpO1xuXG5cdFx0XHQvLyBTYXZlIGl0IGZvciByZWFkaW5nIGluIGxpbmtlZCBzZXJpZXMgKEVycm9yIGJhcnMgcGFydGljdWxhcmx5KVxuXHRcdFx0cmV0dXJuIChzZXJpZXMuY29sdW1uTWV0cmljcyA9IHsgXG5cdFx0XHRcdHdpZHRoOiBwb2ludFdpZHRoLCBcblx0XHRcdFx0b2Zmc2V0OiBwb2ludFhPZmZzZXQgXG5cdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZSBlYWNoIHBvaW50IHRvIHRoZSBwbG90IGFyZWEgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIGZpbmQgc2hhcGUgcG9zaXRpb25zXG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBzZXJpZXMuYm9yZGVyV2lkdGggPSBwaWNrKFxuXHRcdFx0XHRcdG9wdGlvbnMuYm9yZGVyV2lkdGgsIFxuXHRcdFx0XHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZSAqIHNlcmllcy54QXhpcy50cmFuc0EgPCAyID8gMCA6IDEgLy8gIzM2MzVcblx0XHRcdFx0KSxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkID0gc2VyaWVzLnRyYW5zbGF0ZWRUaHJlc2hvbGQgPSB5QXhpcy5nZXRUaHJlc2hvbGQodGhyZXNob2xkKSxcblx0XHRcdFx0bWluUG9pbnRMZW5ndGggPSBwaWNrKG9wdGlvbnMubWluUG9pbnRMZW5ndGgsIDUpLFxuXHRcdFx0XHRtZXRyaWNzID0gc2VyaWVzLmdldENvbHVtbk1ldHJpY3MoKSxcblx0XHRcdFx0cG9pbnRXaWR0aCA9IG1ldHJpY3Mud2lkdGgsXG5cdFx0XHRcdHNlcmllc0JhclcgPSBzZXJpZXMuYmFyVyA9IG1hdGhNYXgocG9pbnRXaWR0aCwgMSArIDIgKiBib3JkZXJXaWR0aCksIC8vIHBvc3Rwcm9jZXNzZWQgZm9yIGJvcmRlciB3aWR0aFxuXHRcdFx0XHRwb2ludFhPZmZzZXQgPSBzZXJpZXMucG9pbnRYT2Zmc2V0ID0gbWV0cmljcy5vZmZzZXQsXG5cdFx0XHRcdHhDcmlzcCA9IC0oYm9yZGVyV2lkdGggJSAyID8gMC41IDogMCksXG5cdFx0XHRcdHlDcmlzcCA9IGJvcmRlcldpZHRoICUgMiA/IDAuNSA6IDE7XG5cblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkIC09IDAuNTsgLy8gIzMzNTVcblx0XHRcdFx0aWYgKGNoYXJ0LnJlbmRlcmVyLmlzVk1MKSB7XG5cdFx0XHRcdFx0eUNyaXNwICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiB0aGUgcG9pbnRQYWRkaW5nIGlzIDAsIHdlIHdhbnQgdGhlIGNvbHVtbnMgdG8gYmUgcGFja2VkIHRpZ2h0bHksIHNvIHdlIGFsbG93IGluZGl2aWR1YWxcblx0XHRcdC8vIGNvbHVtbnMgdG8gaGF2ZSBpbmRpdmlkdWFsIHNpemVzLiBXaGVuIHBvaW50UGFkZGluZyBpcyBncmVhdGVyLCB3ZSBzdHJpdmUgZm9yIGVxdWFsLXdpZHRoXG5cdFx0XHQvLyBjb2x1bW5zICgjMjY5NCkuXG5cdFx0XHRpZiAob3B0aW9ucy5wb2ludFBhZGRpbmcpIHtcblx0XHRcdFx0c2VyaWVzQmFyVyA9IG1hdGhDZWlsKHNlcmllc0JhclcpO1xuXHRcdFx0fVxuXG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLnRyYW5zbGF0ZS5hcHBseShzZXJpZXMpO1xuXG5cdFx0XHQvLyBSZWNvcmQgdGhlIG5ldyB2YWx1ZXNcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdHZhciB5Qm90dG9tID0gcGljayhwb2ludC55Qm90dG9tLCB0cmFuc2xhdGVkVGhyZXNob2xkKSxcblx0XHRcdFx0XHRzYWZlRGlzdGFuY2UgPSA5OTkgKyBtYXRoQWJzKHlCb3R0b20pLFxuXHRcdFx0XHRcdHBsb3RZID0gbWF0aE1pbihtYXRoTWF4KC1zYWZlRGlzdGFuY2UsIHBvaW50LnBsb3RZKSwgeUF4aXMubGVuICsgc2FmZURpc3RhbmNlKSwgLy8gRG9uJ3QgZHJhdyB0b28gZmFyIG91dHNpZGUgcGxvdCBhcmVhICgjMTMwMywgIzIyNDEsICM0MjY0KVxuXHRcdFx0XHRcdGJhclggPSBwb2ludC5wbG90WCArIHBvaW50WE9mZnNldCxcblx0XHRcdFx0XHRiYXJXID0gc2VyaWVzQmFyVyxcblx0XHRcdFx0XHRiYXJZID0gbWF0aE1pbihwbG90WSwgeUJvdHRvbSksXG5cdFx0XHRcdFx0cmlnaHQsXG5cdFx0XHRcdFx0Ym90dG9tLFxuXHRcdFx0XHRcdGZyb21Ub3AsXG5cdFx0XHRcdFx0dXAsXG5cdFx0XHRcdFx0YmFySCA9IG1hdGhNYXgocGxvdFksIHlCb3R0b20pIC0gYmFyWTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgb3B0aW9ucy5taW5Qb2ludExlbmd0aFxuXHRcdFx0XHRpZiAobWF0aEFicyhiYXJIKSA8IG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYgKG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRiYXJIID0gbWluUG9pbnRMZW5ndGg7XG5cdFx0XHRcdFx0XHR1cCA9ICgheUF4aXMucmV2ZXJzZWQgJiYgIXBvaW50Lm5lZ2F0aXZlKSB8fCAoeUF4aXMucmV2ZXJzZWQgJiYgcG9pbnQubmVnYXRpdmUpO1xuXHRcdFx0XHRcdFx0YmFyWSA9XG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChtYXRoQWJzKGJhclkgLSB0cmFuc2xhdGVkVGhyZXNob2xkKSA+IG1pblBvaW50TGVuZ3RoID8gLy8gc3RhY2tlZFxuXHRcdFx0XHRcdFx0XHRcdHlCb3R0b20gLSBtaW5Qb2ludExlbmd0aCA6IC8vIGtlZXAgcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkIC0gKHVwID8gbWluUG9pbnRMZW5ndGggOiAwKSk7IC8vICMxNDg1LCAjNDA1MVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIGZvciBhY2Nlc3MgaW4gcG9sYXJcblx0XHRcdFx0cG9pbnQuYmFyWCA9IGJhclg7XG5cdFx0XHRcdHBvaW50LnBvaW50V2lkdGggPSBwb2ludFdpZHRoO1xuXG5cdFx0XHRcdC8vIFJvdW5kIG9mZiB0byBvYnRhaW4gY3Jpc3AgZWRnZXMgYW5kIGF2b2lkIG92ZXJsYXBwaW5nIHdpdGggbmVpZ2hib3VycyAoIzI2OTQpXG5cdFx0XHRcdHJpZ2h0ID0gbWF0aFJvdW5kKGJhclggKyBiYXJXKSArIHhDcmlzcDtcblx0XHRcdFx0YmFyWCA9IG1hdGhSb3VuZChiYXJYKSArIHhDcmlzcDtcblx0XHRcdFx0YmFyVyA9IHJpZ2h0IC0gYmFyWDtcblxuXHRcdFx0XHRmcm9tVG9wID0gbWF0aEFicyhiYXJZKSA8IDAuNTtcblx0XHRcdFx0Ym90dG9tID0gbWF0aE1pbihtYXRoUm91bmQoYmFyWSArIGJhckgpICsgeUNyaXNwLCA5ZTQpOyAvLyAjMzU3NVxuXHRcdFx0XHRiYXJZID0gbWF0aFJvdW5kKGJhclkpICsgeUNyaXNwO1xuXHRcdFx0XHRiYXJIID0gYm90dG9tIC0gYmFyWTtcblxuXHRcdFx0XHQvLyBUb3AgZWRnZXMgYXJlIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKGZyb21Ub3ApIHtcblx0XHRcdFx0XHRiYXJZIC09IDE7XG5cdFx0XHRcdFx0YmFySCArPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRml4IHRoZSB0b29sdGlwIG9uIGNlbnRlciBvZiBncm91cGVkIGNvbHVtbnMgKCMxMjE2LCAjNDI0LCAjMzY0OClcblx0XHRcdFx0cG9pbnQudG9vbHRpcFBvcyA9IGNoYXJ0LmludmVydGVkID8gXG5cdFx0XHRcdFx0W3lBeGlzLmxlbiArIHlBeGlzLnBvcyAtIGNoYXJ0LnBsb3RMZWZ0IC0gcGxvdFksIHNlcmllcy54QXhpcy5sZW4gLSBiYXJYIC0gYmFyVyAvIDIsIGJhckhdIDogXG5cdFx0XHRcdFx0W2JhclggKyBiYXJXIC8gMiwgcGxvdFkgKyB5QXhpcy5wb3MgLSBjaGFydC5wbG90VG9wLCBiYXJIXTtcblxuXHRcdFx0XHQvLyBSZWdpc3RlciBzaGFwZSB0eXBlIGFuZCBhcmd1bWVudHMgdG8gYmUgdXNlZCBpbiBkcmF3UG9pbnRzXG5cdFx0XHRcdHBvaW50LnNoYXBlVHlwZSA9ICdyZWN0Jztcblx0XHRcdFx0cG9pbnQuc2hhcGVBcmdzID0ge1xuXHRcdFx0XHRcdHg6IGJhclgsXG5cdFx0XHRcdFx0eTogYmFyWSxcblx0XHRcdFx0XHR3aWR0aDogYmFyVyxcblx0XHRcdFx0XHRoZWlnaHQ6IGJhckhcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdGdldFN5bWJvbDogbm9vcCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBVc2UgYSBzb2xpZCByZWN0YW5nbGUgbGlrZSB0aGUgYXJlYSBzZXJpZXMgdHlwZXNcblx0XHQgKi9cblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLFxuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbHVtbnMgaGF2ZSBubyBncmFwaFxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogbm9vcCxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGNvbHVtbnMuIEZvciBiYXJzLCB0aGUgc2VyaWVzLmdyb3VwIGlzIHJvdGF0ZWQsIHNvIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5cdFx0ICogYXBwbHkgZm9yIGNvbHVtbnMgYW5kIGJhcnMuIFRoaXMgbWV0aG9kIGlzIGluaGVyaXRlZCBieSBzY2F0dGVyIHNlcmllcy5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0YW5pbWF0aW9uTGltaXQgPSBvcHRpb25zLmFuaW1hdGlvbkxpbWl0IHx8IDI1MCxcblx0XHRcdFx0c2hhcGVBcmdzLFxuXHRcdFx0XHRwb2ludEF0dHI7XG5cblx0XHRcdC8vIGRyYXcgdGhlIGNvbHVtbnNcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdHZhciBwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRcdGJvcmRlckF0dHI7XG5cblx0XHRcdFx0aWYgKHBsb3RZICE9PSBVTkRFRklORUQgJiYgIWlzTmFOKHBsb3RZKSAmJiBwb2ludC55ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0c2hhcGVBcmdzID0gcG9pbnQuc2hhcGVBcmdzO1xuXG5cdFx0XHRcdFx0Ym9yZGVyQXR0ciA9IGRlZmluZWQoc2VyaWVzLmJvcmRlcldpZHRoKSA/IHtcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzZXJpZXMuYm9yZGVyV2lkdGhcblx0XHRcdFx0XHR9IDoge307XG5cblx0XHRcdFx0XHRwb2ludEF0dHIgPSBwb2ludC5wb2ludEF0dHJbcG9pbnQuc2VsZWN0ZWQgPyBTRUxFQ1RfU1RBVEUgOiBOT1JNQUxfU1RBVEVdIHx8IHNlcmllcy5wb2ludEF0dHJbTk9STUFMX1NUQVRFXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZ3JhcGhpYykgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRcdHN0b3AoZ3JhcGhpYyk7XG5cdFx0XHRcdFx0XHRncmFwaGljLmF0dHIoYm9yZGVyQXR0cilbY2hhcnQucG9pbnRDb3VudCA8IGFuaW1hdGlvbkxpbWl0ID8gJ2FuaW1hdGUnIDogJ2F0dHInXShtZXJnZShzaGFwZUFyZ3MpKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IHJlbmRlcmVyW3BvaW50LnNoYXBlVHlwZV0oc2hhcGVBcmdzKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihib3JkZXJBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihwb2ludEF0dHIpXG5cdFx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93LCBudWxsLCBvcHRpb25zLnN0YWNraW5nICYmICFvcHRpb25zLmJvcmRlclJhZGl1cyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTsgLy8gIzEyNjlcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGUgdGhlIGNvbHVtbiBoZWlnaHRzIG9uZSBieSBvbmUgZnJvbSB6ZXJvXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpbml0IFdoZXRoZXIgdG8gaW5pdGlhbGl6ZSB0aGUgYW5pbWF0aW9uIG9yIHJ1biBpdFxuXHRcdCAqL1xuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGludmVydGVkID0gdGhpcy5jaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0YXR0ciA9IHt9LFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkO1xuXG5cdFx0XHRpZiAoaGFzU1ZHKSB7IC8vIFZNTCBpcyB0b28gc2xvdyBhbnl3YXlcblx0XHRcdFx0aWYgKGluaXQpIHtcblx0XHRcdFx0XHRhdHRyLnNjYWxlWSA9IDAuMDAxO1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgPSBtYXRoTWluKHlBeGlzLnBvcyArIHlBeGlzLmxlbiwgbWF0aE1heCh5QXhpcy5wb3MsIHlBeGlzLnRvUGl4ZWxzKG9wdGlvbnMudGhyZXNob2xkKSkpO1xuXHRcdFx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVYID0gdHJhbnNsYXRlZFRocmVzaG9sZCAtIHlBeGlzLmxlbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVZID0gdHJhbnNsYXRlZFRocmVzaG9sZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VyaWVzLmdyb3VwLmF0dHIoYXR0cik7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gcnVuIHRoZSBhbmltYXRpb25cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRhdHRyLnNjYWxlWSA9IDE7XG5cdFx0XHRcdFx0YXR0cltpbnZlcnRlZCA/ICd0cmFuc2xhdGVYJyA6ICd0cmFuc2xhdGVZJ10gPSB5QXhpcy5wb3M7XG5cdFx0XHRcdFx0c2VyaWVzLmdyb3VwLmFuaW1hdGUoYXR0ciwgc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uKTtcblxuXHRcdFx0XHRcdC8vIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoaXMgc2VyaWVzIGZyb20gdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRcdC8vIGNvbHVtbiBhbmQgYmFyIHNlcmllcyBhZmZlY3RzIG90aGVyIHNlcmllcyBvZiB0aGUgc2FtZSB0eXBlXG5cdFx0XHQvLyBhcyB0aGV5IGFyZSBlaXRoZXIgc3RhY2tlZCBvciBncm91cGVkXG5cdFx0XHRpZiAoY2hhcnQuaGFzUmVuZGVyZWQpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSkge1xuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkoc2VyaWVzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSk7XG5cdHNlcmllc1R5cGVzLmNvbHVtbiA9IENvbHVtblNlcmllcztcblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBiYXJcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5iYXIgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuY29sdW1uKTtcblx0LyoqXG5cdCAqIFRoZSBCYXIgc2VyaWVzIGNsYXNzXG5cdCAqL1xuXHR2YXIgQmFyU2VyaWVzID0gZXh0ZW5kQ2xhc3MoQ29sdW1uU2VyaWVzLCB7XG5cdFx0dHlwZTogJ2JhcicsXG5cdFx0aW52ZXJ0ZWQ6IHRydWVcblx0fSk7XG5cdHNlcmllc1R5cGVzLmJhciA9IEJhclNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHNjYXR0ZXJcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5zY2F0dGVyID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0XHRsaW5lV2lkdGg6IDAsXG5cdFx0bWFya2VyOiB7XG5cdFx0XHRlbmFibGVkOiB0cnVlIC8vIE92ZXJyaWRlcyBhdXRvLWVuYWJsaW5nIGluIGxpbmUgc2VyaWVzICgjMzY0Nylcblx0XHR9LFxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3Nlcmllcy5jb2xvcn1cIj5cXHUyNUNGPC9zcGFuPiA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweDtcIj4ge3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicsXG5cdFx0XHRwb2ludEZvcm1hdDogJ3g6IDxiPntwb2ludC54fTwvYj48YnIvPnk6IDxiPntwb2ludC55fTwvYj48YnIvPidcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2NhdHRlciBzZXJpZXMgY2xhc3Ncblx0ICovXG5cdHZhciBTY2F0dGVyU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdFx0dHlwZTogJ3NjYXR0ZXInLFxuXHRcdHNvcnRlZDogZmFsc2UsXG5cdFx0cmVxdWlyZVNvcnRpbmc6IGZhbHNlLFxuXHRcdG5vU2hhcmVkVG9vbHRpcDogdHJ1ZSxcblx0XHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ21hcmtlckdyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdHRha2VPcmRpbmFsUG9zaXRpb246IGZhbHNlLCAvLyAjMjM0MlxuXHRcdGtkRGltZW5zaW9uczogMixcblx0XHRkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMubGluZVdpZHRoKSB7XG5cdFx0XHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRzZXJpZXNUeXBlcy5zY2F0dGVyID0gU2NhdHRlclNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHBpZVxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLnBpZSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0Ym9yZGVyQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRjZW50ZXI6IFtudWxsLCBudWxsXSxcblx0XHRjbGlwOiBmYWxzZSxcblx0XHRjb2xvckJ5UG9pbnQ6IHRydWUsIC8vIGFsd2F5cyB0cnVlIGZvciBwaWVzXG5cdFx0ZGF0YUxhYmVsczoge1xuXHRcdFx0Ly8gYWxpZ246IG51bGwsXG5cdFx0XHQvLyBjb25uZWN0b3JXaWR0aDogMSxcblx0XHRcdC8vIGNvbm5lY3RvckNvbG9yOiBwb2ludC5jb2xvcixcblx0XHRcdC8vIGNvbm5lY3RvclBhZGRpbmc6IDUsXG5cdFx0XHRkaXN0YW5jZTogMzAsXG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7IC8vICMyOTQ1XG5cdFx0XHRcdHJldHVybiB0aGlzLnkgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLnBvaW50Lm5hbWU7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gc29mdENvbm5lY3RvcjogdHJ1ZSxcblx0XHRcdHg6IDBcblx0XHRcdC8vIHk6IDBcblx0XHR9LFxuXHRcdGlnbm9yZUhpZGRlblBvaW50OiB0cnVlLFxuXHRcdC8vaW5uZXJTaXplOiAwLFxuXHRcdGxlZ2VuZFR5cGU6ICdwb2ludCcsXG5cdFx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRcdHNpemU6IG51bGwsXG5cdFx0c2hvd0luTGVnZW5kOiBmYWxzZSxcblx0XHRzbGljZWRPZmZzZXQ6IDEwLFxuXHRcdHN0YXRlczoge1xuXHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0YnJpZ2h0bmVzczogMC4xLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdGlja3lUcmFja2luZzogZmFsc2UsXG5cdFx0dG9vbHRpcDoge1xuXHRcdFx0Zm9sbG93UG9pbnRlcjogdHJ1ZVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEV4dGVuZGVkIHBvaW50IG9iamVjdCBmb3IgcGllc1xuXHQgKi9cblx0dmFyIFBpZVBvaW50ID0gZXh0ZW5kQ2xhc3MoUG9pbnQsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWF0ZSB0aGUgcGllIHNsaWNlXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRQb2ludC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHR0b2dnbGVTbGljZTtcblxuXHRcdFx0ZXh0ZW5kKHBvaW50LCB7XG5cdFx0XHRcdHZpc2libGU6IHBvaW50LnZpc2libGUgIT09IGZhbHNlLFxuXHRcdFx0XHRuYW1lOiBwaWNrKHBvaW50Lm5hbWUsICdTbGljZScpXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gYWRkIGV2ZW50IGxpc3RlbmVyIGZvciBzZWxlY3Rcblx0XHRcdHRvZ2dsZVNsaWNlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cG9pbnQuc2xpY2UoZS50eXBlID09PSAnc2VsZWN0Jyk7XG5cdFx0XHR9O1xuXHRcdFx0YWRkRXZlbnQocG9pbnQsICdzZWxlY3QnLCB0b2dnbGVTbGljZSk7XG5cdFx0XHRhZGRFdmVudChwb2ludCwgJ3Vuc2VsZWN0JywgdG9nZ2xlU2xpY2UpO1xuXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcGllIHNsaWNlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSB2aXMgV2hldGhlciB0byBzaG93IHRoZSBzbGljZSBvciBub3QuIElmIHVuZGVmaW5lZCwgdGhlXG5cdFx0ICogICAgdmlzaWJpbGl0eSBpcyB0b2dnbGVkXG5cdFx0ICovXG5cdFx0c2V0VmlzaWJsZTogZnVuY3Rpb24gKHZpcywgcmVkcmF3KSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRpZ25vcmVIaWRkZW5Qb2ludCA9IHNlcmllcy5vcHRpb25zLmlnbm9yZUhpZGRlblBvaW50O1xuXHRcdFx0XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgaWdub3JlSGlkZGVuUG9pbnQpO1xuXG5cdFx0XHRpZiAodmlzICE9PSBwb2ludC52aXNpYmxlKSB7XG5cblx0XHRcdFx0Ly8gSWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZSB2aXNpYmlsaXR5XG5cdFx0XHRcdHBvaW50LnZpc2libGUgPSBwb2ludC5vcHRpb25zLnZpc2libGUgPSB2aXMgPSB2aXMgPT09IFVOREVGSU5FRCA/ICFwb2ludC52aXNpYmxlIDogdmlzO1xuXHRcdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhW2luQXJyYXkocG9pbnQsIHNlcmllcy5kYXRhKV0gPSBwb2ludC5vcHRpb25zOyAvLyB1cGRhdGUgdXNlck9wdGlvbnMuZGF0YVxuXG5cdFx0XHRcdC8vIFNob3cgYW5kIGhpZGUgYXNzb2NpYXRlZCBlbGVtZW50cy4gVGhpcyBpcyBwZXJmb3JtZWQgcmVnYXJkbGVzcyBvZiByZWRyYXcgb3Igbm90LFxuXHRcdFx0XHQvLyBiZWNhdXNlIGNoYXJ0LnJlZHJhdyBvbmx5IGhhbmRsZXMgZnVsbCBzZXJpZXMuXG5cdFx0XHRcdGVhY2goWydncmFwaGljJywgJ2RhdGFMYWJlbCcsICdjb25uZWN0b3InLCAnc2hhZG93R3JvdXAnXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdGlmIChwb2ludFtrZXldKSB7XG5cdFx0XHRcdFx0XHRwb2ludFtrZXldW3ZpcyA/ICdzaG93JyA6ICdoaWRlJ10odHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAocG9pbnQubGVnZW5kSXRlbSkge1xuXHRcdFx0XHRcdGNoYXJ0LmxlZ2VuZC5jb2xvcml6ZUl0ZW0ocG9pbnQsIHZpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyAjNDE3MCwgaGlkZSBoYWxvIGFmdGVyIGhpZGluZyBwb2ludFxuXHRcdFx0XHRpZiAoIXZpcyAmJiBwb2ludC5zdGF0ZSA9PT0gJ2hvdmVyJykge1xuXHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSGFuZGxlIGlnbm9yZSBoaWRkZW4gc2xpY2VzXG5cdFx0XHRcdGlmIChpZ25vcmVIaWRkZW5Qb2ludCkge1xuXHRcdFx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgb3IgdG9nZ2xlIHdoZXRoZXIgdGhlIHNsaWNlIGlzIGN1dCBvdXQgZnJvbSB0aGUgcGllXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzbGljZWQgV2hlbiB1bmRlZmluZWQsIHRoZSBzbGljZSBzdGF0ZSBpcyB0b2dnbGVkXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0LiBUcnVlIGJ5IGRlZmF1bHQuXG5cdFx0ICovXG5cdFx0c2xpY2U6IGZ1bmN0aW9uIChzbGljZWQsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHR0cmFuc2xhdGlvbjtcblxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0XHQvLyByZWRyYXcgaXMgdHJ1ZSBieSBkZWZhdWx0XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGVcblx0XHRcdHBvaW50LnNsaWNlZCA9IHBvaW50Lm9wdGlvbnMuc2xpY2VkID0gc2xpY2VkID0gZGVmaW5lZChzbGljZWQpID8gc2xpY2VkIDogIXBvaW50LnNsaWNlZDtcblx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShwb2ludCwgc2VyaWVzLmRhdGEpXSA9IHBvaW50Lm9wdGlvbnM7IC8vIHVwZGF0ZSB1c2VyT3B0aW9ucy5kYXRhXG5cblx0XHRcdHRyYW5zbGF0aW9uID0gc2xpY2VkID8gcG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IDAsXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IDBcblx0XHRcdH07XG5cblx0XHRcdHBvaW50LmdyYXBoaWMuYW5pbWF0ZSh0cmFuc2xhdGlvbik7XG5cdFx0XHRcblx0XHRcdGlmIChwb2ludC5zaGFkb3dHcm91cCkge1xuXHRcdFx0XHRwb2ludC5zaGFkb3dHcm91cC5hbmltYXRlKHRyYW5zbGF0aW9uKTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRoYWxvUGF0aDogZnVuY3Rpb24gKHNpemUpIHtcblx0XHRcdHZhciBzaGFwZUFyZ3MgPSB0aGlzLnNoYXBlQXJncyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLnNlcmllcy5jaGFydDtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2xpY2VkIHx8ICF0aGlzLnZpc2libGUgPyBbXSA6IHRoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuYXJjKGNoYXJ0LnBsb3RMZWZ0ICsgc2hhcGVBcmdzLngsIGNoYXJ0LnBsb3RUb3AgKyBzaGFwZUFyZ3MueSwgc2hhcGVBcmdzLnIgKyBzaXplLCBzaGFwZUFyZ3MuciArIHNpemUsIHtcblx0XHRcdFx0aW5uZXJSOiB0aGlzLnNoYXBlQXJncy5yLFxuXHRcdFx0XHRzdGFydDogc2hhcGVBcmdzLnN0YXJ0LFxuXHRcdFx0XHRlbmQ6IHNoYXBlQXJncy5lbmRcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFRoZSBQaWUgc2VyaWVzIGNsYXNzXG5cdCAqL1xuXHR2YXIgUGllU2VyaWVzID0ge1xuXHRcdHR5cGU6ICdwaWUnLFxuXHRcdGlzQ2FydGVzaWFuOiBmYWxzZSxcblx0XHRwb2ludENsYXNzOiBQaWVQb2ludCxcblx0XHRyZXF1aXJlU29ydGluZzogZmFsc2UsXG5cdFx0ZGlyZWN0VG91Y2g6IHRydWUsXG5cdFx0bm9TaGFyZWRUb29sdGlwOiB0cnVlLFxuXHRcdHRyYWNrZXJHcm91cHM6IFsnZ3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJ10sXG5cdFx0YXhpc1R5cGVzOiBbXSxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0XHQnc3Ryb2tlLXdpZHRoJzogJ2JvcmRlcldpZHRoJyxcblx0XHRcdGZpbGw6ICdjb2xvcidcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGllcyBoYXZlIG9uZSBjb2xvciBlYWNoIHBvaW50XG5cdFx0ICovXG5cdFx0Z2V0Q29sb3I6IG5vb3AsXG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRlIHRoZSBwaWVzIGluXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGluaXQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRzdGFydEFuZ2xlUmFkID0gc2VyaWVzLnN0YXJ0QW5nbGVSYWQ7XG5cblx0XHRcdGlmICghaW5pdCkge1xuXHRcdFx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0dmFyIGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRcdFx0YXJncyA9IHBvaW50LnNoYXBlQXJncztcblxuXHRcdFx0XHRcdGlmIChncmFwaGljKSB7XG5cdFx0XHRcdFx0XHQvLyBzdGFydCB2YWx1ZXNcblx0XHRcdFx0XHRcdGdyYXBoaWMuYXR0cih7XG5cdFx0XHRcdFx0XHRcdHI6IHBvaW50LnN0YXJ0UiB8fCAoc2VyaWVzLmNlbnRlclszXSAvIDIpLCAvLyBhbmltYXRlIGZyb20gaW5uZXIgcmFkaXVzICgjNzc5KVxuXHRcdFx0XHRcdFx0XHRzdGFydDogc3RhcnRBbmdsZVJhZCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBzdGFydEFuZ2xlUmFkXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0Ly8gYW5pbWF0ZVxuXHRcdFx0XHRcdFx0Z3JhcGhpYy5hbmltYXRlKHtcblx0XHRcdFx0XHRcdFx0cjogYXJncy5yLFxuXHRcdFx0XHRcdFx0XHRzdGFydDogYXJncy5zdGFydCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBhcmdzLmVuZFxuXHRcdFx0XHRcdFx0fSwgc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCB0aGUgYmFzaWMgc2V0RGF0YSBtZXRob2QgYnkgcnVubmluZyBwcm9jZXNzRGF0YSBhbmQgZ2VuZXJhdGVQb2ludHMgaW1tZWRpYXRlbHksXG5cdFx0ICogaW4gb3JkZXIgdG8gYWNjZXNzIHRoZSBwb2ludHMgZnJvbSB0aGUgbGVnZW5kLlxuXHRcdCAqL1xuXHRcdHNldERhdGE6IGZ1bmN0aW9uIChkYXRhLCByZWRyYXcsIGFuaW1hdGlvbiwgdXBkYXRlUG9pbnRzKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLnNldERhdGEuY2FsbCh0aGlzLCBkYXRhLCBmYWxzZSwgYW5pbWF0aW9uLCB1cGRhdGVQb2ludHMpO1xuXHRcdFx0dGhpcy5wcm9jZXNzRGF0YSgpO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0fSBcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVjb21wdXRlIHRvdGFsIGNoYXJ0IHN1bSBhbmQgdXBkYXRlIHBlcmNlbnRhZ2VzIG9mIHBvaW50cy5cblx0XHQgKi9cblx0XHR1cGRhdGVUb3RhbHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHR0b3RhbCA9IDAsXG5cdFx0XHRcdHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0XHRsZW4gPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0aWdub3JlSGlkZGVuUG9pbnQgPSB0aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG5cblx0XHRcdC8vIEdldCB0aGUgdG90YWwgc3VtXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdHRvdGFsICs9IChpZ25vcmVIaWRkZW5Qb2ludCAmJiAhcG9pbnQudmlzaWJsZSkgPyAwIDogcG9pbnQueTtcblx0XHRcdH1cblx0XHRcdHRoaXMudG90YWwgPSB0b3RhbDtcblxuXHRcdFx0Ly8gU2V0IGVhY2ggcG9pbnQncyBwcm9wZXJ0aWVzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdHBvaW50LnBlcmNlbnRhZ2UgPSAodG90YWwgPiAwICYmIChwb2ludC52aXNpYmxlIHx8ICFpZ25vcmVIaWRkZW5Qb2ludCkpID8gcG9pbnQueSAvIHRvdGFsICogMTAwIDogMDtcblx0XHRcdFx0cG9pbnQudG90YWwgPSB0b3RhbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5kIHRoZSBnZW5lcmF0ZVBvaW50cyBtZXRob2QgYnkgYWRkaW5nIHRvdGFsIGFuZCBwZXJjZW50YWdlIHByb3BlcnRpZXMgdG8gZWFjaCBwb2ludFxuXHRcdCAqL1xuXHRcdGdlbmVyYXRlUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRG8gdHJhbnNsYXRpb24gZm9yIHBpZSBzbGljZXNcblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uIChwb3NpdGlvbnMpIHtcblx0XHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHRcdFxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGN1bXVsYXRpdmUgPSAwLFxuXHRcdFx0XHRwcmVjaXNpb24gPSAxMDAwLCAvLyBpc3N1ZSAjMTcyXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c2xpY2VkT2Zmc2V0ID0gb3B0aW9ucy5zbGljZWRPZmZzZXQsXG5cdFx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IHNsaWNlZE9mZnNldCArIG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdHN0YXJ0LFxuXHRcdFx0XHRlbmQsXG5cdFx0XHRcdGFuZ2xlLFxuXHRcdFx0XHRzdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IDAsXG5cdFx0XHRcdHN0YXJ0QW5nbGVSYWQgPSBzZXJpZXMuc3RhcnRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqIChzdGFydEFuZ2xlIC0gOTApLFxuXHRcdFx0XHRlbmRBbmdsZVJhZCA9IHNlcmllcy5lbmRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqICgocGljayhvcHRpb25zLmVuZEFuZ2xlLCBzdGFydEFuZ2xlICsgMzYwKSkgLSA5MCksXG5cdFx0XHRcdGNpcmMgPSBlbmRBbmdsZVJhZCAtIHN0YXJ0QW5nbGVSYWQsIC8vMiAqIG1hdGhQSSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0cmFkaXVzWCwgLy8gdGhlIHggY29tcG9uZW50IG9mIHRoZSByYWRpdXMgdmVjdG9yIGZvciBhIGdpdmVuIHBvaW50XG5cdFx0XHRcdHJhZGl1c1ksXG5cdFx0XHRcdGxhYmVsRGlzdGFuY2UgPSBvcHRpb25zLmRhdGFMYWJlbHMuZGlzdGFuY2UsXG5cdFx0XHRcdGlnbm9yZUhpZGRlblBvaW50ID0gb3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludCxcblx0XHRcdFx0aSxcblx0XHRcdFx0bGVuID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdFx0cG9pbnQ7XG5cblx0XHRcdC8vIEdldCBwb3NpdGlvbnMgLSBlaXRoZXIgYW4gaW50ZWdlciBvciBhIHBlcmNlbnRhZ2Ugc3RyaW5nIG11c3QgYmUgZ2l2ZW4uXG5cdFx0XHQvLyBJZiBwb3NpdGlvbnMgYXJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlciwgd2UncmUgaW4gYSByZWN1cnNpdmUgbG9vcCBmb3IgYWRqdXN0aW5nXG5cdFx0XHQvLyBzcGFjZSBmb3IgZGF0YSBsYWJlbHMuXG5cdFx0XHRpZiAoIXBvc2l0aW9ucykge1xuXHRcdFx0XHRzZXJpZXMuY2VudGVyID0gcG9zaXRpb25zID0gc2VyaWVzLmdldENlbnRlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1dGlsaXR5IGZvciBnZXR0aW5nIHRoZSB4IHZhbHVlIGZyb20gYSBnaXZlbiB5LCB1c2VkIGZvciBhbnRpY29sbGlzaW9uIGxvZ2ljIGluIGRhdGEgbGFiZWxzXG5cdFx0XHRzZXJpZXMuZ2V0WCA9IGZ1bmN0aW9uICh5LCBsZWZ0KSB7XG5cblx0XHRcdFx0YW5nbGUgPSBtYXRoLmFzaW4obWF0aE1pbigoeSAtIHBvc2l0aW9uc1sxXSkgLyAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpLCAxKSk7XG5cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uc1swXSArXG5cdFx0XHRcdFx0KGxlZnQgPyAtMSA6IDEpICpcblx0XHRcdFx0XHQobWF0aENvcyhhbmdsZSkgKiAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGVhY2ggcG9pbnRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzZXQgc3RhcnQgYW5kIGVuZCBhbmdsZVxuXHRcdFx0XHRzdGFydCA9IHN0YXJ0QW5nbGVSYWQgKyAoY3VtdWxhdGl2ZSAqIGNpcmMpO1xuXHRcdFx0XHRpZiAoIWlnbm9yZUhpZGRlblBvaW50IHx8IHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0XHRjdW11bGF0aXZlICs9IHBvaW50LnBlcmNlbnRhZ2UgLyAxMDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZW5kID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBzaGFwZVxuXHRcdFx0XHRwb2ludC5zaGFwZVR5cGUgPSAnYXJjJztcblx0XHRcdFx0cG9pbnQuc2hhcGVBcmdzID0ge1xuXHRcdFx0XHRcdHg6IHBvc2l0aW9uc1swXSxcblx0XHRcdFx0XHR5OiBwb3NpdGlvbnNbMV0sXG5cdFx0XHRcdFx0cjogcG9zaXRpb25zWzJdIC8gMixcblx0XHRcdFx0XHRpbm5lclI6IHBvc2l0aW9uc1szXSAvIDIsXG5cdFx0XHRcdFx0c3RhcnQ6IG1hdGhSb3VuZChzdGFydCAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24sXG5cdFx0XHRcdFx0ZW5kOiBtYXRoUm91bmQoZW5kICogcHJlY2lzaW9uKSAvIHByZWNpc2lvblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIFRoZSBhbmdsZSBtdXN0IHN0YXkgd2l0aGluIC05MCBhbmQgMjcwICgjMjY0NSlcblx0XHRcdFx0YW5nbGUgPSAoZW5kICsgc3RhcnQpIC8gMjtcblx0XHRcdFx0aWYgKGFuZ2xlID4gMS41ICogbWF0aFBJKSB7XG5cdFx0XHRcdFx0YW5nbGUgLT0gMiAqIG1hdGhQSTtcblx0XHRcdFx0fSBlbHNlIGlmIChhbmdsZSA8IC1tYXRoUEkgLyAyKSB7XG5cdFx0XHRcdFx0YW5nbGUgKz0gMiAqIG1hdGhQSTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENlbnRlciBmb3IgdGhlIHNsaWNlZCBvdXQgc2xpY2Vcblx0XHRcdFx0cG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gPSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogbWF0aFJvdW5kKG1hdGhDb3MoYW5nbGUpICogc2xpY2VkT2Zmc2V0KSxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBtYXRoUm91bmQobWF0aFNpbihhbmdsZSkgKiBzbGljZWRPZmZzZXQpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBhbmNob3IgcG9pbnQgZm9yIHRvb2x0aXBzXG5cdFx0XHRcdHJhZGl1c1ggPSBtYXRoQ29zKGFuZ2xlKSAqIHBvc2l0aW9uc1syXSAvIDI7XG5cdFx0XHRcdHJhZGl1c1kgPSBtYXRoU2luKGFuZ2xlKSAqIHBvc2l0aW9uc1syXSAvIDI7XG5cdFx0XHRcdHBvaW50LnRvb2x0aXBQb3MgPSBbXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCAqIDAuNyxcblx0XHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZICogMC43XG5cdFx0XHRcdF07XG5cdFx0XHRcdFxuXHRcdFx0XHRwb2ludC5oYWxmID0gYW5nbGUgPCAtbWF0aFBJIC8gMiB8fCBhbmdsZSA+IG1hdGhQSSAvIDIgPyAxIDogMDtcblx0XHRcdFx0cG9pbnQuYW5nbGUgPSBhbmdsZTtcblxuXHRcdFx0XHQvLyBzZXQgdGhlIGFuY2hvciBwb2ludCBmb3IgZGF0YSBsYWJlbHNcblx0XHRcdFx0Y29ubmVjdG9yT2Zmc2V0ID0gbWF0aE1pbihjb25uZWN0b3JPZmZzZXQsIGxhYmVsRGlzdGFuY2UgLyAyKTsgLy8gIzE2Nzhcblx0XHRcdFx0cG9pbnQubGFiZWxQb3MgPSBbXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogbGFiZWxEaXN0YW5jZSwgLy8gZmlyc3QgYnJlYWsgb2YgY29ubmVjdG9yXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSArIG1hdGhTaW4oYW5nbGUpICogbGFiZWxEaXN0YW5jZSwgLy8gYS9hXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBzZWNvbmQgYnJlYWssIHJpZ2h0IG91dHNpZGUgcGllXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSArIG1hdGhTaW4oYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBhL2Fcblx0XHRcdFx0XHRwb3NpdGlvbnNbMF0gKyByYWRpdXNYLCAvLyBsYW5kaW5nIHBvaW50IGZvciBjb25uZWN0b3Jcblx0XHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZLCAvLyBhL2Fcblx0XHRcdFx0XHRsYWJlbERpc3RhbmNlIDwgMCA/IC8vIGFsaWdubWVudFxuXHRcdFx0XHRcdFx0J2NlbnRlcicgOlxuXHRcdFx0XHRcdFx0cG9pbnQuaGFsZiA/ICdyaWdodCcgOiAnbGVmdCcsIC8vIGFsaWdubWVudFxuXHRcdFx0XHRcdGFuZ2xlIC8vIGNlbnRlciBhbmdsZVxuXHRcdFx0XHRdO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHRkcmF3R3JhcGg6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBkYXRhIHBvaW50c1xuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0Z3JvdXBUcmFuc2xhdGlvbixcblx0XHRcdFx0Ly9jZW50ZXIsXG5cdFx0XHRcdGdyYXBoaWMsXG5cdFx0XHRcdC8vZ3JvdXAsXG5cdFx0XHRcdHNoYWRvdyA9IHNlcmllcy5vcHRpb25zLnNoYWRvdyxcblx0XHRcdFx0c2hhZG93R3JvdXAsXG5cdFx0XHRcdHNoYXBlQXJncyxcblx0XHRcdFx0YXR0cjtcblxuXHRcdFx0aWYgKHNoYWRvdyAmJiAhc2VyaWVzLnNoYWRvd0dyb3VwKSB7XG5cdFx0XHRcdHNlcmllcy5zaGFkb3dHcm91cCA9IHJlbmRlcmVyLmcoJ3NoYWRvdycpXG5cdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHRoZSBzbGljZXNcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdGlmIChwb2ludC55ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Z3JhcGhpYyA9IHBvaW50LmdyYXBoaWM7XG5cdFx0XHRcdFx0c2hhcGVBcmdzID0gcG9pbnQuc2hhcGVBcmdzO1xuXHRcdFx0XHRcdHNoYWRvd0dyb3VwID0gcG9pbnQuc2hhZG93R3JvdXA7XG5cblx0XHRcdFx0XHQvLyBwdXQgdGhlIHNoYWRvdyBiZWhpbmQgYWxsIHBvaW50c1xuXHRcdFx0XHRcdGlmIChzaGFkb3cgJiYgIXNoYWRvd0dyb3VwKSB7XG5cdFx0XHRcdFx0XHRzaGFkb3dHcm91cCA9IHBvaW50LnNoYWRvd0dyb3VwID0gcmVuZGVyZXIuZygnc2hhZG93Jylcblx0XHRcdFx0XHRcdFx0LmFkZChzZXJpZXMuc2hhZG93R3JvdXApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBwb2ludCBpcyBzbGljZWQsIHVzZSBzcGVjaWFsIHRyYW5zbGF0aW9uLCBlbHNlIHVzZSBwbG90IGFyZWEgdHJhc2xhdGlvblxuXHRcdFx0XHRcdGdyb3VwVHJhbnNsYXRpb24gPSBwb2ludC5zbGljZWQgPyBwb2ludC5zbGljZWRUcmFuc2xhdGlvbiA6IHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVg6IDAsXG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vZ3JvdXAudHJhbnNsYXRlKGdyb3VwVHJhbnNsYXRpb25bMF0sIGdyb3VwVHJhbnNsYXRpb25bMV0pO1xuXHRcdFx0XHRcdGlmIChzaGFkb3dHcm91cCkge1xuXHRcdFx0XHRcdFx0c2hhZG93R3JvdXAuYXR0cihncm91cFRyYW5zbGF0aW9uKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBkcmF3IHRoZSBzbGljZVxuXHRcdFx0XHRcdGlmIChncmFwaGljKSB7XG5cdFx0XHRcdFx0XHRncmFwaGljLmFuaW1hdGUoZXh0ZW5kKHNoYXBlQXJncywgZ3JvdXBUcmFuc2xhdGlvbikpO1x0XHRcdFx0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF0dHIgPSB7ICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnIH07XG5cdFx0XHRcdFx0XHRpZiAoIXBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0YXR0ci52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljID0gcmVuZGVyZXJbcG9pbnQuc2hhcGVUeXBlXShzaGFwZUFyZ3MpXG5cdFx0XHRcdFx0XHRcdC5zZXRSYWRpYWxSZWZlcmVuY2Uoc2VyaWVzLmNlbnRlcilcblx0XHRcdFx0XHRcdFx0LmF0dHIoXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKGdyb3VwVHJhbnNsYXRpb24pXG5cdFx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0XHQuc2hhZG93KHNoYWRvdywgc2hhZG93R3JvdXApO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblxuXHRcdHNlYXJjaFBvaW50OiBub29wLFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSBmb3Igc29ydGluZyBkYXRhIGxhYmVsc1xuXHRcdCAqL1xuXHRcdHNvcnRCeUFuZ2xlOiBmdW5jdGlvbiAocG9pbnRzLCBzaWduKSB7XG5cdFx0XHRwb2ludHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5hbmdsZSAhPT0gdW5kZWZpbmVkICYmIChiLmFuZ2xlIC0gYS5hbmdsZSkgKiBzaWduO1xuXHRcdFx0fSk7XG5cdFx0fSxcdFx0XG5cblx0XHQvKipcblx0XHQgKiBVc2UgYSBzaW1wbGUgc3ltYm9sIGZyb20gTGVnZW5kU3ltYm9sTWl4aW5cblx0XHQgKi9cblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLFxuXG5cdFx0LyoqXG5cdFx0ICogVXNlIHRoZSBnZXRDZW50ZXIgbWV0aG9kIGZyb20gZHJhd0xlZ2VuZFN5bWJvbFxuXHRcdCAqL1xuXHRcdGdldENlbnRlcjogQ2VudGVyZWRTZXJpZXNNaXhpbi5nZXRDZW50ZXIsXG5cblx0XHQvKipcblx0XHQgKiBQaWVzIGRvbid0IGhhdmUgcG9pbnQgbWFya2VyIHN5bWJvbHNcblx0XHQgKi9cblx0XHRnZXRTeW1ib2w6IG5vb3BcblxuXHR9O1xuXHRQaWVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIFBpZVNlcmllcyk7XG5cdHNlcmllc1R5cGVzLnBpZSA9IFBpZVNlcmllcztcblxuXHQvKipcblx0ICogRHJhdyB0aGUgZGF0YSBsYWJlbHNcblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGN1cnNvciA9IHNlcmllc09wdGlvbnMuY3Vyc29yLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllc09wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRwb2ludE9wdGlvbnMsXG5cdFx0XHRnZW5lcmFsT3B0aW9ucyxcblx0XHRcdGhhc1JlbmRlcmVkID0gc2VyaWVzLmhhc1JlbmRlcmVkIHx8IDAsXG5cdFx0XHRzdHIsXG5cdFx0XHRkYXRhTGFiZWxzR3JvdXAsXG5cdFx0XHRyZW5kZXJlciA9IHNlcmllcy5jaGFydC5yZW5kZXJlcjtcblxuXHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgc2VyaWVzLl9oYXNQb2ludExhYmVscykge1xuXG5cdFx0XHQvLyBQcm9jZXNzIGRlZmF1bHQgYWxpZ25tZW50IG9mIGRhdGEgbGFiZWxzIGZvciBjb2x1bW5zXG5cdFx0XHRpZiAoc2VyaWVzLmRsUHJvY2Vzc09wdGlvbnMpIHtcblx0XHRcdFx0c2VyaWVzLmRsUHJvY2Vzc09wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIHNlcGFyYXRlIGdyb3VwIGZvciB0aGUgZGF0YSBsYWJlbHMgdG8gYXZvaWQgcm90YXRpb25cblx0XHRcdGRhdGFMYWJlbHNHcm91cCA9IHNlcmllcy5wbG90R3JvdXAoXG5cdFx0XHRcdCdkYXRhTGFiZWxzR3JvdXAnLFxuXHRcdFx0XHQnZGF0YS1sYWJlbHMnLFxuXHRcdFx0XHRvcHRpb25zLmRlZmVyID8gSElEREVOIDogVklTSUJMRSxcblx0XHRcdFx0b3B0aW9ucy56SW5kZXggfHwgNlxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHBpY2sob3B0aW9ucy5kZWZlciwgdHJ1ZSkpIHtcblx0XHRcdFx0ZGF0YUxhYmVsc0dyb3VwLmF0dHIoeyBvcGFjaXR5OiAraGFzUmVuZGVyZWQgfSk7IC8vICMzMzAwXG5cdFx0XHRcdGlmICghaGFzUmVuZGVyZWQpIHtcblx0XHRcdFx0XHRhZGRFdmVudChzZXJpZXMsICdhZnRlckFuaW1hdGUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VyaWVzLnZpc2libGUpIHsgLy8gIzMwMjMsICMzMDI0XG5cdFx0XHRcdFx0XHRcdGRhdGFMYWJlbHNHcm91cC5zaG93KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWxzR3JvdXBbc2VyaWVzT3B0aW9ucy5hbmltYXRpb24gPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgb3BhY2l0eTogMSB9LCB7IGR1cmF0aW9uOiAyMDAgfSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSB0aGUgbGFiZWxzIGZvciBlYWNoIHBvaW50XG5cdFx0XHRnZW5lcmFsT3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cblx0XHRcdFx0dmFyIGVuYWJsZWQsXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRcdGxhYmVsQ29uZmlnLFxuXHRcdFx0XHRcdGF0dHIsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRyb3RhdGlvbixcblx0XHRcdFx0XHRjb25uZWN0b3IgPSBwb2ludC5jb25uZWN0b3IsXG5cdFx0XHRcdFx0aXNOZXcgPSB0cnVlLFxuXHRcdFx0XHRcdHN0eWxlLFxuXHRcdFx0XHRcdG1vcmVTdHlsZSA9IHt9O1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBpZiBlYWNoIGRhdGEgbGFiZWwgaXMgZW5hYmxlZFxuXHRcdFx0XHRwb2ludE9wdGlvbnMgPSBwb2ludC5kbE9wdGlvbnMgfHwgKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5kYXRhTGFiZWxzKTsgLy8gZGxPcHRpb25zIGlzIHVzZWQgaW4gdHJlZW1hcHNcblx0XHRcdFx0ZW5hYmxlZCA9IHBpY2socG9pbnRPcHRpb25zICYmIHBvaW50T3B0aW9ucy5lbmFibGVkLCBnZW5lcmFsT3B0aW9ucy5lbmFibGVkKTsgLy8gIzIyODJcblxuXG5cdFx0XHRcdC8vIElmIHRoZSBwb2ludCBpcyBvdXRzaWRlIHRoZSBwbG90IGFyZWEsIGRlc3Ryb3kgaXQuICM2NzgsICM4MjBcblx0XHRcdFx0aWYgKGRhdGFMYWJlbCAmJiAhZW5hYmxlZCkge1xuXHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IGRhdGFMYWJlbC5kZXN0cm95KCk7XG5cblx0XHRcdFx0Ly8gSW5kaXZpZHVhbCBsYWJlbHMgYXJlIGRpc2FibGVkIGlmIHRoZSBhcmUgZXhwbGljaXRseSBkaXNhYmxlZFxuXHRcdFx0XHQvLyBpbiB0aGUgcG9pbnQgb3B0aW9ucywgb3IgaWYgdGhleSBmYWxsIG91dHNpZGUgdGhlIHBsb3QgYXJlYS5cblx0XHRcdFx0fSBlbHNlIGlmIChlbmFibGVkKSB7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgaW5kaXZpZHVhbCBvcHRpb25zIHN0cnVjdHVyZSB0aGF0IGNhbiBiZSBleHRlbmRlZCB3aXRob3V0XG5cdFx0XHRcdFx0Ly8gYWZmZWN0aW5nIG90aGVyc1xuXHRcdFx0XHRcdG9wdGlvbnMgPSBtZXJnZShnZW5lcmFsT3B0aW9ucywgcG9pbnRPcHRpb25zKTtcblx0XHRcdFx0XHRzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cblx0XHRcdFx0XHRyb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdGxhYmVsQ29uZmlnID0gcG9pbnQuZ2V0TGFiZWxDb25maWcoKTtcblx0XHRcdFx0XHRzdHIgPSBvcHRpb25zLmZvcm1hdCA/XG5cdFx0XHRcdFx0XHRmb3JtYXQob3B0aW9ucy5mb3JtYXQsIGxhYmVsQ29uZmlnKSA6XG5cdFx0XHRcdFx0XHRvcHRpb25zLmZvcm1hdHRlci5jYWxsKGxhYmVsQ29uZmlnLCBvcHRpb25zKTtcblxuXHRcdFx0XHRcdC8vIERldGVybWluZSB0aGUgY29sb3Jcblx0XHRcdFx0XHRzdHlsZS5jb2xvciA9IHBpY2sob3B0aW9ucy5jb2xvciwgc3R5bGUuY29sb3IsIHNlcmllcy5jb2xvciwgJ2JsYWNrJyk7XG5cblxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBleGlzdGluZyBsYWJlbFxuXHRcdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblxuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQoc3RyKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhTGFiZWxcblx0XHRcdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBzdHJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aXNOZXcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gIzE0MzcgLSB0aGUgbGFiZWwgaXMgc2hvd24gY29uZGl0aW9uYWxseVxuXHRcdFx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuY29ubmVjdG9yID0gY29ubmVjdG9yLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIG5ldyBsYWJlbFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVmaW5lZChzdHIpKSB7XG5cdFx0XHRcdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRcdFx0XHQvL2FsaWduOiBhbGlnbixcblx0XHRcdFx0XHRcdFx0ZmlsbDogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdHI6IG9wdGlvbnMuYm9yZGVyUmFkaXVzIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJvdGF0aW9uOiByb3RhdGlvbixcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogb3B0aW9ucy5wYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDFcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEdldCBhdXRvbWF0ZWQgY29udHJhc3QgY29sb3Jcblx0XHRcdFx0XHRcdGlmIChzdHlsZS5jb2xvciA9PT0gJ2NvbnRyYXN0Jykge1xuXHRcdFx0XHRcdFx0XHRtb3JlU3R5bGUuY29sb3IgPSBvcHRpb25zLmluc2lkZSB8fCBvcHRpb25zLmRpc3RhbmNlIDwgMCB8fCAhIXNlcmllc09wdGlvbnMuc3RhY2tpbmcgPyBcblx0XHRcdFx0XHRcdFx0XHRyZW5kZXJlci5nZXRDb250cmFzdChwb2ludC5jb2xvciB8fCBzZXJpZXMuY29sb3IpIDogXG5cdFx0XHRcdFx0XHRcdFx0JyMwMDAwMDAnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1cnNvcikge1xuXHRcdFx0XHRcdFx0XHRtb3JlU3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSB1bnVzZWQgYXR0cmlidXRlcyAoIzk0Nylcblx0XHRcdFx0XHRcdGZvciAobmFtZSBpbiBhdHRyKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyW25hbWVdID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgYXR0cltuYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwgPSByZW5kZXJlcltyb3RhdGlvbiA/ICd0ZXh0JyA6ICdsYWJlbCddKCAvLyBsYWJlbHMgZG9uJ3Qgc3VwcG9ydCByb3RhdGlvblxuXHRcdFx0XHRcdFx0XHRzdHIsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdC05OTksXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc2hhcGUsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmF0dHIoYXR0cilcblx0XHRcdFx0XHRcdC5jc3MoZXh0ZW5kKHN0eWxlLCBtb3JlU3R5bGUpKVxuXHRcdFx0XHRcdFx0LmFkZChkYXRhTGFiZWxzR3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRcdC8vIE5vdyB0aGUgZGF0YSBsYWJlbCBpcyBjcmVhdGVkIGFuZCBwbGFjZWQgYXQgMCwwLCBzbyB3ZSBuZWVkIHRvIGFsaWduIGl0XG5cdFx0XHRcdFx0XHRzZXJpZXMuYWxpZ25EYXRhTGFiZWwocG9pbnQsIGRhdGFMYWJlbCwgb3B0aW9ucywgbnVsbCwgaXNOZXcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlnbiBlYWNoIGluZGl2aWR1YWwgZGF0YSBsYWJlbFxuXHQgKi9cblx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnblRvLCBpc05ldykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0cGxvdFggPSBwaWNrKHBvaW50LnBsb3RYLCAtOTk5KSxcblx0XHRcdHBsb3RZID0gcGljayhwb2ludC5wbG90WSwgLTk5OSksXG5cdFx0XHRiQm94ID0gZGF0YUxhYmVsLmdldEJCb3goKSxcblx0XHRcdGJhc2VsaW5lID0gY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3Mob3B0aW9ucy5zdHlsZS5mb250U2l6ZSkuYixcblx0XHRcdHJvdENvcnIsIC8vIHJvdGF0aW9uIGNvcnJlY3Rpb25cblx0XHRcdC8vIE1hdGgucm91bmQgZm9yIHJvdW5kaW5nIGVycm9ycyAoIzI2ODMpLCBhbGlnblRvIHRvIGFsbG93IGNvbHVtbiBsYWJlbHMgKCMyNzAwKVxuXHRcdFx0dmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiAocG9pbnQuc2VyaWVzLmZvcmNlREwgfHwgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBtYXRoUm91bmQocGxvdFkpLCBpbnZlcnRlZCkgfHxcblx0XHRcdFx0KGFsaWduVG8gJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBpbnZlcnRlZCA/IGFsaWduVG8ueCArIDEgOiBhbGlnblRvLnkgKyBhbGlnblRvLmhlaWdodCAtIDEsIGludmVydGVkKSkpLFxuXHRcdFx0YWxpZ25BdHRyOyAvLyB0aGUgZmluYWwgcG9zaXRpb247XG5cblx0XHRpZiAodmlzaWJsZSkge1xuXG5cdFx0XHQvLyBUaGUgYWxpZ25tZW50IGJveCBpcyBhIHNpbmd1bGFyIHBvaW50XG5cdFx0XHRhbGlnblRvID0gZXh0ZW5kKHtcblx0XHRcdFx0eDogaW52ZXJ0ZWQgPyBjaGFydC5wbG90V2lkdGggLSBwbG90WSA6IHBsb3RYLFxuXHRcdFx0XHR5OiBtYXRoUm91bmQoaW52ZXJ0ZWQgPyBjaGFydC5wbG90SGVpZ2h0IC0gcGxvdFggOiBwbG90WSksXG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0sIGFsaWduVG8pO1xuXG5cdFx0XHQvLyBBZGQgdGhlIHRleHQgc2l6ZSBmb3IgYWxpZ25tZW50IGNhbGN1bGF0aW9uXG5cdFx0XHRleHRlbmQob3B0aW9ucywge1xuXHRcdFx0XHR3aWR0aDogYkJveC53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFsbG93IGEgaG9vayBmb3IgY2hhbmdpbmcgYWxpZ25tZW50IGluIHRoZSBsYXN0IG1vbWVudCwgdGhlbiBkbyB0aGUgYWxpZ25tZW50XG5cdFx0XHRpZiAob3B0aW9ucy5yb3RhdGlvbikgeyAvLyBGYW5jeSBib3ggYWxpZ25tZW50IGlzbid0IHN1cHBvcnRlZCBmb3Igcm90YXRlZCB0ZXh0XG5cdFx0XHRcdHJvdENvcnIgPSBjaGFydC5yZW5kZXJlci5yb3RDb3JyKGJhc2VsaW5lLCBvcHRpb25zLnJvdGF0aW9uKTsgLy8gIzM3MjNcblx0XHRcdFx0ZGF0YUxhYmVsW2lzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh7XG5cdFx0XHRcdFx0XHR4OiBhbGlnblRvLnggKyBvcHRpb25zLnggKyBhbGlnblRvLndpZHRoIC8gMiArIHJvdENvcnIueCxcblx0XHRcdFx0XHRcdHk6IGFsaWduVG8ueSArIG9wdGlvbnMueSArIGFsaWduVG8uaGVpZ2h0IC8gMlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmF0dHIoeyAvLyAjMzAwM1xuXHRcdFx0XHRcdFx0YWxpZ246IG9wdGlvbnMuYWxpZ25cblx0XHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFMYWJlbC5hbGlnbihvcHRpb25zLCBudWxsLCBhbGlnblRvKTtcblx0XHRcdFx0YWxpZ25BdHRyID0gZGF0YUxhYmVsLmFsaWduQXR0cjtcblxuXHRcdFx0XHQvLyBIYW5kbGUganVzdGlmeSBvciBjcm9wXG5cdFx0XHRcdGlmIChwaWNrKG9wdGlvbnMub3ZlcmZsb3csICdqdXN0aWZ5JykgPT09ICdqdXN0aWZ5Jykge1xuXHRcdFx0XHRcdHRoaXMuanVzdGlmeURhdGFMYWJlbChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAocGljayhvcHRpb25zLmNyb3AsIHRydWUpKSB7XG5cdFx0XHRcdFx0Ly8gTm93IGNoZWNrIHRoYXQgdGhlIGRhdGEgbGFiZWwgaXMgd2l0aGluIHRoZSBwbG90IGFyZWFcblx0XHRcdFx0XHR2aXNpYmxlID0gY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54LCBhbGlnbkF0dHIueSkgJiYgY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54ICsgYkJveC53aWR0aCwgYWxpZ25BdHRyLnkgKyBiQm94LmhlaWdodCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdoZW4gd2UncmUgdXNpbmcgYSBzaGFwZSwgbWFrZSBpdCBwb3NzaWJsZSB3aXRoIGEgY29ubmVjdG9yIG9yIGFuIGFycm93IHBvaW50aW5nIHRvIHRoaWUgcG9pbnRcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2hhcGUpIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0XHRhbmNob3JYOiBwb2ludC5wbG90WCxcblx0XHRcdFx0XHRcdGFuY2hvclk6IHBvaW50LnBsb3RZXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNob3cgb3IgaGlkZSBiYXNlZCBvbiB0aGUgZmluYWwgYWxpZ25lZCBwb3NpdGlvblxuXHRcdGlmICghdmlzaWJsZSkge1xuXHRcdFx0ZGF0YUxhYmVsLmF0dHIoeyB5OiAtOTk5IH0pO1xuXHRcdFx0ZGF0YUxhYmVsLnBsYWNlZCA9IGZhbHNlOyAvLyBkb24ndCBhbmltYXRlIGJhY2sgaW5cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogSWYgZGF0YSBsYWJlbHMgZmFsbCBwYXJ0bHkgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhbGlnbiB0aGVtIGJhY2sgaW4sIGluIGEgd2F5IHRoYXRcblx0ICogZG9lc24ndCBoaWRlIHRoZSBwb2ludC5cblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbCA9IGZ1bmN0aW9uIChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0YWxpZ24gPSBvcHRpb25zLmFsaWduLFxuXHRcdFx0dmVydGljYWxBbGlnbiA9IG9wdGlvbnMudmVydGljYWxBbGlnbixcblx0XHRcdG9mZixcblx0XHRcdGp1c3RpZmllZCxcblx0XHRcdHBhZGRpbmcgPSBkYXRhTGFiZWwuYm94ID8gMCA6IChkYXRhTGFiZWwucGFkZGluZyB8fCAwKTtcblxuXHRcdC8vIE9mZiBsZWZ0XG5cdFx0b2ZmID0gYWxpZ25BdHRyLnggKyBwYWRkaW5nO1xuXHRcdGlmIChvZmYgPCAwKSB7XG5cdFx0XHRpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdsZWZ0Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueCA9IC1vZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiByaWdodFxuXHRcdG9mZiA9IGFsaWduQXR0ci54ICsgYkJveC53aWR0aCAtIHBhZGRpbmc7XG5cdFx0aWYgKG9mZiA+IGNoYXJ0LnBsb3RXaWR0aCkge1xuXHRcdFx0aWYgKGFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdyaWdodCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnggPSBjaGFydC5wbG90V2lkdGggLSBvZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiB0b3Bcblx0XHRvZmYgPSBhbGlnbkF0dHIueSArIHBhZGRpbmc7XG5cdFx0aWYgKG9mZiA8IDApIHtcblx0XHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24gPSAndG9wJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueSA9IC1vZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiBib3R0b21cblx0XHRvZmYgPSBhbGlnbkF0dHIueSArIGJCb3guaGVpZ2h0IC0gcGFkZGluZztcblx0XHRpZiAob2ZmID4gY2hhcnQucGxvdEhlaWdodCkge1xuXHRcdFx0aWYgKHZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdG9wdGlvbnMudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy55ID0gY2hhcnQucGxvdEhlaWdodCAtIG9mZjtcblx0XHRcdH1cblx0XHRcdGp1c3RpZmllZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGp1c3RpZmllZCkge1xuXHRcdFx0ZGF0YUxhYmVsLnBsYWNlZCA9ICFpc05ldztcblx0XHRcdGRhdGFMYWJlbC5hbGlnbihvcHRpb25zLCBudWxsLCBhbGlnblRvKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIHRoZSBiYXNlIGRyYXdEYXRhTGFiZWxzIG1ldGhvZCBieSBwaWUgc3BlY2lmaWMgZnVuY3Rpb25hbGl0eVxuXHQgKi9cblx0aWYgKHNlcmllc1R5cGVzLnBpZSkge1xuXHRcdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucy5kYXRhTGFiZWxzLFxuXHRcdFx0XHRjb25uZWN0b3JQYWRkaW5nID0gcGljayhvcHRpb25zLmNvbm5lY3RvclBhZGRpbmcsIDEwKSxcblx0XHRcdFx0Y29ubmVjdG9yV2lkdGggPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yV2lkdGgsIDEpLFxuXHRcdFx0XHRwbG90V2lkdGggPSBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0XHRjb25uZWN0b3IsXG5cdFx0XHRcdGNvbm5lY3RvclBhdGgsXG5cdFx0XHRcdHNvZnRDb25uZWN0b3IgPSBwaWNrKG9wdGlvbnMuc29mdENvbm5lY3RvciwgdHJ1ZSksXG5cdFx0XHRcdGRpc3RhbmNlT3B0aW9uID0gb3B0aW9ucy5kaXN0YW5jZSxcblx0XHRcdFx0c2VyaWVzQ2VudGVyID0gc2VyaWVzLmNlbnRlcixcblx0XHRcdFx0cmFkaXVzID0gc2VyaWVzQ2VudGVyWzJdIC8gMixcblx0XHRcdFx0Y2VudGVyWSA9IHNlcmllc0NlbnRlclsxXSxcblx0XHRcdFx0b3V0c2lkZSA9IGRpc3RhbmNlT3B0aW9uID4gMCxcblx0XHRcdFx0ZGF0YUxhYmVsLFxuXHRcdFx0XHRkYXRhTGFiZWxXaWR0aCxcblx0XHRcdFx0bGFiZWxQb3MsXG5cdFx0XHRcdGxhYmVsSGVpZ2h0LFxuXHRcdFx0XHRoYWx2ZXMgPSBbLy8gZGl2aWRlIHRoZSBwb2ludHMgaW50byByaWdodCBhbmQgbGVmdCBoYWx2ZXMgZm9yIGFudGkgY29sbGlzaW9uXG5cdFx0XHRcdFx0W10sIC8vIHJpZ2h0XG5cdFx0XHRcdFx0W10gIC8vIGxlZnRcblx0XHRcdFx0XSxcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdFx0cmFua0Fycixcblx0XHRcdFx0aSxcblx0XHRcdFx0aixcblx0XHRcdFx0b3ZlcmZsb3cgPSBbMCwgMCwgMCwgMF0sIC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0XHRzb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYi55IC0gYS55O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBnZXQgb3V0IGlmIG5vdCBlbmFibGVkXG5cdFx0XHRpZiAoIXNlcmllcy52aXNpYmxlIHx8ICghb3B0aW9ucy5lbmFibGVkICYmICFzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBwYXJlbnQgbWV0aG9kXG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KHNlcmllcyk7XG5cblx0XHRcdC8vIGFycmFuZ2UgcG9pbnRzIGZvciBkZXRlY3Rpb24gY29sbGlzaW9uXG5cdFx0XHRlYWNoKGRhdGEsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRpZiAocG9pbnQuZGF0YUxhYmVsICYmIHBvaW50LnZpc2libGUpIHsgLy8gIzQwNywgIzI1MTBcblx0XHRcdFx0XHRoYWx2ZXNbcG9pbnQuaGFsZl0ucHVzaChwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvKiBMb29wIG92ZXIgdGhlIHBvaW50cyBpbiBlYWNoIGhhbGYsIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tXG5cdFx0XHQgKiBvZiB0aGUgcGllIHRvIGRldGVjdCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdFx0XHQgKi9cblx0XHRcdGkgPSAyO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHRcdHZhciBzbG90cyA9IFtdLFxuXHRcdFx0XHRcdHNsb3RzTGVuZ3RoLFxuXHRcdFx0XHRcdHVzZWRTbG90cyA9IFtdLFxuXHRcdFx0XHRcdHBvaW50cyA9IGhhbHZlc1tpXSxcblx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdFx0Ym90dG9tLFxuXHRcdFx0XHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0c2xvdEluZGV4O1xuXG5cdFx0XHRcdGlmICghbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTb3J0IGJ5IGFuZ2xlXG5cdFx0XHRcdHNlcmllcy5zb3J0QnlBbmdsZShwb2ludHMsIGkgLSAwLjUpO1xuXG5cdFx0XHRcdC8vIEFzc3VtZSBlcXVhbCBsYWJlbCBoZWlnaHRzIG9uIGVpdGhlciBoZW1pc3BoZXJlICgjMjYzMClcblx0XHRcdFx0aiA9IGxhYmVsSGVpZ2h0ID0gMDtcblx0XHRcdFx0d2hpbGUgKCFsYWJlbEhlaWdodCAmJiBwb2ludHNbal0pIHsgLy8gIzE1Njlcblx0XHRcdFx0XHRsYWJlbEhlaWdodCA9IHBvaW50c1tqXSAmJiBwb2ludHNbal0uZGF0YUxhYmVsICYmIChwb2ludHNbal0uZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHQgfHwgMjEpOyAvLyAyMSBpcyBmb3IgIzk2OFxuXHRcdFx0XHRcdGorKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE9ubHkgZG8gYW50aS1jb2xsaXNpb24gd2hlbiB3ZSBhcmUgb3V0c2lkZSB0aGUgcGllIGFuZCBoYXZlIGNvbm5lY3RvcnMgKCM4NTYpXG5cdFx0XHRcdGlmIChkaXN0YW5jZU9wdGlvbiA+IDApIHtcblxuXHRcdFx0XHRcdC8vIEJ1aWxkIHRoZSBzbG90c1xuXHRcdFx0XHRcdGJvdHRvbSA9IG1hdGhNaW4oY2VudGVyWSArIHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uLCBjaGFydC5wbG90SGVpZ2h0KTtcblx0XHRcdFx0XHRmb3IgKHBvcyA9IG1hdGhNYXgoMCwgY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uKTsgcG9zIDw9IGJvdHRvbTsgcG9zICs9IGxhYmVsSGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRzbG90cy5wdXNoKHBvcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNsb3RzTGVuZ3RoID0gc2xvdHMubGVuZ3RoO1xuXG5cblx0XHRcdFx0XHQvKiBWaXN1YWxpemUgdGhlIHNsb3RzXG5cdFx0XHRcdFx0aWYgKCFzZXJpZXMuc2xvdEVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpID09PSAxKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMubGVuZ3RoID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRzbG90cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MsIG5vKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2xvdFggPSBzZXJpZXMuZ2V0WChwb3MsIGkpICsgY2hhcnQucGxvdExlZnQgLSAoaSA/IDEwMCA6IDApLFxuXHRcdFx0XHRcdFx0XHRzbG90WSA9IHBvcyArIGNoYXJ0LnBsb3RUb3A7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICghaXNOYU4oc2xvdFgpKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMucHVzaChjaGFydC5yZW5kZXJlci5yZWN0KHNsb3RYLCBzbG90WSAtIDcsIDEwMCwgbGFiZWxIZWlnaHQsIDEpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJva2U6ICdzaWx2ZXInLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3JnYmEoMCwwLDI1NSwwLjEpJ1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0LmFkZCgpKTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cy5wdXNoKGNoYXJ0LnJlbmRlcmVyLnRleHQoJ1Nsb3QgJysgbm8sIHNsb3RYLCBzbG90WSArIDQpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3NpbHZlcidcblx0XHRcdFx0XHRcdFx0XHR9KS5hZGQoKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gKi9cblxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBtb3JlIHZhbHVlcyB0aGFuIGF2YWlsYWJsZSBzbG90cywgcmVtb3ZlIGxvd2VzdCB2YWx1ZXNcblx0XHRcdFx0XHRpZiAobGVuZ3RoID4gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIGNyZWF0ZSBhbiBhcnJheSBmb3Igc29ydGluZyBhbmQgcmFua2luZyB0aGUgcG9pbnRzIHdpdGhpbiBlYWNoIHF1YXJ0ZXJcblx0XHRcdFx0XHRcdHJhbmtBcnIgPSBbXS5jb25jYXQocG9pbnRzKTtcblx0XHRcdFx0XHRcdHJhbmtBcnIuc29ydChzb3J0KTtcblx0XHRcdFx0XHRcdGogPSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0XHRcdHJhbmtBcnJbal0ucmFuayA9IGo7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRqID0gbGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocG9pbnRzW2pdLnJhbmsgPj0gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludHMuc3BsaWNlKGosIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRoZSBsYWJlbCBnb2VzIHRvIHRoZSBuZWFyZXN0IG9wZW4gc2xvdCwgYnV0IG5vdCBjbG9zZXIgdG8gdGhlIGVkZ2UgdGhhblxuXHRcdFx0XHRcdC8vIHRoZSBsYWJlbCdzIGluZGV4LlxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXG5cdFx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tqXTtcblx0XHRcdFx0XHRcdGxhYmVsUG9zID0gcG9pbnQubGFiZWxQb3M7XG5cblx0XHRcdFx0XHRcdHZhciBjbG9zZXN0ID0gOTk5OSxcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHNsb3RJO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBjbG9zZXN0IHNsb3QgaW5kZXhcblx0XHRcdFx0XHRcdGZvciAoc2xvdEkgPSAwOyBzbG90SSA8IHNsb3RzTGVuZ3RoOyBzbG90SSsrKSB7XG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlID0gbWF0aEFicyhzbG90c1tzbG90SV0gLSBsYWJlbFBvc1sxXSk7XG5cdFx0XHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IGNsb3Nlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdEk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhhdCBzbG90IGluZGV4IGlzIGNsb3NlciB0byB0aGUgZWRnZXMgb2YgdGhlIHNsb3RzLCBtb3ZlIGl0XG5cdFx0XHRcdFx0XHQvLyB0byB0aGUgY2xvc2VzdCBhcHByb3ByaWF0ZSBzbG90XG5cdFx0XHRcdFx0XHRpZiAoc2xvdEluZGV4IDwgaiAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSB0b3Bcblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gajtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2xvdHNMZW5ndGggIDwgbGVuZ3RoIC0gaiArIHNsb3RJbmRleCAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSBib3R0b21cblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdHNMZW5ndGggLSBsZW5ndGggKyBqO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoc2xvdHNbc2xvdEluZGV4XSA9PT0gbnVsbCkgeyAvLyBtYWtlIHN1cmUgaXQgaXMgbm90IHRha2VuXG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNsb3QgaXMgdGFrZW4sIGZpbmQgbmV4dCBmcmVlIHNsb3QgYmVsb3cuIEluIHRoZSBuZXh0IHJ1biwgdGhlIG5leHQgc2xpY2Ugd2lsbCBmaW5kIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBzbG90IGFib3ZlIHRoZXNlLCBiZWNhdXNlIGl0IGlzIHRoZSBjbG9zZXN0IG9uZVxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoc2xvdHNbc2xvdEluZGV4XSA9PT0gbnVsbCkgeyAvLyBtYWtlIHN1cmUgaXQgaXMgbm90IHRha2VuXG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dXNlZFNsb3RzLnB1c2goeyBpOiBzbG90SW5kZXgsIHk6IHNsb3RzW3Nsb3RJbmRleF0gfSk7XG5cdFx0XHRcdFx0XHRzbG90c1tzbG90SW5kZXhdID0gbnVsbDsgLy8gbWFyayBhcyB0YWtlblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzb3J0IHRoZW0gaW4gb3JkZXIgdG8gZmlsbCBpbiBmcm9tIHRoZSB0b3Bcblx0XHRcdFx0XHR1c2VkU2xvdHMuc29ydChzb3J0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyB0aGUgdXNlZCBzbG90cyBhcmUgc29ydGVkLCBmaWxsIHRoZW0gdXAgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXG5cdFx0XHRcdFx0dmFyIHNsb3QsIG5hdHVyYWxZO1xuXG5cdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbal07XG5cdFx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWw7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eSA9IHBvaW50LnZpc2libGUgPT09IGZhbHNlID8gSElEREVOIDogJ2luaGVyaXQnO1xuXHRcdFx0XHRcdG5hdHVyYWxZID0gbGFiZWxQb3NbMV07XG5cblx0XHRcdFx0XHRpZiAoZGlzdGFuY2VPcHRpb24gPiAwKSB7XG5cdFx0XHRcdFx0XHRzbG90ID0gdXNlZFNsb3RzLnBvcCgpO1xuXHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdC5pO1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgc2xvdCBuZXh0IHRvIGN1cnJyZW50IHNsb3QgaXMgZnJlZSwgdGhlIHkgdmFsdWUgaXMgYWxsb3dlZFxuXHRcdFx0XHRcdFx0Ly8gdG8gZmFsbCBiYWNrIHRvIHRoZSBuYXR1cmFsIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHR5ID0gc2xvdC55O1xuXHRcdFx0XHRcdFx0aWYgKChuYXR1cmFsWSA+IHkgJiYgc2xvdHNbc2xvdEluZGV4ICsgMV0gIT09IG51bGwpIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG5hdHVyYWxZIDwgeSAmJiAgc2xvdHNbc2xvdEluZGV4IC0gMV0gIT09IG51bGwpKSB7XG5cdFx0XHRcdFx0XHRcdHkgPSBtYXRoTWluKG1hdGhNYXgoMCwgbmF0dXJhbFkpLCBjaGFydC5wbG90SGVpZ2h0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR5ID0gbmF0dXJhbFk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSB4IC0gdXNlIHRoZSBuYXR1cmFsIHggcG9zaXRpb24gZm9yIGZpcnN0IGFuZCBsYXN0IHNsb3QsIHRvIHByZXZlbnQgdGhlIHRvcFxuXHRcdFx0XHRcdC8vIGFuZCBib3R0b24gc2xpY2UgY29ubmVjdG9ycyBmcm9tIHRvdWNoaW5nIGVhY2ggb3RoZXIgb24gZWl0aGVyIHNpZGVcblx0XHRcdFx0XHR4ID0gb3B0aW9ucy5qdXN0aWZ5ID9cblx0XHRcdFx0XHRcdHNlcmllc0NlbnRlclswXSArIChpID8gLTEgOiAxKSAqIChyYWRpdXMgKyBkaXN0YW5jZU9wdGlvbikgOlxuXHRcdFx0XHRcdFx0c2VyaWVzLmdldFgoeSA9PT0gY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uIHx8IHkgPT09IGNlbnRlclkgKyByYWRpdXMgKyBkaXN0YW5jZU9wdGlvbiA/IG5hdHVyYWxZIDogeSwgaSk7XG5cblxuXHRcdFx0XHRcdC8vIFJlY29yZCB0aGUgcGxhY2VtZW50IGFuZCB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLl9hdHRyID0ge1xuXHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRcdGFsaWduOiBsYWJlbFBvc1s2XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLl9wb3MgPSB7XG5cdFx0XHRcdFx0XHR4OiB4ICsgb3B0aW9ucy54ICtcblx0XHRcdFx0XHRcdFx0KHsgbGVmdDogY29ubmVjdG9yUGFkZGluZywgcmlnaHQ6IC1jb25uZWN0b3JQYWRkaW5nIH1bbGFiZWxQb3NbNl1dIHx8IDApLFxuXHRcdFx0XHRcdFx0eTogeSArIG9wdGlvbnMueSAtIDEwIC8vIDEwIGlzIGZvciB0aGUgYmFzZWxpbmUgKGxhYmVsIHZzIHRleHQpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRkYXRhTGFiZWwuY29ublggPSB4O1xuXHRcdFx0XHRcdGRhdGFMYWJlbC5jb25uWSA9IHk7XG5cblxuXHRcdFx0XHRcdC8vIERldGVjdCBvdmVyZmxvd2luZyBkYXRhIGxhYmVsc1xuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsV2lkdGggPSBkYXRhTGFiZWwud2lkdGg7XG5cdFx0XHRcdFx0XHQvLyBPdmVyZmxvdyBsZWZ0XG5cdFx0XHRcdFx0XHRpZiAoeCAtIGRhdGFMYWJlbFdpZHRoIDwgY29ubmVjdG9yUGFkZGluZykge1xuXHRcdFx0XHRcdFx0XHRvdmVyZmxvd1szXSA9IG1hdGhNYXgobWF0aFJvdW5kKGRhdGFMYWJlbFdpZHRoIC0geCArIGNvbm5lY3RvclBhZGRpbmcpLCBvdmVyZmxvd1szXSk7XG5cblx0XHRcdFx0XHRcdC8vIE92ZXJmbG93IHJpZ2h0XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggKyBkYXRhTGFiZWxXaWR0aCA+IHBsb3RXaWR0aCAtIGNvbm5lY3RvclBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmZsb3dbMV0gPSBtYXRoTWF4KG1hdGhSb3VuZCh4ICsgZGF0YUxhYmVsV2lkdGggLSBwbG90V2lkdGggKyBjb25uZWN0b3JQYWRkaW5nKSwgb3ZlcmZsb3dbMV0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPdmVyZmxvdyB0b3Bcblx0XHRcdFx0XHRcdGlmICh5IC0gbGFiZWxIZWlnaHQgLyAyIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRvdmVyZmxvd1swXSA9IG1hdGhNYXgobWF0aFJvdW5kKC15ICsgbGFiZWxIZWlnaHQgLyAyKSwgb3ZlcmZsb3dbMF0pO1xuXG5cdFx0XHRcdFx0XHQvLyBPdmVyZmxvdyBsZWZ0XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgKyBsYWJlbEhlaWdodCAvIDIgPiBwbG90SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93WzJdID0gbWF0aE1heChtYXRoUm91bmQoeSArIGxhYmVsSGVpZ2h0IC8gMiAtIHBsb3RIZWlnaHQpLCBvdmVyZmxvd1syXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGZvciBlYWNoIHBvaW50XG5cdFx0XHR9IC8vIGZvciBlYWNoIGhhbGZcblxuXHRcdFx0Ly8gRG8gbm90IGFwcGx5IHRoZSBmaW5hbCBwbGFjZW1lbnQgYW5kIGRyYXcgdGhlIGNvbm5lY3RvcnMgdW50aWwgd2UgaGF2ZSB2ZXJpZmllZFxuXHRcdFx0Ly8gdGhhdCBsYWJlbHMgYXJlIG5vdCBzcGlsbGluZyBvdmVyLlxuXHRcdFx0aWYgKGFycmF5TWF4KG92ZXJmbG93KSA9PT0gMCB8fCB0aGlzLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93KG92ZXJmbG93KSkge1xuXG5cdFx0XHRcdC8vIFBsYWNlIHRoZSBsYWJlbHMgaW4gdGhlIGZpbmFsIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMucGxhY2VEYXRhTGFiZWxzKCk7XG5cblx0XHRcdFx0Ly8gRHJhdyB0aGUgY29ubmVjdG9yc1xuXHRcdFx0XHRpZiAob3V0c2lkZSAmJiBjb25uZWN0b3JXaWR0aCkge1xuXHRcdFx0XHRcdGVhY2godGhpcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdFx0Y29ubmVjdG9yID0gcG9pbnQuY29ubmVjdG9yO1xuXHRcdFx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XHRcdFx0XHRcdGRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbDtcblxuXHRcdFx0XHRcdFx0aWYgKGRhdGFMYWJlbCAmJiBkYXRhTGFiZWwuX3BvcyAmJiBwb2ludC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2liaWxpdHkgPSBkYXRhTGFiZWwuX2F0dHIudmlzaWJpbGl0eTtcblx0XHRcdFx0XHRcdFx0eCA9IGRhdGFMYWJlbC5jb25uWDtcblx0XHRcdFx0XHRcdFx0eSA9IGRhdGFMYWJlbC5jb25uWTtcblx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yUGF0aCA9IHNvZnRDb25uZWN0b3IgPyBbXG5cdFx0XHRcdFx0XHRcdFx0TSxcblx0XHRcdFx0XHRcdFx0XHR4ICsgKGxhYmVsUG9zWzZdID09PSAnbGVmdCcgPyA1IDogLTUpLCB5LCAvLyBlbmQgb2YgdGhlIHN0cmluZyBhdCB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0XHQnQycsXG5cdFx0XHRcdFx0XHRcdFx0eCwgeSwgLy8gZmlyc3QgYnJlYWssIG5leHQgdG8gdGhlIGxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGxhYmVsUG9zWzJdIC0gbGFiZWxQb3NbNF0sIDIgKiBsYWJlbFBvc1szXSAtIGxhYmVsUG9zWzVdLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzJdLCBsYWJlbFBvc1szXSwgLy8gc2Vjb25kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFBvc1s0XSwgbGFiZWxQb3NbNV0gLy8gYmFzZVxuXHRcdFx0XHRcdFx0XHRdIDogW1xuXHRcdFx0XHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0XHRcdFx0eCArIChsYWJlbFBvc1s2XSA9PT0gJ2xlZnQnID8gNSA6IC01KSwgeSwgLy8gZW5kIG9mIHRoZSBzdHJpbmcgYXQgdGhlIGxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFBvc1syXSwgbGFiZWxQb3NbM10sIC8vIHNlY29uZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxQb3NbNF0sIGxhYmVsUG9zWzVdIC8vIGJhc2Vcblx0XHRcdFx0XHRcdFx0XTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yLmFuaW1hdGUoeyBkOiBjb25uZWN0b3JQYXRoIH0pO1xuXHRcdFx0XHRcdFx0XHRcdGNvbm5lY3Rvci5hdHRyKCd2aXNpYmlsaXR5JywgdmlzaWJpbGl0eSk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChjb25uZWN0b3JQYXRoKS5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBjb25uZWN0b3JXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5jb25uZWN0b3JDb2xvciB8fCBwb2ludC5jb2xvciB8fCAnIzYwNjA2MCcsXG5cdFx0XHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHQvL3pJbmRleDogMCAvLyAjMjcyMiAocmV2ZXJzZWQpXG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5kYXRhTGFiZWxzR3JvdXApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbm5lY3Rvcikge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtIHRoZSBmaW5hbCBwbGFjZW1lbnQgb2YgdGhlIGRhdGEgbGFiZWxzIGFmdGVyIHdlIGhhdmUgdmVyaWZpZWQgdGhhdCB0aGV5XG5cdFx0ICogZmFsbCB3aXRoaW4gdGhlIHBsb3QgYXJlYS5cblx0XHQgKi9cblx0XHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnBsYWNlRGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGVhY2godGhpcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRcdF9wb3M7XG5cblx0XHRcdFx0aWYgKGRhdGFMYWJlbCAmJiBwb2ludC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0X3BvcyA9IGRhdGFMYWJlbC5fcG9zO1xuXHRcdFx0XHRcdGlmIChfcG9zKSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cihkYXRhTGFiZWwuX2F0dHIpO1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsW2RhdGFMYWJlbC5tb3ZlZCA/ICdhbmltYXRlJyA6ICdhdHRyJ10oX3Bvcyk7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwubW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7IHk6IC05OTkgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9ICBub29wO1xuXG5cdFx0LyoqXG5cdFx0ICogVmVyaWZ5IHdoZXRoZXIgdGhlIGRhdGEgbGFiZWxzIGFyZSBhbGxvd2VkIHRvIGRyYXcsIG9yIHdlIHNob3VsZCBydW4gbW9yZSB0cmFuc2xhdGlvbiBhbmQgZGF0YVxuXHRcdCAqIGxhYmVsIHBvc2l0aW9uaW5nIHRvIGtlZXAgdGhlbSBpbnNpZGUgdGhlIHBsb3QgYXJlYS4gUmV0dXJucyB0cnVlIHdoZW4gZGF0YSBsYWJlbHMgYXJlIHJlYWR5XG5cdFx0ICogdG8gZHJhdy5cblx0XHQgKi9cblx0XHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93ID0gZnVuY3Rpb24gKG92ZXJmbG93KSB7XG5cblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcixcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0Y2VudGVyT3B0aW9uID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRcdG1pblNpemUgPSBvcHRpb25zLm1pblNpemUgfHwgODAsXG5cdFx0XHRcdG5ld1NpemUgPSBtaW5TaXplLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdC8vIEhhbmRsZSBob3Jpem9udGFsIHNpemUgYW5kIGNlbnRlclxuXHRcdFx0aWYgKGNlbnRlck9wdGlvblswXSAhPT0gbnVsbCkgeyAvLyBGaXhlZCBjZW50ZXJcblx0XHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgoY2VudGVyWzJdIC0gbWF0aE1heChvdmVyZmxvd1sxXSwgb3ZlcmZsb3dbM10pLCBtaW5TaXplKTtcblxuXHRcdFx0fSBlbHNlIHsgLy8gQXV0byBjZW50ZXJcblx0XHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0Y2VudGVyWzJdIC0gb3ZlcmZsb3dbMV0gLSBvdmVyZmxvd1szXSwgLy8gaG9yaXpvbnRhbCBvdmVyZmxvd1xuXHRcdFx0XHRcdG1pblNpemVcblx0XHRcdFx0KTtcblx0XHRcdFx0Y2VudGVyWzBdICs9IChvdmVyZmxvd1szXSAtIG92ZXJmbG93WzFdKSAvIDI7IC8vIGhvcml6b250YWwgY2VudGVyXG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB2ZXJ0aWNhbCBzaXplIGFuZCBjZW50ZXJcblx0XHRcdGlmIChjZW50ZXJPcHRpb25bMV0gIT09IG51bGwpIHsgLy8gRml4ZWQgY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KG1hdGhNaW4obmV3U2l6ZSwgY2VudGVyWzJdIC0gbWF0aE1heChvdmVyZmxvd1swXSwgb3ZlcmZsb3dbMl0pKSwgbWluU2l6ZSk7XG5cblx0XHRcdH0gZWxzZSB7IC8vIEF1dG8gY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdG1hdGhNaW4oXG5cdFx0XHRcdFx0XHRuZXdTaXplLFxuXHRcdFx0XHRcdFx0Y2VudGVyWzJdIC0gb3ZlcmZsb3dbMF0gLSBvdmVyZmxvd1syXSAvLyB2ZXJ0aWNhbCBvdmVyZmxvd1xuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0bWluU2l6ZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjZW50ZXJbMV0gKz0gKG92ZXJmbG93WzBdIC0gb3ZlcmZsb3dbMl0pIC8gMjsgLy8gdmVydGljYWwgY2VudGVyXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBzaXplIG11c3QgYmUgZGVjcmVhc2VkLCB3ZSBuZWVkIHRvIHJ1biB0cmFuc2xhdGUgYW5kIGRyYXdEYXRhTGFiZWxzIGFnYWluXG5cdFx0XHRpZiAobmV3U2l6ZSA8IGNlbnRlclsyXSkge1xuXHRcdFx0XHRjZW50ZXJbMl0gPSBuZXdTaXplO1xuXHRcdFx0XHRjZW50ZXJbM10gPSByZWxhdGl2ZUxlbmd0aChvcHRpb25zLmlubmVyU2l6ZSB8fCAwLCBuZXdTaXplKTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdFx0cG9pbnQuZGF0YUxhYmVsLl9wb3MgPSBudWxsOyAvLyByZXNldFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuZHJhd0RhdGFMYWJlbHMpIHtcblx0XHRcdFx0XHR0aGlzLmRyYXdEYXRhTGFiZWxzKCk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIEVsc2UsIHJldHVybiB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHBpZSBhbmQgaXRzIGxhYmVscyBpcyB3aXRoaW4gdGhlIHBsb3QgYXJlYVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fTtcblx0fVxuXG5cdGlmIChzZXJpZXNUeXBlcy5jb2x1bW4pIHtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJyaWRlIHRoZSBiYXNpYyBkYXRhIGxhYmVsIGFsaWdubWVudCBieSBhZGp1c3RpbmcgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uXG5cdFx0ICovXG5cdFx0c2VyaWVzVHlwZXMuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCAgYWxpZ25UbywgaXNOZXcpIHtcblx0XHRcdHZhciBpbnZlcnRlZCA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0ZGxCb3ggPSBwb2ludC5kbEJveCB8fCBwb2ludC5zaGFwZUFyZ3MsIC8vIGRhdGEgbGFiZWwgYm94IGZvciBhbGlnbm1lbnRcblx0XHRcdFx0YmVsb3cgPSBwaWNrKHBvaW50LmJlbG93LCBwb2ludC5wbG90WSA+IHBpY2sodGhpcy50cmFuc2xhdGVkVGhyZXNob2xkLCBzZXJpZXMueUF4aXMubGVuKSksIC8vIHBvaW50LmJlbG93IGlzIHVzZWQgaW4gcmFuZ2Ugc2VyaWVzXG5cdFx0XHRcdGluc2lkZSA9IHBpY2sob3B0aW9ucy5pbnNpZGUsICEhdGhpcy5vcHRpb25zLnN0YWNraW5nKTsgLy8gZHJhdyBpdCBpbnNpZGUgdGhlIGJveD9cblxuXHRcdFx0Ly8gQWxpZ24gdG8gdGhlIGNvbHVtbiBpdHNlbGYsIG9yIHRoZSB0b3Agb2YgaXRcblx0XHRcdGlmIChkbEJveCkgeyAvLyBBcmVhIHJhbmdlIHVzZXMgdGhpcyBtZXRob2QgYnV0IG5vdCBhbGlnblRvXG5cdFx0XHRcdGFsaWduVG8gPSBtZXJnZShkbEJveCk7XG5cblx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0YWxpZ25UbyA9IHtcblx0XHRcdFx0XHRcdHg6IHNlcmllcy55QXhpcy5sZW4gLSBhbGlnblRvLnkgLSBhbGlnblRvLmhlaWdodCxcblx0XHRcdFx0XHRcdHk6IHNlcmllcy54QXhpcy5sZW4gLSBhbGlnblRvLnggLSBhbGlnblRvLndpZHRoLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGFsaWduVG8uaGVpZ2h0LFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBhbGlnblRvLndpZHRoXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbXB1dGUgdGhlIGFsaWdubWVudCBib3hcblx0XHRcdFx0aWYgKCFpbnNpZGUpIHtcblx0XHRcdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0XHRcdGFsaWduVG8ueCArPSBiZWxvdyA/IDAgOiBhbGlnblRvLndpZHRoO1xuXHRcdFx0XHRcdFx0YWxpZ25Uby53aWR0aCA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFsaWduVG8ueSArPSBiZWxvdyA/IGFsaWduVG8uaGVpZ2h0IDogMDtcblx0XHRcdFx0XHRcdGFsaWduVG8uaGVpZ2h0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBXaGVuIGFsaWdubWVudCBpcyB1bmRlZmluZWQgKHR5cGljYWxseSBjb2x1bW5zIGFuZCBiYXJzKSwgZGlzcGxheSB0aGUgaW5kaXZpZHVhbFxuXHRcdFx0Ly8gcG9pbnQgYmVsb3cgb3IgYWJvdmUgdGhlIHBvaW50IGRlcGVuZGluZyBvbiB0aGUgdGhyZXNob2xkXG5cdFx0XHRvcHRpb25zLmFsaWduID0gcGljayhcblx0XHRcdFx0b3B0aW9ucy5hbGlnbixcblx0XHRcdFx0IWludmVydGVkIHx8IGluc2lkZSA/ICdjZW50ZXInIDogYmVsb3cgPyAncmlnaHQnIDogJ2xlZnQnXG5cdFx0XHQpO1xuXHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduID0gcGljayhcblx0XHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduLFxuXHRcdFx0XHRpbnZlcnRlZCB8fCBpbnNpZGUgPyAnbWlkZGxlJyA6IGJlbG93ID8gJ3RvcCcgOiAnYm90dG9tJ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgcGFyZW50IG1ldGhvZFxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsIHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduVG8sIGlzTmV3KTtcblx0XHR9O1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBIaWdoY2hhcnRzIEpTIHY0LjEuNy1tb2RpZmllZCAoKVxuXHQgKiBIaWdoY2hhcnRzIG1vZHVsZSB0byBoaWRlIG92ZXJsYXBwaW5nIGRhdGEgbGFiZWxzLiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBieSBkZWZhdWx0IGluIEhpZ2htYXBzLlxuXHQgKlxuXHQgKiAoYykgMjAxMC0yMDE0IFRvcnN0ZWluIEhvbnNpXG5cdCAqXG5cdCAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG5cdCAqL1xuXG5cdC8qZ2xvYmFsIEhpZ2hjaGFydHMsIEhpZ2hjaGFydHNBZGFwdGVyICovXG5cdChmdW5jdGlvbiAoSCkge1xuXHRcdHZhciBDaGFydCA9IEguQ2hhcnQsXG5cdFx0XHRlYWNoID0gSC5lYWNoLFxuXHRcdFx0cGljayA9IEgucGljayxcblx0XHRcdGFkZEV2ZW50ID0gSGlnaGNoYXJ0c0FkYXB0ZXIuYWRkRXZlbnQ7XG5cblx0XHQvLyBDb2xsZWN0IHBvdGVuc2lhbCBvdmVybGFwcGluZyBkYXRhIGxhYmVscy4gU3RhY2sgbGFiZWxzIHByb2JhYmx5IGRvbid0IG5lZWQgdG8gYmUgXG5cdFx0Ly8gY29uc2lkZXJlZCBiZWNhdXNlIHRoZXkgYXJlIHVzdWFsbHkgYWNjb21wYW5pZWQgYnkgZGF0YSBsYWJlbHMgdGhhdCBsaWUgaW5zaWRlIHRoZSBjb2x1bW5zLlxuXHRcdENoYXJ0LnByb3RvdHlwZS5jYWxsYmFja3MucHVzaChmdW5jdGlvbiAoY2hhcnQpIHtcblx0XHRcdGZ1bmN0aW9uIGNvbGxlY3RBbmRIaWRlKCkge1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gW107XG5cblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHR2YXIgZGxPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscztcblx0XHRcdFx0XHRpZiAoKGRsT3B0aW9ucy5lbmFibGVkIHx8IHNlcmllcy5faGFzUG9pbnRMYWJlbHMpICYmICFkbE9wdGlvbnMuYWxsb3dPdmVybGFwICYmIHNlcmllcy52aXNpYmxlKSB7IC8vICMzODY2XG5cdFx0XHRcdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkgeyBcblx0XHRcdFx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5sYWJlbHJhbmsgPSBwaWNrKHBvaW50LmxhYmVscmFuaywgcG9pbnQuc2hhcGVBcmdzICYmIHBvaW50LnNoYXBlQXJncy5oZWlnaHQpOyAvLyAjNDExOFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVscy5wdXNoKHBvaW50LmRhdGFMYWJlbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNoYXJ0LmhpZGVPdmVybGFwcGluZ0xhYmVscyhsYWJlbHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEbyBpdCBub3cgLi4uXG5cdFx0XHRjb2xsZWN0QW5kSGlkZSgpO1xuXG5cdFx0XHQvLyAuLi4gYW5kIGFmdGVyIGVhY2ggY2hhcnQgcmVkcmF3XG5cdFx0XHRhZGRFdmVudChjaGFydCwgJ3JlZHJhdycsIGNvbGxlY3RBbmRIaWRlKTtcblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlkZSBvdmVybGFwcGluZyBsYWJlbHMuIExhYmVscyBhcmUgbW92ZWQgYW5kIGZhZGVkIGluIGFuZCBvdXQgb24gem9vbSB0byBwcm92aWRlIGEgc21vb3RoIFxuXHRcdCAqIHZpc3VhbCBpbXJlc3Npb24uXG5cdFx0ICovXHRcdFxuXHRcdENoYXJ0LnByb3RvdHlwZS5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMgPSBmdW5jdGlvbiAobGFiZWxzKSB7XG5cblx0XHRcdHZhciBsZW4gPSBsYWJlbHMubGVuZ3RoLFxuXHRcdFx0XHRsYWJlbCxcblx0XHRcdFx0aSxcblx0XHRcdFx0aixcblx0XHRcdFx0bGFiZWwxLFxuXHRcdFx0XHRsYWJlbDIsXG5cdFx0XHRcdGlzSW50ZXJzZWN0aW5nLFxuXHRcdFx0XHRwb3MxLFxuXHRcdFx0XHRwb3MyLFxuXHRcdFx0XHRwYWRkaW5nLFxuXHRcdFx0XHRpbnRlcnNlY3RSZWN0ID0gZnVuY3Rpb24gKHgxLCB5MSwgdzEsIGgxLCB4MiwgeTIsIHcyLCBoMikge1xuXHRcdFx0XHRcdHJldHVybiAhKFxuXHRcdFx0XHRcdFx0eDIgPiB4MSArIHcxIHx8XG5cdFx0XHRcdFx0XHR4MiArIHcyIDwgeDEgfHxcblx0XHRcdFx0XHRcdHkyID4geTEgKyBoMSB8fFxuXHRcdFx0XHRcdFx0eTIgKyBoMiA8IHkxXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fTtcblx0XHRcblx0XHRcdC8vIE1hcmsgd2l0aCBpbml0aWFsIG9wYWNpdHlcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRsYWJlbCA9IGxhYmVsc1tpXTtcblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwub2xkT3BhY2l0eSA9IGxhYmVsLm9wYWNpdHk7XG5cdFx0XHRcdFx0bGFiZWwubmV3T3BhY2l0eSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJldmVudCBhIHNpdHVhdGlvbiBpbiBhIGdyYWR1YWxseSByaXNpbmcgc2xvcGUsIHRoYXQgZWFjaCBsYWJlbFxuXHRcdFx0Ly8gd2lsbCBoaWRlIHRoZSBwcmV2aW91cyBvbmUgYmVjYXVzZSB0aGUgcHJldmlvdXMgb25lIGFsd2F5cyBoYXNcblx0XHRcdC8vIGxvd2VyIHJhbmsuXG5cdFx0XHRsYWJlbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gKGIubGFiZWxyYW5rIHx8IDApIC0gKGEubGFiZWxyYW5rIHx8IDApO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIERldGVjdCBvdmVybGFwcGluZyBsYWJlbHNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRsYWJlbDEgPSBsYWJlbHNbaV07XG5cblx0XHRcdFx0Zm9yIChqID0gaSArIDE7IGogPCBsZW47ICsraikge1xuXHRcdFx0XHRcdGxhYmVsMiA9IGxhYmVsc1tqXTtcblx0XHRcdFx0XHRpZiAobGFiZWwxICYmIGxhYmVsMiAmJiBsYWJlbDEucGxhY2VkICYmIGxhYmVsMi5wbGFjZWQgJiYgbGFiZWwxLm5ld09wYWNpdHkgIT09IDAgJiYgbGFiZWwyLm5ld09wYWNpdHkgIT09IDApIHtcblx0XHRcdFx0XHRcdHBvczEgPSBsYWJlbDEuYWxpZ25BdHRyO1xuXHRcdFx0XHRcdFx0cG9zMiA9IGxhYmVsMi5hbGlnbkF0dHI7XG5cdFx0XHRcdFx0XHRwYWRkaW5nID0gMiAqIChsYWJlbDEuYm94ID8gMCA6IGxhYmVsMS5wYWRkaW5nKTsgLy8gU3Vic3RyYWN0IHRoZSBwYWRkaW5nIGlmIG5vIGJhY2tncm91bmQgb3IgYm9yZGVyICgjNDMzMylcblx0XHRcdFx0XHRcdGlzSW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0UmVjdChcblx0XHRcdFx0XHRcdFx0cG9zMS54LFxuXHRcdFx0XHRcdFx0XHRwb3MxLnksXG5cdFx0XHRcdFx0XHRcdGxhYmVsMS53aWR0aCAtIHBhZGRpbmcsXG5cdFx0XHRcdFx0XHRcdGxhYmVsMS5oZWlnaHQgLSBwYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHRwb3MyLngsXG5cdFx0XHRcdFx0XHRcdHBvczIueSxcblx0XHRcdFx0XHRcdFx0bGFiZWwyLndpZHRoIC0gcGFkZGluZyxcblx0XHRcdFx0XHRcdFx0bGFiZWwyLmhlaWdodCAtIHBhZGRpbmdcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmIChpc0ludGVyc2VjdGluZykge1xuXHRcdFx0XHRcdFx0XHQobGFiZWwxLmxhYmVscmFuayA8IGxhYmVsMi5sYWJlbHJhbmsgPyBsYWJlbDEgOiBsYWJlbDIpLm5ld09wYWNpdHkgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIaWRlIG9yIHNob3dcblx0XHRcdGVhY2gobGFiZWxzLCBmdW5jdGlvbiAobGFiZWwpIHtcblx0XHRcdFx0dmFyIGNvbXBsZXRlLFxuXHRcdFx0XHRcdG5ld09wYWNpdHk7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bmV3T3BhY2l0eSA9IGxhYmVsLm5ld09wYWNpdHk7XG5cblx0XHRcdFx0XHRpZiAobGFiZWwub2xkT3BhY2l0eSAhPT0gbmV3T3BhY2l0eSAmJiBsYWJlbC5wbGFjZWQpIHtcblxuXHRcdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBsYWJlbCBpcyBjb21wbGV0ZWx5IGhpZGRlbiB0byBhdm9pZCBjYXRjaGluZyBjbGlja3MgKCM0MzYyKVxuXHRcdFx0XHRcdFx0aWYgKG5ld09wYWNpdHkpIHtcblx0XHRcdFx0XHRcdFx0bGFiZWwuc2hvdyh0cnVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdGxhYmVsLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQW5pbWF0ZSBvciBzZXQgdGhlIG9wYWNpdHlcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRsYWJlbC5hbGlnbkF0dHIub3BhY2l0eSA9IG5ld09wYWNpdHk7XG5cdFx0XHRcdFx0XHRsYWJlbFtsYWJlbC5pc09sZCA/ICdhbmltYXRlJyA6ICdhdHRyJ10obGFiZWwuYWxpZ25BdHRyLCBudWxsLCBjb21wbGV0ZSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFiZWwuaXNPbGQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdH0oSGlnaGNoYXJ0cykpOy8qKlxuXHQgKiBUcmFja2VyTWl4aW4gZm9yIHBvaW50cyBhbmQgZ3JhcGhzXG5cdCAqL1xuXG5cdHZhciBUcmFja2VyTWl4aW4gPSBIaWdoY2hhcnRzLlRyYWNrZXJNaXhpbiA9IHtcblxuXHRcdGRyYXdUcmFja2VyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGN1cnNvciA9IHNlcmllcy5vcHRpb25zLmN1cnNvcixcblx0XHRcdFx0Y3NzID0gY3Vyc29yICYmIHsgY3Vyc29yOiBjdXJzb3IgfSxcblx0XHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdFx0XHRwb2ludDtcblxuXHRcdFx0XHRcdHdoaWxlICh0YXJnZXQgJiYgIXBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IHRhcmdldC5wb2ludDtcblx0XHRcdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChwb2ludCAhPT0gVU5ERUZJTkVEICYmIHBvaW50ICE9PSBjaGFydC5ob3ZlclBvaW50KSB7IC8vIHVuZGVmaW5lZCBvbiBncmFwaCBpbiBzY2F0dGVyY2hhcnRcblx0XHRcdFx0XHRcdHBvaW50Lm9uTW91c2VPdmVyKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gQWRkIHJlZmVyZW5jZSB0byB0aGUgcG9pbnRcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdGlmIChwb2ludC5ncmFwaGljKSB7XG5cdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYy5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycywgd2UgbmVlZCB0byBkbyB0aGlzIG9ubHkgb25jZVxuXHRcdFx0aWYgKCFzZXJpZXMuX2hhc1RyYWNraW5nKSB7XG5cdFx0XHRcdGVhY2goc2VyaWVzLnRyYWNrZXJHcm91cHMsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRpZiAoc2VyaWVzW2tleV0pIHsgLy8gd2UgZG9uJ3QgYWx3YXlzIGhhdmUgZGF0YUxhYmVsc0dyb3VwXG5cdFx0XHRcdFx0XHRzZXJpZXNba2V5XVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoUFJFRklYICsgJ3RyYWNrZXInKVxuXHRcdFx0XHRcdFx0XHQub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKVxuXHRcdFx0XHRcdFx0XHQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHsgcG9pbnRlci5vblRyYWNrZXJNb3VzZU91dChlKTsgfSlcblx0XHRcdFx0XHRcdFx0LmNzcyhjc3MpO1xuXHRcdFx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllc1trZXldLm9uKCd0b3VjaHN0YXJ0Jywgb25Nb3VzZU92ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNlcmllcy5faGFzVHJhY2tpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSB0cmFja2VyIG9iamVjdCB0aGF0IHNpdHMgYWJvdmUgYWxsIGRhdGEgbGFiZWxzIGFuZCBtYXJrZXJzIHRvXG5cdFx0ICogdHJhY2sgbW91c2UgZXZlbnRzIG9uIHRoZSBncmFwaCBvciBwb2ludHMuIEZvciB0aGUgbGluZSB0eXBlIGNoYXJ0c1xuXHRcdCAqIHRoZSB0cmFja2VyIHVzZXMgdGhlIHNhbWUgZ3JhcGhQYXRoLCBidXQgd2l0aCBhIGdyZWF0ZXIgc3Ryb2tlIHdpZHRoXG5cdFx0ICogZm9yIGJldHRlciBjb250cm9sLlxuXHRcdCAqL1xuXHRcdGRyYXdUcmFja2VyR3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHRyYWNrQnlBcmVhID0gb3B0aW9ucy50cmFja0J5QXJlYSxcblx0XHRcdFx0dHJhY2tlclBhdGggPSBbXS5jb25jYXQodHJhY2tCeUFyZWEgPyBzZXJpZXMuYXJlYVBhdGggOiBzZXJpZXMuZ3JhcGhQYXRoKSxcblx0XHRcdFx0dHJhY2tlclBhdGhMZW5ndGggPSB0cmFja2VyUGF0aC5sZW5ndGgsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRwb2ludGVyID0gY2hhcnQucG9pbnRlcixcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0c25hcCA9IGNoYXJ0Lm9wdGlvbnMudG9vbHRpcC5zbmFwLFxuXHRcdFx0XHR0cmFja2VyID0gc2VyaWVzLnRyYWNrZXIsXG5cdFx0XHRcdGN1cnNvciA9IG9wdGlvbnMuY3Vyc29yLFxuXHRcdFx0XHRjc3MgPSBjdXJzb3IgJiYgeyBjdXJzb3I6IGN1cnNvciB9LFxuXHRcdFx0XHRzaW5nbGVQb2ludHMgPSBzZXJpZXMuc2luZ2xlUG9pbnRzLFxuXHRcdFx0XHRzaW5nbGVQb2ludCxcblx0XHRcdFx0aSxcblx0XHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmhvdmVyU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdFx0XHRcdHNlcmllcy5vbk1vdXNlT3ZlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Lypcblx0XHRcdFx0ICogRW1waXJpY2FsIGxvd2VzdCBwb3NzaWJsZSBvcGFjaXRpZXMgZm9yIFRSQUNLRVJfRklMTCBmb3IgYW4gZWxlbWVudCB0byBzdGF5IGludmlzaWJsZSBidXQgY2xpY2thYmxlXG5cdFx0XHRcdCAqIElFNjogMC4wMDJcblx0XHRcdFx0ICogSUU3OiAwLjAwMlxuXHRcdFx0XHQgKiBJRTg6IDAuMDAyXG5cdFx0XHRcdCAqIElFOTogMC4wMDAwMDAwMDAwMSAodW5saW1pdGVkKVxuXHRcdFx0XHQgKiBJRTEwOiAwLjAwMDEgKGV4cG9ydGluZyBvbmx5KVxuXHRcdFx0XHQgKiBGRjogMC4wMDAwMDAwMDAwMSAodW5saW1pdGVkKVxuXHRcdFx0XHQgKiBDaHJvbWU6IDAuMDAwMDAxXG5cdFx0XHRcdCAqIFNhZmFyaTogMC4wMDAwMDFcblx0XHRcdFx0ICogT3BlcmE6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdFx0ICovXG5cdFx0XHRcdFRSQUNLRVJfRklMTCA9ICdyZ2JhKDE5MiwxOTIsMTkyLCcgKyAoaGFzU1ZHID8gMC4wMDAxIDogMC4wMDIpICsgJyknO1xuXG5cdFx0XHQvLyBFeHRlbmQgZW5kIHBvaW50cy4gQSBiZXR0ZXIgd2F5IHdvdWxkIGJlIHRvIHVzZSByb3VuZCBsaW5lY2Fwcyxcblx0XHRcdC8vIGJ1dCB0aG9zZSBhcmUgbm90IGNsaWNrYWJsZSBpbiBWTUwuXG5cdFx0XHRpZiAodHJhY2tlclBhdGhMZW5ndGggJiYgIXRyYWNrQnlBcmVhKSB7XG5cdFx0XHRcdGkgPSB0cmFja2VyUGF0aExlbmd0aCArIDE7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAodHJhY2tlclBhdGhbaV0gPT09IE0pIHsgLy8gZXh0ZW5kIGxlZnQgc2lkZVxuXHRcdFx0XHRcdFx0dHJhY2tlclBhdGguc3BsaWNlKGkgKyAxLCAwLCB0cmFja2VyUGF0aFtpICsgMV0gLSBzbmFwLCB0cmFja2VyUGF0aFtpICsgMl0sIEwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKGkgJiYgdHJhY2tlclBhdGhbaV0gPT09IE0pIHx8IGkgPT09IHRyYWNrZXJQYXRoTGVuZ3RoKSB7IC8vIGV4dGVuZCByaWdodCBzaWRlXG5cdFx0XHRcdFx0XHR0cmFja2VyUGF0aC5zcGxpY2UoaSwgMCwgTCwgdHJhY2tlclBhdGhbaSAtIDJdICsgc25hcCwgdHJhY2tlclBhdGhbaSAtIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaGFuZGxlIHNpbmdsZSBwb2ludHNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaW5nbGVQb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c2luZ2xlUG9pbnQgPSBzaW5nbGVQb2ludHNbaV07XG5cdFx0XHRcdHRyYWNrZXJQYXRoLnB1c2goTSwgc2luZ2xlUG9pbnQucGxvdFggLSBzbmFwLCBzaW5nbGVQb2ludC5wbG90WSxcblx0XHRcdFx0TCwgc2luZ2xlUG9pbnQucGxvdFggKyBzbmFwLCBzaW5nbGVQb2ludC5wbG90WSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRyYXcgdGhlIHRyYWNrZXJcblx0XHRcdGlmICh0cmFja2VyKSB7XG5cdFx0XHRcdHRyYWNrZXIuYXR0cih7IGQ6IHRyYWNrZXJQYXRoIH0pO1xuXHRcdFx0fSBlbHNlIHsgLy8gY3JlYXRlXG5cblx0XHRcdFx0c2VyaWVzLnRyYWNrZXIgPSByZW5kZXJlci5wYXRoKHRyYWNrZXJQYXRoKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0J3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsIC8vICMxMjI1XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogc2VyaWVzLnZpc2libGUgPyBWSVNJQkxFIDogSElEREVOLFxuXHRcdFx0XHRcdHN0cm9rZTogVFJBQ0tFUl9GSUxMLFxuXHRcdFx0XHRcdGZpbGw6IHRyYWNrQnlBcmVhID8gVFJBQ0tFUl9GSUxMIDogTk9ORSxcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJyA6IG9wdGlvbnMubGluZVdpZHRoICsgKHRyYWNrQnlBcmVhID8gMCA6IDIgKiBzbmFwKSxcblx0XHRcdFx0XHR6SW5kZXg6IDJcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApO1xuXG5cdFx0XHRcdC8vIFRoZSB0cmFja2VyIGlzIGFkZGVkIHRvIHRoZSBzZXJpZXMgZ3JvdXAsIHdoaWNoIGlzIGNsaXBwZWQsIGJ1dCBpcyBjb3ZlcmVkXG5cdFx0XHRcdC8vIGJ5IHRoZSBtYXJrZXIgZ3JvdXAuIFNvIHRoZSBtYXJrZXIgZ3JvdXAgYWxzbyBuZWVkcyB0byBjYXB0dXJlIGV2ZW50cy5cblx0XHRcdFx0ZWFjaChbc2VyaWVzLnRyYWNrZXIsIHNlcmllcy5tYXJrZXJHcm91cF0sIGZ1bmN0aW9uICh0cmFja2VyKSB7XG5cdFx0XHRcdFx0dHJhY2tlci5hZGRDbGFzcyhQUkVGSVggKyAndHJhY2tlcicpXG5cdFx0XHRcdFx0XHQub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKVxuXHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7IHBvaW50ZXIub25UcmFja2VyTW91c2VPdXQoZSk7IH0pXG5cdFx0XHRcdFx0XHQuY3NzKGNzcyk7XG5cblx0XHRcdFx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdFx0XHRcdHRyYWNrZXIub24oJ3RvdWNoc3RhcnQnLCBvbk1vdXNlT3Zlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdC8qIEVuZCBUcmFja2VyTWl4aW4gKi9cblxuXG5cdC8qKlxuXHQgKiBBZGQgdHJhY2tpbmcgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHNlcmllcyBncm91cCwgc28gdGhlIHBvaW50IGdyYXBoaWNzXG5cdCAqIHRoZW1zZWx2ZXMgYWN0IGFzIHRyYWNrZXJzXG5cdCAqLyBcblxuXHRpZiAoc2VyaWVzVHlwZXMuY29sdW1uKSB7XG5cdFx0Q29sdW1uU2VyaWVzLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1x0XG5cdH1cblxuXHRpZiAoc2VyaWVzVHlwZXMucGllKSB7XG5cdFx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1xuXHR9XG5cblx0aWYgKHNlcmllc1R5cGVzLnNjYXR0ZXIpIHtcblx0XHRTY2F0dGVyU2VyaWVzLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1xuXHR9XG5cblx0LyogXG5cdCAqIEV4dGVuZCBMZWdlbmQgZm9yIGl0ZW0gZXZlbnRzIFxuXHQgKi8gXG5cdGV4dGVuZChMZWdlbmQucHJvdG90eXBlLCB7XG5cblx0XHRzZXRJdGVtRXZlbnRzOiBmdW5jdGlvbiAoaXRlbSwgbGVnZW5kSXRlbSwgdXNlSFRNTCwgaXRlbVN0eWxlLCBpdGVtSGlkZGVuU3R5bGUpIHtcblx0XHR2YXIgbGVnZW5kID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIGV2ZW50cyBvbiB0aGUgaXRlbSBncm91cCwgb3IgaW4gY2FzZSBvZiB1c2VIVE1MLCB0aGUgaXRlbSBpdHNlbGYgKCMxMjQ5KVxuXHRcdCh1c2VIVE1MID8gbGVnZW5kSXRlbSA6IGl0ZW0ubGVnZW5kR3JvdXApLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGl0ZW0uc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdFx0XHRsZWdlbmRJdGVtLmNzcyhsZWdlbmQub3B0aW9ucy5pdGVtSG92ZXJTdHlsZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bGVnZW5kSXRlbS5jc3MoaXRlbS52aXNpYmxlID8gaXRlbVN0eWxlIDogaXRlbUhpZGRlblN0eWxlKTtcblx0XHRcdFx0aXRlbS5zZXRTdGF0ZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0dmFyIHN0ckxlZ2VuZEl0ZW1DbGljayA9ICdsZWdlbmRJdGVtQ2xpY2snLFxuXHRcdFx0XHRcdGZuTGVnZW5kSXRlbUNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRWaXNpYmxlKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gUGFzcyBvdmVyIHRoZSBjbGljay90b3VjaCBldmVudC4gIzQuXG5cdFx0XHRcdGV2ZW50ID0ge1xuXHRcdFx0XHRcdGJyb3dzZXJFdmVudDogZXZlbnRcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBjbGljayB0aGUgbmFtZSBvciBzeW1ib2xcblx0XHRcdFx0aWYgKGl0ZW0uZmlyZVBvaW50RXZlbnQpIHsgLy8gcG9pbnRcblx0XHRcdFx0XHRpdGVtLmZpcmVQb2ludEV2ZW50KHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoaXRlbSwgc3RyTGVnZW5kSXRlbUNsaWNrLCBldmVudCwgZm5MZWdlbmRJdGVtQ2xpY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlQ2hlY2tib3hGb3JJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cblx0XHRcdGl0ZW0uY2hlY2tib3ggPSBjcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcblx0XHRcdFx0dHlwZTogJ2NoZWNrYm94Jyxcblx0XHRcdFx0Y2hlY2tlZDogaXRlbS5zZWxlY3RlZCxcblx0XHRcdFx0ZGVmYXVsdENoZWNrZWQ6IGl0ZW0uc2VsZWN0ZWQgLy8gcmVxdWlyZWQgYnkgSUU3XG5cdFx0XHR9LCBsZWdlbmQub3B0aW9ucy5pdGVtQ2hlY2tib3hTdHlsZSwgbGVnZW5kLmNoYXJ0LmNvbnRhaW5lcik7XG5cblx0XHRcdGFkZEV2ZW50KGl0ZW0uY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRmaXJlRXZlbnQoaXRlbS5zZXJpZXMgfHwgaXRlbSwgJ2NoZWNrYm94Q2xpY2snLCB7IC8vICMzNzEyXG5cdFx0XHRcdFx0XHRjaGVja2VkOiB0YXJnZXQuY2hlY2tlZCxcblx0XHRcdFx0XHRcdGl0ZW06IGl0ZW1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGl0ZW0uc2VsZWN0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fVx0XG5cdH0pO1xuXG5cdC8qIFxuXHQgKiBBZGQgcG9pbnRlciBjdXJzb3IgdG8gbGVnZW5kIGl0ZW1zdHlsZSBpbiBkZWZhdWx0T3B0aW9uc1xuXHQgKi9cblx0ZGVmYXVsdE9wdGlvbnMubGVnZW5kLml0ZW1TdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG5cblxuXHQvKiBcblx0ICogRXh0ZW5kIHRoZSBDaGFydCBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuXHQgKi9cblxuXHRleHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogRGlzcGxheSB0aGUgem9vbSBidXR0b25cblx0XHQgKi9cblx0XHRzaG93UmVzZXRab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdFx0YnRuT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLFxuXHRcdFx0XHR0aGVtZSA9IGJ0bk9wdGlvbnMudGhlbWUsXG5cdFx0XHRcdHN0YXRlcyA9IHRoZW1lLnN0YXRlcyxcblx0XHRcdFx0YWxpZ25UbyA9IGJ0bk9wdGlvbnMucmVsYXRpdmVUbyA9PT0gJ2NoYXJ0JyA/IG51bGwgOiAncGxvdEJveCc7XG5cdFx0XHRcdFxuXHRcdFx0dGhpcy5yZXNldFpvb21CdXR0b24gPSBjaGFydC5yZW5kZXJlci5idXR0b24obGFuZy5yZXNldFpvb20sIG51bGwsIG51bGwsIGZ1bmN0aW9uICgpIHsgY2hhcnQuem9vbU91dCgpOyB9LCB0aGVtZSwgc3RhdGVzICYmIHN0YXRlcy5ob3Zlcilcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBidG5PcHRpb25zLnBvc2l0aW9uLmFsaWduLFxuXHRcdFx0XHRcdHRpdGxlOiBsYW5nLnJlc2V0Wm9vbVRpdGxlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHQuYWxpZ24oYnRuT3B0aW9ucy5wb3NpdGlvbiwgZmFsc2UsIGFsaWduVG8pO1xuXHRcdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogWm9vbSBvdXQgdG8gMToxXG5cdFx0ICovXG5cdFx0em9vbU91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcztcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3NlbGVjdGlvbicsIHsgcmVzZXRTZWxlY3Rpb246IHRydWUgfSwgZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0Y2hhcnQuem9vbSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFpvb20gaW50byBhIGdpdmVuIHBvcnRpb24gb2YgdGhlIGNoYXJ0IGdpdmVuIGJ5IGF4aXMgY29vcmRpbmF0ZXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQgKi9cblx0XHR6b29tOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGhhc1pvb21lZCxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGRpc3BsYXlCdXR0b24gPSBmYWxzZSxcblx0XHRcdFx0cmVzZXRab29tQnV0dG9uO1xuXG5cdFx0XHQvLyBJZiB6b29tIGlzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVzZXQgdGhlIGF4ZXNcblx0XHRcdGlmICghZXZlbnQgfHwgZXZlbnQucmVzZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7IC8vIGVsc2UsIHpvb20gaW4gb24gYWxsIGF4ZXNcblx0XHRcdFx0ZWFjaChldmVudC54QXhpcy5jb25jYXQoZXZlbnQueUF4aXMpLCBmdW5jdGlvbiAoYXhpc0RhdGEpIHtcblx0XHRcdFx0XHR2YXIgYXhpcyA9IGF4aXNEYXRhLmF4aXMsXG5cdFx0XHRcdFx0XHRpc1hBeGlzID0gYXhpcy5pc1hBeGlzO1xuXG5cdFx0XHRcdFx0Ly8gZG9uJ3Qgem9vbSBtb3JlIHRoYW4gbWluUmFuZ2Vcblx0XHRcdFx0XHRpZiAocG9pbnRlcltpc1hBeGlzID8gJ3pvb21YJyA6ICd6b29tWSddIHx8IHBvaW50ZXJbaXNYQXhpcyA/ICdwaW5jaFgnIDogJ3BpbmNoWSddKSB7XG5cdFx0XHRcdFx0XHRoYXNab29tZWQgPSBheGlzLnpvb20oYXhpc0RhdGEubWluLCBheGlzRGF0YS5tYXgpO1xuXHRcdFx0XHRcdFx0aWYgKGF4aXMuZGlzcGxheUJ0bikge1xuXHRcdFx0XHRcdFx0XHRkaXNwbGF5QnV0dG9uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTaG93IG9yIGhpZGUgdGhlIFJlc2V0IHpvb20gYnV0dG9uXG5cdFx0XHRyZXNldFpvb21CdXR0b24gPSBjaGFydC5yZXNldFpvb21CdXR0b247XG5cdFx0XHRpZiAoZGlzcGxheUJ1dHRvbiAmJiAhcmVzZXRab29tQnV0dG9uKSB7XG5cdFx0XHRcdGNoYXJ0LnNob3dSZXNldFpvb20oKTtcblx0XHRcdH0gZWxzZSBpZiAoIWRpc3BsYXlCdXR0b24gJiYgaXNPYmplY3QocmVzZXRab29tQnV0dG9uKSkge1xuXHRcdFx0XHRjaGFydC5yZXNldFpvb21CdXR0b24gPSByZXNldFpvb21CdXR0b24uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdC8vIFJlZHJhd1xuXHRcdFx0aWYgKGhhc1pvb21lZCkge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoXG5cdFx0XHRcdFx0cGljayhjaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgZXZlbnQgJiYgZXZlbnQuYW5pbWF0aW9uLCBjaGFydC5wb2ludENvdW50IDwgMTAwKSAvLyBhbmltYXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGFuIHRoZSBjaGFydCBieSBkcmFnZ2luZyB0aGUgbW91c2UgYWNyb3NzIHRoZSBwYW5lLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuXHRcdCAqIG9uIG1vdXNlIG1vdmUsIGFuZCB0aGUgZGlzdGFuY2UgdG8gcGFuIGlzIGNvbXB1dGVkIGZyb20gY2hhcnRYIGNvbXBhcmVkIHRvXG5cdFx0ICogdGhlIGZpcnN0IGNoYXJ0WCBwb3NpdGlvbiBpbiB0aGUgZHJhZ2dpbmcgb3BlcmF0aW9uLlxuXHRcdCAqL1xuXHRcdHBhbjogZnVuY3Rpb24gKGUsIHBhbm5pbmcpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cyxcblx0XHRcdFx0ZG9SZWRyYXc7XG5cblx0XHRcdC8vIHJlbW92ZSBhY3RpdmUgcG9pbnRzIGZvciBzaGFyZWQgdG9vbHRpcFxuXHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlYWNoKHBhbm5pbmcgPT09ICd4eScgPyBbMSwgMF0gOiBbMV0sIGZ1bmN0aW9uIChpc1gpIHsgLy8geHkgaXMgdXNlZCBpbiBtYXBzXG5cdFx0XHRcdHZhciBtb3VzZVBvcyA9IGVbaXNYID8gJ2NoYXJ0WCcgOiAnY2hhcnRZJ10sXG5cdFx0XHRcdFx0YXhpcyA9IGNoYXJ0W2lzWCA/ICd4QXhpcycgOiAneUF4aXMnXVswXSxcblx0XHRcdFx0XHRzdGFydFBvcyA9IGNoYXJ0W2lzWCA/ICdtb3VzZURvd25YJyA6ICdtb3VzZURvd25ZJ10sXG5cdFx0XHRcdFx0aGFsZlBvaW50UmFuZ2UgPSAoYXhpcy5wb2ludFJhbmdlIHx8IDApIC8gMixcblx0XHRcdFx0XHRleHRyZW1lcyA9IGF4aXMuZ2V0RXh0cmVtZXMoKSxcblx0XHRcdFx0XHRuZXdNaW4gPSBheGlzLnRvVmFsdWUoc3RhcnRQb3MgLSBtb3VzZVBvcywgdHJ1ZSkgKyBoYWxmUG9pbnRSYW5nZSxcblx0XHRcdFx0XHRuZXdNYXggPSBheGlzLnRvVmFsdWUoc3RhcnRQb3MgKyBjaGFydFtpc1ggPyAncGxvdFdpZHRoJyA6ICdwbG90SGVpZ2h0J10gLSBtb3VzZVBvcywgdHJ1ZSkgLSBoYWxmUG9pbnRSYW5nZSxcblx0XHRcdFx0XHRnb2luZ0xlZnQgPSBzdGFydFBvcyA+IG1vdXNlUG9zOyAvLyAjMzYxM1xuXG5cdFx0XHRcdGlmIChheGlzLnNlcmllcy5sZW5ndGggJiYgXG5cdFx0XHRcdFx0XHQoZ29pbmdMZWZ0IHx8IG5ld01pbiA+IG1hdGhNaW4oZXh0cmVtZXMuZGF0YU1pbiwgZXh0cmVtZXMubWluKSkgJiYgXG5cdFx0XHRcdFx0XHQoIWdvaW5nTGVmdCB8fCBuZXdNYXggPCBtYXRoTWF4KGV4dHJlbWVzLmRhdGFNYXgsIGV4dHJlbWVzLm1heCkpKSB7XG5cdFx0XHRcdFx0YXhpcy5zZXRFeHRyZW1lcyhuZXdNaW4sIG5ld01heCwgZmFsc2UsIGZhbHNlLCB7IHRyaWdnZXI6ICdwYW4nIH0pO1xuXHRcdFx0XHRcdGRvUmVkcmF3ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNoYXJ0W2lzWCA/ICdtb3VzZURvd25YJyA6ICdtb3VzZURvd25ZJ10gPSBtb3VzZVBvczsgLy8gc2V0IG5ldyByZWZlcmVuY2UgZm9yIG5leHQgcnVuXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGRvUmVkcmF3KSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7IGN1cnNvcjogJ21vdmUnIH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0ICogRXh0ZW5kIHRoZSBQb2ludCBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuXHQgKi9cblx0ZXh0ZW5kKFBvaW50LnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZSB0aGUgc2VsZWN0aW9uIHN0YXR1cyBvZiBhIHBvaW50XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzZWxlY3RlZCBXaGV0aGVyIHRvIHNlbGVjdCBvciB1bnNlbGVjdCB0aGUgcG9pbnQuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBhY2N1bXVsYXRlIFdoZXRoZXIgdG8gYWRkIHRvIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsXG5cdFx0ICpcdFx0IHRoaXMgaGFwcGVucyBpZiB0aGUgY29udHJvbCBrZXkgKENtZCBvbiBNYWMpIHdhcyBwcmVzc2VkIGR1cmluZyBjbGlja2luZy5cblx0XHQgKi9cblx0XHRzZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZCwgYWNjdW11bGF0ZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdFx0c2VsZWN0ZWQgPSBwaWNrKHNlbGVjdGVkLCAhcG9pbnQuc2VsZWN0ZWQpO1xuXG5cdFx0XHQvLyBmaXJlIHRoZSBldmVudCB3aXRoIHRoZSBkZWZhbHV0IGhhbmRsZXJcblx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KHNlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5zZWxlY3QnLCB7IGFjY3VtdWxhdGU6IGFjY3VtdWxhdGUgfSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwb2ludC5zZWxlY3RlZCA9IHBvaW50Lm9wdGlvbnMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KHBvaW50LCBzZXJpZXMuZGF0YSldID0gcG9pbnQub3B0aW9ucztcblxuXHRcdFx0XHRwb2ludC5zZXRTdGF0ZShzZWxlY3RlZCAmJiBTRUxFQ1RfU1RBVEUpO1xuXG5cdFx0XHRcdC8vIHVuc2VsZWN0IGFsbCBvdGhlciBwb2ludHMgdW5sZXNzIEN0cmwgb3IgQ21kICsgY2xpY2tcblx0XHRcdFx0aWYgKCFhY2N1bXVsYXRlKSB7XG5cdFx0XHRcdFx0ZWFjaChjaGFydC5nZXRTZWxlY3RlZFBvaW50cygpLCBmdW5jdGlvbiAobG9vcFBvaW50KSB7XG5cdFx0XHRcdFx0XHRpZiAobG9vcFBvaW50LnNlbGVjdGVkICYmIGxvb3BQb2ludCAhPT0gcG9pbnQpIHtcblx0XHRcdFx0XHRcdFx0bG9vcFBvaW50LnNlbGVjdGVkID0gbG9vcFBvaW50Lm9wdGlvbnMuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KGxvb3BQb2ludCwgc2VyaWVzLmRhdGEpXSA9IGxvb3BQb2ludC5vcHRpb25zO1xuXHRcdFx0XHRcdFx0XHRsb29wUG9pbnQuc2V0U3RhdGUoTk9STUFMX1NUQVRFKTtcblx0XHRcdFx0XHRcdFx0XHRsb29wUG9pbnQuZmlyZVBvaW50RXZlbnQoJ3Vuc2VsZWN0Jyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW5zIG9uIG1vdXNlIG92ZXIgdGhlIHBvaW50XG5cdFx0ICovXG5cdFx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQ7XG5cblx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdHNlcmllcy5vbk1vdXNlT3ZlcigpO1xuXHRcdFx0fVx0XHRcblxuXHRcdFx0Ly8gc2V0IG5vcm1hbCBzdGF0ZSB0byBwcmV2aW91cyBzZXJpZXNcblx0XHRcdGlmIChob3ZlclBvaW50ICYmIGhvdmVyUG9pbnQgIT09IHBvaW50KSB7XG5cdFx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocG9pbnQuc2VyaWVzKSB7IC8vIEl0IG1heSBoYXZlIGJlZW4gZGVzdHJveWVkLCAjNDEzMFxuXG5cdFx0XHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50XG5cdFx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KCdtb3VzZU92ZXInKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIHRvb2x0aXBcblx0XHRcdFx0aWYgKHRvb2x0aXAgJiYgKCF0b29sdGlwLnNoYXJlZCB8fCBzZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0XHRcdHRvb2x0aXAucmVmcmVzaChwb2ludCwgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBob3ZlciB0aGlzXG5cdFx0XHRcdHBvaW50LnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW5zIG9uIG1vdXNlIG91dCBmcm9tIHRoZSBwb2ludFxuXHRcdCAqL1xuXHRcdG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzO1xuXG5cdFx0XHR0aGlzLmZpcmVQb2ludEV2ZW50KCdtb3VzZU91dCcpO1xuXG5cdFx0XHRpZiAoIWhvdmVyUG9pbnRzIHx8IGluQXJyYXkodGhpcywgaG92ZXJQb2ludHMpID09PSAtMSkgeyAvLyAjODg3LCAjMjI0MFxuXHRcdFx0XHR0aGlzLnNldFN0YXRlKCk7XG5cdFx0XHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbXBvcnQgZXZlbnRzIGZyb20gdGhlIHNlcmllcycgYW5kIHBvaW50J3Mgb3B0aW9ucy4gT25seSBkbyBpdCBvblxuXHRcdCAqIGRlbWFuZCwgdG8gc2F2ZSBwcm9jZXNzaW5nIHRpbWUgb24gaG92ZXJpbmcuXG5cdFx0ICovXG5cdFx0aW1wb3J0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzSW1wb3J0ZWRFdmVudHMpIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0XHRvcHRpb25zID0gbWVyZ2UocG9pbnQuc2VyaWVzLm9wdGlvbnMucG9pbnQsIHBvaW50Lm9wdGlvbnMpLFxuXHRcdFx0XHRcdGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzLFxuXHRcdFx0XHRcdGV2ZW50VHlwZTtcblxuXHRcdFx0XHRwb2ludC5ldmVudHMgPSBldmVudHM7XG5cblx0XHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQocG9pbnQsIGV2ZW50VHlwZSwgZXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGFzSW1wb3J0ZWRFdmVudHMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcG9pbnQncyBzdGF0ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZVxuXHRcdCAqL1xuXHRcdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUsIG1vdmUpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0c3RhdGVPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuc3RhdGVzLFxuXHRcdFx0XHRtYXJrZXJPcHRpb25zID0gZGVmYXVsdFBsb3RPcHRpb25zW3Nlcmllcy50eXBlXS5tYXJrZXIgJiYgc2VyaWVzLm9wdGlvbnMubWFya2VyLFxuXHRcdFx0XHRub3JtYWxEaXNhYmxlZCA9IG1hcmtlck9wdGlvbnMgJiYgIW1hcmtlck9wdGlvbnMuZW5hYmxlZCxcblx0XHRcdFx0bWFya2VyU3RhdGVPcHRpb25zID0gbWFya2VyT3B0aW9ucyAmJiBtYXJrZXJPcHRpb25zLnN0YXRlc1tzdGF0ZV0sXG5cdFx0XHRcdHN0YXRlRGlzYWJsZWQgPSBtYXJrZXJTdGF0ZU9wdGlvbnMgJiYgbWFya2VyU3RhdGVPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlLFxuXHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMgPSBzZXJpZXMuc3RhdGVNYXJrZXJHcmFwaGljLFxuXHRcdFx0XHRwb2ludE1hcmtlciA9IHBvaW50Lm1hcmtlciB8fCB7fSxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHJhZGl1cyxcblx0XHRcdFx0aGFsbyA9IHNlcmllcy5oYWxvLFxuXHRcdFx0XHRoYWxvT3B0aW9ucyxcblx0XHRcdFx0bmV3U3ltYm9sLFxuXHRcdFx0XHRwb2ludEF0dHI7XG5cblx0XHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFOyAvLyBlbXB0eSBzdHJpbmdcblx0XHRcdHBvaW50QXR0ciA9IHBvaW50LnBvaW50QXR0cltzdGF0ZV0gfHwgc2VyaWVzLnBvaW50QXR0cltzdGF0ZV07XG5cblx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBhbHJlYWR5IGhhcyB0aGlzIHN0YXRlXG5cdFx0XHRcdFx0KHN0YXRlID09PSBwb2ludC5zdGF0ZSAmJiAhbW92ZSkgfHxcblx0XHRcdFx0XHQvLyBzZWxlY3RlZCBwb2ludHMgZG9uJ3QgcmVzcG9uZCB0byBob3ZlclxuXHRcdFx0XHRcdChwb2ludC5zZWxlY3RlZCAmJiBzdGF0ZSAhPT0gU0VMRUNUX1NUQVRFKSB8fFxuXHRcdFx0XHRcdC8vIHNlcmllcycgc3RhdGUgb3B0aW9ucyBpcyBkaXNhYmxlZFxuXHRcdFx0XHRcdChzdGF0ZU9wdGlvbnNbc3RhdGVdICYmIHN0YXRlT3B0aW9uc1tzdGF0ZV0uZW5hYmxlZCA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0Ly8gZ2VuZXJhbCBwb2ludCBtYXJrZXIncyBzdGF0ZSBvcHRpb25zIGlzIGRpc2FibGVkXG5cdFx0XHRcdFx0KHN0YXRlICYmIChzdGF0ZURpc2FibGVkIHx8IChub3JtYWxEaXNhYmxlZCAmJiBtYXJrZXJTdGF0ZU9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpKSkgfHxcblx0XHRcdFx0XHQvLyBpbmRpdmlkdWFsIHBvaW50IG1hcmtlcidzIHN0YXRlIG9wdGlvbnMgaXMgZGlzYWJsZWRcblx0XHRcdFx0XHQoc3RhdGUgJiYgcG9pbnRNYXJrZXIuc3RhdGVzICYmIHBvaW50TWFya2VyLnN0YXRlc1tzdGF0ZV0gJiYgcG9pbnRNYXJrZXIuc3RhdGVzW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkgLy8gIzE2MTBcblxuXHRcdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSBob3ZlciBzdHlsZXMgdG8gdGhlIGV4aXN0aW5nIHBvaW50XG5cdFx0XHRpZiAocG9pbnQuZ3JhcGhpYykge1xuXHRcdFx0XHRyYWRpdXMgPSBtYXJrZXJPcHRpb25zICYmIHBvaW50LmdyYXBoaWMuc3ltYm9sTmFtZSAmJiBwb2ludEF0dHIucjtcblx0XHRcdFx0cG9pbnQuZ3JhcGhpYy5hdHRyKG1lcmdlKFxuXHRcdFx0XHRcdHBvaW50QXR0cixcblx0XHRcdFx0XHRyYWRpdXMgPyB7IC8vIG5ldyBzeW1ib2wgYXR0cmlidXRlcyAoIzUwNywgIzYxMilcblx0XHRcdFx0XHRcdHg6IHBsb3RYIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0eTogcGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdGhlaWdodDogMiAqIHJhZGl1c1xuXHRcdFx0XHRcdH0gOiB7fVxuXHRcdFx0XHQpKTtcblxuXHRcdFx0XHQvLyBab29taW5nIGluIGZyb20gYSByYW5nZSB3aXRoIG5vIG1hcmtlcnMgdG8gYSByYW5nZSB3aXRoIG1hcmtlcnNcblx0XHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYykge1xuXHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIGEgZ3JhcGhpYyBpcyBub3QgYXBwbGllZCB0byBlYWNoIHBvaW50IGluIHRoZSBub3JtYWwgc3RhdGUsIGNyZWF0ZSBhIHNoYXJlZFxuXHRcdFx0XHQvLyBncmFwaGljIGZvciB0aGUgaG92ZXIgc3RhdGVcblx0XHRcdFx0aWYgKHN0YXRlICYmIG1hcmtlclN0YXRlT3B0aW9ucykge1xuXHRcdFx0XHRcdHJhZGl1cyA9IG1hcmtlclN0YXRlT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHRcdFx0bmV3U3ltYm9sID0gcG9pbnRNYXJrZXIuc3ltYm9sIHx8IHNlcmllcy5zeW1ib2w7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcG9pbnQgaGFzIGFub3RoZXIgc3ltYm9sIHRoYW4gdGhlIHByZXZpb3VzIG9uZSwgdGhyb3cgYXdheSB0aGVcblx0XHRcdFx0XHQvLyBzdGF0ZSBtYXJrZXIgZ3JhcGhpYyBhbmQgZm9yY2UgYSBuZXcgb25lICgjMTQ1OSlcblx0XHRcdFx0XHRpZiAoc3RhdGVNYXJrZXJHcmFwaGljICYmIHN0YXRlTWFya2VyR3JhcGhpYy5jdXJyZW50U3ltYm9sICE9PSBuZXdTeW1ib2wpIHtcblx0XHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYyA9IHN0YXRlTWFya2VyR3JhcGhpYy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWRkIGEgbmV3IHN0YXRlIG1hcmtlciBncmFwaGljXG5cdFx0XHRcdFx0aWYgKCFzdGF0ZU1hcmtlckdyYXBoaWMpIHtcblx0XHRcdFx0XHRcdGlmIChuZXdTeW1ib2wpIHtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnN0YXRlTWFya2VyR3JhcGhpYyA9IHN0YXRlTWFya2VyR3JhcGhpYyA9IGNoYXJ0LnJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHRcdFx0XHRuZXdTeW1ib2wsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHQyICogcmFkaXVzXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0LmF0dHIocG9pbnRBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5tYXJrZXJHcm91cCk7XG5cdFx0XHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5jdXJyZW50U3ltYm9sID0gbmV3U3ltYm9sO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0aGUgZXhpc3RpbmcgZ3JhcGhpY1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbbW92ZSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oeyAvLyAjMTA1NFxuXHRcdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0eTogcGxvdFkgLSByYWRpdXNcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGF0ZU1hcmtlckdyYXBoaWMpIHtcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbc3RhdGUgJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBwbG90WSwgY2hhcnQuaW52ZXJ0ZWQpID8gJ3Nob3cnIDogJ2hpZGUnXSgpOyAvLyAjMjQ1MFxuXHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5lbGVtZW50LnBvaW50ID0gcG9pbnQ7IC8vICM0MzEwXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBtZSB5b3VyIGhhbG9cblx0XHRcdGhhbG9PcHRpb25zID0gc3RhdGVPcHRpb25zW3N0YXRlXSAmJiBzdGF0ZU9wdGlvbnNbc3RhdGVdLmhhbG87XG5cdFx0XHRpZiAoaGFsb09wdGlvbnMgJiYgaGFsb09wdGlvbnMuc2l6ZSkge1xuXHRcdFx0XHRpZiAoIWhhbG8pIHtcblx0XHRcdFx0XHRzZXJpZXMuaGFsbyA9IGhhbG8gPSBjaGFydC5yZW5kZXJlci5wYXRoKClcblx0XHRcdFx0XHRcdC5hZGQoY2hhcnQuc2VyaWVzR3JvdXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhbG8uYXR0cihleHRlbmQoe1xuXHRcdFx0XHRcdGZpbGw6IENvbG9yKHBvaW50LmNvbG9yIHx8IHNlcmllcy5jb2xvcikuc2V0T3BhY2l0eShoYWxvT3B0aW9ucy5vcGFjaXR5KS5nZXQoKVxuXHRcdFx0XHR9LCBoYWxvT3B0aW9ucy5hdHRyaWJ1dGVzKSlbbW92ZSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oe1xuXHRcdFx0XHRcdGQ6IHBvaW50LmhhbG9QYXRoKGhhbG9PcHRpb25zLnNpemUpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChoYWxvKSB7XG5cdFx0XHRcdGhhbG8uYXR0cih7IGQ6IFtdIH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludC5zdGF0ZSA9IHN0YXRlO1xuXHRcdH0sXG5cblx0XHRoYWxvUGF0aDogZnVuY3Rpb24gKHNpemUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHBsb3RCb3ggPSBzZXJpZXMuZ2V0UGxvdEJveCgpLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkO1xuXG5cdFx0XHRyZXR1cm4gY2hhcnQucmVuZGVyZXIuc3ltYm9scy5jaXJjbGUoXG5cdFx0XHRcdHBsb3RCb3gudHJhbnNsYXRlWCArIChpbnZlcnRlZCA/IHNlcmllcy55QXhpcy5sZW4gLSB0aGlzLnBsb3RZIDogdGhpcy5wbG90WCkgLSBzaXplLCBcblx0XHRcdFx0cGxvdEJveC50cmFuc2xhdGVZICsgKGludmVydGVkID8gc2VyaWVzLnhBeGlzLmxlbiAtIHRoaXMucGxvdFggOiB0aGlzLnBsb3RZKSAtIHNpemUsIFxuXHRcdFx0XHRzaXplICogMiwgXG5cdFx0XHRcdHNpemUgKiAyXG5cdFx0XHQpO1xuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0ICogRXh0ZW5kIHRoZSBTZXJpZXMgb2JqZWN0IHdpdGggaW50ZXJhY3Rpb25cblx0ICovXG5cblx0ZXh0ZW5kKFNlcmllcy5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBTZXJpZXMgbW91c2Ugb3ZlciBoYW5kbGVyXG5cdFx0ICovXG5cdFx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0aG92ZXJTZXJpZXMgPSBjaGFydC5ob3ZlclNlcmllcztcblxuXHRcdFx0Ly8gc2V0IG5vcm1hbCBzdGF0ZSB0byBwcmV2aW91cyBzZXJpZXNcblx0XHRcdGlmIChob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdGhvdmVyU2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJpZ2dlciB0aGUgZXZlbnQsIGJ1dCB0byBzYXZlIHByb2Nlc3NpbmcgdGltZSxcblx0XHRcdC8vIG9ubHkgaWYgZGVmaW5lZFxuXHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLmV2ZW50cy5tb3VzZU92ZXIpIHtcblx0XHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ21vdXNlT3ZlcicpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBob3ZlciB0aGlzXG5cdFx0XHRzZXJpZXMuc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdFx0Y2hhcnQuaG92ZXJTZXJpZXMgPSBzZXJpZXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNlcmllcyBtb3VzZSBvdXQgaGFuZGxlclxuXHRcdCAqL1xuXHRcdG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50IG9ubHkgaWYgbGlzdGVuZXJzIGV4aXN0XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50O1xuXG5cdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IG51bGw7IC8vICMxODIsIHNldCB0byBudWxsIGJlZm9yZSB0aGUgbW91c2VPdXQgZXZlbnQgZmlyZXNcblxuXHRcdFx0Ly8gdHJpZ2dlciBtb3VzZSBvdXQgb24gdGhlIHBvaW50LCB3aGljaCBtdXN0IGJlIGluIHRoaXMgc2VyaWVzXG5cdFx0XHRpZiAoaG92ZXJQb2ludCkge1xuXHRcdFx0XHRob3ZlclBvaW50Lm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyZSB0aGUgbW91c2Ugb3V0IGV2ZW50XG5cdFx0XHRpZiAoc2VyaWVzICYmIG9wdGlvbnMuZXZlbnRzLm1vdXNlT3V0KSB7XG5cdFx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdtb3VzZU91dCcpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIGhpZGUgdGhlIHRvb2x0aXBcblx0XHRcdGlmICh0b29sdGlwICYmICFvcHRpb25zLnN0aWNreVRyYWNraW5nICYmICghdG9vbHRpcC5zaGFyZWQgfHwgc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdFx0dG9vbHRpcC5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBub3JtYWwgc3RhdGVcblx0XHRcdHNlcmllcy5zZXRTdGF0ZSgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBncmFwaFxuXHRcdCAqL1xuXHRcdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBvcHRpb25zLnN0YXRlcyxcblx0XHRcdFx0bGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGgsXG5cdFx0XHRcdGF0dHJpYnMsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRzdGF0ZSA9IHN0YXRlIHx8IE5PUk1BTF9TVEFURTtcblxuXHRcdFx0aWYgKHNlcmllcy5zdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdFx0c2VyaWVzLnN0YXRlID0gc3RhdGU7XG5cblx0XHRcdFx0aWYgKHN0YXRlT3B0aW9uc1tzdGF0ZV0gJiYgc3RhdGVPcHRpb25zW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0XHRcdGxpbmVXaWR0aCA9IHN0YXRlT3B0aW9uc1tzdGF0ZV0ubGluZVdpZHRoIHx8IGxpbmVXaWR0aCArIChzdGF0ZU9wdGlvbnNbc3RhdGVdLmxpbmVXaWR0aFBsdXMgfHwgMCk7IC8vICM0MDM1XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JhcGggJiYgIWdyYXBoLmRhc2hzdHlsZSkgeyAvLyBob3ZlciBpcyB0dXJuZWQgb2ZmIGZvciBkYXNoZWQgbGluZXMgaW4gVk1MXG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsaW5lV2lkdGhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHVzZSBhdHRyIGJlY2F1c2UgYW5pbWF0ZSB3aWxsIGNhdXNlIGFueSBvdGhlciBhbmltYXRpb24gb24gdGhlIGdyYXBoIHRvIHN0b3Bcblx0XHRcdFx0XHRncmFwaC5hdHRyKGF0dHJpYnMpO1xuXHRcdFx0XHRcdHdoaWxlIChzZXJpZXNbJ3pvbmVHcmFwaCcgKyBpXSkge1xuXHRcdFx0XHRcdFx0c2VyaWVzWyd6b25lR3JhcGgnICsgaV0uYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0XHRcdGkgPSBpICsgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBncmFwaFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHZpcyB7Qm9vbGVhbn0gVHJ1ZSB0byBzaG93IHRoZSBzZXJpZXMsIGZhbHNlIHRvIGhpZGUuIElmIFVOREVGSU5FRCxcblx0XHQgKlx0XHRcdFx0dGhlIHZpc2liaWxpdHkgaXMgdG9nZ2xlZC5cblx0XHQgKi9cblx0XHRzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmlzLCByZWRyYXcpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0bGVnZW5kSXRlbSA9IHNlcmllcy5sZWdlbmRJdGVtLFxuXHRcdFx0XHRzaG93T3JIaWRlLFxuXHRcdFx0XHRpZ25vcmVIaWRkZW5TZXJpZXMgPSBjaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyxcblx0XHRcdFx0b2xkVmlzaWJpbGl0eSA9IHNlcmllcy52aXNpYmxlO1xuXG5cdFx0XHQvLyBpZiBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgdG9nZ2xlIHZpc2liaWxpdHlcblx0XHRcdHNlcmllcy52aXNpYmxlID0gdmlzID0gc2VyaWVzLnVzZXJPcHRpb25zLnZpc2libGUgPSB2aXMgPT09IFVOREVGSU5FRCA/ICFvbGRWaXNpYmlsaXR5IDogdmlzO1xuXHRcdFx0c2hvd09ySGlkZSA9IHZpcyA/ICdzaG93JyA6ICdoaWRlJztcblxuXHRcdFx0Ly8gc2hvdyBvciBoaWRlIGVsZW1lbnRzXG5cdFx0XHRlYWNoKFsnZ3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJywgJ21hcmtlckdyb3VwJywgJ3RyYWNrZXInXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW2tleV0pIHtcblx0XHRcdFx0XHRzZXJpZXNba2V5XVtzaG93T3JIaWRlXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXAgKCMxMzYxKVxuXHRcdFx0aWYgKGNoYXJ0LmhvdmVyU2VyaWVzID09PSBzZXJpZXMgfHwgKGNoYXJ0LmhvdmVyUG9pbnQgJiYgY2hhcnQuaG92ZXJQb2ludC5zZXJpZXMpID09PSBzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAobGVnZW5kSXRlbSkge1xuXHRcdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHNlcmllcywgdmlzKTtcblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZXNjYWxlIG9yIGFkYXB0IHRvIHJlc2l6ZWQgY2hhcnRcblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdC8vIGluIGEgc3RhY2ssIGFsbCBvdGhlciBzZXJpZXMgYXJlIGFmZmVjdGVkXG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRcdGlmIChvdGhlclNlcmllcy5vcHRpb25zLnN0YWNraW5nICYmIG90aGVyU2VyaWVzLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdG90aGVyU2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNob3cgb3IgaGlkZSBsaW5rZWQgc2VyaWVzXG5cdFx0XHRlYWNoKHNlcmllcy5saW5rZWRTZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRvdGhlclNlcmllcy5zZXRWaXNpYmxlKHZpcywgZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChpZ25vcmVIaWRkZW5TZXJpZXMpIHtcblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVkcmF3ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgc2hvd09ySGlkZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgdGhlIGdyYXBoXG5cdFx0ICovXG5cdFx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZXRWaXNpYmxlKHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWRlIHRoZSBncmFwaFxuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgZ3JhcGhcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBzZWxlY3RlZCB7Qm9vbGVhbn0gVHJ1ZSB0byBzZWxlY3QgdGhlIHNlcmllcywgZmFsc2UgdG8gdW5zZWxlY3QuIElmXG5cdFx0ICpcdFx0XHRcdFVOREVGSU5FRCwgdGhlIHNlbGVjdGlvbiBzdGF0ZSBpcyB0b2dnbGVkLlxuXHRcdCAqL1xuXHRcdHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcztcblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGVcblx0XHRcdHNlcmllcy5zZWxlY3RlZCA9IHNlbGVjdGVkID0gKHNlbGVjdGVkID09PSBVTkRFRklORUQpID8gIXNlcmllcy5zZWxlY3RlZCA6IHNlbGVjdGVkO1xuXG5cdFx0XHRpZiAoc2VyaWVzLmNoZWNrYm94KSB7XG5cdFx0XHRcdHNlcmllcy5jaGVja2JveC5jaGVja2VkID0gc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmVFdmVudChzZXJpZXMsIHNlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5zZWxlY3QnKTtcblx0XHR9LFxuXG5cdFx0ZHJhd1RyYWNrZXI6IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlckdyYXBoXG5cdH0pO1xuXHQvLyBnbG9iYWwgdmFyaWFibGVzXG5cdGV4dGVuZChIaWdoY2hhcnRzLCB7XG5cdFx0XG5cdFx0Ly8gQ29uc3RydWN0b3JzXG5cdFx0Q29sb3I6IENvbG9yLFxuXHRcdFBvaW50OiBQb2ludCxcblx0XHRUaWNrOiBUaWNrLFx0XG5cdFx0UmVuZGVyZXI6IFJlbmRlcmVyLFxuXHRcdFNWR0VsZW1lbnQ6IFNWR0VsZW1lbnQsXG5cdFx0U1ZHUmVuZGVyZXI6IFNWR1JlbmRlcmVyLFxuXHRcdFxuXHRcdC8vIFZhcmlvdXNcblx0XHRhcnJheU1pbjogYXJyYXlNaW4sXG5cdFx0YXJyYXlNYXg6IGFycmF5TWF4LFxuXHRcdGNoYXJ0czogY2hhcnRzLFxuXHRcdGRhdGVGb3JtYXQ6IGRhdGVGb3JtYXQsXG5cdFx0ZXJyb3I6IGVycm9yLFxuXHRcdGZvcm1hdDogZm9ybWF0LFxuXHRcdHBhdGhBbmltOiBwYXRoQW5pbSxcblx0XHRnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuXHRcdGhhc0JpZGlCdWc6IGhhc0JpZGlCdWcsXG5cdFx0aXNUb3VjaERldmljZTogaXNUb3VjaERldmljZSxcblx0XHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRcdGFkZEV2ZW50OiBhZGRFdmVudCxcblx0XHRyZW1vdmVFdmVudDogcmVtb3ZlRXZlbnQsXG5cdFx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0XHRkaXNjYXJkRWxlbWVudDogZGlzY2FyZEVsZW1lbnQsXG5cdFx0Y3NzOiBjc3MsXG5cdFx0ZWFjaDogZWFjaCxcblx0XHRtYXA6IG1hcCxcblx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0c3BsYXQ6IHNwbGF0LFxuXHRcdGV4dGVuZENsYXNzOiBleHRlbmRDbGFzcyxcblx0XHRwSW50OiBwSW50LFxuXHRcdHN2ZzogaGFzU1ZHLFxuXHRcdGNhbnZhczogdXNlQ2FuVkcsXG5cdFx0dm1sOiAhaGFzU1ZHICYmICF1c2VDYW5WRyxcblx0XHRwcm9kdWN0OiBQUk9EVUNULFxuXHRcdHZlcnNpb246IFZFUlNJT05cblx0fSk7XG5cblx0fSgpKTtcblxuXG5cdC8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG53YXJuaW5nKFxuICBmYWxzZSxcbiAgLy8gUmVxdWlyZSBleGFtcGxlcyBpbiB0aGlzIHN0cmluZyBtdXN0IGJlIHNwbGl0IHRvIHByZXZlbnQgUmVhY3Qnc1xuICAvLyBidWlsZCB0b29scyBmcm9tIG1pc3Rha2luZyB0aGVtIGZvciByZWFsIHJlcXVpcmVzLlxuICAvLyBPdGhlcndpc2UgdGhlIGJ1aWxkIHRvb2xzIHdpbGwgYXR0ZW1wdCB0byBidWlsZCBhICdyZWFjdC1hZGRvbnMte2FkZG9ufScgbW9kdWxlLlxuICAncmVxdWlyZScgKyBcIigncmVhY3QvYWRkb25zJykgaXMgZGVwcmVjYXRlZC4gXCIgK1xuICAnQWNjZXNzIHVzaW5nIHJlcXVpcmUnICsgXCIoJ3JlYWN0LWFkZG9ucy17YWRkb259JykgaW5zdGVhZC5cIlxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFdpdGhBZGRvbnMnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIE1peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgTWl4aW46IE1peGluLFxuXG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZCh0b3BMZXZlbFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzKSB7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhDU1NQcm9wZXJ0eU9wZXJhdGlvbnMsICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnLCB7XG4gIHNldFZhbHVlRm9yU3R5bGVzOiAnc2V0VmFsdWVGb3JTdHlsZXMnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbmFzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SURGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJREZ1bmMpIHtcbiAgICAgIHZhciB0YXJnZXRJRCA9IGdldFRhcmdldElERnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIHRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHRSZWFjdFJvb3RJbmRleCA9IDA7XG5cbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV4dFJlYWN0Um9vdEluZGV4Kys7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50UmVhY3RSb290SW5kZXg7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gIC8vIEJ5IGV4cGxvaXRpbmcgYXJyYXlzIHJldHVybmluZyBgdW5kZWZpbmVkYCBmb3IgYW4gdW5kZWZpbmVkIGluZGV4LCB3ZSBjYW5cbiAgLy8gcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gSG93ZXZlciwgdXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsXG4gIC8vIGJyb3dzZXJzIHNvIHdlIG11c3QgcmVwbGFjZSBpdCB3aXRoIGBudWxsYC5cblxuICAvLyBmaXggcmVuZGVyIG9yZGVyIGVycm9yIGluIHNhZmFyaVxuICAvLyBJRTggd2lsbCB0aHJvdyBlcnJvciB3aGVuIGluZGV4IG91dCBvZiBsaXN0IHNpemUuXG4gIHZhciBiZWZvcmVDaGlsZCA9IGluZGV4ID49IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBudWxsIDogcGFyZW50Tm9kZS5jaGlsZE5vZGVzLml0ZW0oaW5kZXgpO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgYmVmb3JlQ2hpbGQpO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgdXBkYXRlVGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8IHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgICF1cGRhdGVkQ2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc1VwZGF0ZXMoKTogVW5hYmxlIHRvIGZpbmQgY2hpbGQgJXMgb2YgZWxlbWVudC4gVGhpcyAnICsgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgKyAnbmVzdGluZyB0YWdzIGxpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyAnICsgJ2luIGFuIDxzdmc+IHBhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50ICcgKyAnd2l0aCBSZWFjdCBJRCBgJXNgLicsIHVwZGF0ZWRJbmRleCwgcGFyZW50SUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cDtcbiAgICAvLyBtYXJrdXBMaXN0IGlzIGVpdGhlciBhIGxpc3Qgb2YgbWFya3VwIG9yIGp1c3QgYSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgaWYgKG1hcmt1cExpc3QubGVuZ3RoICYmIHR5cGVvZiBtYXJrdXBMaXN0WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gbWFya3VwTGlzdDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01DaGlsZHJlbk9wZXJhdGlvbnMsICdET01DaGlsZHJlbk9wZXJhdGlvbnMnLCB7XG4gIHVwZGF0ZVRleHRDb250ZW50OiAndXBkYXRlVGV4dENvbnRlbnQnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9BVFRSSUJVVEU6IDB4MSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MixcbiAgSEFTX1NJREVfRUZGRUNUUzogMHg0LFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHgxMCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MjAgfCAweDEwLFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZUF0dHJpYnV0ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEUpLFxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNTaWRlRWZmZWN0czogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuXG4gICAgICAhKCFwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSB8fCAhcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5IHx8ICFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0VmFsdWVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VBdHRyaWJ1dGU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCB1c2luZyBgKkF0dHJpYnV0ZSgpYC5cbiAgICogICAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc1NpZGVFZmZlY3RzOlxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHNldHRpbmcgYSB2YWx1ZSBjYXVzZXMgc2lkZSBlZmZlY3RzIHN1Y2ggYXMgdHJpZ2dlcmluZ1xuICAgKiAgIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gSWYgdHJ1ZSwgd2UgcmVhZCBmcm9tXG4gICAqICAgdGhlIERPTSBiZWZvcmUgdXBkYXRpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG9ubHkgc2V0IGlmIGl0IGhhc1xuICAgKiAgIGNoYW5nZWQuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIGZvciBhIERPTSBwcm9wZXJ0eSAoaS5lLiwgbm90IGFuXG4gICAqIGF0dHJpYnV0ZSkuIE1vc3QgZGVmYXVsdCB2YWx1ZXMgYXJlICcnIG9yIGZhbHNlLCBidXQgbm90IGFsbC4gV29yc2UgeWV0LFxuICAgKiBzb21lIChpbiBwYXJ0aWN1bGFyLCBgdHlwZWApIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIFRPRE86IElzIGl0IGJldHRlciB0byBncmFiIGFsbCB0aGUgcG9zc2libGUgcHJvcGVydGllcyB3aGVuIGNyZWF0aW5nIGFuXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgc2FtZSBlbGVtZW50IHR3aWNlP1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gL15bYS16QS1aX11bXFx3XFwuXFwtXSokLztcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHdhcm5Vbmtub3duUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzdGFuZGFyZE5hbWUgPT0gbnVsbCwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgc3RhbmRhcmROYW1lKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBET01Qcm9wZXJ0eS5nZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eShub2RlLm5vZGVOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NUHJvcGVydHlPcGVyYXRpb25zLCAnRE9NUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiAnc2V0VmFsdWVGb3JQcm9wZXJ0eScsXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnLFxuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbiAobWFya3VwTGlzdCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArICd0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5ICcgKyAnYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAhbWFya3VwTGlzdFtpXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciByZXN1bHRJbmRleDtcbiAgICAgIGZvciAocmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLCBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbal07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJiByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAhIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6JywgcmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAhKHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgIShyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsIG1hcmt1cExpc3QubGVuZ3RoLCByZXN1bHRMaXN0Lmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArICd3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSAnICsgJ2dsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShvbGRDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICsgJzxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgJyArICdhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSAnICsgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoaWxkID0gbWFya3VwO1xuICAgIH1cbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbnZhciBnZXRGaXJzdFJlYWN0RE9NID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBleHRyYWN0ZWRFdmVudHMgPSBbbnVsbCwgbnVsbF07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlciAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0ICYmIHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmICh0b3BMZXZlbFRhcmdldC53aW5kb3cgPT09IHRvcExldmVsVGFyZ2V0KSB7XG4gICAgICAvLyBgdG9wTGV2ZWxUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gdG9wTGV2ZWxUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIHZhciBmcm9tSUQgPSAnJztcbiAgICB2YXIgdG9JRCA9ICcnO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQpIHtcbiAgICAgIGZyb20gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIGZyb21JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICB0byA9IGdldEZpcnN0UmVhY3RET00obmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpO1xuICAgICAgaWYgKHRvKSB7XG4gICAgICAgIHRvSUQgPSBSZWFjdE1vdW50LmdldElEKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0gd2luO1xuICAgICAgfVxuICAgICAgdG8gPSB0byB8fCB3aW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSB3aW47XG4gICAgICB0byA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgdG9JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb21JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb207XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0b0lELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG87XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb207XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCk7XG5cbiAgICBleHRyYWN0ZWRFdmVudHNbMF0gPSBsZWF2ZTtcbiAgICBleHRyYWN0ZWRFdmVudHNbMV0gPSBlbnRlcjtcblxuICAgIHJldHVybiBleHRyYWN0ZWRFdmVudHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50Q29uc3RhbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQWJvcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArICd0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCAnICsgJ21ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAnZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ3JlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiAnICsgJ29uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArICd1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uIChJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUgJiYgSW5qZWN0ZWRNb3VudC5nZXRJRCwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50ICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZSBvciBnZXRJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGRvbUlEKTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQsIGRvbUlEKTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSURzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSURzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoaWQpO1xuICB9LFxuICBnZXRJRDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldElEKG5vZGUpO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoZG9tSUQsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZG9tSUQsICdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGRvbUlELCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldChldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKGZyb21JRCwgdG9JRCwgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyk7XG59XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC8pLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2NlcHRDaGFyc2V0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hhbGxlbmdlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjbGFzc0lEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUFjdGlvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1FbmNUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGlucHV0TW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGludGVncml0eTogbnVsbCxcbiAgICBpczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVBhcmFtczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBraW5kOiBudWxsLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGxvb3A6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiBudWxsLFxuICAgIG1hbmlmZXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFyZ2luSGVpZ2h0OiBudWxsLFxuICAgIG1hcmdpbldpZHRoOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vbmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogbnVsbCxcbiAgICBwYXR0ZXJuOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJhZGlvR3JvdXA6IG51bGwsXG4gICAgcmVhZE9ubHk6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiBudWxsLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY0xhbmc6IG51bGwsXG4gICAgc3JjU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgc3VtbWFyeTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd3JhcDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGF0YXR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbmxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVmaXg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJlc291cmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ3R5cGVvZic6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2b2NhYjogTVVTVF9VU0VfQVRUUklCVVRFLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiBudWxsLFxuICAgIGF1dG9Db3JyZWN0OiBudWxsLFxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xuICAgIGF1dG9TYXZlOiBudWxsLFxuICAgIC8vIGNvbG9yIGlzIGZvciBTYWZhcmkgbWFzay1pY29uIGxpbmtcbiAgICBjb2xvcjogbnVsbCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1TY29wZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVJlZjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIHJlc3VsdHMgc2hvdyBsb29raW5nIGdsYXNzIGljb24gYW5kIHJlY2VudCBzZWFyY2hlcyBvbiBpbnB1dFxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXG4gICAgcmVzdWx0czogbnVsbCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gYW4gaWZyYW1lXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXG4gICAgc2VjdXJpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7XG4gICAgYXV0b0NhcGl0YWxpemU6ICdhdXRvY2FwaXRhbGl6ZScsXG4gICAgYXV0b0NvbXBsZXRlOiAnYXV0b2NvbXBsZXRlJyxcbiAgICBhdXRvQ29ycmVjdDogJ2F1dG9jb3JyZWN0JyxcbiAgICBhdXRvRm9jdXM6ICdhdXRvZm9jdXMnLFxuICAgIGF1dG9QbGF5OiAnYXV0b3BsYXknLFxuICAgIGF1dG9TYXZlOiAnYXV0b3NhdmUnLFxuICAgIC8vIGBlbmNvZGluZ2AgaXMgZXF1aXZhbGVudCB0byBgZW5jdHlwZWAsIElFOCBsYWNrcyBhbiBgZW5jdHlwZWAgc2V0dGVyLlxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjZG9tLWZzLWVuY29kaW5nXG4gICAgZW5jVHlwZTogJ2VuY29kaW5nJyxcbiAgICBocmVmTGFuZzogJ2hyZWZsYW5nJyxcbiAgICByYWRpb0dyb3VwOiAncmFkaW9ncm91cCcsXG4gICAgc3BlbGxDaGVjazogJ3NwZWxsY2hlY2snLFxuICAgIHNyY0RvYzogJ3NyY2RvYycsXG4gICAgc3JjU2V0OiAnc3Jjc2V0J1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkU3RhdGVNaXhpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdExpbmsgPSByZXF1aXJlKCcuL1JlYWN0TGluaycpO1xudmFyIFJlYWN0U3RhdGVTZXR0ZXJzID0gcmVxdWlyZSgnLi9SZWFjdFN0YXRlU2V0dGVycycpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG1peGluIGFyb3VuZCBSZWFjdExpbmsuZm9yU3RhdGUoKS5cbiAqL1xudmFyIExpbmtlZFN0YXRlTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBSZWFjdExpbmsgdGhhdCdzIGxpbmtlZCB0byBwYXJ0IG9mIHRoaXMgY29tcG9uZW50J3Mgc3RhdGUuIFRoZVxuICAgKiBSZWFjdExpbmsgd2lsbCBoYXZlIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMuc3RhdGVba2V5XSBhbmQgd2lsbCBjYWxsXG4gICAqIHNldFN0YXRlKCkgd2hlbiBhIGNoYW5nZSBpcyByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3RhdGUga2V5IHRvIHVwZGF0ZS4gTm90ZTogeW91IG1heSB3YW50IHRvIHVzZSBrZXlPZigpXG4gICAqIGlmIHlvdSdyZSB1c2luZyBHb29nbGUgQ2xvc3VyZSBDb21waWxlciBhZHZhbmNlZCBtb2RlLlxuICAgKiBAcmV0dXJuIHtSZWFjdExpbmt9IFJlYWN0TGluayBpbnN0YW5jZSBsaW5raW5nIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGxpbmtTdGF0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RMaW5rKHRoaXMuc3RhdGVba2V5XSwgUmVhY3RTdGF0ZVNldHRlcnMuY3JlYXRlU3RhdGVLZXlTZXR0ZXIodGhpcywga2V5KSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkU3RhdGVNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkVmFsdWVVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlICcgKyAnY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50ICcgKyAndG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gJyArICdJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byAnICsgJ3VzZSBjaGVja2VkTGluaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICAgKi9cbiAgZXhlY3V0ZU9uQ2hhbmdlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcywgZXZlbnQpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFBvb2xlZENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzIChvcHRpb25hbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgnLi9SZWFjdERPTScpO1xudmFyIFJlYWN0RE9NU2VydmVyID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlcnZlcicpO1xudmFyIFJlYWN0SXNvbW9ycGhpYyA9IHJlcXVpcmUoJy4vUmVhY3RJc29tb3JwaGljJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkJyk7XG5cbi8vIGB2ZXJzaW9uYCB3aWxsIGJlIGFkZGVkIGhlcmUgYnkgUmVhY3RJc29tb3JwaGljLlxudmFyIFJlYWN0ID0ge307XG5cbmFzc2lnbihSZWFjdCwgUmVhY3RJc29tb3JwaGljKTtcblxuYXNzaWduKFJlYWN0LCB7XG4gIC8vIFJlYWN0RE9NXG4gIGZpbmRET01Ob2RlOiBkZXByZWNhdGVkKCdmaW5kRE9NTm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00uZmluZERPTU5vZGUpLFxuICByZW5kZXI6IGRlcHJlY2F0ZWQoJ3JlbmRlcicsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00ucmVuZGVyKSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZGVwcmVjYXRlZCgndW5tb3VudENvbXBvbmVudEF0Tm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSksXG5cbiAgLy8gUmVhY3RET01TZXJ2ZXJcbiAgcmVuZGVyVG9TdHJpbmc6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RyaW5nJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcpLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogZGVwcmVjYXRlZCgncmVuZGVyVG9TdGF0aWNNYXJrdXAnLCAnUmVhY3RET01TZXJ2ZXInLCAncmVhY3QtZG9tL3NlcnZlcicsIFJlYWN0RE9NU2VydmVyLCBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cClcbn0pO1xuXG5SZWFjdC5fX1NFQ1JFVF9ET01fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NO1xuUmVhY3QuX19TRUNSRVRfRE9NX1NFUlZFUl9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RET01TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5LZXkgPSAnX2dldERPTU5vZGVEaWRXYXJuJztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSwgJyVzLmdldERPTU5vZGUoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgKyAnUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpIGluc3RlYWQuJywgUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuZ2V0TmFtZSgpIHx8IHRoaXMudGFnTmFtZSB8fCAnVW5rbm93bicpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0gPSB0cnVlO1xuICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBhc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcblxuICAvKipcbiAgICogSW5qZWN0YWJsZSBldmVudCBiYWNrZW5kXG4gICAqL1xuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFJlYWN0RXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5oYW5kbGVUb3BMZXZlbCk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuc2V0RW5hYmxlZChlbmFibGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2FsbGJhY2tzIGFyZSBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiYgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICpcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICAgKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAqXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAgICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAgICovXG4gIGxpc3RlblRvOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICAgIHZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fCBkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEJsdXJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEZvY3VzXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVucyB0byB3aW5kb3cgc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzLiBXZSBjYWNoZSBzY3JvbGwgdmFsdWVzIHNvIHRoYXRcbiAgICogYXBwbGljYXRpb24gY29kZSBjYW4gYWNjZXNzIHRoZW0gd2l0aG91dCB0cmlnZ2VyaW5nIHJlZmxvd3MuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpbkh1Yi5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luSHViLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIHB1dExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcixcblxuICBnZXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXIsXG5cbiAgZGVsZXRlTGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyLFxuXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzXG5cbn0pO1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLCAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJywge1xuICBwdXRMaXN0ZW5lcjogJ3B1dExpc3RlbmVyJyxcbiAgZGVsZXRlTGlzdGVuZXI6ICdkZWxldGVMaXN0ZW5lcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZSgnLi9SZWFjdFRyYW5zaXRpb25Hcm91cCcpO1xudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQnKTtcblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKHRyYW5zaXRpb25UeXBlKSB7XG4gIHZhciB0aW1lb3V0UHJvcE5hbWUgPSAndHJhbnNpdGlvbicgKyB0cmFuc2l0aW9uVHlwZSArICdUaW1lb3V0JztcbiAgdmFyIGVuYWJsZWRQcm9wTmFtZSA9ICd0cmFuc2l0aW9uJyArIHRyYW5zaXRpb25UeXBlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiBpcyBlbmFibGVkXG4gICAgaWYgKHByb3BzW2VuYWJsZWRQcm9wTmFtZV0pIHtcbiAgICAgIC8vIElmIG5vIHRpbWVvdXQgZHVyYXRpb24gaXMgcHJvdmlkZWRcbiAgICAgIGlmIChwcm9wc1t0aW1lb3V0UHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIHdhc25cXCd0IHN1cHBsaWVkIHRvIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwOiAnICsgJ3RoaXMgY2FuIGNhdXNlIHVucmVsaWFibGUgYW5pbWF0aW9ucyBhbmQgd29uXFwndCBiZSBzdXBwb3J0ZWQgaW4gJyArICdhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWFuaW1hdGlvbi10cmFuc2l0aW9uLWdyb3VwLXRpbWVvdXQgZm9yIG1vcmUgJyArICdpbmZvcm1hdGlvbi4nKTtcblxuICAgICAgICAvLyBJZiB0aGUgZHVyYXRpb24gaXNuJ3QgYSBudW1iZXJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzW3RpbWVvdXRQcm9wTmFtZV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih0aW1lb3V0UHJvcE5hbWUgKyAnIG11c3QgYmUgYSBudW1iZXIgKGluIG1pbGxpc2Vjb25kcyknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0cmFuc2l0aW9uTmFtZTogUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZC5wcm9wVHlwZXMubmFtZSxcblxuICAgIHRyYW5zaXRpb25BcHBlYXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25FbnRlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkxlYXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uQXBwZWFyVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdBcHBlYXInKSxcbiAgICB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0OiBjcmVhdGVUcmFuc2l0aW9uVGltZW91dFByb3BWYWxpZGF0b3IoJ0VudGVyJyksXG4gICAgdHJhbnNpdGlvbkxlYXZlVGltZW91dDogY3JlYXRlVHJhbnNpdGlvblRpbWVvdXRQcm9wVmFsaWRhdG9yKCdMZWF2ZScpXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICBfd3JhcENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBjaGlsZEZhY3Rvcnkgc28gdGhhdFxuICAgIC8vIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgY2FuIHJlY2VpdmUgdXBkYXRlcyB0byBuYW1lLCBlbnRlciwgYW5kXG4gICAgLy8gbGVhdmUgd2hpbGUgaXQgaXMgbGVhdmluZy5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLCB7XG4gICAgICBuYW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgYXBwZWFyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXIsXG4gICAgICBlbnRlcjogdGhpcy5wcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICBsZWF2ZTogdGhpcy5wcm9wcy50cmFuc2l0aW9uTGVhdmUsXG4gICAgICBhcHBlYXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXJUaW1lb3V0LFxuICAgICAgZW50ZXJUaW1lb3V0OiB0aGlzLnByb3BzLnRyYW5zaXRpb25FbnRlclRpbWVvdXQsXG4gICAgICBsZWF2ZVRpbWVvdXQ6IHRoaXMucHJvcHMudHJhbnNpdGlvbkxlYXZlVGltZW91dFxuICAgIH0sIGNoaWxkKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdFRyYW5zaXRpb25Hcm91cCwgYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGNoaWxkRmFjdG9yeTogdGhpcy5fd3JhcENoaWxkIH0pKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCcuL1JlYWN0RE9NJyk7XG5cbnZhciBDU1NDb3JlID0gcmVxdWlyZSgnZmJqcy9saWIvQ1NTQ29yZScpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHJlcXVpcmUoJy4vUmVhY3RUcmFuc2l0aW9uRXZlbnRzJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG4vLyBXZSBkb24ndCByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NIHVudGlsIHdlIHJlY2VpdmUgYW4gYW5pbWF0aW9uZW5kIG9yXG4vLyB0cmFuc2l0aW9uZW5kIGV2ZW50LiBJZiB0aGUgdXNlciBzY3Jld3MgdXAgYW5kIGZvcmdldHMgdG8gYWRkIGFuIGFuaW1hdGlvblxuLy8gdGhlaXIgbm9kZSB3aWxsIGJlIHN0dWNrIGluIHRoZSBET00gZm9yZXZlciwgc28gd2UgZGV0ZWN0IGlmIGFuIGFuaW1hdGlvblxuLy8gZG9lcyBub3Qgc3RhcnQgYW5kIGlmIGl0IGRvZXNuJ3QsIHdlIGp1c3QgY2FsbCB0aGUgZW5kIGxpc3RlbmVyIGltbWVkaWF0ZWx5LlxudmFyIFRJQ0sgPSAxNztcblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgbGVhdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBhY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9KSwgUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgZW50ZXJBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBsZWF2ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGxlYXZlQWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYXBwZWFyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYXBwZWFyQWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gICAgfSldKS5pc1JlcXVpcmVkLFxuXG4gICAgLy8gT25jZSB3ZSByZXF1aXJlIHRpbWVvdXRzIHRvIGJlIHNwZWNpZmllZCwgd2UgY2FuIHJlbW92ZSB0aGVcbiAgICAvLyBib29sZWFuIGZsYWdzIChhcHBlYXIgZXRjLikgYW5kIGp1c3QgYWNjZXB0IGEgbnVtYmVyXG4gICAgLy8gb3IgYSBib29sIGZvciB0aGUgdGltZW91dCBmbGFncyAoYXBwZWFyVGltZW91dCBldGMuKVxuICAgIGFwcGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZW50ZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGxlYXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhcHBlYXJUaW1lb3V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudGVyVGltZW91dDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWF2ZVRpbWVvdXQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgfSxcblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAoYW5pbWF0aW9uVHlwZSwgZmluaXNoQ2FsbGJhY2ssIHVzZXJTcGVjaWZpZWREZWxheSkge1xuICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmIChmaW5pc2hDYWxsYmFjaykge1xuICAgICAgICBmaW5pc2hDYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLm5hbWVbYW5pbWF0aW9uVHlwZV0gfHwgdGhpcy5wcm9wcy5uYW1lICsgJy0nICsgYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gdGhpcy5wcm9wcy5uYW1lW2FuaW1hdGlvblR5cGUgKyAnQWN0aXZlJ10gfHwgY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFVzdWFsbHkgdGhpcyBvcHRpb25hbCBjYWxsYmFjayBpcyB1c2VkIGZvciBpbmZvcm1pbmcgYW4gb3duZXIgb2ZcbiAgICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICBpZiAoZmluaXNoQ2FsbGJhY2spIHtcbiAgICAgICAgZmluaXNoQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1NTQ29yZS5hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIHRvIGFjdHVhbGx5IHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgIHRoaXMucXVldWVDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgdGltZW91dCBkZWxheS5cbiAgICBpZiAodXNlclNwZWNpZmllZERlbGF5KSB7XG4gICAgICAvLyBDbGVhbi11cCB0aGUgYW5pbWF0aW9uIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXlcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGVuZExpc3RlbmVyLCB1c2VyU3BlY2lmaWVkRGVsYXkpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZW91dHMucHVzaCh0aW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gREVQUkVDQVRFRDogdGhpcyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiByZWFjdFxuICAgICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICBxdWV1ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5wdXNoKGNsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmZsdXNoQ2xhc3NOYW1lUXVldWUsIFRJQ0spO1xuICAgIH1cbiAgfSxcblxuICBmbHVzaENsYXNzTmFtZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lUXVldWUuZm9yRWFjaChDU1NDb3JlLmFkZENsYXNzLmJpbmQoQ1NTQ29yZSwgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZSA9IFtdO1xuICAgIHRoaXMudHJhbnNpdGlvblRpbWVvdXRzID0gW107XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZW91dHMuZm9yRWFjaChmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxBcHBlYXI6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXBwZWFyKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUsIHRoaXMucHJvcHMuYXBwZWFyVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEVudGVyOiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmVudGVyKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2VudGVyJywgZG9uZSwgdGhpcy5wcm9wcy5lbnRlclRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5sZWF2ZSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUsIHRoaXMucHJvcHMubGVhdmVUaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8oPyFcXC8pL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJy8vJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZCAhPT0gY2hpbGQgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5IHx8ICcnKSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG52YXIgd2FybmVkU2V0UHJvcHMgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5TZXRQcm9wcygpIHtcbiAgaWYgKCF3YXJuZWRTZXRQcm9wcykge1xuICAgIHdhcm5lZFNldFByb3BzID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3NldFByb3BzKC4uLikgYW5kIHJlcGxhY2VQcm9wcyguLi4pIGFyZSBkZXByZWNhdGVkLiAnICsgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgbm90IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICsgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgKyAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgKyAndG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBpZiAoIXByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICsgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSAobmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVMpO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgKyAnY29uc3RydWN0b3IuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gKG5hbWUgaW4gQ29uc3RydWN0b3IpO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgKyAnZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICsgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgKyAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgKyAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICsgJ3dpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIG5vLXVuZGVmICovXG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICBpZiAoY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwW2F1dG9CaW5kS2V5XTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRQcm9wczogZnVuY3Rpb24gKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0UHJvcHModGhpcywgcGFydGlhbFByb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVwbGFjZVByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5TZXRQcm9wcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VQcm9wcyh0aGlzLCBuZXdQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBnZXRET01Ob2RlOiBbJ2dldERPTU5vZGUnLCAnVXNlIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbXBvbmVudCkgaW5zdGVhZC4nXSxcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVByb3BzOiBbJ3JlcGxhY2VQcm9wcycsICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddLFxuICAgIHNldFByb3BzOiBbJ3NldFByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbiAocm9vdE5vZGVJRCkge1xuICAgIFJlYWN0TW91bnQucHVyZ2VJRChyb290Tm9kZUlEKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gICAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICAgKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWxsb3dDb21wYXJlID0gcmVxdWlyZSgnLi9zaGFsbG93Q29tcGFyZScpO1xuXG4vKipcbiAqIElmIHlvdXIgUmVhY3QgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIGlzIFwicHVyZVwiLCBlLmcuIGl0IHdpbGwgcmVuZGVyIHRoZVxuICogc2FtZSByZXN1bHQgZ2l2ZW4gdGhlIHNhbWUgcHJvcHMgYW5kIHN0YXRlLCBwcm92aWRlIHRoaXMgTWl4aW4gZm9yIGFcbiAqIGNvbnNpZGVyYWJsZSBwZXJmb3JtYW5jZSBib29zdC5cbiAqXG4gKiBNb3N0IFJlYWN0IGNvbXBvbmVudHMgaGF2ZSBwdXJlIHJlbmRlciBmdW5jdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPVxuICogICAgIHJlcXVpcmUoJ1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbicpO1xuICogICBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXSxcbiAqXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9PmZvbzwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIE5vdGU6IFRoaXMgb25seSBjaGVja3Mgc2hhbGxvdyBlcXVhbGl0eSBmb3IgcHJvcHMgYW5kIHN0YXRlLiBJZiB0aGVzZSBjb250YWluXG4gKiBjb21wbGV4IGRhdGEgc3RydWN0dXJlcyB0aGlzIG1peGluIG1heSBoYXZlIGZhbHNlLW5lZ2F0aXZlcyBmb3IgZGVlcGVyXG4gKiBkaWZmZXJlbmNlcy4gT25seSBtaXhpbiB0byBjb21wb25lbnRzIHdoaWNoIGhhdmUgc2ltcGxlIHByb3BzIGFuZCBzdGF0ZSwgb3JcbiAqIHVzZSBgZm9yY2VVcGRhdGUoKWAgd2hlbiB5b3Uga25vdyBkZWVwIGRhdGEgc3RydWN0dXJlcyBoYXZlIGNoYW5nZWQuXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPSB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuIHNoYWxsb3dDb21wYXJlKHRoaXMsIG5leHRQcm9wcywgbmV4dFN0YXRlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHJldHVybiBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBpbnN0O1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2F5IHRvIGRldGVjdCBpZiBDb21wb25lbnQgaXMgYSBzdGF0ZWxlc3MgYXJyb3cgZnVuY3Rpb25cbiAgICAvLyBjb21wb25lbnQsIHdoaWNoIGlzIG5vdCBuZXdhYmxlLiBJdCBtaWdodCBub3QgYmUgMTAwJSByZWxpYWJsZSBidXQgaXNcbiAgICAvLyBzb21ldGhpbmcgd2UgY2FuIGRvIHVudGlsIHdlIHN0YXJ0IGRldGVjdGluZyB0aGF0IENvbXBvbmVudCBleHRlbmRzXG4gICAgLy8gUmVhY3QuQ29tcG9uZW50LiBXZSBhbHJlYWR5IGFzc3VtZSB0aGF0IHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicuXG4gICAgdmFyIGNhbkluc3RhbnRpYXRlID0gKCdwcm90b3R5cGUnIGluIENvbXBvbmVudCk7XG5cbiAgICBpZiAoY2FuSW5zdGFudGlhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FuSW5zdGFudGlhdGUgfHwgaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAsIHJldHVybmVkICcgKyAnbnVsbC9mYWxzZSBmcm9tIGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgb3IgdHJpZWQgdG8gcmVuZGVyIGFuICcgKyAnZWxlbWVudCB3aG9zZSB0eXBlIGlzIGEgZnVuY3Rpb24gdGhhdCBpc25cXCd0IGEgUmVhY3QgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzdXBwb3J0IEVTNiBpbmhlcml0aW5nIGZyb20gUmVhY3QuQ29tcG9uZW50LCB0aGUgbW9kdWxlIHBhdHRlcm4sXG4gICAgICAgIC8vIGFuZCBzdGF0ZWxlc3MgY29tcG9uZW50cywgYnV0IG5vdCBFUzYgY2xhc3NlcyB0aGF0IGRvbid0IGV4dGVuZFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCB8fCAhY2FuSW5zdGFudGlhdGUgfHwgIShpbnN0IGluc3RhbmNlb2YgQ29tcG9uZW50KSwgJyVzKC4uLik6IFJlYWN0IGNvbXBvbmVudCBjbGFzc2VzIG11c3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgcm9vdElELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5wcm9wVHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LnByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uIChwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBlbGVtZW50XG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSAnICsgJ2Zyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gdG9wLWxldmVsIHJlbmRlciBjYWxscywgc28gSSdtIGFic3RyYWN0aW5nIGl0IGF3YXkgaW50b1xuICAgICAgICAgIC8vIGEgZnVuY3Rpb24gdG8gbWluaW1pemUgcmVmYWN0b3JpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSh0aGlzKTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKSB7XG4gICAgICAgICAgICAvLyBQcmVmYWNlIGdpdmVzIHVzIHNvbWV0aGluZyB0byBibGFja2xpc3QgaW4gd2FybmluZyBtb2R1bGVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29udGV4dCBUeXBlczogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCB8fCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBuZXh0Q29udGV4dCA9IHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQgPyBpbnN0LmNvbnRleHQgOiB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB2YXIgbmV4dFByb3BzO1xuXG4gICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhIHByb3BzIHVwZGF0ZSB2ZXJzdXMgYSBzaW1wbGUgc3RhdGUgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ID09PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgLy8gU2tpcCBjaGVja2luZyBwcm9wIHR5cGVzIGFnYWluIC0tIHdlIGRvbid0IHJlYWQgaW5zdC5wcm9wcyB0byBhdm9pZFxuICAgICAgLy8gd2FybmluZyBmb3IgRE9NIGNvbXBvbmVudCBwcm9wcyBpbiB0aGlzIHVwZ3JhZGVcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dFBhcmVudEVsZW1lbnQucHJvcHMpO1xuICAgICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuXG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHwgIWluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHNob3VsZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRoaXNJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdCBpbnN0YW5jZW9mIFN0YXRlbGVzc0NvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4sICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCcsXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50J1xufSk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIHJlbmRlciA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdCcsICdyZW5kZXInLCBSZWFjdE1vdW50LnJlbmRlcik7XG5cbnZhciBSZWFjdCA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIEluc3RhbmNlSGFuZGxlczogUmVhY3RJbnN0YW5jZUhhbmRsZXMsXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyLFxuICAgIFRleHRDb21wb25lbnQ6IFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cbiAgICAvLyBzaGFtc1xuICAgIE9iamVjdC5jcmVhdGUsIE9iamVjdC5mcmVlemVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignT25lIG9yIG1vcmUgRVM1IHNoaW0vc2hhbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb3VzZUxpc3RlbmVyTmFtZXMgPSB7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHByb3BzLCBleGNlcHQgdGhlIG1vdXNlIGxpc3RlbmVyc1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSB7XG4gICAgICAgIG5hdGl2ZVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBDSElMRFJFTiA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbGVnYWN5UHJvcHNEZXNjcmlwdG9yO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbGVnYWN5UHJvcHNEZXNjcmlwdG9yID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucHJvcHMgb2YgYSBET00gbm9kZTsgaW5zdGVhZCwgJyArICdyZWNyZWF0ZSB0aGUgcHJvcHMgYXMgYHJlbmRlcmAgZGlkIG9yaWdpbmFsbHkgb3IgcmVhZCB0aGUgRE9NICcgKyAncHJvcGVydGllcy9hdHRyaWJ1dGVzIGRpcmVjdGx5IGZyb20gdGhpcyBub2RlIChlLmcuLCAnICsgJ3RoaXMucmVmcy5ib3guY2xhc3NOYW1lKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lHZXRET01Ob2RlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmdldERPTU5vZGUoKSBvZiBhIERPTSBub2RlOyAnICsgJ2luc3RlYWQsIHVzZSB0aGUgbm9kZSBkaXJlY3RseS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbGVnYWN5SXNNb3VudGVkKCkge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5pc01vdW50ZWQoKSBvZiBhIERPTSBub2RlLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAhIWNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0U3RhdGVFdGMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0U3RhdGUoKSwgLnJlcGxhY2VTdGF0ZSgpLCBvciAnICsgJy5mb3JjZVVwZGF0ZSgpIG9mIGEgRE9NIG5vZGUuIFRoaXMgaXMgYSBuby1vcC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlcGxhY2VQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnJlcGxhY2VQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZXMgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHVuZGVmaW5lZDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArICdub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuICcgKyAndXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50IDogY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGlkOiBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaWQsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVhZHlJbnB1dFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NSW5wdXQubW91bnRSZWFkeVdyYXBwZXIodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIGluc3QpIHtcbiAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICB2YXIgaW5mbyA9IGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldO1xuICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQgPSBSZWFjdERPTVNlbGVjdC5wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHt9LCBwcm9wcywgdHJhbnNhY3Rpb24sIGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShtb3VudFJlYWR5SW5wdXRXcmFwcGVyLCB0aGlzKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAocHJvcEtleSAhPT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChlbCwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgcmVmZXJlbmNlLWVxdWFsIHRvIHRoZSBvbGQgb25lLCBwYXNzIGRvd24gdGhlIHNhbWVcbiAgICAgIC8vIHByb2Nlc3NlZCBvYmplY3Qgc28gdGhlIHVwZGF0ZSBiYWlsb3V0IGluIFJlYWN0UmVjb25jaWxlciBiZWhhdmVzXG4gICAgICAvLyBjb3JyZWN0bHkgKGFuZCBpZGVudGljYWxseSBpbiBkZXYgYW5kIHByb2QpLiBTZWUgIzUwMDUuXG4gICAgICBpZiAodGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSAmJiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbm9kZSkge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIH1cbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudW5tb3VudFdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcblxuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IHRoaXM7XG4gICAgICBub2RlLmdldERPTU5vZGUgPSBsZWdhY3lHZXRET01Ob2RlO1xuICAgICAgbm9kZS5pc01vdW50ZWQgPSBsZWdhY3lJc01vdW50ZWQ7XG4gICAgICBub2RlLnNldFN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnJlcGxhY2VTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5mb3JjZVVwZGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5zZXRQcm9wcyA9IGxlZ2FjeVNldFByb3BzO1xuICAgICAgbm9kZS5yZXBsYWNlUHJvcHMgPSBsZWdhY3lSZXBsYWNlUHJvcHM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIGxlZ2FjeVByb3BzRGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUNvbXBvbmVudCwgJ1JlYWN0RE9NQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50J1xufSk7XG5cbmFzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9tYXBPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRhZyBuYW1lIChlLmcuIGBkaXZgKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTUZhY3RvcnkodGFnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5KHRhZyk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IG1hcE9iamVjdCh7XG4gIGE6ICdhJyxcbiAgYWJicjogJ2FiYnInLFxuICBhZGRyZXNzOiAnYWRkcmVzcycsXG4gIGFyZWE6ICdhcmVhJyxcbiAgYXJ0aWNsZTogJ2FydGljbGUnLFxuICBhc2lkZTogJ2FzaWRlJyxcbiAgYXVkaW86ICdhdWRpbycsXG4gIGI6ICdiJyxcbiAgYmFzZTogJ2Jhc2UnLFxuICBiZGk6ICdiZGknLFxuICBiZG86ICdiZG8nLFxuICBiaWc6ICdiaWcnLFxuICBibG9ja3F1b3RlOiAnYmxvY2txdW90ZScsXG4gIGJvZHk6ICdib2R5JyxcbiAgYnI6ICdicicsXG4gIGJ1dHRvbjogJ2J1dHRvbicsXG4gIGNhbnZhczogJ2NhbnZhcycsXG4gIGNhcHRpb246ICdjYXB0aW9uJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjb2RlOiAnY29kZScsXG4gIGNvbDogJ2NvbCcsXG4gIGNvbGdyb3VwOiAnY29sZ3JvdXAnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGFsaXN0OiAnZGF0YWxpc3QnLFxuICBkZDogJ2RkJyxcbiAgZGVsOiAnZGVsJyxcbiAgZGV0YWlsczogJ2RldGFpbHMnLFxuICBkZm46ICdkZm4nLFxuICBkaWFsb2c6ICdkaWFsb2cnLFxuICBkaXY6ICdkaXYnLFxuICBkbDogJ2RsJyxcbiAgZHQ6ICdkdCcsXG4gIGVtOiAnZW0nLFxuICBlbWJlZDogJ2VtYmVkJyxcbiAgZmllbGRzZXQ6ICdmaWVsZHNldCcsXG4gIGZpZ2NhcHRpb246ICdmaWdjYXB0aW9uJyxcbiAgZmlndXJlOiAnZmlndXJlJyxcbiAgZm9vdGVyOiAnZm9vdGVyJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBoMTogJ2gxJyxcbiAgaDI6ICdoMicsXG4gIGgzOiAnaDMnLFxuICBoNDogJ2g0JyxcbiAgaDU6ICdoNScsXG4gIGg2OiAnaDYnLFxuICBoZWFkOiAnaGVhZCcsXG4gIGhlYWRlcjogJ2hlYWRlcicsXG4gIGhncm91cDogJ2hncm91cCcsXG4gIGhyOiAnaHInLFxuICBodG1sOiAnaHRtbCcsXG4gIGk6ICdpJyxcbiAgaWZyYW1lOiAnaWZyYW1lJyxcbiAgaW1nOiAnaW1nJyxcbiAgaW5wdXQ6ICdpbnB1dCcsXG4gIGluczogJ2lucycsXG4gIGtiZDogJ2tiZCcsXG4gIGtleWdlbjogJ2tleWdlbicsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsZWdlbmQ6ICdsZWdlbmQnLFxuICBsaTogJ2xpJyxcbiAgbGluazogJ2xpbmsnLFxuICBtYWluOiAnbWFpbicsXG4gIG1hcDogJ21hcCcsXG4gIG1hcms6ICdtYXJrJyxcbiAgbWVudTogJ21lbnUnLFxuICBtZW51aXRlbTogJ21lbnVpdGVtJyxcbiAgbWV0YTogJ21ldGEnLFxuICBtZXRlcjogJ21ldGVyJyxcbiAgbmF2OiAnbmF2JyxcbiAgbm9zY3JpcHQ6ICdub3NjcmlwdCcsXG4gIG9iamVjdDogJ29iamVjdCcsXG4gIG9sOiAnb2wnLFxuICBvcHRncm91cDogJ29wdGdyb3VwJyxcbiAgb3B0aW9uOiAnb3B0aW9uJyxcbiAgb3V0cHV0OiAnb3V0cHV0JyxcbiAgcDogJ3AnLFxuICBwYXJhbTogJ3BhcmFtJyxcbiAgcGljdHVyZTogJ3BpY3R1cmUnLFxuICBwcmU6ICdwcmUnLFxuICBwcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgcTogJ3EnLFxuICBycDogJ3JwJyxcbiAgcnQ6ICdydCcsXG4gIHJ1Ynk6ICdydWJ5JyxcbiAgczogJ3MnLFxuICBzYW1wOiAnc2FtcCcsXG4gIHNjcmlwdDogJ3NjcmlwdCcsXG4gIHNlY3Rpb246ICdzZWN0aW9uJyxcbiAgc2VsZWN0OiAnc2VsZWN0JyxcbiAgc21hbGw6ICdzbWFsbCcsXG4gIHNvdXJjZTogJ3NvdXJjZScsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3Ryb25nOiAnc3Ryb25nJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1YjogJ3N1YicsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgc3VwOiAnc3VwJyxcbiAgdGFibGU6ICd0YWJsZScsXG4gIHRib2R5OiAndGJvZHknLFxuICB0ZDogJ3RkJyxcbiAgdGV4dGFyZWE6ICd0ZXh0YXJlYScsXG4gIHRmb290OiAndGZvb3QnLFxuICB0aDogJ3RoJyxcbiAgdGhlYWQ6ICd0aGVhZCcsXG4gIHRpbWU6ICd0aW1lJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHRyOiAndHInLFxuICB0cmFjazogJ3RyYWNrJyxcbiAgdTogJ3UnLFxuICB1bDogJ3VsJyxcbiAgJ3Zhcic6ICd2YXInLFxuICB2aWRlbzogJ3ZpZGVvJyxcbiAgd2JyOiAnd2JyJyxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiAnY2lyY2xlJyxcbiAgY2xpcFBhdGg6ICdjbGlwUGF0aCcsXG4gIGRlZnM6ICdkZWZzJyxcbiAgZWxsaXBzZTogJ2VsbGlwc2UnLFxuICBnOiAnZycsXG4gIGltYWdlOiAnaW1hZ2UnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBFcnJvcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHVwZGF0ZWQgd2l0aCBgdXBkYXRlUHJvcGVydHlCeUlEKClgLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMgPSB7XG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlSW5uZXJIVE1MQnlJRCgpYC4nLFxuICBzdHlsZTogJ2BzdHlsZWAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZVN0eWxlc0J5SUQoKWAuJ1xufTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgcHJvcGVydHkgdmFsdWVzLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG9cbiAgICogdXBkYXRlIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdmFsaWQgcHJvcGVydHkgbmFtZSwgc2VlIGBET01Qcm9wZXJ0eWAuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVQcm9wZXJ0eUJ5SUQ6IGZ1bmN0aW9uIChpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgISFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLCBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIERPTSBub2RlIHRoYXQgZXhpc3RzIGluIHRoZSBkb2N1bWVudCB3aXRoIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGNoaWxkIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIERhbmdlcm91cyBtYXJrdXAgdG8gaW5qZWN0IGluIHBsYWNlIG9mIGNoaWxkLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwfVxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBmdW5jdGlvbiAoaWQsIG1hcmt1cCkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAobm9kZSwgbWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHVwZGF0ZXMsIG1hcmt1cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlc1tpXS5wYXJlbnROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHVwZGF0ZXNbaV0ucGFyZW50SUQpO1xuICAgIH1cbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXModXBkYXRlcywgbWFya3VwKTtcbiAgfVxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NSURPcGVyYXRpb25zLCAnUmVhY3RET01JRE9wZXJhdGlvbnMnLCB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCcsXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICBtb3VudFJlYWR5V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBDYW4ndCBiZSBpbiBtb3VudFdyYXBwZXIgb3IgZWxzZSBzZXJ2ZXIgcmVuZGVyaW5nIGxlYWtzLlxuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXSA9IGluc3Q7XG4gIH0sXG5cbiAgdW5tb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHdpdGggbm9uLVJlYWN0LlxuICAgICAgdmFyIG90aGVySUQgPSBSZWFjdE1vdW50LmdldElEKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArICdzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gaW5zdGFuY2VzQnlSZWFjdElEW290aGVySURdO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJywgb3RoZXJJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9IFJlYWN0RE9NU2VsZWN0LnZhbHVlQ29udGV4dEtleTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJyB2aWEgY29udGV4dFxuICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNvbnRleHRbdmFsdWVDb250ZXh0S2V5XTtcblxuICAgIC8vIElmIGNvbnRleHQga2V5IGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09ICcnICsgcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSAnJyArIHByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBuYXRpdmVQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG5hdGl2ZVByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gJ19fUmVhY3RET01TZWxlY3RfdmFsdWUkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBwcm9wcywgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICB2YWx1ZUNvbnRleHRLZXk6IHZhbHVlQ29udGV4dEtleSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcbiAgfSxcblxuICBwcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBQYXNzIGRvd24gaW5pdGlhbCB2YWx1ZSBzbyBpbml0aWFsIGdlbmVyYXRlZCBtYXJrdXAgaGFzIGNvcnJlY3RcbiAgICAvLyBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBjaGlsZENvbnRleHRbdmFsdWVDb250ZXh0S2V5XSA9IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gICAgcmV0dXJuIGNoaWxkQ29udGV4dDtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoZSBjb250ZXh0IHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSB0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlcnZlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RhdGljTWFya3VwLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZXJ2ZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAvLyBUaGlzIGNvbnN0cnVjdG9yIGFuZCBpdHMgYXJndW1lbnQgaXMgY3VycmVudGx5IHVzZWQgYnkgbW9ja3MuXG59O1xuXG5hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICAgIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnc3BhbicsIG51bGwsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgcm9vdElEKTtcbiAgICAgIC8vIFBvcHVsYXRlIG5vZGUgY2FjaGVcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoZWwpO1xuICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIHRoaXMuX3N0cmluZ1RleHQpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksXG4gICAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICsgZXNjYXBlZFRleHQgKyAnPC9zcGFuPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50KG5vZGUsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgLy8gV2Ugc2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZSBzbyB0aGF0IGBSZWFjdERPTUNvbXBvbmVudGAgZG9lc24ndCB1cGRhdGVcbiAgICAgIC8vIGB0ZXh0Q29udGVudGAgKHVubmVjZXNzYXJ5IHNpbmNlIHdlIHVwZGF0ZSB2YWx1ZSkuXG4gICAgICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3NcbiAgICAgIC8vIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyAodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vQ2xpZW50UmVhY3RSb290SW5kZXgnKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vU2VydmVyUmVhY3RSb290SW5kZXgnKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gICAgaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gICAgICB2YXIgUmVhY3REZWZhdWx0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZicpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcblxuZnVuY3Rpb24gcm91bmRGbG9hdCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUob2JqLCBrZXksIHZhbCkge1xuICBvYmpba2V5XSA9IChvYmpba2V5XSB8fCAwKSArIHZhbDtcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmYgPSB7XG4gIF9hbGxNZWFzdXJlbWVudHM6IFtdLCAvLyBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgdGhlIGN1cnJlbnQgb25lXG4gIF9tb3VudFN0YWNrOiBbMF0sXG4gIF9pbmplY3RlZDogZmFsc2UsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0TGFzdE1lYXN1cmVtZW50czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gIH0sXG5cbiAgcHJpbnRFeGNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQ29tcG9uZW50IGNsYXNzIG5hbWUnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdUb3RhbCBpbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmluY2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgbW91bnQgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgcmVuZGVyIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIpLFxuICAgICAgICAnTW91bnQgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ1JlbmRlciB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgLy8gVE9ETzogUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZSgpIGRvZXMgbm90IHJldHVybiB0aGUgY29ycmVjdFxuICAgIC8vIG51bWJlci5cbiAgfSxcblxuICBwcmludEluY2x1c2l2ZTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBnZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIHRydWUpO1xuICAgIHJldHVybiBzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnV2FzdGVkIHRpbWUgKG1zKSc6IGl0ZW0udGltZSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgcHJpbnRXYXN0ZWQ6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIGNvbnNvbGUudGFibGUoUmVhY3REZWZhdWx0UGVyZi5nZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwKG1lYXN1cmVtZW50cykpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIHByaW50RE9NOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0W0RPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FXSA9IGl0ZW0uaWQ7XG4gICAgICByZXN1bHQudHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgIHJlc3VsdC5hcmdzID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5hcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIF9yZWNvcmRXcml0ZTogZnVuY3Rpb24gKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgYXJncykge1xuICAgIC8vIFRPRE86IHRvdGFsVGltZSBpc24ndCB0aGF0IHVzZWZ1bCBzaW5jZSBpdCBkb2Vzbid0IGNvdW50IHBhaW50cy9yZWZsb3dzXG4gICAgdmFyIHdyaXRlcyA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0ud3JpdGVzO1xuICAgIHdyaXRlc1tpZF0gPSB3cml0ZXNbaWRdIHx8IFtdO1xuICAgIHdyaXRlc1tpZF0ucHVzaCh7XG4gICAgICB0eXBlOiBmbk5hbWUsXG4gICAgICB0aW1lOiB0b3RhbFRpbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxUaW1lO1xuICAgICAgdmFyIHJ2O1xuICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICBpZiAoZm5OYW1lID09PSAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnIHx8IGZuTmFtZSA9PT0gJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnKSB7XG4gICAgICAgIC8vIEEgXCJtZWFzdXJlbWVudFwiIGlzIGEgc2V0IG9mIG1ldHJpY3MgcmVjb3JkZWQgZm9yIGVhY2ggZmx1c2guIFdlIHdhbnRcbiAgICAgICAgLy8gdG8gZ3JvdXAgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gZmx1c2ggdG9nZXRoZXIgc28gd2UgY2FuIGxvb2sgYXQgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCBhbmQgdGhlIERPTSBvcGVyYXRpb25zIHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gaGFwcGVuZWQgdG8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgXCJ3YXN0ZWQgd29ya1wiIHBlcmZvcm1lZC5cbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGV4Y2x1c2l2ZToge30sXG4gICAgICAgICAgaW5jbHVzaXZlOiB7fSxcbiAgICAgICAgICByZW5kZXI6IHt9LFxuICAgICAgICAgIGNvdW50czoge30sXG4gICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICBkaXNwbGF5TmFtZXM6IHt9LFxuICAgICAgICAgIHRvdGFsVGltZTogMCxcbiAgICAgICAgICBjcmVhdGVkOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0udG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdERPTUlET3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0NTU1Byb3BlcnR5T3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTUNoaWxkcmVuT3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycpIHtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoZm5OYW1lID09PSAnX21vdW50SW1hZ2VJbnRvTm9kZScpIHtcbiAgICAgICAgICB2YXIgbW91bnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1sxXSk7XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUobW91bnRJRCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZvcm1hdFxuICAgICAgICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVBcmdzID0ge307XG4gICAgICAgICAgICBpZiAodXBkYXRlLmZyb21JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MuZnJvbUluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudG9JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudG9JbmRleCA9IHVwZGF0ZS50b0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudGV4dENvbnRlbnQgPSB1cGRhdGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLm1hcmt1cEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5tYXJrdXAgPSBhcmdzWzFdW3VwZGF0ZS5tYXJrdXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZSh1cGRhdGUucGFyZW50SUQsIHVwZGF0ZS50eXBlLCB0b3RhbFRpbWUsIHdyaXRlQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFzaWMgZm9ybWF0XG4gICAgICAgICAgdmFyIGlkID0gYXJnc1swXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcgJiYgKGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICd1cGRhdGVDb21wb25lbnQnIHx8IC8vIFRPRE86IHJlY2VpdmVDb21wb25lbnQoKT9cbiAgICAgIGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnKSkge1xuXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlID09PSBSZWFjdE1vdW50LlRvcExldmVsV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3ROb2RlSUQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgPyBhcmdzWzBdIDogdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgICAgdmFyIGlzUmVuZGVyID0gZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCc7XG4gICAgICAgIHZhciBpc01vdW50ID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBtb3VudFN0YWNrID0gUmVhY3REZWZhdWx0UGVyZi5fbW91bnRTdGFjaztcbiAgICAgICAgdmFyIGVudHJ5ID0gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5jb3VudHMsIHJvb3ROb2RlSUQsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICBlbnRyeS5jcmVhdGVkW3Jvb3ROb2RlSURdID0gdHJ1ZTtcbiAgICAgICAgICBtb3VudFN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LnJlbmRlciwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgdmFyIHN1Yk1vdW50VGltZSA9IG1vdW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgbW91bnRTdGFja1ttb3VudFN0YWNrLmxlbmd0aCAtIDFdICs9IHRvdGFsVGltZTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5leGNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSAtIHN1Yk1vdW50VGltZSk7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5LmRpc3BsYXlOYW1lc1tyb290Tm9kZUlEXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiB0aGlzLmdldE5hbWUoKSxcbiAgICAgICAgICBvd25lcjogdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyID8gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSA6ICc8cm9vdD4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxuLy8gRG9uJ3QgdHJ5IHRvIHNhdmUgdXNlcnMgbGVzcyB0aGFuIDEuMm1zIChhIG51bWJlciBJIG1hZGUgdXApXG52YXIgRE9OVF9DQVJFX1RIUkVTSE9MRCA9IDEuMjtcbnZhciBET01fT1BFUkFUSU9OX1RZUEVTID0ge1xuICAnX21vdW50SW1hZ2VJbnRvTm9kZSc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgSU5TRVJUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBNT1ZFX0VYSVNUSU5HOiAnbW92ZScsXG4gIFJFTU9WRV9OT0RFOiAncmVtb3ZlJyxcbiAgU0VUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBURVhUX0NPTlRFTlQ6ICdzZXQgdGV4dENvbnRlbnQnLFxuICAnc2V0VmFsdWVGb3JQcm9wZXJ0eSc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ3NldFZhbHVlRm9yQXR0cmlidXRlJzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSc6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCc6ICdyZXBsYWNlJ1xufTtcblxuZnVuY3Rpb24gZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykge1xuICAvLyBUT0RPOiByZXR1cm4gbnVtYmVyIG9mIERPTSBvcHM/IGNvdWxkIGJlIG1pc2xlYWRpbmcuXG4gIC8vIFRPRE86IG1lYXN1cmUgZHJvcHBlZCBmcmFtZXMgYWZ0ZXIgcmVjb25jaWxlP1xuICAvLyBUT0RPOiBsb2cgdG90YWwgdGltZSBvZiBlYWNoIHJlY29uY2lsZSBhbmQgdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgLy8gY2xhc3MgdGhhdCB0cmlnZ2VyZWQgaXQuXG4gIHZhciB0b3RhbFRpbWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB0b3RhbFRpbWUgKz0gbWVhc3VyZW1lbnQudG90YWxUaW1lO1xuICB9XG4gIHJldHVybiB0b3RhbFRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBtZWFzdXJlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZW1lbnQpIHtcbiAgICBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBtZWFzdXJlbWVudC53cml0ZXNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0eXBlOiBET01fT1BFUkFUSU9OX1RZUEVTW3dyaXRlLnR5cGVdIHx8IHdyaXRlLnR5cGUsXG4gICAgICAgICAgYXJnczogd3JpdGUuYXJnc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgZGlzcGxheU5hbWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF0uY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gPSBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbmNsdXNpdmU6IDAsXG4gICAgICAgIGV4Y2x1c2l2ZTogMCxcbiAgICAgICAgcmVuZGVyOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWFzdXJlbWVudC5yZW5kZXJbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLnJlbmRlciArPSBtZWFzdXJlbWVudC5yZW5kZXJbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlICs9IG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5pbmNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGRpc3BsYXlOYW1lIGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmV4Y2x1c2l2ZSAtIGEuZXhjbHVzaXZlO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgb25seUNsZWFuKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBpbmNsdXNpdmVLZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuICAgIHZhciBjbGVhbkNvbXBvbmVudHM7XG5cbiAgICBpZiAob25seUNsZWFuKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHMgPSBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGlmIChvbmx5Q2xlYW4gJiYgIWNsZWFuQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF07XG5cbiAgICAgIC8vIEluY2x1c2l2ZSB0aW1lIGlzIG5vdCB1c2VmdWwgZm9yIG1hbnkgY29tcG9uZW50cyB3aXRob3V0IGtub3dpbmcgd2hlcmVcbiAgICAgIC8vIHRoZXkgYXJlIGluc3RhbnRpYXRlZC4gU28gd2UgYWdncmVnYXRlIGluY2x1c2l2ZSB0aW1lIHdpdGggYm90aCB0aGVcbiAgICAgIC8vIG93bmVyIGFuZCBjdXJyZW50IGRpc3BsYXlOYW1lIGFzIHRoZSBrZXkuXG4gICAgICBpbmNsdXNpdmVLZXkgPSBkaXNwbGF5TmFtZS5vd25lciArICcgPiAnICsgZGlzcGxheU5hbWUuY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldID0gY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogaW5jbHVzaXZlS2V5LFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChpbmNsdXNpdmVLZXkgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCkge1xuICAvLyBGb3IgYSBnaXZlbiByZWNvbmNpbGUsIGxvb2sgYXQgd2hpY2ggY29tcG9uZW50cyBkaWQgbm90IGFjdHVhbGx5XG4gIC8vIHJlbmRlciBhbnl0aGluZyB0byB0aGUgRE9NIGFuZCByZXR1cm4gYSBtYXBwaW5nIG9mIHRoZWlyIElEIHRvXG4gIC8vIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIHJlbmRlciB0aGUgZW50aXJlIHN1YnRyZWUuXG4gIHZhciBjbGVhbkNvbXBvbmVudHMgPSB7fTtcbiAgdmFyIGRpcnR5TGVhZklEcyA9IE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcyk7XG4gIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuICAgIC8vIEZvciBlYWNoIGNvbXBvbmVudCB0aGF0IHJlbmRlcmVkLCBzZWUgaWYgYSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICAvLyBhIERPTSBvcCBpcyBpbiBpdHMgc3VidHJlZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5TGVhZklEcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpcnR5TGVhZklEc1tpXS5pbmRleE9mKGlkKSA9PT0gMCkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGNvbXBvbmVudCBuZXdseSBjcmVhdGVkXG4gICAgaWYgKG1lYXN1cmVtZW50LmNyZWF0ZWRbaWRdKSB7XG4gICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmIG1lYXN1cmVtZW50LmNvdW50c1tpZF0gPiAwKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuQ29tcG9uZW50cztcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHtcbiAgZ2V0RXhjbHVzaXZlU3VtbWFyeTogZ2V0RXhjbHVzaXZlU3VtbWFyeSxcbiAgZ2V0SW5jbHVzaXZlU3VtbWFyeTogZ2V0SW5jbHVzaXZlU3VtbWFyeSxcbiAgZ2V0RE9NU3VtbWFyeTogZ2V0RE9NU3VtbWFyeSxcbiAgZ2V0VG90YWxUaW1lOiBnZXRUb3RhbFRpbWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBlbGVtZW50cy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIHJlZiA9IGNvbmZpZy5yZWYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcucmVmO1xuICAgIGtleSA9IGNvbmZpZy5rZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAnJyArIGNvbmZpZy5rZXk7XG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdQcm9wcykge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG9sZEVsZW1lbnQua2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgbmV3UHJvcHMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSWYgdGhlIGtleSBvbiB0aGUgb3JpZ2luYWwgaXMgdmFsaWQsIHRoZW4gdGhlIGNsb25lIGlzIHZhbGlkXG4gICAgbmV3RWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICB9XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGFkZGVuZGEgPSBnZXRBZGRlbmRhRm9yS2V5VXNlKCd1bmlxdWVLZXknLCBlbGVtZW50LCBwYXJlbnRUeXBlKTtcbiAgaWYgKGFkZGVuZGEgPT09IG51bGwpIHtcbiAgICAvLyB3ZSBhbHJlYWR5IHNob3dlZCB0aGUgd2FybmluZ1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyVzJywgYWRkZW5kYS5wYXJlbnRPck93bmVyIHx8ICcnLCBhZGRlbmRhLmNoaWxkT3duZXIgfHwgJycsIGFkZGVuZGEudXJsIHx8ICcnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlIEEga2V5IHVzZWQgZm9yIGRlLWR1cGluZyB3YXJuaW5ncy5cbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICogQHJldHVybnMgez9vYmplY3R9IEEgc2V0IG9mIGFkZGVuZGEgdG8gdXNlIGluIHRoZSB3YXJuaW5nIG1lc3NhZ2UsIG9yIG51bGxcbiAqIGlmIHRoZSB3YXJuaW5nIGhhcyBhbHJlYWR5IGJlZW4gc2hvd24gYmVmb3JlIChhbmQgc2hvdWxkbid0IGJlIHNob3duIGFnYWluKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWRkZW5kYUZvcktleVVzZShtZXNzYWdlVHlwZSwgZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgaWYgKCFhZGRlbmR1bSkge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBhZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gfHwgKG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gPSB7fSk7XG4gIGlmIChtZW1vaXplclthZGRlbmR1bV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtZW1vaXplclthZGRlbmR1bV0gPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0ge1xuICAgIHBhcmVudE9yT3duZXI6IGFkZGVuZHVtLFxuICAgIHVybDogJyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICBjaGlsZE93bmVyOiBudWxsXG4gIH07XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgYWRkZW5kYS5jaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVuZGE7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgcHJvcFR5cGVzLCBwcm9wcywgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUsIHR5cGVvZiBlcnJvcikgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKG5hbWUsIGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh2YWxpZFR5cGUsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG52YXIgcGxhY2Vob2xkZXJFbGVtZW50O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBwbGFjZWhvbGRlckVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlKHBsYWNlaG9sZGVyRWxlbWVudCk7XG59O1xuYXNzaWduKFJlYWN0RW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHt9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQocm9vdElEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICB9XG59KTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SURzUmVnaXN0cnkgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gISFudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVbm1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbDogaXQgcmVuZGVycyB0byBzb21ldGhpbmcgbm93LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgZGVsZXRlIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSB7XG4gIGlzTnVsbENvbXBvbmVudElEOiBpc051bGxDb21wb25lbnRJRCxcbiAgcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IHJlZ2lzdGVyTnVsbENvbXBvbmVudElELFxuICBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoYSwgYik7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSwgYikge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhLCBiKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgZW52aXJvbm1lbnQgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIC8vIFRPRE86IFJlLWVuYWJsZSBldmVudC5wYXRoIGhhbmRsaW5nXG4gIC8vXG4gIC8vIGlmIChib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoICYmIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGgubGVuZ3RoID4gMSkge1xuICAvLyAgIC8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9XG5cbiAgdm9pZCBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoOyAvLyB0ZW1wb3JhcmlseSB1bnVzZWRcbiAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG59XG5cbi8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZykge1xuICB2YXIgdG9wTGV2ZWxUYXJnZXQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZykge1xuICB2YXIgcGF0aCA9IGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGg7XG4gIHZhciBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFswXTtcbiAgdmFyIGV2ZW50c0ZpcmVkID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSB7XG4gICAgICBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFtpICsgMV07XG4gICAgfVxuICAgIC8vIFRPRE86IHNsb3dcbiAgICB2YXIgcmVhY3RQYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICBpZiAocmVhY3RQYXJlbnQgPT09IGN1cnJlbnRQYXRoRWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgdmFyIG5ld1Jvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjdXJyZW50UGF0aEVsZW1lbnRJRCk7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChjdXJyZW50UGF0aEVsZW1lbnQpO1xuXG4gICAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KSB8fCAnJztcbiAgICAgIGV2ZW50c0ZpcmVkKys7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgY3VycmVudFBhdGhFbGVtZW50LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgY3VycmVudE5hdGl2ZVRhcmdldCk7XG5cbiAgICAgIC8vIEp1bXAgdG8gdGhlIHJvb3Qgb2YgdGhpcyBSZWFjdCByZW5kZXIgdHJlZVxuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoRWxlbWVudElEICE9PSBuZXdSb290SUQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50c0ZpcmVkID09PSAwKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHdpbmRvdywgJycsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEZyYWdtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogV2UgdXNlZCB0byBhbGxvdyBrZXllZCBvYmplY3RzIHRvIHNlcnZlIGFzIGEgY29sbGVjdGlvbiBvZiBSZWFjdEVsZW1lbnRzLFxuICogb3IgbmVzdGVkIHNldHMuIFRoaXMgYWxsb3dlZCB1cyBhIHdheSB0byBleHBsaWNpdGx5IGtleSBhIHNldCBhIGZyYWdtZW50IG9mXG4gKiBjb21wb25lbnRzLiBUaGlzIGlzIG5vdyBiZWluZyByZXBsYWNlZCB3aXRoIGFuIG9wYXF1ZSBkYXRhIHN0cnVjdHVyZS5cbiAqIFRoZSB1cGdyYWRlIHBhdGggaXMgdG8gY2FsbCBSZWFjdC5hZGRvbnMuY3JlYXRlRnJhZ21lbnQoeyBrZXk6IHZhbHVlIH0pIHRvXG4gKiBjcmVhdGUgYSBrZXllZCBmcmFnbWVudC4gVGhlIHJlc3VsdGluZyBkYXRhIHN0cnVjdHVyZSBpcyBhbiBhcnJheS5cbiAqL1xuXG52YXIgbnVtZXJpY1Byb3BlcnR5UmVnZXggPSAvXlxcZCskLztcblxudmFyIHdhcm5lZEFib3V0TnVtZXJpYyA9IGZhbHNlO1xuXG52YXIgUmVhY3RGcmFnbWVudCA9IHtcbiAgLy8gV3JhcCBhIGtleWVkIG9iamVjdCBpbiBhbiBvcGFxdWUgcHJveHkgdGhhdCB3YXJucyB5b3UgaWYgeW91IGFjY2VzcyBhbnlcbiAgLy8gb2YgaXRzIHByb3BlcnRpZXMuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCAhb2JqZWN0IHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5hZGRvbnMuY3JlYXRlRnJhZ21lbnQgb25seSBhY2NlcHRzIGEgc2luZ2xlIG9iamVjdC4gR290OiAlcycsIG9iamVjdCkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG9iamVjdCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50IGRvZXMgbm90IGFjY2VwdCBhIFJlYWN0RWxlbWVudCAnICsgJ3dpdGhvdXQgYSB3cmFwcGVyIG9iamVjdC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgIShvYmplY3Qubm9kZVR5cGUgIT09IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCguLi4pOiBFbmNvdW50ZXJlZCBhbiBpbnZhbGlkIGNoaWxkOyBET00gJyArICdlbGVtZW50cyBhcmUgbm90IHZhbGlkIGNoaWxkcmVuIG9mIFJlYWN0IGNvbXBvbmVudHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE51bWVyaWMgJiYgbnVtZXJpY1Byb3BlcnR5UmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5hZGRvbnMuY3JlYXRlRnJhZ21lbnQoLi4uKTogQ2hpbGQgb2JqZWN0cyBzaG91bGQgaGF2ZSAnICsgJ25vbi1udW1lcmljIGtleXMgc28gb3JkZXJpbmcgaXMgcHJlc2VydmVkLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHdhcm5lZEFib3V0TnVtZXJpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlYWN0Q2hpbGRyZW4ubWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChvYmplY3Rba2V5XSwgcmVzdWx0LCBrZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZyYWdtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0TmF0aXZlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vUmVhY3RSb290SW5kZXgnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIE5hdGl2ZUNvbXBvbmVudDogUmVhY3ROYXRpdmVDb21wb25lbnQuaW5qZWN0aW9uLFxuICBQZXJmOiBSZWFjdFBlcmYuaW5qZWN0aW9uLFxuICBSb290SW5kZXg6IFJlYWN0Um9vdEluZGV4LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgKGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTRVBBUkFUT1JfTEVOR1RIID0gU0VQQVJBVE9SLmxlbmd0aDtcblxuLyoqXG4gKiBNYXhpbXVtIGRlcHRoIG9mIHRyYXZlcnNhbHMgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGJhZCBJRC5cbiAqL1xudmFyIE1BWF9UUkVFX0RFUFRIID0gMTAwMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJiBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBJRCBvZiB0aGUgc3VwcGxpZWQgUmVhY3QgRE9NIElELCBgaWRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHBhcmVudCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SUQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKFNFUEFSQVRPUikpIDogJyc7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCBET00gSUQgb24gdGhlIHRyZWUgcGF0aCBmcm9tIHRoZSBzdXBwbGllZCBgYW5jZXN0b3JJRGAgdG8gdGhlXG4gKiBzdXBwbGllZCBgZGVzdGluYXRpb25JRGAuIElmIHRoZXkgYXJlIGVxdWFsLCB0aGUgSUQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySUQgSUQgb2YgYW4gYW5jZXN0b3Igbm9kZSBvZiBgZGVzdGluYXRpb25JRGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25JRCBJRCBvZiB0aGUgZGVzdGluYXRpb24gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBJRCBvbiB0aGUgcGF0aCBmcm9tIGBhbmNlc3RvcklEYCB0byBgZGVzdGluYXRpb25JRGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXROZXh0RGVzY2VuZGFudElEKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIHtcbiAgIShpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKCVzLCAlcyk6IFJlY2VpdmVkIGFuIGludmFsaWQgUmVhY3QgRE9NIElELicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgKyAndGhlIERPTSBoaWVyYXJjaHkuIEV4cGVjdGVkIGAlc2AgdG8gYmUgYW4gYW5jZXN0b3Igb2YgYCVzYC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChhbmNlc3RvcklEID09PSBkZXN0aW5hdGlvbklEKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ySUQ7XG4gIH1cbiAgLy8gU2tpcCBvdmVyIHRoZSBhbmNlc3RvciBhbmQgdGhlIGltbWVkaWF0ZSBzZXBhcmF0b3IuIFRyYXZlcnNlIHVudGlsIHdlIGhpdFxuICAvLyBhbm90aGVyIHNlcGFyYXRvciBvciB3ZSByZWFjaCB0aGUgZW5kIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAgdmFyIHN0YXJ0ID0gYW5jZXN0b3JJRC5sZW5ndGggKyBTRVBBUkFUT1JfTEVOR1RIO1xuICB2YXIgaTtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBkZXN0aW5hdGlvbklELmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkoZGVzdGluYXRpb25JRCwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25JRC5zdWJzdHIoMCwgaSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgb2YgdHdvIElEcy5cbiAqXG4gKiBVc2luZyB0aGlzIElEIHNjaGVtZSwgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIGlzIHRoZSBsb25nZXN0IGNvbW1vblxuICogcHJlZml4IG9mIHRoZSB0d28gSURzIHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYSBcIm1hcmtlclwiIGluIGJvdGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB0d29JRFxuICogQHJldHVybiB7c3RyaW5nfSBOZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCwgb3IgdGhlIGVtcHR5IHN0cmluZyBpZiBub25lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKG9uZUlELCB0d29JRCkge1xuICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4ob25lSUQubGVuZ3RoLCB0d29JRC5sZW5ndGgpO1xuICBpZiAobWluTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0Q29tbW9uTWFya2VySW5kZXggPSAwO1xuICAvLyBVc2UgYDw9YCB0byB0cmF2ZXJzZSB1bnRpbCB0aGUgXCJFT0xcIiBvZiB0aGUgc2hvcnRlciBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkob25lSUQsIGkpICYmIGlzQm91bmRhcnkodHdvSUQsIGkpKSB7XG4gICAgICBsYXN0Q29tbW9uTWFya2VySW5kZXggPSBpO1xuICAgIH0gZWxzZSBpZiAob25lSUQuY2hhckF0KGkpICE9PSB0d29JRC5jaGFyQXQoaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbG9uZ2VzdENvbW1vbklEID0gb25lSUQuc3Vic3RyKDAsIGxhc3RDb21tb25NYXJrZXJJbmRleCk7XG4gICFpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJywgb25lSUQsIHR3b0lELCBsb25nZXN0Q29tbW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAhKHN0YXJ0ICE9PSBzdG9wKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsIHN0YXJ0KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAhKHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDs7IC8qIHVudGlsIGJyZWFrICovaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhKGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogRGV0ZWN0ZWQgYW4gaW5maW5pdGUgbG9vcCB3aGlsZSAnICsgJ3RyYXZlcnNpbmcgdGhlIFJlYWN0IERPTSBJRCB0cmVlLiBUaGlzIG1heSBiZSBkdWUgdG8gbWFsZm9ybWVkIElEczogJXMnLCBzdGFydCwgc3RvcCwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIElEcyBhc3NpZ25lZCB0byBET00gcmVwcmVzZW50YXRpb25zIG9mIFJlYWN0IGNvbXBvbmVudHMuIFRoaXNcbiAqIHVzZXMgYSBzcGVjaWZpYyBzY2hlbWUgaW4gb3JkZXIgdG8gdHJhdmVyc2UgdGhlIERPTSBlZmZpY2llbnRseSAoZS5nLiBpblxuICogb3JkZXIgdG8gc2ltdWxhdGUgZXZlbnRzKS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3Qgcm9vdCBJRFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3Qgcm9vdCBJRC5cbiAgICovXG4gIGNyZWF0ZVJlYWN0Um9vdElEOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uIChyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoU0VQQVJBVE9SLCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaWQuc3Vic3RyKDAsIGluZGV4KSA6IGlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gICAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAgICpcbiAgICogTk9URTogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZVxuICAgKiBub3RoaW5nIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYXZlSUQgSUQgYmVpbmcgbGVmdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudGVySUQgSUQgYmVpbmcgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZW50ZXJlZC9sZWZ0IElELlxuICAgKiBAcGFyYW0geyp9IHVwQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBsZWZ0IElEcy5cbiAgICogQHBhcmFtIHsqfSBkb3duQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBlbnRlcmVkIElEcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGB0cmF2ZXJzZVR3b1BoYXNlYCBidXQgc2tpcHMgdGhlIGB0YXJnZXRJRGAuXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldDogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2UgYSBub2RlIElELCBjYWxsaW5nIHRoZSBzdXBwbGllZCBgY2JgIGZvciBlYWNoIGFuY2VzdG9yIElELiBGb3JcbiAgICogZXhhbXBsZSwgcGFzc2luZyBgLjAuJHJvdy0wLjFgIHdvdWxkIHJlc3VsdCBpbiBgY2JgIGdldHRpbmcgY2FsbGVkXG4gICAqIHdpdGggYC4wYCwgYC4wLiRyb3ctMGAsIGFuZCBgLjAuJHJvdy0wLjFgLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcblxuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2U7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElzb21vcnBoaWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIEhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZyBlbHNlLlxuICBfX3NwcmVhZDogYXNzaWduXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdExpbmtcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0TGluayBlbmNhcHN1bGF0ZXMgYSBjb21tb24gcGF0dGVybiBpbiB3aGljaCBhIGNvbXBvbmVudCB3YW50cyB0byBtb2RpZnlcbiAqIGEgcHJvcCByZWNlaXZlZCBmcm9tIGl0cyBwYXJlbnQuIFJlYWN0TGluayBhbGxvd3MgdGhlIHBhcmVudCB0byBwYXNzIGRvd24gYVxuICogdmFsdWUgY291cGxlZCB3aXRoIGEgY2FsbGJhY2sgdGhhdCwgd2hlbiBpbnZva2VkLCBleHByZXNzZXMgYW4gaW50ZW50IHRvXG4gKiBtb2RpZnkgdGhhdCB2YWx1ZS4gRm9yIGV4YW1wbGU6XG4gKlxuICogUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiB7dmFsdWU6ICcnfTtcbiAqICAgfSxcbiAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICB2YXIgdmFsdWVMaW5rID0gbmV3IFJlYWN0TGluayh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLl9oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gKiAgICAgcmV0dXJuIDxpbnB1dCB2YWx1ZUxpbms9e3ZhbHVlTGlua30gLz47XG4gKiAgIH0sXG4gKiAgIF9oYW5kbGVWYWx1ZUNoYW5nZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAqICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogbmV3VmFsdWV9KTtcbiAqICAgfVxuICogfSk7XG4gKlxuICogV2UgaGF2ZSBwcm92aWRlZCBzb21lIHN1Z2FyeSBtaXhpbnMgdG8gbWFrZSB0aGUgY3JlYXRpb24gYW5kXG4gKiBjb25zdW1wdGlvbiBvZiBSZWFjdExpbmsgZWFzaWVyOyBzZWUgTGlua2VkVmFsdWVVdGlscyBhbmQgTGlua2VkU3RhdGVNaXhpbi5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBsaW5rXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXF1ZXN0Q2hhbmdlIGNhbGxiYWNrIHRvIHJlcXVlc3QgYSBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gUmVhY3RMaW5rKHZhbHVlLCByZXF1ZXN0Q2hhbmdlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5yZXF1ZXN0Q2hhbmdlID0gcmVxdWVzdENoYW5nZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJvcFR5cGUgdGhhdCBlbmZvcmNlcyB0aGUgUmVhY3RMaW5rIEFQSSBhbmQgb3B0aW9uYWxseSBjaGVja3MgdGhlXG4gKiB0eXBlIG9mIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgaW5zaWRlIHRoZSBsaW5rLiBFeGFtcGxlOlxuICpcbiAqIE15Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAqICAgdGFiSW5kZXhMaW5rOiBSZWFjdExpbmsuUHJvcFR5cGVzLmxpbmsoUmVhY3QuUHJvcFR5cGVzLm51bWJlcilcbiAqIH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlua1R5cGVDaGVja2VyKGxpbmtUeXBlKSB7XG4gIHZhciBzaGFwZXMgPSB7XG4gICAgdmFsdWU6IHR5cGVvZiBsaW5rVHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC5Qcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQgOiBsaW5rVHlwZS5pc1JlcXVpcmVkLFxuICAgIHJlcXVlc3RDaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LlByb3BUeXBlcy5zaGFwZShzaGFwZXMpO1xufVxuXG5SZWFjdExpbmsuUHJvcFR5cGVzID0ge1xuICBsaW5rOiBjcmVhdGVMaW5rVHlwZUNoZWNrZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RMaW5rOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnknKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBub2RlQ2FjaGUgPSB7fTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5ID0gJ19fUmVhY3RNb3VudF9vd25lckRvY3VtZW50JCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuICovXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIGBjb250YWluZXJgIG5vZGVzLiAqL1xudmFyIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKiBfX0RFVl9fLW9ubHkgbWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIHJvb3QgZWxlbWVudHMuICovXG4gIHZhciByb290RWxlbWVudHNCeVJlYWN0Um9vdElEID0ge307XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYnJlYWR0aC1maXJzdCBzZWFyY2ggc3RhdGUgaW4gZmluZENvbXBvbmVudFJvb3QuXG52YXIgZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5ID0gW107XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAhIWlzVmFsaWQoY2FjaGVkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVHdvIHZhbGlkIGJ1dCB1bmVxdWFsIG5vZGVzIHdpdGggdGhlIHNhbWUgYCVzYDogJXMnLCBBVFRSX05BTUUsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpbnN0YW5jZSBBIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0YW5jZSkuX3Jvb3ROb2RlSUQ7XG4gIGlmIChSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuaXNOdWxsQ29tcG9uZW50SUQoaWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaXMgXCJ2YWxpZFwiIGlmIGl0IGlzIGNvbnRhaW5lZCBieSBhIGN1cnJlbnRseSBtb3VudGVkIGNvbnRhaW5lci5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0byBiZSBjb250YWluZWQgYnkgYSBkb2N1bWVudCBpblxuICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGV4cGVjdGVkIElEIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBjb250YWluZWQgYnkgYSBtb3VudGVkIGNvbnRhaW5lci5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChub2RlLCBpZCkge1xuICBpZiAobm9kZSkge1xuICAgICEoaW50ZXJuYWxHZXRJRChub2RlKSA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFVuZXhwZWN0ZWQgbW9kaWZpY2F0aW9uIG9mIGAlc2AnLCBBVFRSX05BTUUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5zTm9kZShjb250YWluZXIsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2F1c2VzIHRoZSBjYWNoZSB0byBmb3JnZXQgYWJvdXQgb25lIFJlYWN0LXNwZWNpZmljIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gZm9yZ2V0LlxuICovXG5mdW5jdGlvbiBwdXJnZUlEKGlkKSB7XG4gIGRlbGV0ZSBub2RlQ2FjaGVbaWRdO1xufVxuXG52YXIgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbChhbmNlc3RvcklEKSB7XG4gIHZhciBhbmNlc3RvciA9IG5vZGVDYWNoZVthbmNlc3RvcklEXTtcbiAgaWYgKGFuY2VzdG9yICYmIGlzVmFsaWQoYW5jZXN0b3IsIGFuY2VzdG9ySUQpKSB7XG4gICAgZGVlcGVzdE5vZGVTb0ZhciA9IGFuY2VzdG9yO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbm9kZSBpc24ndCBwb3B1bGF0ZWQgaW4gdGhlIGNhY2hlLCBzbyBwcmVzdW1hYmx5IG5vbmUgb2YgaXRzXG4gICAgLy8gZGVzY2VuZGFudHMgYXJlLiBCcmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwZXN0IGNhY2hlZCBub2RlIHdob3NlIElEIGlzIGEgcHJlZml4IG9mIGB0YXJnZXRJRGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIFJlYWN0SW5zdGFuY2VIYW5kbGVzLnRyYXZlcnNlQW5jZXN0b3JzKHRhcmdldElELCBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbCk7XG5cbiAgdmFyIGZvdW5kTm9kZSA9IGRlZXBlc3ROb2RlU29GYXI7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICByZXR1cm4gZm91bmROb2RlO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgaWYgKFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgICBjb250ZXh0W293bmVyRG9jdW1lbnRDb250ZXh0S2V5XSA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gZW1wdHlPYmplY3QpIHtcbiAgICAgIGNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGNvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdGFnLCBudWxsKTtcbiAgfVxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgY29tcG9uZW50SW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSBjb21wb25lbnRJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiBmb3JjZUhUTUwgKi9zaG91bGRSZXVzZU1hcmt1cCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIpIHtcbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UpO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQobm9kZSkge1xuICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChub2RlKTtcbiAgcmV0dXJuIHJlYWN0Um9vdElEID8gcmVhY3RSb290SUQgIT09IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCkgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCAoZGVlcGVzdCkgYW5jZXN0b3Igb2YgYSBub2RlIHdoaWNoIGlzIHJlbmRlcmVkIGJ5IHRoaXMgY29weVxuICogb2YgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKSB7XG4gIC8vIFRoaXMgbm9kZSBtaWdodCBiZSBmcm9tIGFub3RoZXIgUmVhY3QgaW5zdGFuY2UsIHNvIHdlIG1ha2Ugc3VyZSBub3QgdG9cbiAgLy8gZXhhbWluZSB0aGUgbm9kZSBjYWNoZSBoZXJlXG4gIGZvciAoOyBub2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBOb3QgYSBET01FbGVtZW50LCB0aGVyZWZvcmUgbm90IGEgUmVhY3QgY29tcG9uZW50XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vZGVJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gICAgaWYgKCFub2RlSUQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQobm9kZUlEKTtcblxuICAgIC8vIElmIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEIGNvbnRhaW5zIHRoZSBjb250YWluZXIgd2UgZmluZCBieSBjcmF3bGluZyB1cFxuICAgIC8vIHRoZSB0cmVlLCB3ZSBrbm93IHRoYXQgdGhpcyBpbnN0YW5jZSBvZiBSZWFjdCByZW5kZXJlZCB0aGUgbm9kZS5cbiAgICAvLyBuYi4gaXNWYWxpZCdzIHN0cmF0ZWd5ICh3aXRoIGNvbnRhaW5zTm9kZSkgZG9lcyBub3Qgd29yayBiZWNhdXNlIHJlbmRlclxuICAgIC8vIHRyZWVzIG1heSBiZSBuZXN0ZWQgYW5kIHdlIGRvbid0IHdhbnQgYSBmYWxzZSBwb3NpdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHZhciBsYXN0SUQ7XG4gICAgZG8ge1xuICAgICAgbGFzdElEID0gaW50ZXJuYWxHZXRJRChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwYXNzZWQtaW4gbm9kZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIHRoZSBjb250YWluZXIgaXQgd2FzXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgcmVuZGVyZWQgaW50by5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSB3aGlsZSAobGFzdElEICE9PSByZWFjdFJvb3RJRCk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMucHJvcHMgaXMgYWN0dWFsbHkgYSBSZWFjdEVsZW1lbnRcbiAgcmV0dXJuIHRoaXMucHJvcHM7XG59O1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqIEV4cG9zZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAqKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IGludG8gdGhlIGluc3RhbmNlIG1hcCBhbmQgc3RhcnRzIHNjcm9sbCB2YWx1ZVxuICAgKiBtb25pdG9yaW5nXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHJldHVybiB7c3RyaW5nfSByZWFjdFJvb3QgSUQgcHJlZml4XG4gICAqL1xuICBfcmVnaXN0ZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50LnJlZ2lzdGVyQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBuZXh0Q29tcG9uZW50O1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50Ll9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIHJlYWN0Um9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVsZW1lbnQgc3RyaW5nLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gbmV3IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHM7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgcGFyZW50Q29tcG9uZW50ICE9IG51bGwgPyBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkgOiBlbXB0eU9iamVjdCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY29udGFpbmVyIG5vZGUgaW50byB3aGljaCBSZWFjdCBjb21wb25lbnRzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIFRoaXMgYWxzbyBjcmVhdGVzIHRoZSBcInJlYWN0Um9vdFwiIElEIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZWxlbWVudFxuICAgKiByZW5kZXJlZCB3aXRoaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGFzIGEgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBcInJlYWN0Um9vdFwiIElEIG9mIGVsZW1lbnRzIHJlbmRlcmVkIHdpdGhpbi5cbiAgICovXG4gIHJlZ2lzdGVyQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICBpZiAocmVhY3RSb290SUQpIHtcbiAgICAgIC8vIElmIG9uZSBleGlzdHMsIG1ha2Ugc3VyZSBpdCBpcyBhIHZhbGlkIFwicmVhY3RSb290XCIgSUQuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCk7XG4gICAgfVxuICAgIGlmICghcmVhY3RSb290SUQpIHtcbiAgICAgIC8vIE5vIHZhbGlkIFwicmVhY3RSb290XCIgSUQgZm91bmQsIGNyZWF0ZSBvbmUuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lcjtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICB2YXIgY29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJJRCA9IGludGVybmFsR2V0SUQoY29udGFpbmVyKTtcbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lcklEICYmIGNvbnRhaW5lcklEID09PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoY29udGFpbmVySUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgY29tcG9uZW50LCBjb250YWluZXIpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBkZWxldGUgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgUmVhY3QgY29tcG9uZW50IHRvIHdoaWNoIHRoZVxuICAgKiBzdXBwbGllZCBET00gYGlkYCBiZWxvbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBgaWRgLlxuICAgKi9cbiAgZmluZFJlYWN0Q29udGFpbmVyRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChpZCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICAgIGlmIChyb290RWxlbWVudCAmJiByb290RWxlbWVudC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAgIC8vIENhbGwgaW50ZXJuYWxHZXRJRCBoZXJlIGJlY2F1c2UgZ2V0SUQgY2FsbHMgaXNWYWxpZCB3aGljaCBjYWxsc1xuICAgICAgICAvLyBmaW5kUmVhY3RDb250YWluZXJGb3JJRCAodGhpcyBmdW5jdGlvbikuXG4gICAgICAgIGludGVybmFsR2V0SUQocm9vdEVsZW1lbnQpID09PSByZWFjdFJvb3RJRCwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBJRCBkaWZmZXJlZCBmcm9tIHJlYWN0Um9vdElELicpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29udGFpbmVyQ2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNvbnRhaW5lckNoaWxkICYmIHJlYWN0Um9vdElEID09PSBpbnRlcm5hbEdldElEKGNvbnRhaW5lckNoaWxkKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIGEgbmV3IGNoaWxkIHdpdGggdGhlIHNhbWUgSUQgYXMgdGhlIG9sZFxuICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCwgdGhlbiByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSBpc1xuICAgICAgICAgIC8vIGp1c3Qgc3RhbGUgYW5kIG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFRoZSBjYXNlIHRoYXQgZGVzZXJ2ZXMgYVxuICAgICAgICAgIC8vIHdhcm5pbmcgaXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIGVtcHR5LlxuICAgICAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyQ2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCAnICsgJ2NvbnRhaW5lci4gTmV3IGNvbnRhaW5lcjogJXMnLCByb290RWxlbWVudC5wYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgUmVhY3Qgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIERPTSBub2RlIGluIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFJvb3QgRE9NIG5vZGUgb2YgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGZpbmRSZWFjdE5vZGVCeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290ID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZmluZENvbXBvbmVudFJvb3QocmVhY3RSb290LCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB1cCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBzdXBwbGllZCBub2RlIHRvIGZpbmQgYSBub2RlIHRoYXQgaXMgYVxuICAgKiBET00gcmVwcmVzZW50YXRpb24gb2YgYSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgYnkgdGhpcyBjb3B5IG9mIFJlYWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGVcbiAgICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEZpcnN0UmVhY3RET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAgaW5zaWRlIG9mIHRoZSBzdXBwbGllZFxuICAgKiBgYW5jZXN0b3JOb2RlYC4gIEV4cGxvaXRzIHRoZSBJRCBuYW1pbmcgc2NoZW1lIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICAgKiBxdWlja2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBhbmNlc3Rvck5vZGUgU2VhcmNoIGZyb20gdGhpcyByb290LlxuICAgKiBAcGFyYXJtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZmluZENvbXBvbmVudFJvb3Q6IGZ1bmN0aW9uIChhbmNlc3Rvck5vZGUsIHRhcmdldElEKSB7XG4gICAgdmFyIGZpcnN0Q2hpbGRyZW4gPSBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXk7XG4gICAgdmFyIGNoaWxkSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlZXBlc3RBbmNlc3RvciA9IGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHx8IGFuY2VzdG9yTm9kZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgb24gdGhlIG5leHQgbGluZTsgZ2l2ZSBhbiBlYXJseSB3YXJuaW5nXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkZWVwZXN0QW5jZXN0b3IgIT0gbnVsbCwgJ1JlYWN0IGNhblxcJ3QgZmluZCB0aGUgcm9vdCBjb21wb25lbnQgbm9kZSBmb3IgZGF0YS1yZWFjdGlkIHZhbHVlICcgKyAnYCVzYC4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMgbWVzc2FnZSwgaXQgcHJvYmFibHkgbWVhbnMgdGhhdCAnICsgJ3lvdVxcJ3ZlIGxvYWRlZCB0d28gY29waWVzIG9mIFJlYWN0IG9uIHRoZSBwYWdlLiBBdCB0aGlzIHRpbWUsIG9ubHkgJyArICdhIHNpbmdsZSBjb3B5IG9mIFJlYWN0IGNhbiBiZSBsb2FkZWQgYXQgYSB0aW1lLicsIHRhcmdldElEKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuWzBdID0gZGVlcGVzdEFuY2VzdG9yLmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAxO1xuXG4gICAgd2hpbGUgKGNoaWxkSW5kZXggPCBmaXJzdENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZHJlbltjaGlsZEluZGV4KytdO1xuICAgICAgdmFyIHRhcmdldENoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSUQgPSBSZWFjdE1vdW50LmdldElEKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSUQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHdlIGZpbmQgdGhlIG5vZGUgd2UncmUgbG9va2luZyBmb3IsIHdlIGZpbmlzaCBsb29waW5nXG4gICAgICAgICAgLy8gdGhyb3VnaCBpdHMgc2libGluZ3MgdG8gZW5zdXJlIHRoZXkncmUgY2FjaGVkIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIHRvIHJldmlzaXQgdGhpcyBub2RlIGFnYWluLiBPdGhlcndpc2UsIHdlIG1ha2Ugbl4yIGNhbGxzIHRvIGdldElEXG4gICAgICAgICAgLy8gd2hlbiB2aXNpdGluZyB0aGUgbWFueSBjaGlsZHJlbiBvZiBhIHNpbmdsZSBub2RlIGluIG9yZGVyLlxuXG4gICAgICAgICAgaWYgKHRhcmdldElEID09PSBjaGlsZElEKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUmVhY3RJbnN0YW5jZUhhbmRsZXMuaXNBbmNlc3RvcklET2YoY2hpbGRJRCwgdGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgY2hpbGQgd2hvc2UgSUQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIElELFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gYmUgc3VyZSB0aGF0IHdlIG9ubHkgd2FudCB0byBzZWFyY2ggdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIC8vIHJvb3RlZCBhdCB0aGlzIGNoaWxkLCBzbyB3ZSBjYW4gdGhyb3cgb3V0IHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2VhcmNoIHN0YXRlLlxuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjaGlsZCBoYWQgbm8gSUQsIHRoZW4gdGhlcmUncyBhIGNoYW5jZSB0aGF0IGl0IHdhc1xuICAgICAgICAgIC8vIGluamVjdGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJyb3dzZXIsIGFzIHdoZW4gYSBgPHRhYmxlPmBcbiAgICAgICAgICAvLyBlbGVtZW50IHNwcm91dHMgYW4gZXh0cmEgYDx0Ym9keT5gIGNoaWxkIGFzIGEgc2lkZSBlZmZlY3Qgb2ZcbiAgICAgICAgICAvLyBgLmlubmVySFRNTGAgcGFyc2luZy4gT3B0aW1pc3RpY2FsbHkgY29udGludWUgZG93biB0aGlzXG4gICAgICAgICAgLy8gYnJhbmNoLCBidXQgbm90IGJlZm9yZSBleGFtaW5pbmcgdGhlIG90aGVyIHNpYmxpbmdzLlxuICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRDaGlsZCkge1xuICAgICAgICAvLyBFbXB0eWluZyBmaXJzdENoaWxkcmVuL2ZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSBpc1xuICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciBjb3JyZWN0bmVzcywgYnV0IGl0IGhlbHBzIHRoZSBHQyByZWNsYWltXG4gICAgICAgIC8vIGFueSBub2RlcyB0aGF0IHdlcmUgbGVmdCBhdCB0aGUgZW5kIG9mIHRoZSBzZWFyY2guXG4gICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q2hpbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRDb21wb25lbnRSb290KC4uLiwgJXMpOiBVbmFibGUgdG8gZmluZCBlbGVtZW50LiBUaGlzIHByb2JhYmx5ICcgKyAnbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSBicm93c2VyKSwgJyArICd1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgbmVzdGluZyB0YWdzICcgKyAnbGlrZSA8Zm9ybT4sIDxwPiwgb3IgPGE+LCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzIGluIGFuIDxzdmc+ICcgKyAncGFyZW50LiAnICsgJ1RyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCB3aXRoIFJlYWN0IElEIGAlc2AuJywgdGFyZ2V0SUQsIFJlYWN0TW91bnQuZ2V0SUQoYW5jZXN0b3JOb2RlKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyAnICsgJ3NlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5ICcgKyAnbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uICcgKyAndGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSAnICsgJ21ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvICcgKyAnY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3UgJyArICdzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzICcgKyAnYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0ICcgKyAneW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgJyArICd3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiAnICsgJ1NlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWFya3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICB9XG4gIH0sXG5cbiAgb3duZXJEb2N1bWVudENvbnRleHRLZXk6IG93bmVyRG9jdW1lbnRDb250ZXh0S2V5LFxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcblxuICBpc1ZhbGlkOiBpc1ZhbGlkLFxuXG4gIHB1cmdlSUQ6IHB1cmdlSURcbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdE1vdW50LCAnUmVhY3RNb3VudCcsIHtcbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6ICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcsXG4gIF9tb3VudEltYWdlSW50b05vZGU6ICdfbW91bnRJbWFnZUludG9Ob2RlJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xuXG4vKipcbiAqIFVwZGF0aW5nIGNoaWxkcmVuIG9mIGEgY29tcG9uZW50IG1heSB0cmlnZ2VyIHJlY3Vyc2l2ZSB1cGRhdGVzLiBUaGUgZGVwdGggaXNcbiAqIHVzZWQgdG8gYmF0Y2ggcmVjdXJzaXZlIHVwZGF0ZXMgdG8gcmVuZGVyIG1hcmt1cCBtb3JlIGVmZmljaWVudGx5LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlRGVwdGggPSAwO1xuXG4vKipcbiAqIFF1ZXVlIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gKlxuICogRWFjaCBvYmplY3QgaGFzIGEgYHR5cGVgIHByb3BlcnR5IHRoYXQgaXMgaW4gYFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzYC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8b2JqZWN0Pn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIFF1ZXVlIG9mIG1hcmt1cCB0byBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXJrdXBRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEVucXVldWVzIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlSW5zZXJ0TWFya3VwKHBhcmVudElELCBtYXJrdXAsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBtYXJrdXBRdWV1ZS5wdXNoKG1hcmt1cCkgLSAxLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlUmVtb3ZlKHBhcmVudElELCBmcm9tSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVNldE1hcmt1cChwYXJlbnRJRCwgbWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVRleHRDb250ZW50KHBhcmVudElELCB0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKHVwZGF0ZVF1ZXVlLCBtYXJrdXBRdWV1ZSk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gIHVwZGF0ZVF1ZXVlLmxlbmd0aCA9IDA7XG4gIG1hcmt1cFF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICAvLyBUT0RPOiBUaGUgc2V0VGV4dENvbnRlbnQgb3BlcmF0aW9uIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV4dENvbnRlbnQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNYXJrdXAobmV4dE1hcmt1cCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEltcHJvdmUgcGVyZm9ybWFuY2UgYnkgaXNvbGF0aW5nIHRoaXMgaG90IGNvZGUgcGF0aCBmcm9tIHRoZSB0cnkvY2F0Y2hcbiAgICAgKiBibG9jayBpbiBgdXBkYXRlQ2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIG5leHRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdGhpcy5fbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgobmV4dENoaWxkLCBuYW1lLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICBlbnF1ZXVlTW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UpIHtcbiAgICAgIGVucXVldWVJbnNlcnRNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbW91bnRJbWFnZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBlbnF1ZXVlUmVtb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgZW5xdWV1ZVRleHRDb250ZW50KHRoaXMuX3Jvb3ROb2RlSUQsIHRleHRDb250ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldE1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgICAgZW5xdWV1ZVNldE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtYXJrdXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQnlOYW1lQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBuYW1lLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROYXRpdmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyA9IG51bGw7XG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBuYXRpdmUgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXG4gIC8vIHRoYXQgY2FuIHJlbmRlciBhbnkga2luZCBvZiB0YWcuXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxuICBpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3Nlcykge1xuICAgIGFzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb21wb3NpdGUgY29tcG9uZW50IHdyYXBwZXIgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSB0YWcgZm9yIHdoaWNoIHRvIGdldCB0aGUgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIFJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH1cbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXSA9IGNvbXBvbmVudENsYXNzID0gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHRhZyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuXG4vKipcbiAqIEdldCBhIG5hdGl2ZSBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHtcbiAgZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50OiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQsXG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TmF0aXZlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IgJiYgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJycpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TmFtZVxuICAgKiBAcGFyYW0ge29iamVjdDxzdHJpbmc+fSBtZXRob2ROYW1lc1xuICAgKi9cbiAgbWVhc3VyZU1ldGhvZHM6IGZ1bmN0aW9uIChvYmplY3QsIG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2ROYW1lcykge1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IFJlYWN0UGVyZi5tZWFzdXJlKG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzW2tleV0sIG9iamVjdFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHdyYXAgbWV0aG9kcyB5b3Ugd2FudCB0byBtZWFzdXJlLiBaZXJvIG92ZXJoZWFkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlKSB7XG4gICAgICAgICAgaWYgKCFtZWFzdXJlZEZ1bmMpIHtcbiAgICAgICAgICAgIG1lYXN1cmVkRnVuYyA9IFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZWFzdXJlZEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBwZXIuZGlzcGxheU5hbWUgPSBvYmpOYW1lICsgJ18nICsgZm5OYW1lO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lYXN1cmVcbiAgICAgKi9cbiAgICBpbmplY3RNZWFzdXJlOiBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTaW1wbHkgcGFzc2VzIHRocm91Z2ggdGhlIG1lYXN1cmVkIGZ1bmN0aW9uLCB3aXRob3V0IG1lYXN1cmluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIF9ub01lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gIHJldHVybiBmdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UGVyZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHJhbnNmZXJlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgam9pbkNsYXNzZXMgPSByZXF1aXJlKCdmYmpzL2xpYi9qb2luQ2xhc3NlcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2ZlciBzdHJhdGVneSB0aGF0IHdpbGwgbWVyZ2UgcHJvcCB2YWx1ZXMgdXNpbmcgdGhlIHN1cHBsaWVkXG4gKiBgbWVyZ2VTdHJhdGVneWAuIElmIGEgcHJvcCB3YXMgcHJldmlvdXNseSB1bnNldCwgdGhpcyBqdXN0IHNldHMgaXQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWVyZ2VTdHJhdGVneVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3kobWVyZ2VTdHJhdGVneSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzW2tleV0gPSBtZXJnZVN0cmF0ZWd5KHByb3BzW2tleV0sIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB0cmFuc2ZlclN0cmF0ZWd5TWVyZ2UgPSBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIGBtZXJnZWAgb3ZlcnJpZGVzIHRoZSBmaXJzdCBvYmplY3QncyAoYHByb3BzW2tleV1gIGFib3ZlKSBrZXlzIHVzaW5nIHRoZVxuICAvLyBzZWNvbmQgb2JqZWN0J3MgKGB2YWx1ZWApIGtleXMuIEFuIG9iamVjdCdzIHN0eWxlJ3MgZXhpc3RpbmcgYHByb3BBYCB3b3VsZFxuICAvLyBnZXQgb3ZlcnJpZGRlbi4gRmxpcCB0aGUgb3JkZXIgaGVyZS5cbiAgcmV0dXJuIGFzc2lnbih7fSwgYiwgYSk7XG59KTtcblxuLyoqXG4gKiBUcmFuc2ZlciBzdHJhdGVnaWVzIGRpY3RhdGUgaG93IHByb3BzIGFyZSB0cmFuc2ZlcnJlZCBieSBgdHJhbnNmZXJQcm9wc1RvYC5cbiAqIE5PVEU6IGlmIHlvdSBhZGQgYW55IG1vcmUgZXhjZXB0aW9ucyB0byB0aGlzIGxpc3QgeW91IHNob3VsZCBiZSBzdXJlIHRvXG4gKiB1cGRhdGUgYGNsb25lV2l0aFByb3BzKClgIGFjY29yZGluZ2x5LlxuICovXG52YXIgVHJhbnNmZXJTdHJhdGVnaWVzID0ge1xuICAvKipcbiAgICogTmV2ZXIgdHJhbnNmZXIgYGNoaWxkcmVuYC5cbiAgICovXG4gIGNoaWxkcmVuOiBlbXB0eUZ1bmN0aW9uLFxuICAvKipcbiAgICogVHJhbnNmZXIgdGhlIGBjbGFzc05hbWVgIHByb3AgYnkgbWVyZ2luZyB0aGVtLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KGpvaW5DbGFzc2VzKSxcbiAgLyoqXG4gICAqIFRyYW5zZmVyIHRoZSBgc3R5bGVgIHByb3AgKHdoaWNoIGlzIGFuIG9iamVjdCkgYnkgbWVyZ2luZyB0aGVtLlxuICAgKi9cbiAgc3R5bGU6IHRyYW5zZmVyU3RyYXRlZ3lNZXJnZVxufTtcblxuLyoqXG4gKiBNdXRhdGVzIHRoZSBmaXJzdCBhcmd1bWVudCBieSB0cmFuc2ZlcnJpbmcgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgc2Vjb25kXG4gKiBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiB0cmFuc2ZlckludG8ocHJvcHMsIG5ld1Byb3BzKSB7XG4gIGZvciAodmFyIHRoaXNLZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmZXJTdHJhdGVneSA9IFRyYW5zZmVyU3RyYXRlZ2llc1t0aGlzS2V5XTtcblxuICAgIGlmICh0cmFuc2ZlclN0cmF0ZWd5ICYmIFRyYW5zZmVyU3RyYXRlZ2llcy5oYXNPd25Qcm9wZXJ0eSh0aGlzS2V5KSkge1xuICAgICAgdHJhbnNmZXJTdHJhdGVneShwcm9wcywgdGhpc0tleSwgbmV3UHJvcHNbdGhpc0tleV0pO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBwcm9wc1t0aGlzS2V5XSA9IG5ld1Byb3BzW3RoaXNLZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8qKlxuICogUmVhY3RQcm9wVHJhbnNmZXJlciBhcmUgY2FwYWJsZSBvZiB0cmFuc2ZlcnJpbmcgcHJvcHMgdG8gYW5vdGhlciBjb21wb25lbnRcbiAqIHVzaW5nIGEgYHRyYW5zZmVyUHJvcHNUb2AgbWV0aG9kLlxuICpcbiAqIEBjbGFzcyBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0ge1xuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gcHJvcHMgb2JqZWN0cyB1c2luZyBUcmFuc2ZlclN0cmF0ZWdpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBvcmlnaW5hbCBwcm9wcyAodGhleSB0YWtlIHByZWNlZGVuY2UpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBuZXcgcHJvcHMgdG8gbWVyZ2UgaW5cbiAgICogQHJldHVybiB7b2JqZWN0fSBhIG5ldyBvYmplY3QgY29udGFpbmluZyBib3RoIHNldHMgb2YgcHJvcHMgbWVyZ2VkLlxuICAgKi9cbiAgbWVyZ2VQcm9wczogZnVuY3Rpb24gKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHJldHVybiB0cmFuc2ZlckludG8oYXNzaWduKHt9LCBvbGRQcm9wcyksIG5ld1Byb3BzKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFRyYW5zZmVyZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IGV4cGVjdGVkVmFsdWVzW2ldKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gJzw8YW5vbnltb3VzPj4nO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cnJlZC4gYGNsb3NlYFxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAocHJldmlvdXNseUVuYWJsZWQpIHtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKGZvcmNlSFRNTCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RUZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gIWZvcmNlSFRNTCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cblxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uKSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlZlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuXG4gIHJldHVybihcbiAgICAvLyBUaGlzIGhhcyBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgdy9yL3QgZW1wdHkgY29tcG9uZW50cy5cbiAgICBwcmV2RW1wdHkgfHwgbmV4dEVtcHR5IHx8IG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyIHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmXG4gICk7XG59O1xuXG5SZWFjdFJlZi5kZXRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXhJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBfY3JlYXRlUmVhY3RSb290SW5kZXhcbiAgICovXG4gIGluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoX2NyZWF0ZVJlYWN0Um9vdEluZGV4KSB7XG4gICAgUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggPSBfY3JlYXRlUmVhY3RSb290SW5kZXg7XG4gIH1cbn07XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IG51bGwsXG4gIGluamVjdGlvbjogUmVhY3RSb290SW5kZXhJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSb290SW5kZXg7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGhlcmUuIER1cmluZyB0aGUgc2VydmVyIHJlbmRlcmluZyB3ZSBkb24ndCB3YW50IHRvXG4gICAgLy8gc2NoZWR1bGUgYW55IHVwZGF0ZXMuIFdlIHdpbGwgc2ltcGx5IGlnbm9yZSB0aGVtLlxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RyaW5nKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgdmFyIG1hcmt1cCA9IGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgICAgcmV0dXJuIFJlYWN0TWFya3VwQ2hlY2tzdW0uYWRkQ2hlY2tzdW1Ub01hcmt1cChtYXJrdXApO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cCwgd2l0aG91dCB0aGUgZXh0cmEgUmVhY3QgSUQgYW5kIGNoZWNrc3VtXG4gKiAoZm9yIGdlbmVyYXRpbmcgc3RhdGljIHBhZ2VzKVxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdGF0aWNNYXJrdXAoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIC8vIFJldmVydCB0byB0aGUgRE9NIGJhdGNoaW5nIHN0cmF0ZWd5IHNpbmNlIHRoZXNlIHR3byByZW5kZXJlcnNcbiAgICAvLyBjdXJyZW50bHkgc2hhcmUgdGhlc2Ugc3RhdGVmdWwgbW9kdWxlcy5cbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IHJlbmRlclRvU3RhdGljTWFya3VwXG59OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBgQ2FsbGJhY2tRdWV1ZWAgcXVldWUgZm9yIGNvbGxlY3RpbmcgYG9uRE9NUmVhZHlgIGNhbGxiYWNrc1xuICogZHVyaW5nIHRoZSBwZXJmb3JtaW5nIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZW1wdHlGdW5jdGlvblxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW09OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTdGF0ZVNldHRlcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFN0YXRlU2V0dGVycyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgYW5kIHVzZXMgdGhlIHJlc3VsdFxuICAgKiBvZiB0aGF0IHRvIHNldCB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb3NpdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmV0dXJuaW5nU3RhdGUgUmV0dXJuZWQgY2FsbGJhY2sgdXNlcyB0aGlzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaG93IHRvIHVwZGF0ZSBzdGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIHRoYXQgd2hlbiBpbnZva2VkIHVzZXMgZnVuY1JldHVybmluZ1N0YXRlIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVkIHRoZSBvYmplY3QgbGl0ZXJhbCB0byBzZXRTdGF0ZS5cbiAgICovXG4gIGNyZWF0ZVN0YXRlU2V0dGVyOiBmdW5jdGlvbiAoY29tcG9uZW50LCBmdW5jUmV0dXJuaW5nU3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBmdW5jUmV0dXJuaW5nU3RhdGUuY2FsbChjb21wb25lbnQsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgaWYgKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICBjb21wb25lbnQuc2V0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2luZ2xlLWFyZ3VtZW50IGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGEgc2luZ2xlXG4gICAqIGtleSBpbiB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgbWVtb2l6ZWQgZnVuY3Rpb24sIHdoaWNoIG1ha2VzIGl0IGluZXhwZW5zaXZlIHRvIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb3NpdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgaW4gdGhlIHN0YXRlIHRoYXQgeW91IHNob3VsZCB1cGRhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayBvZiAxIGFyZ3VtZW50IHdoaWNoIGNhbGxzIHNldFN0YXRlKCkgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgdGhlIHByb3ZpZGVkIGtleU5hbWUgYW5kIGNhbGxiYWNrIGFyZ3VtZW50LlxuICAgKi9cbiAgY3JlYXRlU3RhdGVLZXlTZXR0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnQsIGtleSkge1xuICAgIC8vIE1lbW9pemUgdGhlIHNldHRlcnMuXG4gICAgdmFyIGNhY2hlID0gY29tcG9uZW50Ll9fa2V5U2V0dGVycyB8fCAoY29tcG9uZW50Ll9fa2V5U2V0dGVycyA9IHt9KTtcbiAgICByZXR1cm4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSB7XG4gIC8vIFBhcnRpYWwgc3RhdGUgaXMgYWxsb2NhdGVkIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIGNsb3N1cmUgc28gaXQgY2FuIGJlXG4gIC8vIHJldXNlZCB3aXRoIGV2ZXJ5IGNhbGwsIGF2b2lkaW5nIG1lbW9yeSBhbGxvY2F0aW9uIHdoZW4gdGhpcyBmdW5jdGlvblxuICAvLyBpcyBjYWxsZWQuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlS2V5U2V0dGVyKHZhbHVlKSB7XG4gICAgcGFydGlhbFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICBjb21wb25lbnQuc2V0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgfTtcbn1cblxuUmVhY3RTdGF0ZVNldHRlcnMuTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIGFuZCB1c2VzIHRoZSByZXN1bHRcbiAgICogb2YgdGhhdCB0byBzZXQgdGhlIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdGhlc2Ugc3RhdGVtZW50cyBhcmUgZXF1aXZhbGVudDpcbiAgICpcbiAgICogICB0aGlzLnNldFN0YXRlKHt4OiAxfSk7XG4gICAqICAgdGhpcy5jcmVhdGVTdGF0ZVNldHRlcihmdW5jdGlvbih4VmFsdWUpIHtcbiAgICogICAgIHJldHVybiB7eDogeFZhbHVlfTtcbiAgICogICB9KSgxKTtcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JldHVybmluZ1N0YXRlIFJldHVybmVkIGNhbGxiYWNrIHVzZXMgdGhpcyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGhvdyB0byB1cGRhdGUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayB0aGF0IHdoZW4gaW52b2tlZCB1c2VzIGZ1bmNSZXR1cm5pbmdTdGF0ZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lZCB0aGUgb2JqZWN0IGxpdGVyYWwgdG8gc2V0U3RhdGUuXG4gICAqL1xuICBjcmVhdGVTdGF0ZVNldHRlcjogZnVuY3Rpb24gKGZ1bmNSZXR1cm5pbmdTdGF0ZSkge1xuICAgIHJldHVybiBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZVNldHRlcih0aGlzLCBmdW5jUmV0dXJuaW5nU3RhdGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2luZ2xlLWFyZ3VtZW50IGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGEgc2luZ2xlXG4gICAqIGtleSBpbiB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0aGVzZSBzdGF0ZW1lbnRzIGFyZSBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgIHRoaXMuc2V0U3RhdGUoe3g6IDF9KTtcbiAgICogICB0aGlzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKCd4JykoMSk7XG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgbWVtb2l6ZWQgZnVuY3Rpb24sIHdoaWNoIG1ha2VzIGl0IGluZXhwZW5zaXZlIHRvIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBpbiB0aGUgc3RhdGUgdGhhdCB5b3Ugc2hvdWxkIHVwZGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIG9mIDEgYXJndW1lbnQgd2hpY2ggY2FsbHMgc2V0U3RhdGUoKSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgcHJvdmlkZWQga2V5TmFtZSBhbmQgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAqL1xuICBjcmVhdGVTdGF0ZUtleVNldHRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZUtleVNldHRlcih0aGlzLCBrZXkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U3RhdGVTZXR0ZXJzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRlc3RVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJy4vUmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJy4vUmVhY3RET00nKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIEV2ZW50KHN1ZmZpeCkge31cblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RUZXN0VXRpbHNcbiAqL1xuXG5mdW5jdGlvbiBmaW5kQWxsSW5SZW5kZXJlZFRyZWVJbnRlcm5hbChpbnN0LCB0ZXN0KSB7XG4gIGlmICghaW5zdCB8fCAhaW5zdC5nZXRQdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgcHVibGljSW5zdCA9IGluc3QuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgdmFyIHJldCA9IHRlc3QocHVibGljSW5zdCkgPyBbcHVibGljSW5zdF0gOiBbXTtcbiAgdmFyIGN1cnJlbnRFbGVtZW50ID0gaW5zdC5fY3VycmVudEVsZW1lbnQ7XG4gIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChwdWJsaWNJbnN0KSkge1xuICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gaW5zdC5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmICghcmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0ID0gcmV0LmNvbmNhdChmaW5kQWxsSW5SZW5kZXJlZFRyZWVJbnRlcm5hbChyZW5kZXJlZENoaWxkcmVuW2tleV0sIHRlc3QpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGN1cnJlbnRFbGVtZW50KSAmJiB0eXBlb2YgY3VycmVudEVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldCA9IHJldC5jb25jYXQoZmluZEFsbEluUmVuZGVyZWRUcmVlSW50ZXJuYWwoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQsIHRlc3QpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFRvZG86IFN1cHBvcnQgdGhlIGVudGlyZSBET00uc2NyeSBxdWVyeSBzeW50YXguIEZvciBub3csIHRoZXNlIHNpbXBsZVxuICogdXRpbGl0aWVzIHdpbGwgc3VmZmljZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqIEBsZW5kcyBSZWFjdFRlc3RVdGlsc1xuICovXG52YXIgUmVhY3RUZXN0VXRpbHMgPSB7XG4gIHJlbmRlckludG9Eb2N1bWVudDogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIE5vbmUgb2Ygb3VyIHRlc3RzIGFjdHVhbGx5IHJlcXVpcmUgYXR0YWNoaW5nIHRoZSBjb250YWluZXIgdG8gdGhlXG4gICAgLy8gRE9NLCBhbmQgZG9pbmcgc28gY3JlYXRlcyBhIG1lc3MgdGhhdCB3ZSByZWx5IG9uIHRlc3QgaXNvbGF0aW9uIHRvXG4gICAgLy8gY2xlYW4gdXAsIHNvIHdlJ3JlIGdvaW5nIHRvIHN0b3AgaG9ub3JpbmcgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2RcbiAgICAvLyAoYW5kIHByb2JhYmx5IHJlbmFtZSBpdCBldmVudHVhbGx5KSBpZiBubyBwcm9ibGVtcyBhcmlzZS5cbiAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gUmVhY3RET00ucmVuZGVyKGluc3RhbmNlLCBkaXYpO1xuICB9LFxuXG4gIGlzRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpO1xuICB9LFxuXG4gIGlzRWxlbWVudE9mVHlwZTogZnVuY3Rpb24gKGluc3QsIGNvbnZlbmllbmNlQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpICYmIGluc3QudHlwZSA9PT0gY29udmVuaWVuY2VDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpc0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Lm5vZGVUeXBlID09PSAxICYmIGluc3QudGFnTmFtZSk7XG4gIH0sXG5cbiAgaXNET01Db21wb25lbnRFbGVtZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiAhIShpbnN0ICYmIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSAmJiAhIWluc3QudGFnTmFtZSk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgaW5zdC5zZXRTdGF0ZSB3YXJuczsganVzdCByZXR1cm4gZmFsc2UgYXMgdGhhdCdsbCBiZSB3aGF0XG4gICAgICAvLyB0aGlzIHJldHVybnMgd2hlbiB3ZSBoYXZlIERPTSBub2RlcyBhcyByZWZzIGRpcmVjdGx5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpbnN0ICE9IG51bGwgJiYgdHlwZW9mIGluc3QucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0LnNldFN0YXRlID09PSAnZnVuY3Rpb24nO1xuICB9LFxuXG4gIGlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGU6IGZ1bmN0aW9uIChpbnN0LCB0eXBlKSB7XG4gICAgaWYgKCFSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICByZXR1cm4gY29uc3RydWN0b3IgPT09IHR5cGU7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnRFbGVtZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFdlIGNoZWNrIHRoZSBwcm90b3R5cGUgb2YgdGhlIHR5cGUgdGhhdCB3aWxsIGdldCBtb3VudGVkLCBub3QgdGhlXG4gICAgLy8gaW5zdGFuY2UgaXRzZWxmLiBUaGlzIGlzIGEgZnV0dXJlIHByb29mIHdheSBvZiBkdWNrIHR5cGluZy5cbiAgICB2YXIgcHJvdG90eXBlID0gaW5zdC50eXBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gdHlwZW9mIHByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3RvdHlwZS5zZXRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnRXaXRoVHlwZTogZnVuY3Rpb24gKGluc3QsIHR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICByZXR1cm4gISEoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGluc3QpICYmIGNvbnN0cnVjdG9yID09PSB0eXBlKTtcbiAgfSxcblxuICBnZXRSZW5kZXJlZENoaWxkT2ZDb21wb3NpdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCk7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gIH0sXG5cbiAgZmluZEFsbEluUmVuZGVyZWRUcmVlOiBmdW5jdGlvbiAoaW5zdCwgdGVzdCkge1xuICAgIGlmICghaW5zdCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAhUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZEFsbEluUmVuZGVyZWRUcmVlKC4uLik6IGluc3RhbmNlIG11c3QgYmUgYSBjb21wb3NpdGUgY29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmaW5kQWxsSW5SZW5kZXJlZFRyZWVJbnRlcm5hbChSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0KSwgdGVzdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZSBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICAgKiBjb21wb25lbnRzIHdpdGggdGhlIGNsYXNzIG5hbWUgbWF0Y2hpbmcgYGNsYXNzTmFtZWAuXG4gICAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAqL1xuICBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzOiBmdW5jdGlvbiAocm9vdCwgY2xhc3NOYW1lcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjbGFzc05hbWVzKSkge1xuICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyb290LCBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgaWYgKFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBpbnN0LmNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gU1ZHLCBwcm9iYWJseS5cbiAgICAgICAgICBjbGFzc05hbWUgPSBpbnN0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzTGlzdC5pbmRleE9mKG5hbWUpICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpa2Ugc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyBidXQgZXhwZWN0cyB0aGVyZSB0byBiZSBvbmUgcmVzdWx0LFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RET01Db21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3M6IGZ1bmN0aW9uIChyb290LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgYWxsID0gUmVhY3RUZXN0VXRpbHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyhyb290LCBjbGFzc05hbWUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCAnICsgJyhmb3VuZDogJyArIGFsbC5sZW5ndGggKyAnKSBmb3IgY2xhc3M6JyArIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZSBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICAgKiBjb21wb25lbnRzIHdpdGggdGhlIHRhZyBuYW1lIG1hdGNoaW5nIGB0YWdOYW1lYC5cbiAgICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnOiBmdW5jdGlvbiAocm9vdCwgdGFnTmFtZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChpbnN0KSAmJiBpbnN0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gICAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAgICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gICAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAgICovXG4gIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWc6IGZ1bmN0aW9uIChyb290LCB0YWdOYW1lKSB7XG4gICAgdmFyIGFsbCA9IFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgdGFnOicgKyB0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGluc3RhbmNlcyBvZiBjb21wb25lbnRzIHdpdGggdHlwZSBlcXVhbCB0byBgY29tcG9uZW50VHlwZWAuXG4gICAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAqL1xuICBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGU6IGZ1bmN0aW9uIChyb290LCBjb21wb25lbnRUeXBlKSB7XG4gICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyb290LCBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUoaW5zdCwgY29tcG9uZW50VHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZWAgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RDb21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRDb21wb25lbnRXaXRoVHlwZTogZnVuY3Rpb24gKHJvb3QsIGNvbXBvbmVudFR5cGUpIHtcbiAgICB2YXIgYWxsID0gUmVhY3RUZXN0VXRpbHMuc2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlKHJvb3QsIGNvbXBvbmVudFR5cGUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgY29tcG9uZW50VHlwZTonICsgY29tcG9uZW50VHlwZSArICcgKGZvdW5kICcgKyBhbGwubGVuZ3RoICsgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzcyBhIG1vY2tlZCBjb21wb25lbnQgbW9kdWxlIHRvIHRoaXMgbWV0aG9kIHRvIGF1Z21lbnQgaXQgd2l0aFxuICAgKiB1c2VmdWwgbWV0aG9kcyB0aGF0IGFsbG93IGl0IHRvIGJlIHVzZWQgYXMgYSBkdW1teSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEluc3RlYWQgb2YgcmVuZGVyaW5nIGFzIHVzdWFsLCB0aGUgY29tcG9uZW50IHdpbGwgYmVjb21lIGEgc2ltcGxlXG4gICAqIDxkaXY+IGNvbnRhaW5pbmcgYW55IHByb3ZpZGVkIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlIHRoZSBtb2NrIGZ1bmN0aW9uIG9iamVjdCBleHBvcnRlZCBmcm9tIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdGhhdCBkZWZpbmVzIHRoZSBjb21wb25lbnQgdG8gYmUgbW9ja2VkXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbW9ja1RhZ05hbWUgb3B0aW9uYWwgZHVtbXkgcm9vdCB0YWcgbmFtZSB0byByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJlbmRlciBtZXRob2QgKG92ZXJyaWRlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5tb2NrVGFnTmFtZSBpZiBwcm92aWRlZClcbiAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgUmVhY3RUZXN0VXRpbHMgb2JqZWN0IChmb3IgY2hhaW5pbmcpXG4gICAqL1xuICBtb2NrQ29tcG9uZW50OiBmdW5jdGlvbiAobW9kdWxlLCBtb2NrVGFnTmFtZSkge1xuICAgIG1vY2tUYWdOYW1lID0gbW9ja1RhZ05hbWUgfHwgbW9kdWxlLm1vY2tUYWdOYW1lIHx8ICdkaXYnO1xuXG4gICAgbW9kdWxlLnByb3RvdHlwZS5yZW5kZXIubW9ja0ltcGxlbWVudGF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KG1vY2tUYWdOYW1lLCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSB0b3AgbGV2ZWwgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIGEgcmF3IGV2ZW50IHRoYXQgb2NjdXJyZWRcbiAgICogb24gYW4gYEVsZW1lbnRgIG5vZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b3BMZXZlbFR5cGUgQSB0eXBlIGZyb20gYEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNgXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgVGhlIGRvbSB0byBzaW11bGF0ZSBhbiBldmVudCBvY2N1cnJpbmcgb24uXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBmYWtlTmF0aXZlRXZlbnQgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZTogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbm9kZSwgZmFrZU5hdGl2ZUV2ZW50KSB7XG4gICAgZmFrZU5hdGl2ZUV2ZW50LnRhcmdldCA9IG5vZGU7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgZmFrZU5hdGl2ZUV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIGEgdG9wIGxldmVsIGV2ZW50IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSBhIHJhdyBldmVudCB0aGF0IG9jY3VycmVkXG4gICAqIG9uIHRoZSBgUmVhY3RET01Db21wb25lbnRgIGBjb21wYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRvcExldmVsVHlwZSBBIHR5cGUgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2AuXG4gICAqIEBwYXJhbSB7IVJlYWN0RE9NQ29tcG9uZW50fSBjb21wXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBmYWtlTmF0aXZlRXZlbnQgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgc2ltdWxhdGVOYXRpdmVFdmVudE9uRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBjb21wLCBmYWtlTmF0aXZlRXZlbnQpIHtcbiAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlKHRvcExldmVsVHlwZSwgZmluZERPTU5vZGUoY29tcCksIGZha2VOYXRpdmVFdmVudCk7XG4gIH0sXG5cbiAgbmF0aXZlVG91Y2hEYXRhOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3VjaGVzOiBbeyBwYWdlWDogeCwgcGFnZVk6IHkgfV1cbiAgICB9O1xuICB9LFxuXG4gIGNyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFNoYWxsb3dSZW5kZXJlcigpO1xuICB9LFxuXG4gIFNpbXVsYXRlOiBudWxsLFxuICBTaW11bGF0ZU5hdGl2ZToge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2hhbGxvd1JlbmRlcmVyXG4gKi9cbnZhciBSZWFjdFNoYWxsb3dSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xufTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLmdldFJlbmRlck91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudCAmJiB0aGlzLl9pbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3JlbmRlcmVkT3V0cHV0IHx8IG51bGw7XG59O1xuXG52YXIgTm9vcEludGVybmFsQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5fcmVuZGVyZWRPdXRwdXQgPSBlbGVtZW50O1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG59O1xuXG5Ob29wSW50ZXJuYWxDb21wb25lbnQucHJvdG90eXBlID0ge1xuXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX3JlbmRlcmVkT3V0cHV0ID0gZWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIFNoYWxsb3dDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oU2hhbGxvd0NvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE5vb3BJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgfSxcbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uICgpIHt9LFxuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbi5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0XG59KTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RTaGFsbG93UmVuZGVyZXIgcmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgZWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6ICcnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICEodHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0U2hhbGxvd1JlbmRlcmVyIHJlbmRlcigpOiBTaGFsbG93IHJlbmRlcmluZyB3b3JrcyBvbmx5IHdpdGggY3VzdG9tICcgKyAnY29tcG9uZW50cywgbm90IHByaW1pdGl2ZXMgKCVzKS4gSW5zdGVhZCBvZiBjYWxsaW5nIGAucmVuZGVyKGVsKWAgYW5kICcgKyAnaW5zcGVjdGluZyB0aGUgcmVuZGVyZWQgb3V0cHV0LCBsb29rIGF0IGBlbC5wcm9wc2AgZGlyZWN0bHkgaW5zdGVhZC4nLCBlbGVtZW50LnR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gIH1cbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKGZhbHNlKTtcbiAgdGhpcy5fcmVuZGVyKGVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59O1xuXG5SZWFjdFNoYWxsb3dSZW5kZXJlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgdGhpcy5faW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuICB9XG59O1xuXG5SZWFjdFNoYWxsb3dSZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICB0aGlzLl9pbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KGVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgU2hhbGxvd0NvbXBvbmVudFdyYXBwZXIoZWxlbWVudC50eXBlKTtcbiAgICBpbnN0YW5jZS5jb25zdHJ1Y3QoZWxlbWVudCk7XG5cbiAgICBpbnN0YW5jZS5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3J0czpcbiAqXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZS5jbGljayhFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlLm1vdXNlTW92ZShFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlLmNoYW5nZShFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gLi4uIChBbGwga2V5cyBmcm9tIGV2ZW50IHBsdWdpbiBgZXZlbnRUeXBlc2Agb2JqZWN0cylcbiAqL1xuZnVuY3Rpb24gbWFrZVNpbXVsYXRvcihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb21Db21wb25lbnRPck5vZGUsIGV2ZW50RGF0YSkge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChkb21Db21wb25lbnRPck5vZGUpKSB7XG4gICAgICBub2RlID0gZmluZERPTU5vZGUoZG9tQ29tcG9uZW50T3JOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGRvbUNvbXBvbmVudE9yTm9kZS50YWdOYW1lKSB7XG4gICAgICBub2RlID0gZG9tQ29tcG9uZW50T3JOb2RlO1xuICAgIH1cblxuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnRUeXBlXTtcblxuICAgIHZhciBmYWtlTmF0aXZlRXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgICBmYWtlTmF0aXZlRXZlbnQudGFyZ2V0ID0gbm9kZTtcbiAgICAvLyBXZSBkb24ndCB1c2UgU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkIGluIG9yZGVyIHRvIG5vdCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgLy8gcHJvcGVybHkgZGVzdHJveWluZyBhbnkgcHJvcGVydGllcyBhc3NpZ25lZCBmcm9tIGBldmVudERhdGFgIHVwb24gcmVsZWFzZVxuICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgUmVhY3RNb3VudC5nZXRJRChub2RlKSwgZmFrZU5hdGl2ZUV2ZW50LCBub2RlKTtcbiAgICBhc3NpZ24oZXZlbnQsIGV2ZW50RGF0YSk7XG5cbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnQpO1xuICAgIH1cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgICAgIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKHRydWUpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNpbXVsYXRvcnMoKSB7XG4gIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlID0ge307XG5cbiAgdmFyIGV2ZW50VHlwZTtcbiAgZm9yIChldmVudFR5cGUgaW4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUVsZW1lbnR8UmVhY3RET01Db21wb25lbnR9IGRvbUNvbXBvbmVudE9yTm9kZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnREYXRhIEZha2UgZXZlbnQgZGF0YSB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAgICovXG4gICAgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVbZXZlbnRUeXBlXSA9IG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKTtcbiAgfVxufVxuXG4vLyBSZWJ1aWxkIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHdoZW5ldmVyIGV2ZW50IHBsdWdpbnMgYXJlIGluamVjdGVkXG52YXIgb2xkSW5qZWN0RXZlbnRQbHVnaW5PcmRlciA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyO1xuRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIG9sZEluamVjdEV2ZW50UGx1Z2luT3JkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgYnVpbGRTaW11bGF0b3JzKCk7XG59O1xudmFyIG9sZEluamVjdEV2ZW50UGx1Z2lucyA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWU7XG5FdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lID0gZnVuY3Rpb24gKCkge1xuICBvbGRJbmplY3RFdmVudFBsdWdpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgYnVpbGRTaW11bGF0b3JzKCk7XG59O1xuXG5idWlsZFNpbXVsYXRvcnMoKTtcblxuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLmNsaWNrKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VNb3ZlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VJbi9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5tb3VzZU91dChFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gLi4uIChBbGwga2V5cyBmcm9tIGBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzYClcbiAqXG4gKiBOb3RlOiBUb3AgbGV2ZWwgZXZlbnQgdHlwZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgc2V0IG9mIGhhbmRsZXIgdHlwZXNcbiAqICh3aGljaCBpbmNsdWRlIGEgYnJvYWRlciBzZXQgb2YgXCJzeW50aGV0aWNcIiBldmVudHMpLiBGb3IgZXhhbXBsZSwgb25EcmFnRG9uZVxuICogaXMgYSBzeW50aGV0aWMgZXZlbnQuIEV4Y2VwdCB3aGVuIHRlc3RpbmcgYW4gZXZlbnQgcGx1Z2luIG9yIFJlYWN0J3MgZXZlbnRcbiAqIGhhbmRsaW5nIGNvZGUgc3BlY2lmaWNhbGx5LCB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVcbiAqIHRvIGRpc3BhdGNoIHN5bnRoZXRpYyBldmVudHMuXG4gKi9cblxuZnVuY3Rpb24gbWFrZU5hdGl2ZVNpbXVsYXRvcihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb21Db21wb25lbnRPck5vZGUsIG5hdGl2ZUV2ZW50RGF0YSkge1xuICAgIHZhciBmYWtlTmF0aXZlRXZlbnQgPSBuZXcgRXZlbnQoZXZlbnRUeXBlKTtcbiAgICBhc3NpZ24oZmFrZU5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudERhdGEpO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChkb21Db21wb25lbnRPck5vZGUpKSB7XG4gICAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25ET01Db21wb25lbnQoZXZlbnRUeXBlLCBkb21Db21wb25lbnRPck5vZGUsIGZha2VOYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIGlmIChkb21Db21wb25lbnRPck5vZGUudGFnTmFtZSkge1xuICAgICAgLy8gV2lsbCBhbGxvdyBvbiBhY3R1YWwgZG9tIG5vZGVzLlxuICAgICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZShldmVudFR5cGUsIGRvbUNvbXBvbmVudE9yTm9kZSwgZmFrZU5hdGl2ZUV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbk9iamVjdC5rZXlzKHRvcExldmVsVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAvLyBFdmVudCB0eXBlIGlzIHN0b3JlZCBhcyAndG9wQ2xpY2snIC0gd2UgdHJhbnNmb3JtIHRoYXQgdG8gJ2NsaWNrJ1xuICB2YXIgY29udmVuaWVuY2VOYW1lID0gZXZlbnRUeXBlLmluZGV4T2YoJ3RvcCcpID09PSAwID8gZXZlbnRUeXBlLmNoYXJBdCgzKS50b0xvd2VyQ2FzZSgpICsgZXZlbnRUeXBlLnN1YnN0cig0KSA6IGV2ZW50VHlwZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR8UmVhY3RET01Db21wb25lbnR9IGRvbUNvbXBvbmVudE9yTm9kZVxuICAgKiBAcGFyYW0gez9FdmVudH0gbmF0aXZlRXZlbnREYXRhIEZha2UgbmF0aXZlIGV2ZW50IHRvIHVzZSBpbiBTeW50aGV0aWNFdmVudC5cbiAgICovXG4gIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlW2NvbnZlbmllbmNlTmFtZV0gPSBtYWtlTmF0aXZlU2ltdWxhdG9yKGV2ZW50VHlwZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRlc3RVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcgPSB7XG4gIC8qKlxuICAgKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuIEp1c3RcbiAgICogc2ltcGxlIHN5bnRhY3RpYyBzdWdhciBhcm91bmQgZmxhdHRlbkNoaWxkcmVuKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gICAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAgICovXG4gIGdldENoaWxkTWFwcGluZzogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB5b3UncmUgYWRkaW5nIG9yIHJlbW92aW5nIGNoaWxkcmVuIHNvbWUgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gICAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICAgKiBhbmltYXRlIGVsZW1lbnRzIGluIGFuZCBvdXQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBwcmV2aW91cyBzZXQgb2Yga2V5c1xuICAgKiBhbmQgYSBuZXcgc2V0IG9mIGtleXMgYW5kIG1lcmdlcyB0aGVtIHdpdGggaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIGNvcnJlY3RcbiAgICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAgICogUmVhY3RNdWx0aUNoaWxkIHRvIG1ha2UgdGhpcyBlYXN5LCBidXQgZm9yIG5vdyBSZWFjdCBpdHNlbGYgZG9lcyBub3RcbiAgICogZGlyZWN0bHkgaGF2ZSB0aGlzIGNvbmNlcHQgb2YgdGhlIHVuaW9uIG9mIHByZXZDaGlsZHJlbiBhbmQgbmV4dENoaWxkcmVuXG4gICAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAgICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0IG5leHQgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICAgKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gICAqIGluIGBuZXh0YCBpbiBhIHJlYXNvbmFibGUgb3JkZXIuXG4gICAqL1xuICBtZXJnZUNoaWxkTWFwcGluZ3M6IGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgcHJldiA9IHByZXYgfHwge307XG4gICAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUZvcktleShrZXkpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmV2W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIGVhY2gga2V5IG9mIGBuZXh0YCwgdGhlIGxpc3Qgb2Yga2V5cyB0byBpbnNlcnQgYmVmb3JlIHRoYXQga2V5IGluXG4gICAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcbiAgICB2YXIgbmV4dEtleXNQZW5kaW5nID0ge307XG5cbiAgICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KHByZXZLZXkpKSB7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0S2V5c1BlbmRpbmdbcHJldktleV0gPSBwZW5kaW5nS2V5cztcbiAgICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcbiAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChuZXh0S2V5c1BlbmRpbmcuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgICBjaGlsZE1hcHBpbmdbbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdOZXh0S2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZE1hcHBpbmc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25FdmVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbi8qKlxuICogRVZFTlRfTkFNRV9NQVAgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZXZlbnQgZmlyZWQgd2hlbiBhXG4gKiB0cmFuc2l0aW9uL2FuaW1hdGlvbiBlbmRzLCBiYXNlZCBvbiB0aGUgc3R5bGUgcHJvcGVydHkgdXNlZCB0b1xuICogZGVmaW5lIHRoYXQgZXZlbnQuXG4gKi9cbnZhciBFVkVOVF9OQU1FX01BUCA9IHtcbiAgdHJhbnNpdGlvbmVuZDoge1xuICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdNb3pUcmFuc2l0aW9uJzogJ21velRyYW5zaXRpb25FbmQnLFxuICAgICdPVHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbic6ICdNU1RyYW5zaXRpb25FbmQnXG4gIH0sXG5cbiAgYW5pbWF0aW9uZW5kOiB7XG4gICAgJ2FuaW1hdGlvbic6ICdhbmltYXRpb25lbmQnLFxuICAgICdXZWJraXRBbmltYXRpb24nOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAnTW96QW5pbWF0aW9uJzogJ21vekFuaW1hdGlvbkVuZCcsXG4gICAgJ09BbmltYXRpb24nOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgJ21zQW5pbWF0aW9uJzogJ01TQW5pbWF0aW9uRW5kJ1xuICB9XG59O1xuXG52YXIgZW5kRXZlbnRzID0gW107XG5cbmZ1bmN0aW9uIGRldGVjdEV2ZW50cygpIHtcbiAgdmFyIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgc3R5bGUgPSB0ZXN0RWwuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2VhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtXG4gIC8vIGZyb20gdGhlIG1hcFxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgfVxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG5cbiAgZm9yICh2YXIgYmFzZUV2ZW50TmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgIHZhciBiYXNlRXZlbnRzID0gRVZFTlRfTkFNRV9NQVBbYmFzZUV2ZW50TmFtZV07XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIGJhc2VFdmVudHMpIHtcbiAgICAgIGlmIChzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgZW5kRXZlbnRzLnB1c2goYmFzZUV2ZW50c1tzdHlsZU5hbWVdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgZGV0ZWN0RXZlbnRzKCk7XG59XG5cbi8vIFdlIHVzZSB0aGUgcmF3IHthZGR8cmVtb3ZlfUV2ZW50TGlzdGVuZXIoKSBjYWxsIGJlY2F1c2UgRXZlbnRMaXN0ZW5lclxuLy8gZG9lcyBub3Qga25vdyBob3cgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBhbmQgd2UgcmVhbGx5IHNob3VsZFxuLy8gY2xlYW4gdXAuIEFsc28sIHRoZXNlIGV2ZW50cyBhcmUgbm90IHRyaWdnZXJlZCBpbiBvbGRlciBicm93c2Vyc1xuLy8gc28gd2Ugc2hvdWxkIGJlIEEtT0sgaGVyZS5cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbnZhciBSZWFjdFRyYW5zaXRpb25FdmVudHMgPSB7XG4gIGFkZEVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIENTUyB0cmFuc2l0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCwgdHJpZ2dlciBhbiBcImVuZCBhbmltYXRpb25cIlxuICAgICAgLy8gZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uRXZlbnRzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25Hcm91cFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgnLi9SZWFjdCcpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZyA9IHJlcXVpcmUoJy4vUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUmVhY3RUcmFuc2l0aW9uR3JvdXAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RUcmFuc2l0aW9uR3JvdXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNvbXBvbmVudDogUmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBjaGlsZEZhY3Rvcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudDogJ3NwYW4nLFxuICAgICAgY2hpbGRGYWN0b3J5OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5cyA9IHt9O1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdGlhbENoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG4gICAgZm9yICh2YXIga2V5IGluIGluaXRpYWxDaGlsZE1hcHBpbmcpIHtcbiAgICAgIGlmIChpbml0aWFsQ2hpbGRNYXBwaW5nW2tleV0pIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQXBwZWFyKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcobmV4dFByb3BzLmNoaWxkcmVuKTtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcubWVyZ2VDaGlsZE1hcHBpbmdzKHByZXZDaGlsZE1hcHBpbmcsIG5leHRDaGlsZE1hcHBpbmcpXG4gICAgfSk7XG5cbiAgICB2YXIga2V5O1xuXG4gICAgZm9yIChrZXkgaW4gbmV4dENoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc1ByZXYgPSBwcmV2Q2hpbGRNYXBwaW5nICYmIHByZXZDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChuZXh0Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc1ByZXYgJiYgIXRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuICAgICAgICB0aGlzLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBwcmV2Q2hpbGRNYXBwaW5nKSB7XG4gICAgICB2YXIgaGFzTmV4dCA9IG5leHRDaGlsZE1hcHBpbmcgJiYgbmV4dENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKHByZXZDaGlsZE1hcHBpbmdba2V5XSAmJiAhaGFzTmV4dCAmJiAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgIHRoaXMua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIHdhbnQgdG8gc29tZWRheSBjaGVjayBmb3IgcmVvcmRlcmluZywgd2UgY291bGQgZG8gaXQgaGVyZS5cbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIga2V5c1RvRW50ZXIgPSB0aGlzLmtleXNUb0VudGVyO1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXTtcbiAgICBrZXlzVG9FbnRlci5mb3JFYWNoKHRoaXMucGVyZm9ybUVudGVyKTtcblxuICAgIHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIGtleXNUb0xlYXZlLmZvckVhY2godGhpcy5wZXJmb3JtTGVhdmUpO1xuICB9LFxuXG4gIHBlcmZvcm1BcHBlYXI6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsQXBwZWFyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLl9oYW5kbGVEb25lQXBwZWFyaW5nLmJpbmQodGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZURvbmVBcHBlYXJpbmcoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZURvbmVBcHBlYXJpbmc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRBcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRBcHBlYXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKCFjdXJyZW50Q2hpbGRNYXBwaW5nIHx8ICFjdXJyZW50Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgd2FzIHJlbW92ZWQgYmVmb3JlIGl0IGhhZCBmdWxseSBhcHBlYXJlZC4gUmVtb3ZlIGl0LlxuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbEVudGVyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50V2lsbEVudGVyKHRoaXMuX2hhbmRsZURvbmVFbnRlcmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZURvbmVFbnRlcmluZzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkRW50ZXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKCFjdXJyZW50Q2hpbGRNYXBwaW5nIHx8ICFjdXJyZW50Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgd2FzIHJlbW92ZWQgYmVmb3JlIGl0IGhhZCBmdWxseSBlbnRlcmVkLiBSZW1vdmUgaXQuXG4gICAgICB0aGlzLnBlcmZvcm1MZWF2ZShrZXkpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbExlYXZlKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50V2lsbExlYXZlKHRoaXMuX2hhbmRsZURvbmVMZWF2aW5nLmJpbmQodGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHNvbWV3aGF0IGRhbmdlcm91cyBiL2MgaXQgY2FsbHMgc2V0U3RhdGUoKVxuICAgICAgLy8gYWdhaW4sIGVmZmVjdGl2ZWx5IG11dGF0aW5nIHRoZSBjb21wb25lbnQgYmVmb3JlIGFsbCB0aGUgd29ya1xuICAgICAgLy8gaXMgZG9uZS5cbiAgICAgIHRoaXMuX2hhbmRsZURvbmVMZWF2aW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lTGVhdmluZzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRMZWF2ZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoY3VycmVudENoaWxkTWFwcGluZyAmJiBjdXJyZW50Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgZW50ZXJlZCBhZ2FpbiBiZWZvcmUgaXQgZnVsbHkgbGVmdC4gQWRkIGl0IGFnYWluLlxuICAgICAgdGhpcy5wZXJmb3JtRW50ZXIoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gYXNzaWduKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG4gICAgICAgIGRlbGV0ZSBuZXdDaGlsZHJlbltrZXldO1xuICAgICAgICByZXR1cm4geyBjaGlsZHJlbjogbmV3Q2hpbGRyZW4gfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiB3ZSBjb3VsZCBnZXQgcmlkIG9mIHRoZSBuZWVkIGZvciB0aGUgd3JhcHBlciBub2RlXG4gICAgLy8gYnkgY2xvbmluZyBhIHNpbmdsZSBjaGlsZFxuICAgIHZhciBjaGlsZHJlblRvUmVuZGVyID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdGUuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuc3RhdGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAvLyBZb3UgbWF5IG5lZWQgdG8gYXBwbHkgcmVhY3RpdmUgdXBkYXRlcyB0byBhIGNoaWxkIGFzIGl0IGlzIGxlYXZpbmcuXG4gICAgICAgIC8vIFRoZSBub3JtYWwgUmVhY3Qgd2F5IHRvIGRvIGl0IHdvbid0IHdvcmsgc2luY2UgdGhlIGNoaWxkIHdpbGwgaGF2ZVxuICAgICAgICAvLyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC4gSW4gY2FzZSB5b3UgbmVlZCB0aGlzIGJlaGF2aW9yIHlvdSBjYW4gcHJvdmlkZVxuICAgICAgICAvLyBhIGNoaWxkRmFjdG9yeSBmdW5jdGlvbiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlXG4gICAgICAgIC8vIGxlYXZpbmcuXG4gICAgICAgIGNoaWxkcmVuVG9SZW5kZXIucHVzaChSZWFjdC5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5jaGlsZEZhY3RvcnkoY2hpbGQpLCB7IHJlZjoga2V5LCBrZXk6IGtleSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCB0aGlzLnByb3BzLCBjaGlsZHJlblRvUmVuZGVyKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uR3JvdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAnICsgJyhzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGUuJywgY2FsbGVyTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcGFydGlhbFByb3BzKTtcbiAgfSxcblxuICBlbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciB0b3BMZXZlbFdyYXBwZXIgPSBpbnRlcm5hbEluc3RhbmNlLl90b3BMZXZlbFdyYXBwZXI7XG4gICAgIXRvcExldmVsV3JhcHBlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMsIHBhcnRpYWxQcm9wcyk7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCBwcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVwbGFjZVByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHJlcGxhY2VQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKHdyYXBFbGVtZW50LCBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgcHJvcHMpKTtcblxuICAgIGVucXVldWVVcGRhdGUodG9wTGV2ZWxXcmFwcGVyKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV3RWxlbWVudCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nICcgKyAnc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoIC8qIGZvcmNlSFRNTCAqL2ZhbHNlKTtcbn1cblxuYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLk1peGluLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byAnICsgJ21hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcbmZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3RVcGRhdGVzJywgJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnLCBmbHVzaEJhdGNoZWRVcGRhdGVzKTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcwLjE0LjMnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFdpdGhBZGRvbnNcbiAqL1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGV4aXN0cyBwdXJlbHkgaW4gdGhlIG9wZW4gc291cmNlIHByb2plY3QsIGFuZCBpcyBtZWFudCBhcyBhIHdheVxuICogdG8gY3JlYXRlIGEgc2VwYXJhdGUgc3RhbmRhbG9uZSBidWlsZCBvZiBSZWFjdC4gVGhpcyBidWlsZCBoYXMgXCJhZGRvbnNcIiwgb3JcbiAqIGZ1bmN0aW9uYWxpdHkgd2UndmUgYnVpbHQgYW5kIHRoaW5rIG1pZ2h0IGJlIHVzZWZ1bCBidXQgZG9lc24ndCBoYXZlIGEgZ29vZFxuICogcGxhY2UgdG8gbGl2ZSBpbnNpZGUgUmVhY3QgY29yZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRTdGF0ZU1peGluID0gcmVxdWlyZSgnLi9MaW5rZWRTdGF0ZU1peGluJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCcuL1JlYWN0Jyk7XG52YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4nKTtcbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoJy4vUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAnKTtcbnZhciBSZWFjdEZyYWdtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEZyYWdtZW50Jyk7XG52YXIgUmVhY3RUcmFuc2l0aW9uR3JvdXAgPSByZXF1aXJlKCcuL1JlYWN0VHJhbnNpdGlvbkdyb3VwJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGNsb25lV2l0aFByb3BzID0gcmVxdWlyZSgnLi9jbG9uZVdpdGhQcm9wcycpO1xudmFyIHNoYWxsb3dDb21wYXJlID0gcmVxdWlyZSgnLi9zaGFsbG93Q29tcGFyZScpO1xudmFyIHVwZGF0ZSA9IHJlcXVpcmUoJy4vdXBkYXRlJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHdhcm5lZEFib3V0QmF0Y2hlZFVwZGF0ZXMgPSBmYWxzZTtcblxuUmVhY3QuYWRkb25zID0ge1xuICBDU1NUcmFuc2l0aW9uR3JvdXA6IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLFxuICBMaW5rZWRTdGF0ZU1peGluOiBMaW5rZWRTdGF0ZU1peGluLFxuICBQdXJlUmVuZGVyTWl4aW46IFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBSZWFjdFRyYW5zaXRpb25Hcm91cCxcblxuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWRBYm91dEJhdGNoZWRVcGRhdGVzLCAnUmVhY3QuYWRkb25zLmJhdGNoZWRVcGRhdGVzIGlzIGRlcHJlY2F0ZWQuIFVzZSAnICsgJ1JlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICB3YXJuZWRBYm91dEJhdGNoZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBjbG9uZVdpdGhQcm9wczogY2xvbmVXaXRoUHJvcHMsXG4gIGNyZWF0ZUZyYWdtZW50OiBSZWFjdEZyYWdtZW50LmNyZWF0ZSxcbiAgc2hhbGxvd0NvbXBhcmU6IHNoYWxsb3dDb21wYXJlLFxuICB1cGRhdGU6IHVwZGF0ZVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3QuYWRkb25zLlBlcmYgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdFBlcmYnKTtcbiAgUmVhY3QuYWRkb25zLlRlc3RVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RUZXN0VXRpbHMnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgY2xpcFBhdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250RmFtaWx5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udFNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyRW5kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyTWlkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyU3RhcnQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvZmZzZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Vbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBvaW50czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHNwcmVhZE1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BDb2xvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlTGluZWNhcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZU9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VXaWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRleHRBbmNob3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0cmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2ZXJzaW9uOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmlld0JveDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBY3R1YXRlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBcmNyb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtIcmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtSb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtTaG93OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUaXRsZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbEJhc2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxMYW5nOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sU3BhY2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gICAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICAgIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gICAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gICAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgICB2aWV3Qm94OiAndmlld0JveCcsXG4gICAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gICAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gICAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gICAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gICAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gICAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICAgIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gICAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpIHx8IHRvcExldmVsVGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VydmVyUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIHJlYWN0Um9vdCBJRCBzcGFjZS4gV2UgZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnMgZm9yIFJlYWN0IHJvb3RcbiAqIElEcyBhbmQgaWYgdGhlcmUncyBhIGNvbGxpc2lvbiB0aGUgZXZlbnRzIGFuZCBET00gdXBkYXRlIHN5c3RlbSB3aWxsXG4gKiBnZXQgY29uZnVzZWQuIEluIHRoZSBmdXR1cmUgd2UgbmVlZCBhIHdheSB0byBnZW5lcmF0ZSBHVUlEcyBidXQgZm9yXG4gKiBub3cgdGhpcyB3aWxsIHdvcmsgb24gYSBzbWFsbGVyIHNjYWxlLlxuICovXG52YXIgR0xPQkFMX01PVU5UX1BPSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcblxudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlRm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLmRpc3BhdGNoTWFya2VyID0gZGlzcGF0Y2hNYXJrZXI7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNVSUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgKyAnaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIHZhciBjdXJyZW50SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gIHZhciBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dCk7XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5ICYmIG5leHRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKG5leHRJc0FycmF5KSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWRsZXIzMlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGZvciAoOyBpIDwgTWF0aC5taW4oaSArIDQwOTYsIG0pOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgY2xvbmVXaXRoUHJvcHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFRyYW5zZmVyZXIgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFRyYW5zZmVyZXInKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQ0hJTERSRU5fUFJPUCA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG5cbnZhciBkaWREZXByZWNhdGVkV2FybiA9IGZhbHNlO1xuXG4vKipcbiAqIFNvbWV0aW1lcyB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIHByb3BzIG9mIGEgY2hpbGQgcGFzc2VkIHRvIHlvdS4gVXN1YWxseVxuICogdGhpcyBpcyB0byBhZGQgYSBDU1MgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGNoaWxkIGNoaWxkIGVsZW1lbnQgeW91J2QgbGlrZSB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BzIHlvdSdkIGxpa2UgdG8gbW9kaWZ5LiBjbGFzc05hbWUgYW5kIHN0eWxlIHdpbGwgYmVcbiAqIG1lcmdlZCBhdXRvbWF0aWNhbGx5LlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBhIGNsb25lIG9mIGNoaWxkIHdpdGggcHJvcHMgbWVyZ2VkIGluLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gY2xvbmVXaXRoUHJvcHMoY2hpbGQsIHByb3BzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkRGVwcmVjYXRlZFdhcm4sICdjbG9uZVdpdGhQcm9wcyguLi4pIGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBSZWFjdC5jbG9uZUVsZW1lbnQgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgICBkaWREZXByZWNhdGVkV2FybiA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNoaWxkLnJlZiwgJ1lvdSBhcmUgY2FsbGluZyBjbG9uZVdpdGhQcm9wcygpIG9uIGEgY2hpbGQgd2l0aCBhIHJlZi4gVGhpcyBpcyAnICsgJ2Rhbmdlcm91cyBiZWNhdXNlIHlvdVxcJ3JlIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHdoaWNoIHdpbGwgbm90IGJlICcgKyAnYWRkZWQgYXMgYSByZWYgdG8gaXRzIHBhcmVudC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IFJlYWN0UHJvcFRyYW5zZmVyZXIubWVyZ2VQcm9wcyhwcm9wcywgY2hpbGQucHJvcHMpO1xuXG4gIC8vIFVzZSBgY2hpbGQucHJvcHMuY2hpbGRyZW5gIGlmIGl0IGlzIHByb3ZpZGVkLlxuICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KENISUxEUkVOX1BST1ApICYmIGNoaWxkLnByb3BzLmhhc093blByb3BlcnR5KENISUxEUkVOX1BST1ApKSB7XG4gICAgbmV3UHJvcHMuY2hpbGRyZW4gPSBjaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgfVxuXG4gIC8vIFRoZSBjdXJyZW50IEFQSSBkb2Vzbid0IHJldGFpbiBfb3duZXIsIHdoaWNoIGlzIHdoeSB0aGlzXG4gIC8vIGRvZXNuJ3QgdXNlIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcy5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50KGNoaWxkLnR5cGUsIG5ld1Byb3BzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVdpdGhQcm9wczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRlcHJlY2F0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFRoaXMgd2lsbCBsb2cgYSBzaW5nbGUgZGVwcmVjYXRpb24gbm90aWNlIHBlciBmdW5jdGlvbiBhbmQgZm9yd2FyZCB0aGUgY2FsbFxuICogb24gdG8gdGhlIG5ldyBBUEkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdNb2R1bGUgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYWNrYWdlIFRoZSBtb2R1bGUgdGhhdCBmbiB3aWxsIGV4aXN0IGluXG4gKiBAcGFyYW0geyp9IGN0eCBUaGUgY29udGV4dCB0aGlzIGZvcndhcmRlZCBjYWxsIHNob3VsZCBydW4gaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBmb3J3YXJkIG9uIHRvXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCB3YXJuIG9uY2UgYW5kIHRoZW4gY2FsbCBmblxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKGZuTmFtZSwgbmV3TW9kdWxlLCBuZXdQYWNrYWdlLCBjdHgsIGZuKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbmV3Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsXG4gICAgICAvLyBSZXF1aXJlIGV4YW1wbGVzIGluIHRoaXMgc3RyaW5nIG11c3QgYmUgc3BsaXQgdG8gcHJldmVudCBSZWFjdCdzXG4gICAgICAvLyBidWlsZCB0b29scyBmcm9tIG1pc3Rha2luZyB0aGVtIGZvciByZWFsIHJlcXVpcmVzLlxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBidWlsZCB0b29scyB3aWxsIGF0dGVtcHQgdG8gYnVpbGQgYSAnJXMnIG1vZHVsZS5cbiAgICAgICdSZWFjdC4lcyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICVzLiVzIGZyb20gcmVxdWlyZScgKyAnKFxcJyVzXFwnKSAnICsgJ2luc3RlYWQuJywgZm5OYW1lLCBuZXdNb2R1bGUsIGZuTmFtZSwgbmV3UGFja2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBmbiBhcmUgY29waWVkIG92ZXIuXG4gICAgLy8gSW4gcGFydGljdWxhciwgdGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBQcm9wVHlwZXNcbiAgICByZXR1cm4gYXNzaWduKG5ld0ZuLCBmbik7XG4gIH1cblxuICByZXR1cm4gZm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGdldERPTU5vZGUgb3IgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG4gIGlmIChSZWFjdEluc3RhbmNlTWFwLmhhcyhjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZUZyb21JbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9XG4gICEoY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PSBudWxsIHx8IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdEVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAhKGVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSAnICsgJ29yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cbiAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldHMgdXAgdGhlIGluc3RhbmNlLiBUaGlzIGNhbiBwcm9iYWJseSBqdXN0IG1vdmUgaW50byB0aGUgY29uc3RydWN0b3Igbm93LlxuICBpbnN0YW5jZS5jb25zdHJ1Y3Qobm9kZSk7XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9pc093bmVyTmVjZXNzYXJ5ID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXG4gIC8vIG5vdCBnZXQgYW55IG5ldyBmaWVsZHMgYWRkZWQgdG8gdGhlbSBhdCB0aGlzIHBvaW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0gfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0cyBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGVcbiAqIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG8gYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmVcbiAqIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdENvbXBvbmVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnb25seUNoaWxkIG11c3QgYmUgcGFzc2VkIGEgY2hpbGRyZW4gd2l0aCBleGFjdGx5IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG4vLyBXaW44IGFwcHM6IEFsbG93IGFsbCBodG1sIHRvIGJlIGluc2VydGVkXG5pZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfTtcbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFxcdUZFRkYgaGFzIHRoZSBwb3RlbnRpYWwgYWR2YW50YWdlIG9mIGJlaW5nIHplcm8td2lkdGgvaW52aXNpYmxlLlxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gdGhlIGFjdHVhbCBVbmljb2RlIGNoYXJhY3RlciAoYnkgQmFiZWwsIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgc2hhbGxvd0NvbXBhcmVcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG4vKipcbiAqIERvZXMgYSBzaGFsbG93IGNvbXBhcmlzb24gZm9yIHByb3BzIGFuZCBzdGF0ZS5cbiAqIFNlZSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUoaW5zdGFuY2UsIG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHJldHVybiAhc2hhbGxvd0VxdWFsKGluc3RhbmNlLnByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdGFuY2Uuc3RhdGUsIG5leHRTdGF0ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0NvbXBhcmU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCA9IHtcbiAgJz0nOiAnPTAnLFxuICAnLic6ICc9MScsXG4gICc6JzogJz0yJ1xufTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1s9LjpdL2c7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVzZXJQcm92aWRlZEtleUVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIHdyYXBVc2VyUHJvdmlkZWRLZXkoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBjb21wb25lbnQga2V5IHNvIHRoYXQgaXQgaXMgc2FmZSB0byB1c2UgaW4gYSByZWFjdGlkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgdXNlclByb3ZpZGVkS2V5RXNjYXBlcik7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyB3cmFwVXNlclByb3ZpZGVkS2V5KGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHVwZGF0ZVxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5jb25jYXQoKTtcbiAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhc3NpZ24obmV3IHguY29uc3RydWN0b3IoKSwgeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbn1cblxudmFyIENPTU1BTkRfUFVTSCA9IGtleU9mKHsgJHB1c2g6IG51bGwgfSk7XG52YXIgQ09NTUFORF9VTlNISUZUID0ga2V5T2YoeyAkdW5zaGlmdDogbnVsbCB9KTtcbnZhciBDT01NQU5EX1NQTElDRSA9IGtleU9mKHsgJHNwbGljZTogbnVsbCB9KTtcbnZhciBDT01NQU5EX1NFVCA9IGtleU9mKHsgJHNldDogbnVsbCB9KTtcbnZhciBDT01NQU5EX01FUkdFID0ga2V5T2YoeyAkbWVyZ2U6IG51bGwgfSk7XG52YXIgQ09NTUFORF9BUFBMWSA9IGtleU9mKHsgJGFwcGx5OiBudWxsIH0pO1xuXG52YXIgQUxMX0NPTU1BTkRTX0xJU1QgPSBbQ09NTUFORF9QVVNILCBDT01NQU5EX1VOU0hJRlQsIENPTU1BTkRfU1BMSUNFLCBDT01NQU5EX1NFVCwgQ09NTUFORF9NRVJHRSwgQ09NTUFORF9BUFBMWV07XG5cbnZhciBBTExfQ09NTUFORFNfU0VUID0ge307XG5cbkFMTF9DT01NQU5EU19MSVNULmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgQUxMX0NPTU1BTkRTX1NFVFtjb21tYW5kXSA9IHRydWU7XG59KTtcblxuZnVuY3Rpb24gaW52YXJpYW50QXJyYXlDYXNlKHZhbHVlLCBzcGVjLCBjb21tYW5kKSB7XG4gICFBcnJheS5pc0FycmF5KHZhbHVlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogZXhwZWN0ZWQgdGFyZ2V0IG9mICVzIHRvIGJlIGFuIGFycmF5OyBnb3QgJXMuJywgY29tbWFuZCwgdmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNbY29tbWFuZF07XG4gICFBcnJheS5pc0FycmF5KHNwZWNWYWx1ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXk7IGdvdCAlcy4gJyArICdEaWQgeW91IGZvcmdldCB0byB3cmFwIHlvdXIgcGFyYW1ldGVyIGluIGFuIGFycmF5PycsIGNvbW1hbmQsIHNwZWNWYWx1ZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUodmFsdWUsIHNwZWMpIHtcbiAgISh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBZb3UgcHJvdmlkZWQgYSBrZXkgcGF0aCB0byB1cGRhdGUoKSB0aGF0IGRpZCBub3QgY29udGFpbiBvbmUgJyArICdvZiAlcy4gRGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSB7JXM6IC4uLn0/JywgQUxMX0NPTU1BTkRTX0xJU1Quam9pbignLCAnKSwgQ09NTUFORF9TRVQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX1NFVCkpIHtcbiAgICAhKE9iamVjdC5rZXlzKHNwZWMpLmxlbmd0aCA9PT0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBrZXkgaW4gYW4gb2JqZWN0IHdpdGggJXMnLCBDT01NQU5EX1NFVCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHNwZWNbQ09NTUFORF9TRVRdO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IHNoYWxsb3dDb3B5KHZhbHVlKTtcblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX01FUkdFKSkge1xuICAgIHZhciBtZXJnZU9iaiA9IHNwZWNbQ09NTUFORF9NRVJHRV07XG4gICAgIShtZXJnZU9iaiAmJiB0eXBlb2YgbWVyZ2VPYmogPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogJXMgZXhwZWN0cyBhIHNwZWMgb2YgdHlwZSBcXCdvYmplY3RcXCc7IGdvdCAlcycsIENPTU1BTkRfTUVSR0UsIG1lcmdlT2JqKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShuZXh0VmFsdWUgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiAlcyBleHBlY3RzIGEgdGFyZ2V0IG9mIHR5cGUgXFwnb2JqZWN0XFwnOyBnb3QgJXMnLCBDT01NQU5EX01FUkdFLCBuZXh0VmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ24obmV4dFZhbHVlLCBzcGVjW0NPTU1BTkRfTUVSR0VdKTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNwZWMsIENPTU1BTkRfUFVTSCkpIHtcbiAgICBpbnZhcmlhbnRBcnJheUNhc2UodmFsdWUsIHNwZWMsIENPTU1BTkRfUFVTSCk7XG4gICAgc3BlY1tDT01NQU5EX1BVU0hdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIG5leHRWYWx1ZS5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9VTlNISUZUKSkge1xuICAgIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgQ09NTUFORF9VTlNISUZUKTtcbiAgICBzcGVjW0NPTU1BTkRfVU5TSElGVF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgbmV4dFZhbHVlLnVuc2hpZnQoaXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX1NQTElDRSkpIHtcbiAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgdGFyZ2V0IHRvIGJlIGFuIGFycmF5OyBnb3QgJXMnLCBDT01NQU5EX1NQTElDRSwgdmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhQXJyYXkuaXNBcnJheShzcGVjW0NPTU1BTkRfU1BMSUNFXSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JywgQ09NTUFORF9TUExJQ0UsIHNwZWNbQ09NTUFORF9TUExJQ0VdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgc3BlY1tDT01NQU5EX1NQTElDRV0uZm9yRWFjaChmdW5jdGlvbiAoYXJncykge1xuICAgICAgIUFycmF5LmlzQXJyYXkoYXJncykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JywgQ09NTUFORF9TUExJQ0UsIHNwZWNbQ09NTUFORF9TUExJQ0VdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBuZXh0VmFsdWUuc3BsaWNlLmFwcGx5KG5leHRWYWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX0FQUExZKSkge1xuICAgICEodHlwZW9mIHNwZWNbQ09NTUFORF9BUFBMWV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGEgZnVuY3Rpb247IGdvdCAlcy4nLCBDT01NQU5EX0FQUExZLCBzcGVjW0NPTU1BTkRfQVBQTFldKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgbmV4dFZhbHVlID0gc3BlY1tDT01NQU5EX0FQUExZXShuZXh0VmFsdWUpO1xuICB9XG5cbiAgZm9yICh2YXIgayBpbiBzcGVjKSB7XG4gICAgaWYgKCEoQUxMX0NPTU1BTkRTX1NFVC5oYXNPd25Qcm9wZXJ0eShrKSAmJiBBTExfQ09NTUFORFNfU0VUW2tdKSkge1xuICAgICAgbmV4dFZhbHVlW2tdID0gdXBkYXRlKHZhbHVlW2tdLCBzcGVjW2tdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgcGFyZW50VGFnOiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8ucGFyZW50VGFnID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgLyplc2xpbnQtZGlzYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgIGRvIHtcbiAgICAgIC8qZXNsaW50LWVuYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5ID0gJ19fdmFsaWRhdGVET01OZXN0aW5nX2FuY2VzdG9ySW5mbyQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU0NvcmVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBUaGUgQ1NTQ29yZSBtb2R1bGUgc3BlY2lmaWVzIHRoZSBBUEkgKGFuZCBpbXBsZW1lbnRzIG1vc3Qgb2YgdGhlIG1ldGhvZHMpXG4gKiB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGVhbGluZyB3aXRoIHRoZSBkaXNwbGF5IG9mIGVsZW1lbnRzICh2aWEgdGhlaXJcbiAqIENTUyBjbGFzc2VzIGFuZCB2aXNpYmlsaXR5IG9uIHNjcmVlbi4gSXQgaXMgYW4gQVBJIGZvY3VzZWQgb24gbXV0YXRpbmcgdGhlXG4gKiBkaXNwbGF5IGFuZCBub3QgcmVhZGluZyBpdCBhcyBubyBsb2dpY2FsIHN0YXRlIHNob3VsZCBiZSBlbmNvZGVkIGluIHRoZVxuICogZGlzcGxheSBvZiBlbGVtZW50cy5cbiAqL1xuXG52YXIgQ1NTQ29yZSA9IHtcblxuICAvKipcbiAgICogQWRkcyB0aGUgY2xhc3MgcGFzc2VkIGluIHRvIHRoZSBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAhIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDU1NDb3JlLmFkZENsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgKyAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIUNTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2xhc3MgcGFzc2VkIGluIGZyb20gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgISEvXFxzLy50ZXN0KGNsYXNzTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ1NTQ29yZS5yZW1vdmVDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuIFwiJXNcIiBjb250YWlucyAnICsgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKENTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoPzpcXFxcc3wkKScsICdnJyksICckMScpLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBtdWx0aXBsZSBzcGFjZXMgdG8gb25lXG4gICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7IC8vIHRyaW0gdGhlIGVuZHNcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhZGQgb3IgcmVtb3ZlIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50IGJhc2VkIG9uIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Kn0gYm9vbCBjb25kaXRpb24gdG8gd2hldGhlciB0byBhZGQgb3IgcmVtb3ZlIHRoZSBjbGFzc1xuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGNvbmRpdGlvbkNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgcmV0dXJuIChib29sID8gQ1NTQ29yZS5hZGRDbGFzcyA6IENTU0NvcmUucmVtb3ZlQ2xhc3MpKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NTm9kZXxET01XaW5kb3d9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcywgZmFsc2UgaWYgbm90XG4gICAqL1xuICBoYXNDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICEhL1xccy8udGVzdChjbGFzc05hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NTUy5oYXNDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+IC0xO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTQ29yZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV4ZWN1dGlvbkVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udGFpbnNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBvdXRlck5vZGUgT3V0ZXIgRE9NIG5vZGUuXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBpbm5lck5vZGUgSW5uZXIgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvdXRlck5vZGVgIGNvbnRhaW5zIG9yIGlzIGBpbm5lck5vZGVgLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUoX3gsIF94Mikge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICB2YXIgb3V0ZXJOb2RlID0gX3gsXG4gICAgICAgIGlubmVyTm9kZSA9IF94MjtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgICBfeCA9IG91dGVyTm9kZTtcbiAgICAgIF94MiA9IGlubmVyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb250YWlucykge1xuICAgICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUFycmF5RnJvbU1peGVkXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvQXJyYXkgPSByZXF1aXJlKCcuL3RvQXJyYXknKTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybihcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTm9kZXNGcm9tTWFya3VwXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5T2JqZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvY3VzTm9kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0QWN0aXZlRWxlbWVudFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdCB5ZXQgZGVmaW5lZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgam9pbkNsYXNzZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGNsYXNzTmFtZSBzdHJpbmdzIGludG8gb25lLlxuICogaHR0cDovL2pzcGVyZi5jb20vam9pbmNsYXNzZXMtYXJncy12cy1hcnJheVxuICpcbiAqIEBwYXJhbSB7Li4uP3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKGNsYXNzTmFtZSAvKiwgLi4uICovKSB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgY2xhc3NOYW1lID0gJyc7XG4gIH1cbiAgdmFyIG5leHRDbGFzcztcbiAgdmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdMZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaWkgPSAxOyBpaSA8IGFyZ0xlbmd0aDsgaWkrKykge1xuICAgICAgbmV4dENsYXNzID0gYXJndW1lbnRzW2lpXTtcbiAgICAgIGlmIChuZXh0Q2xhc3MpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5leHRDbGFzcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqb2luQ2xhc3NlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU9mID0gZnVuY3Rpb24gKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1hcE9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBvbmNlIGZvciBlYWNoIGVudW1lcmFibGUgb3duIHByb3BlcnR5IGluIHRoZVxuICogb2JqZWN0IGFuZCBjb25zdHJ1Y3RzIGEgbmV3IG9iamVjdCBmcm9tIHRoZSByZXN1bHRzLiBUaGUgYGNhbGxiYWNrYCBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqXG4gKiAgLSB0aGUgcHJvcGVydHkgdmFsdWVcbiAqICAtIHRoZSBwcm9wZXJ0eSBuYW1lXG4gKiAgLSB0aGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICpcbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgYWRkZWQgYWZ0ZXIgdGhlIGNhbGwgdG8gYG1hcE9iamVjdGAgd2lsbCBub3QgYmUgdmlzaXRlZFxuICogYnkgYGNhbGxiYWNrYC4gSWYgdGhlIHZhbHVlcyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzIGFyZSBjaGFuZ2VkLCB0aGUgdmFsdWVcbiAqIHBhc3NlZCB0byBgY2FsbGJhY2tgIHdpbGwgYmUgdGhlIHZhbHVlIGF0IHRoZSB0aW1lIGBtYXBPYmplY3RgIHZpc2l0cyB0aGVtLlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBkZWxldGVkIGJlZm9yZSBiZWluZyB2aXNpdGVkIGFyZSBub3QgdmlzaXRlZC5cbiAqXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmplY3RNYXAoKVxuICogQGdyZXAgZnVuY3Rpb24gb2JqTWFwKClcbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2FsbGJhY2suY2FsbChjb250ZXh0LCBvYmplY3RbbmFtZV0sIG5hbWUsIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwT2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xudmFyIGN1clBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAoIWN1clBlcmZvcm1hbmNlIHx8ICFjdXJQZXJmb3JtYW5jZS5ub3cpIHtcbiAgY3VyUGVyZm9ybWFuY2UgPSBEYXRlO1xufVxuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSBjdXJQZXJmb3JtYW5jZS5ub3cuYmluZChjdXJQZXJmb3JtYW5jZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNoYWxsb3dFcXVhbFxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdG9BcnJheVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2UgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3QgaW5cbiAgLy8gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZzsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9BcHBEaXNwYXRjaGVyJyk7XHJcblxyXG52YXIgSW5wdXRBY3Rpb25zID0ge1xyXG5cclxuICAgIHVwc2VydDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogaW5wdXQuYWN0aW9uVHlwZSxcclxuICAgICAgICAgICAgbW9kZWxLZXk6IGlucHV0Lm1vZGVsS2V5LFxyXG4gICAgICAgICAgICBtb2RlbFZhbHVlOiBpbnB1dC5tb2RlbFZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEFjdGlvbnM7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XHJcbnZhciBNYWluQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL01haW5Db21wb25lbnQnKTtcclxuXHJcblJlYWN0RE9NLnJlbmRlcig8TWFpbkNvbXBvbmVudCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKTtcclxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIElucHV0QWN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2FjdGlvbnMvSW5wdXRBY3Rpb25zJyk7XHJcblxyXG52YXIgSW5wdXRDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaW5wdXQgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnMuaW5wdXQpLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICBpZihpbnB1dCA9PT0gJycpe1xyXG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDsgLy9kZWxldGVkIHRoZWlyIGlucHV0OyByZXNvcnQgdG8gdW5kZWZpbmVkfHxkZWZhdWx0c1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLnByb3BzLmlzVmFsaWQoaW5wdXQpKXtcclxuICAgICAgICAgICAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoaXMucHJvcHMuY29udmVydChpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgSW5wdXRBY3Rpb25zLnVwc2VydCh7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25UeXBlOiB0aGlzLnByb3BzLmFjdGlvblR5cGUsXHJcbiAgICAgICAgICAgICAgICBtb2RlbEtleTogdGhpcy5wcm9wcy5pZCxcclxuICAgICAgICAgICAgICAgIG1vZGVsVmFsdWU6IGlucHV0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBiZWZvcmUsIGFmdGVyO1xyXG4gICAgICAgIGlmKHRoaXMucHJvcHMuYWRkT25CZWZvcmVJbnB1dCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucHJvcHMuYWRkT25CZWZvcmVJbnB1dCl7XHJcbiAgICAgICAgICAgIGJlZm9yZSA9IDxzcGFuIGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLWFkZG9uXCI+e3RoaXMucHJvcHMuYWRkT259PC9zcGFuPjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgYWZ0ZXIgPSA8c3BhbiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cC1hZGRvblwiPnt0aGlzLnByb3BzLmFkZE9ufTwvc3Bhbj47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXF1aXJlZCA9IHRoaXMucHJvcHMucmVxdWlyZWQgPyAnIHJlcXVpcmVkJyA6ICcnO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPXtcImxhYmVsIGxhYmVsLWRlZmF1bHRcIiArIHJlcXVpcmVkfSBodG1sRm9yPXt0aGlzLnByb3BzLmlkfT57dGhpcy5wcm9wcy5sYWJlbH08L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtiZWZvcmV9XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPXt0aGlzLnByb3BzLmlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPXt0aGlzLnByb3BzLnR5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e3RoaXMucHJvcHMuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmRlZmF1bHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbklucHV0Q2hhbmdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY9XCJpbnB1dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICB7YWZ0ZXJ9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0Q29tcG9uZW50OyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBJbnB1dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vSW5wdXRDb21wb25lbnQnKTtcclxudmFyIE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RlZmluZXMvTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zJyk7XHJcbnZhciBTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9kZWZpbmVzL1NjZW5hcmlvSW5wdXREZWZpbml0aW9ucycpO1xyXG5cclxudmFyIE1haW5Db21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbnB1dHMgPSBTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMuZ2V0KCk7XHJcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzLmNvbmNhdChNb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMuZ2V0KCkpO1xyXG4gICAgICAgIHZhciBpbnB1dENvbXBvbmVudHM7XHJcbiAgICAgICAgaWYoaW5wdXRzICE9PSB1bmRlZmluZWQgJiYgaW5wdXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaW5wdXRDb21wb25lbnRzID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXRDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtlLmlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD17ZS5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uVHlwZT17ZS5hY3Rpb25UeXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPXtlLnR5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtlLmxhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0PXtlLmRlZmF1bHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkPXtlLnJlcXVpcmVkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0PXtlLmFkZE9uQmVmb3JlSW5wdXR8fHRydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9uPXtlLmFkZE9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkPXtlLmlzVmFsaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnQ9e2UuY29udmVydH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0TGlzdFwiPlxyXG4gICAgICAgICAgICAgICAge2lucHV0Q29tcG9uZW50c31cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Db21wb25lbnQ7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIFRpdGxlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9UaXRsZUNvbXBvbmVudC9UaXRsZUNvbXBvbmVudCcpO1xyXG52YXIgSW5wdXRMaXN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9JbnB1dExpc3RDb21wb25lbnQvSW5wdXRMaXN0Q29tcG9uZW50Jyk7XHJcbnZhciBSZXN1bHRMaXN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZXN1bHRMaXN0Q29tcG9uZW50L1Jlc3VsdExpc3RDb21wb25lbnQnKTtcclxuXHJcbnZhciBNYWluQ29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1haW5Db21wb25lbnRcIj5cclxuICAgICAgICAgICAgICAgIDxUaXRsZUNvbXBvbmVudCAvPlxyXG4gICAgICAgICAgICAgICAgPElucHV0TGlzdENvbXBvbmVudCAvPlxyXG4gICAgICAgICAgICAgICAgPFJlc3VsdExpc3RDb21wb25lbnQgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Db21wb25lbnQ7XHJcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBIaWdoY2hhcnRzID0gcmVxdWlyZSgncmVhY3QtaGlnaGNoYXJ0cycpO1xyXG5cclxudmFyIEluY29tZUJyZWFrZG93bkNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGluY29tZUJyZWFrRG93bkNoYXJ0O1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLm1vbnRobHlJbmNvbWUgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYnJlYWtkb3ducyA9IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ1Rha2UgaG9tZScsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLnByb3BzLm5ldEluY29tZSAvIHRoaXMucHJvcHMubW9udGhseUluY29tZSkgKiAxMDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdFeHBlbnNlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLnByb3BzLm1vbnRobHlFeHBlbnNlcyAvIHRoaXMucHJvcHMubW9udGhseUluY29tZSkgKiAxMDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdNb250aGx5IENhciBDb3N0JyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMucHJvcHMubW9udGhseUNhckNvc3QgLyB0aGlzLnByb3BzLm1vbnRobHlJbmNvbWUpICogMTAwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBicmVha2Rvd25zLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbZS5sYWJlbCwgZS52YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsb3RCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxvdEJvcmRlcldpZHRoOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsb3RTaGFkb3c6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnSW5jb21lPGJyPkJyZWFrZG93bicsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IDQwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50Rm9ybWF0OiAne3Nlcmllcy5uYW1lfTogPGI+e3BvaW50LnBlcmNlbnRhZ2U6LjFmfSU8L2I+J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBsb3RPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGllOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogLTUwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNoYWRvdzogJzBweCAxcHggMnB4IGJsYWNrJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtOTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiA5MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBbJzUwJScsICc3NSUnXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXJpZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpZScsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0luY29tZSBCcmVha2Rvd24nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyU2l6ZTogJzUwJScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaW5jb21lQnJlYWtEb3duQ2hhcnQgPSA8SGlnaGNoYXJ0cyBjb25maWcgPSB7Y29uZmlnfT48L0hpZ2hjaGFydHM+O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge2luY29tZUJyZWFrRG93bkNoYXJ0fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5jb21lQnJlYWtkb3duQ29tcG9uZW50O1xyXG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIE5ldEluY29tZVRleHRDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwid2VsbCBjZW50ZXJUZXh0XCI+VGFrZSBIb21lIFBlciBNb250aCBBZnRlciBFeHBlbnNlcyBBbmQgQ2FyIFBheW1lbnQgJHt0aGlzLnByb3BzLm5ldEluY29tZS50b0ZpeGVkKDIpfTwvaDI+O1xyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmV0SW5jb21lVGV4dENvbXBvbmVudDsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgSW5wdXRBY3Rpb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdGFudHMvSW5wdXRBY3Rpb25Db25zdGFudHMnKTtcclxudmFyIElucHV0U3RvcmUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9zdG9yZXMvSW5wdXRTdG9yZScpO1xyXG5cclxudmFyIFNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgX29uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgSW5wdXRTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcihJbnB1dEFjdGlvbkNvbnN0YW50cy5TQUZFVFlfTkVUX0NIQU5HRSwgdGhpcy5fb25JbnB1dENoYW5nZSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIElucHV0U3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIoSW5wdXRBY3Rpb25Db25zdGFudHMuU0FGRVRZX05FVF9DSEFOR0UsIHRoaXMuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgfSxcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzYWZldHlOZXRFZmZlY3RUZXh0O1xyXG5cclxuICAgICAgICBpZih0aGlzLnN0YXRlLmlucHV0cy5zYWZldHlOZXQgPiAwKXtcclxuICAgICAgICAgICAgdmFyIG1vbnRoc09mU2FmZXR5TmV0RWZmZWN0ID0gMTI7XHJcbiAgICAgICAgICAgIHZhciBvdmVyVGltZSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MTsgaTw9bW9udGhzT2ZTYWZldHlOZXRFZmZlY3Q7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBvdmVyVGltZVtpXSA9ICh0aGlzLnN0YXRlLmlucHV0cy5zYWZldHlOZXQgKyAodGhpcy5wcm9wcy5uZXRJbmNvbWUgKiBpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2FmZXR5TmV0RWZmZWN0VGV4dCA9IDxoMiBjbGFzc05hbWU9XCJ3ZWxsIGNlbnRlclRleHRcIj5BZnRlciA2IE1vbnRocyBZb3VyIFNhZmV0eSBOZXQgV291bGQgQmUgQXQgJHtvdmVyVGltZVs2XS50b0ZpeGVkKDIpfTwvaDI+O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIHtzYWZldHlOZXRFZmZlY3RUZXh0fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQ7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG52YXIgSW5wdXRTdG9yZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3N0b3Jlcy9JbnB1dFN0b3JlJyk7XHJcbnZhciBWYWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9WYWxpZGF0b3JzJyk7XHJcbnZhciBTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9kZWZpbmVzL1NjZW5hcmlvSW5wdXREZWZpbml0aW9ucycpO1xyXG5cclxudmFyIEluY29tZUJyZWFrZG93bkNvbXBvbmVudCA9IHJlcXVpcmUoJy4vTmV0SW5jb21lQmFzZWRDb21wb25lbnRzL0luY29tZUJyZWFrZG93bkNvbXBvbmVudCcpO1xyXG52YXIgTmV0SW5jb21lVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vTmV0SW5jb21lQmFzZWRDb21wb25lbnRzL05ldEluY29tZVRleHRDb21wb25lbnQnKTtcclxudmFyIFNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9OZXRJbmNvbWVCYXNlZENvbXBvbmVudHMvU2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQnKTtcclxuXHJcbnZhciBsaXN0ZW5Ub0FjdGlvbnMgPSBbXHJcbiAgICBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0lOQ09NRV9DSEFOR0UsXHJcbiAgICBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0NIQU5HRVxyXG5dO1xyXG5cclxudmFyIFJlc3VsdExpc3RDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbGlzdGVuVG9BY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uVHlwZUNvbnN0YW50KXtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcihhY3Rpb25UeXBlQ29uc3RhbnQsIHNlbGYuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbGlzdGVuVG9BY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uVHlwZUNvbnN0YW50KXtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcihhY3Rpb25UeXBlQ29uc3RhbnQsIHNlbGYuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbmNvbWVCcmVha2Rvd25Db21wb25lbnQ7XHJcbiAgICAgICAgdmFyIG5ldEluY29tZVRleHRDb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50O1xyXG5cclxuICAgICAgICBpZihWYWxpZGF0b3JzLnZhbGlkYXRlUmVxdWlyZWRJbnB1dHNFeGlzdChTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMuZ2V0KCksIHRoaXMuc3RhdGUuaW5wdXRzKSl7XHJcbiAgICAgICAgICAgIHZhciBuZXRJbmNvbWUgPSB0aGlzLnN0YXRlLmlucHV0cy5tb250aGx5SW5jb21lIC0gdGhpcy5zdGF0ZS5pbnB1dHMubW9udGhseUV4cGVuc2VzIC0gdGhpcy5wcm9wcy5tb250aGx5Q2FyQ29zdDtcclxuICAgICAgICAgICAgaW5jb21lQnJlYWtkb3duQ29tcG9uZW50ID0gPEluY29tZUJyZWFrZG93bkNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgbmV0SW5jb21lPXtuZXRJbmNvbWV9XHJcbiAgICAgICAgICAgICAgICBtb250aGx5SW5jb21lPXt0aGlzLnN0YXRlLmlucHV0cy5tb250aGx5SW5jb21lfVxyXG4gICAgICAgICAgICAgICAgbW9udGhseUNhckNvc3Q9e3RoaXMucHJvcHMubW9udGhseUNhckNvc3R9XHJcbiAgICAgICAgICAgICAgICBtb250aGx5RXhwZW5zZXM9e3RoaXMuc3RhdGUuaW5wdXRzLm1vbnRobHlFeHBlbnNlc31cclxuICAgICAgICAgICAgLz47XHJcbiAgICAgICAgICAgIG5ldEluY29tZVRleHRDb21wb25lbnQgPSA8TmV0SW5jb21lVGV4dENvbXBvbmVudCBuZXRJbmNvbWU9e25ldEluY29tZX0gLz47XHJcbiAgICAgICAgICAgIHNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50ID0gPFNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50IG5ldEluY29tZT17bmV0SW5jb21lfSAvPjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIHtpbmNvbWVCcmVha2Rvd25Db21wb25lbnR9XHJcbiAgICAgICAgICAgICAgICB7bmV0SW5jb21lVGV4dENvbXBvbmVudH1cclxuICAgICAgICAgICAgICAgIHtzYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdExpc3RDb21wb25lbnQ7XHJcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG52YXIgSW5wdXRTdG9yZSA9IHJlcXVpcmUoJy4uLy4uL3N0b3Jlcy9JbnB1dFN0b3JlJyk7XHJcbnZhciBWYWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9WYWxpZGF0b3JzJyk7XHJcbnZhciBNb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9kZWZpbmVzL01vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucycpO1xyXG52YXIgQ2FsY3VsYXRpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9DYWxjdWxhdGlvbnMnKTtcclxudmFyIE5ldEluY29tZUJhc2VkTGlzdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVzdWx0Q29tcG9uZW50cy9OZXRJbmNvbWVCYXNlZExpc3RDb21wb25lbnQnKTtcclxuXHJcbnZhciBSZXN1bHRMaXN0Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgX29uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgSW5wdXRTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcihJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgSW5wdXRTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcihJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcclxuICAgIH0sXHJcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZihWYWxpZGF0b3JzLnZhbGlkYXRlUmVxdWlyZWRJbnB1dHNFeGlzdChNb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMuZ2V0KCksIHRoaXMuc3RhdGUuaW5wdXRzKSl7XHJcbiAgICAgICAgICAgIHZhciBtb250aGx5Q2FyQ29zdCA9IENhbGN1bGF0aW9ucy5tb250aGx5Q29zdChcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnZlaGljbGVQcmljZSxcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmRvd25QYXltZW50LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMudHJhZGVJbixcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLmludGVyZXN0UmF0ZSxcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnNhbGVzVGF4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMudGVybVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibW9udGhseUNvc3RcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cIndlbGwgY2VudGVyVGV4dFwiPkNhciBQYXltZW50ICR7bW9udGhseUNhckNvc3R9L21vbnRoPC9oMj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8TmV0SW5jb21lQmFzZWRMaXN0Q29tcG9uZW50IG1vbnRobHlDYXJDb3N0PXttb250aGx5Q2FyQ29zdH0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PjwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRMaXN0Q29tcG9uZW50O1xyXG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG4vL3ZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoJ3JlYWN0L2FkZG9ucy9DU1NUcmFuc2l0aW9uR3JvdXAnKTtcclxudmFyIFRpdGxlRGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9kZWZpbmVzL1RpdGxlRGVmaW5pdGlvbnMnKTtcclxudmFyIHRpdGxlSW50ZXJ2YWxUaW1lID0gMTAwMDA7XHJcbnZhciB0aXRsZVVwZGF0ZUludGVydmFsO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzI2XHJcbnZhciBJbnB1dENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdGl0bGVzID0gVGl0bGVEZWZpbml0aW9ucy5nZXQoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVzW01hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAodGl0bGVzLmxlbmd0aCkpKV1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aXRsZVVwZGF0ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHRpdGxlcyA9IFRpdGxlRGVmaW5pdGlvbnMuZ2V0KCk7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlc1tNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogKHRpdGxlcy5sZW5ndGgpKSldXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHRpdGxlSW50ZXJ2YWxUaW1lKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKXtcclxuICAgICAgICBjbGVhckludGVydmFsKHRpdGxlVXBkYXRlSW50ZXJ2YWwpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e3RoaXMuc3RhdGUudGl0bGV9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxoNSBrZXk9XCJ0aXRsZVwiIGNsYXNzTmFtZT1cImNlbnRlclRleHRcIj57dGhpcy5zdGF0ZS50aXRsZX08L2g1PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dENvbXBvbmVudDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBNT05USExZX0lOQ09NRV9ERUZBVUxUOiAwLFxyXG4gICAgTU9OVEhMWV9FWFBFTlNFU19ERUZBVUxUOiAwLFxyXG4gICAgU0FGRVRZX05FVF9ERUZBVUxUOiAwLFxyXG4gICAgVkVISUNMRV9QUklDRV9ERUZBVUxUOiB1bmRlZmluZWQsIC8vb25seSByZXF1aXJlZCBmaWVsZCBmb3IgYXBwIHRvIGRvIGJhc2ljIGZ1bmNcclxuICAgIERPV05fUEFZTUVOVF9ERUZBVUxUOiAwLFxyXG4gICAgVFJBREVfSU5fREVGQVVMVDogMCxcclxuICAgIFNBTEVTX1RBWF9ERUZBVUxUOiA1LjEsXHJcbiAgICBJTlRFUkVTVF9SQVRFX0RFRkFVTFQ6IDIuOSxcclxuICAgIFRFUk1fREVGQVVMVDogNzJcclxufTsiLCJ2YXIga2V5TWlycm9yID0gcmVxdWlyZSgna2V5bWlycm9yJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcih7XHJcbiAgICBNT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFOiBudWxsLFxyXG4gICAgTU9OVEhMWV9JTkNPTUVfQ0hBTkdFOiBudWxsLFxyXG4gICAgTU9OVEhMWV9FWFBFTlNFU19DSEFOR0U6IG51bGwsXHJcbiAgICBTQUZFVFlfTkVUX0NIQU5HRTogbnVsbFxyXG59KTsiLCJtb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIERlZmF1bHRJbnB1dENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9EZWZhdWx0SW5wdXRWYWx1ZUNvbnN0YW50cycpO1xyXG4gICAgdmFyIElucHV0QWN0aW9ucyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG4gICAgdmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxuICAgIHZhciBpbnB1dHMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3ZlaGljbGVQcmljZScsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdWZWhpY2xlIFByaWNlJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlZFSElDTEVfUFJJQ0VfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5WRUhJQ0xFX1BSSUNFX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnZG93blBheW1lbnQnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnRG93biBQYXltZW50JyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLkRPV05fUEFZTUVOVF9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLkRPV05fUEFZTUVOVF9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RyYWRlSW4nLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnVHJhZGUgSW4nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuVFJBREVfSU5fREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5UUkFERV9JTl9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3NhbGVzVGF4JyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1NhbGVzIFRheCcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUxFU19UQVhfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUxFU19UQVhfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkT246ICclJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZVBlcmNlbnRJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUZsb2F0KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnaW50ZXJlc3RSYXRlJyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ0ludGVyZXN0IFJhdGUgKEFQUiknLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuSU5URVJFU1RfUkFURV9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLklOVEVSRVNUX1JBVEVfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkT246ICclJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZVBlcmNlbnRJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUZsb2F0KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndGVybScsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdUZXJtIChNb250aHMpJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlRFUk1fREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5URVJNX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT25CZWZvcmVJbnB1dDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnbW9udGhzJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxuICAgIHJldHVybiBpbnB1dHM7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBEZWZhdWx0SW5wdXRDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvRGVmYXVsdElucHV0VmFsdWVDb25zdGFudHMnKTtcclxuICAgIHZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG4gICAgdmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxuICAgIHZhciBpbnB1dHMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ21vbnRobHlJbmNvbWUnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0lOQ09NRV9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ01vbnRobHkgSW5jb21lJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuTU9OVEhMWV9JTkNPTUVfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbjogJyQnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlTnVtYmVySW5wdXQsXHJcbiAgICAgICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKGUpeyByZXR1cm4gcGFyc2VJbnQoZSk7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdtb250aGx5RXhwZW5zZXMnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnTW9udGhseSBFeHBlbnNlcycsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuTU9OVEhMWV9FWFBFTlNFU19ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3NhZmV0eU5ldCcsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9uQ29uc3RhbnRzLlNBRkVUWV9ORVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdTYXZpbmdzIC8gU2FmZXR5IE5ldCcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUZFVFlfTkVUX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuU0FGRVRZX05FVF9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbiAgICByZXR1cm4gaW5wdXRzO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFwiSXQncyBXb3J0aCBJdC4gU2lnbi4gVHJ1c3QgTWUuXCIsXHJcbiAgICAgICAgXCJJdCdzIE9ubHkgNUsgTGVzcyBUaGFuIEEgTW9ydGdhZ2UuXCIsXHJcbiAgICAgICAgXCJDYW4gWW91IFJlYWxseSBQdXQgQSBQcmljZSBPbiBGdW4/XCIsXHJcbiAgICAgICAgXCJSZXRpcmVtZW50IElzIFN0aWxsIDQwIFllYXJzIE91dC5cIixcclxuICAgICAgICBcIldoZW4gSW4gRG91YnQgR2V0IEEgVjguXCIsXHJcbiAgICAgICAgXCJBZHJlbmFsaW5lIElzIFByaWNlbGVzcy5cIixcclxuICAgICAgICBcIkxpZmUgSXMgVG9vIFNob3J0IFRvIERyaXZlIEEgQm9yaW5nIENhci5cIixcclxuICAgICAgICBcIkp1c3QgQ3V0IEJhY2sgT24gRWF0aW5nIE91dC5cIlxyXG4gICAgXVxyXG59O1xyXG4iLCJ2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJ2ZsdXgnKS5EaXNwYXRjaGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlzcGF0Y2hlcigpOyIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9BcHBEaXNwYXRjaGVyJyk7XHJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcbnZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIF9pbnB1dHMgPSB7fTtcclxuXHJcbnZhciBJbnB1dFN0b3JlID0gYXNzaWduKHt9LCBFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICAgIHJldHVybiBfaW5wdXRzW2tleV07XHJcbiAgICB9LFxyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX2lucHV0cztcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdE1vbnRobHlDb3N0SW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdChJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdFNjZW5hcmlvQ2hhbmdlOiBmdW5jdGlvbihzY2VuYXJpb0FjdGlvblR5cGVDb25zdGFudCkge1xyXG4gICAgICAgIHRoaXMuZW1pdChzY2VuYXJpb0FjdGlvblR5cGVDb25zdGFudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5vbihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24oVHlwZU9mQ2hhbmdlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoVHlwZU9mQ2hhbmdlLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XHJcblxyXG4gICAgc3dpdGNoKGFjdGlvbi5hY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFOlxyXG4gICAgICAgICAgICBfaW5wdXRzW2FjdGlvbi5tb2RlbEtleV0gPSBhY3Rpb24ubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5lbWl0TW9udGhseUNvc3RJbnB1dENoYW5nZSgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5TQUZFVFlfTkVUX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBubyBvcFxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0U3RvcmU7IiwibW9kdWxlLmV4cG9ydHMubW9udGhseUNvc3QgPSBmdW5jdGlvbih2ZWhpY2xlUHJpY2UsIGRvd25QYXltZW50LCB0cmFkZUluLCBpbnRlcmVzdFJhdGUsIHNhbGVzVGF4LCB0ZXJtKXtcclxuICAgIHZhciBhZGp1c3RlZEludGVyZXN0UmF0ZVBlcmNlbnQgPSBpbnRlcmVzdFJhdGUgKiAuMDE7XHJcbiAgICB2YXIgYWRqdXN0ZWRTYWxlc1RheFBlcmNlbnQgPSBzYWxlc1RheCAqIC4wMTsgLy8gMi45ID0+IC4wMjlcclxuICAgIHZhciBzYWxlc1RheEFtb3VudCA9IHZlaGljbGVQcmljZSAqIGFkanVzdGVkU2FsZXNUYXhQZXJjZW50O1xyXG4gICAgdmFyIG5ldENvc3QgPSB2ZWhpY2xlUHJpY2UgKyBzYWxlc1RheEFtb3VudCAtIGRvd25QYXltZW50IC0gdHJhZGVJbjtcclxuICAgIHZhciByYXRlID0gYWRqdXN0ZWRJbnRlcmVzdFJhdGVQZXJjZW50IC8gMTI7XHJcbiAgICB2YXIgcmF0ZUNhbGMgPSAocmF0ZSAqIE1hdGgucG93KCgxICsgcmF0ZSksIHRlcm0pKS8oTWF0aC5wb3coKDEgKyByYXRlKSwgdGVybSkgLSAxKTtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KChuZXRDb3N0ICogcmF0ZUNhbGMpLnRvRml4ZWQoMikpO1xyXG59OyIsIi8qXHJcbiAgdW5kZWZpbmVkJ3MgYXJlIG9rLCBkZWZhdWx0cyBhcmUgc2V0IGZvciBpbnB1dHMgKGFuZCBpZiBubyBkZWZhdWx0LCBjYWxjIHNpbXBseSBpc24ndCBtYWRlKVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGVOdW1iZXJJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KXtcclxuICAgIHRyeXtcclxuICAgICAgICBpZihpbnB1dCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHBhcnNlSW50KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZVBlcmNlbnRJbnB1dCA9IGZ1bmN0aW9uKHBlcmNlbnQpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmKHBlcmNlbnQgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQocGVyY2VudCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlUmVxdWlyZWRJbnB1dHNFeGlzdCA9IGZ1bmN0aW9uKGlucHV0RGVmaW5pdGlvbnMsIGlucHV0TW9kZWxzKXtcclxuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgIGlucHV0RGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlKXtcclxuICAgICAgICBpZihpbnB1dE1vZGVsc1tlLmlkXSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaWYoZS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgaW5wdXRNb2RlbHNbZS5pZF0gPSBlLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaXNWYWxpZDtcclxufTsiXX0=
